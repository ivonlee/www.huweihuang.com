{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/胡伟煌.jpg","path":"img/胡伟煌.jpg","modified":0,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":0,"renderable":0},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"source/img/header_img/Iron-Man-3.jpg","path":"img/header_img/Iron-Man-3.jpg","modified":0,"renderable":0},{"_id":"source/img/ironman-draw.png","path":"img/ironman-draw.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"source/img/article/CaaS/docker.png","path":"img/article/CaaS/docker.png","modified":0,"renderable":0},{"_id":"source/img/article/CaaS/云计算三个层次.jpg","path":"img/article/CaaS/云计算三个层次.jpg","modified":0,"renderable":0},{"_id":"source/img/article/CaaS/AppEngine.jpg","path":"img/article/CaaS/AppEngine.jpg","modified":0,"renderable":0},{"_id":"source/img/article/CaaS/ContainerVSVMs.jpg","path":"img/article/CaaS/ContainerVSVMs.jpg","modified":0,"renderable":0},{"_id":"source/img/article/WAE/App Engine.jpg","path":"img/article/WAE/App Engine.jpg","modified":0,"renderable":0},{"_id":"source/img/article/WAE/Container VS VMs.jpg","path":"img/article/WAE/Container VS VMs.jpg","modified":0,"renderable":0},{"_id":"source/img/article/WAE/WAE架构.png","path":"img/article/WAE/WAE架构.png","modified":0,"renderable":0},{"_id":"source/img/article/WAE/WAE监控.png","path":"img/article/WAE/WAE监控.png","modified":0,"renderable":0},{"_id":"source/img/article/WAE/WAE网络.png","path":"img/article/WAE/WAE网络.png","modified":0,"renderable":0},{"_id":"source/img/article/WAE/WAE应用模型.png","path":"img/article/WAE/WAE应用模型.png","modified":0,"renderable":0},{"_id":"source/img/article/WAE/WAE部署图.png","path":"img/article/WAE/WAE部署图.png","modified":0,"renderable":0},{"_id":"source/img/article/WAE/image2016-3-15 15-48-30.png","path":"img/article/WAE/image2016-3-15 15-48-30.png","modified":0,"renderable":0},{"_id":"source/img/article/WAE/云计算三个层次.jpg","path":"img/article/WAE/云计算三个层次.jpg","modified":0,"renderable":0},{"_id":"source/img/article/WAE/Pod网络.png","path":"img/article/WAE/Pod网络.png","modified":0,"renderable":0},{"_id":"source/img/article/WAE/五元组.png","path":"img/article/WAE/五元组.png","modified":0,"renderable":0},{"_id":"source/img/article/WAE/数据存储.png","path":"img/article/WAE/数据存储.png","modified":0,"renderable":0},{"_id":"source/img/article/WAE/容器网络.png","path":"img/article/WAE/容器网络.png","modified":0,"renderable":0},{"_id":"source/img/article/WAE/配置中心.png","path":"img/article/WAE/配置中心.png","modified":0,"renderable":0},{"_id":"source/img/article/flannel/docker启动参数.png","path":"img/article/flannel/docker启动参数.png","modified":0,"renderable":0},{"_id":"source/img/article/golang/位运算.png","path":"img/article/golang/位运算.png","modified":0,"renderable":0},{"_id":"source/img/article/golang/字符串操作.png","path":"img/article/golang/字符串操作.png","modified":0,"renderable":0},{"_id":"source/img/article/golang/整型.png","path":"img/article/golang/整型.png","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/k8s-etcd-registry.png","path":"img/article/kubernetes/k8s-etcd-registry.png","modified":0,"renderable":0},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":0,"renderable":0},{"_id":"source/img/article/WAE/flannel.png","path":"img/article/WAE/flannel.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"source/img/article/CaaS/PaaS.jpg","path":"img/article/CaaS/PaaS.jpg","modified":0,"renderable":0},{"_id":"source/img/article/WAE/WAE多机房.png","path":"img/article/WAE/WAE多机房.png","modified":0,"renderable":0},{"_id":"source/img/article/database/权限列表.jpg","path":"img/article/database/权限列表.jpg","modified":0,"renderable":0},{"_id":"source/img/article/WAE/PaaS.jpg","path":"img/article/WAE/PaaS.jpg","modified":0,"renderable":0},{"_id":"source/img/article/etcd/raft.png","path":"img/article/etcd/raft.png","modified":0,"renderable":0},{"_id":"source/img/article/flannel/UDP封装.png","path":"img/article/flannel/UDP封装.png","modified":0,"renderable":0},{"_id":"source/img/article/flannel/flannel.png","path":"img/article/flannel/flannel.png","modified":0,"renderable":0},{"_id":"source/img/article/flannel/动态路由.png","path":"img/article/flannel/动态路由.png","modified":0,"renderable":0},{"_id":"source/img/article/flannel/数据接收节点路由表.png","path":"img/article/flannel/数据接收节点路由表.png","modified":0,"renderable":0},{"_id":"source/img/article/flannel/静态路由.png","path":"img/article/flannel/静态路由.png","modified":0,"renderable":0},{"_id":"source/img/article/flannel/数据发送节点路由表.png","path":"img/article/flannel/数据发送节点路由表.png","modified":0,"renderable":0},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/article/WAE/传统运维.png","path":"img/article/WAE/传统运维.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/1.png","path":"img/article/docker/docker常用命令原理图/1.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/2.1.png","path":"img/article/docker/docker常用命令原理图/2.1.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/3.1.png","path":"img/article/docker/docker常用命令原理图/3.1.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/3.2.png","path":"img/article/docker/docker常用命令原理图/3.2.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.1.2.png","path":"img/article/docker/docker常用命令原理图/4.1.2.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.1.3.png","path":"img/article/docker/docker常用命令原理图/4.1.3.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.1.png","path":"img/article/docker/docker常用命令原理图/4.2.1.1.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.2.png","path":"img/article/docker/docker常用命令原理图/4.2.1.2.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.3.1.png","path":"img/article/docker/docker常用命令原理图/4.2.1.3.1.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.3.png","path":"img/article/docker/docker常用命令原理图/4.2.1.3.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.4.png","path":"img/article/docker/docker常用命令原理图/4.2.1.4.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.5.png","path":"img/article/docker/docker常用命令原理图/4.2.1.5.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.1.1.png","path":"img/article/docker/docker常用命令原理图/4.1.1.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.7.2.png","path":"img/article/docker/docker常用命令原理图/4.2.1.7.2.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.7.png","path":"img/article/docker/docker常用命令原理图/4.2.1.7.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.8.2.png","path":"img/article/docker/docker常用命令原理图/4.2.1.8.2.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.8.1.png","path":"img/article/docker/docker常用命令原理图/4.2.1.8.1.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.2.1.2.png","path":"img/article/docker/docker常用命令原理图/4.2.2.1.2.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.2.1.1.png","path":"img/article/docker/docker常用命令原理图/4.2.2.1.1.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.2.1.3.png","path":"img/article/docker/docker常用命令原理图/4.2.2.1.3.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.2.2.2.png","path":"img/article/docker/docker常用命令原理图/4.2.2.2.2.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.2.3.1.png","path":"img/article/docker/docker常用命令原理图/4.2.2.3.1.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.3.1.png","path":"img/article/docker/docker常用命令原理图/4.2.3.1.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.3.3.png","path":"img/article/docker/docker常用命令原理图/4.2.3.3.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.3.4.png","path":"img/article/docker/docker常用命令原理图/4.2.3.4.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.2.2.1.png","path":"img/article/docker/docker常用命令原理图/4.2.2.2.1.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.3.2.png","path":"img/article/docker/docker常用命令原理图/4.2.3.2.png","modified":0,"renderable":0},{"_id":"source/img/article/golang/git/git常用命令.png","path":"img/article/golang/git/git常用命令.png","modified":0,"renderable":0},{"_id":"source/img/article/golang/模板处理/image2017-3-8 21-57-48.png","path":"img/article/golang/模板处理/image2017-3-8 21-57-48.png","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/k8s基本概念/pod.png","path":"img/article/kubernetes/k8s基本概念/pod.png","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/k8s基本概念/pod2.png","path":"img/article/kubernetes/k8s基本概念/pod2.png","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/k8s基本概念/service.png","path":"img/article/kubernetes/k8s基本概念/service.png","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/k8s总架构/kubelet.png","path":"img/article/kubernetes/k8s总架构/kubelet.png","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/k8s总架构/master.png","path":"img/article/kubernetes/k8s总架构/master.png","modified":0,"renderable":0},{"_id":"source/img/article/golang/beego/flow.png","path":"img/article/golang/beego/flow.png","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/k8s网络/Pod网络.png","path":"img/article/kubernetes/k8s网络/Pod网络.png","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/k8s网络/image2017-5-4 20-51-53.png","path":"img/article/kubernetes/k8s网络/image2017-5-4 20-51-53.png","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/k8s网络/容器网络.png","path":"img/article/kubernetes/k8s网络/容器网络.png","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/k8s网络/网络架构图.png","path":"img/article/kubernetes/k8s网络/网络架构图.png","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/kubernetes核心原理/EndpointController.png","path":"img/article/kubernetes/kubernetes核心原理/EndpointController.png","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/kubernetes核心原理/NodeController.png","path":"img/article/kubernetes/kubernetes核心原理/NodeController.png","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/kubernetes核心原理/ResourceQuotaController.png","path":"img/article/kubernetes/kubernetes核心原理/ResourceQuotaController.png","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/kubernetes核心原理/controller-manager.png","path":"img/article/kubernetes/kubernetes核心原理/controller-manager.png","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/kubernetes核心原理/scheduler.png","path":"img/article/kubernetes/kubernetes核心原理/scheduler.png","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/监控/k8s监控架构图.png","path":"img/article/kubernetes/监控/k8s监控架构图.png","modified":0,"renderable":0},{"_id":"source/img/article/etcd/etcd的架构图.jpg","path":"img/article/etcd/etcd的架构图.jpg","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker整体架构图/execdriver.jpg","path":"img/article/docker/docker整体架构图/execdriver.jpg","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker源码之Docker-Daemon/Daemon架构图.jpg","path":"img/article/docker/docker源码之Docker-Daemon/Daemon架构图.jpg","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker源码分析之Docker Daemon网络/Docker Daemon网络.jpg","path":"img/article/docker/docker源码分析之Docker Daemon网络/Docker Daemon网络.jpg","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.6.png","path":"img/article/docker/docker常用命令原理图/4.2.1.6.png","modified":0,"renderable":0},{"_id":"source/img/article/golang/beego/architecture.png","path":"img/article/golang/beego/architecture.png","modified":0,"renderable":0},{"_id":"source/img/article/golang/beego/init.png","path":"img/article/golang/beego/init.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker常用命令原理图/docker命令原理图.jpg","path":"img/article/docker/docker常用命令原理图/docker命令原理图.jpg","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/kubernetes核心原理/kube-apiserver.png","path":"img/article/kubernetes/kubernetes核心原理/kube-apiserver.png","modified":0,"renderable":0},{"_id":"source/img/article/CaaS/k8s架构.png","path":"img/article/CaaS/k8s架构.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/IP协议/1.1.png","path":"img/article/TCPIP/tcpip/IP协议/1.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/打包解包过程.png","path":"img/article/TCPIP/tcpip/TCPIP基础/打包解包过程.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/文件传输.png","path":"img/article/TCPIP/tcpip/TCPIP基础/文件传输.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/电子邮件.png","path":"img/article/TCPIP/tcpip/TCPIP基础/电子邮件.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/远程登录.png","path":"img/article/TCPIP/tcpip/TCPIP基础/远程登录.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/通信模型.png","path":"img/article/TCPIP/tcpip/TCPIP基础/通信模型.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCP与UDP/1.3.3.png","path":"img/article/TCPIP/tcpip/TCP与UDP/1.3.3.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCP与UDP/2.2.1.png","path":"img/article/TCPIP/tcpip/TCP与UDP/2.2.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/1.4.1.png","path":"img/article/TCPIP/HTTP/HTTP基础/1.4.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.2.1.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.2.2.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.2.2.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.2.2.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.5.1.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.2.5.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.5.2.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.2.5.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.8.1.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.2.8.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.3.3.2.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.3.3.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/3.5.2.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/3.5.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.1.1.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/4.1.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.1.2.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/4.1.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.1.3.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/4.1.3.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.2.1.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/4.2.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.2.2.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/4.2.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.2.3.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/4.2.3.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.2.4.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/4.2.4.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.3.1.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/4.3.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.3.3.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/4.3.3.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.4.1.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/4.4.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.4.2.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/4.4.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/web服务器/5.1.3.png","path":"img/article/TCPIP/HTTP/web服务器/5.1.3.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/web服务器/5.2.2.png","path":"img/article/TCPIP/HTTP/web服务器/5.2.2.png","modified":0,"renderable":0},{"_id":"source/img/article/WAE/k8s架构.png","path":"img/article/WAE/k8s架构.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker整体架构图/container.jpg","path":"img/article/docker/docker整体架构图/container.jpg","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker整体架构图/docker-daemon.jpg","path":"img/article/docker/docker整体架构图/docker-daemon.jpg","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker整体架构图/docker-server.jpg","path":"img/article/docker/docker整体架构图/docker-server.jpg","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker整体架构图/graphdriver.jpg","path":"img/article/docker/docker整体架构图/graphdriver.jpg","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker整体架构图/libcontainer.jpg","path":"img/article/docker/docker整体架构图/libcontainer.jpg","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker整体架构图/networkdriver.jpg","path":"img/article/docker/docker整体架构图/networkdriver.jpg","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker源码之Docker-Daemon/Daemon启动流程.jpg","path":"img/article/docker/docker源码之Docker-Daemon/Daemon启动流程.jpg","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker源码分析之Docker-Server/流程图.jpg","path":"img/article/docker/docker源码分析之Docker-Server/流程图.jpg","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/IP协议/1.2.png","path":"img/article/TCPIP/tcpip/IP协议/1.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/IP协议/1.3.0.png","path":"img/article/TCPIP/tcpip/IP协议/1.3.0.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/IP协议/1.3.1.png","path":"img/article/TCPIP/tcpip/IP协议/1.3.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/IP协议/1.3.png","path":"img/article/TCPIP/tcpip/IP协议/1.3.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/IP协议/2.2.1.png","path":"img/article/TCPIP/tcpip/IP协议/2.2.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/IP协议/2.2.png","path":"img/article/TCPIP/tcpip/IP协议/2.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/IP协议/4.1.png","path":"img/article/TCPIP/tcpip/IP协议/4.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/IP协议/4.2.png","path":"img/article/TCPIP/tcpip/IP协议/4.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/OSI各层功能.png","path":"img/article/TCPIP/tcpip/TCPIP基础/OSI各层功能.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/OSI通信.png","path":"img/article/TCPIP/tcpip/TCPIP基础/OSI通信.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/WWW.png","path":"img/article/TCPIP/tcpip/TCPIP基础/WWW.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/数据包结构.png","path":"img/article/TCPIP/tcpip/TCPIP基础/数据包结构.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/网络构成.png","path":"img/article/TCPIP/tcpip/TCPIP基础/网络构成.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/网络管理.png","path":"img/article/TCPIP/tcpip/TCPIP基础/网络管理.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCP与UDP/1.1.png","path":"img/article/TCPIP/tcpip/TCP与UDP/1.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCP与UDP/1.2.png","path":"img/article/TCPIP/tcpip/TCP与UDP/1.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCP与UDP/2.2.png","path":"img/article/TCPIP/tcpip/TCP与UDP/2.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/1.1.png","path":"img/article/TCPIP/HTTP/HTTP基础/1.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/1.2.png","path":"img/article/TCPIP/HTTP/HTTP基础/1.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/1.3.2.png","path":"img/article/TCPIP/HTTP/HTTP基础/1.3.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/1.3.3.png","path":"img/article/TCPIP/HTTP/HTTP基础/1.3.3.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/1.4.2.png","path":"img/article/TCPIP/HTTP/HTTP基础/1.4.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.1.1.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.1.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.1.2.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.1.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.1.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.3.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.2.3.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.4.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.2.4.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.6.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.2.6.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.8.2.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.2.8.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.3.2.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.3.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.3.3.3.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.3.3.3.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/3.1.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/3.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/3.2.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/3.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/3.3.2.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/3.3.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/3.3.3.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/3.3.3.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.3.2.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/4.3.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.3.4.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/4.3.4.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/4.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/web服务器/5.1.2.png","path":"img/article/TCPIP/HTTP/web服务器/5.1.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/web服务器/5.2.1.png","path":"img/article/TCPIP/HTTP/web服务器/5.2.1.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker整体架构图/docker总架构图.jpg","path":"img/article/docker/docker整体架构图/docker总架构图.jpg","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker整体架构图/graph架构.jpg","path":"img/article/docker/docker整体架构图/graph架构.jpg","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker源码分析之Docker Daemon网络/网络初始化.jpg","path":"img/article/docker/docker源码分析之Docker Daemon网络/网络初始化.jpg","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/监控/cAdvisor.png","path":"img/article/kubernetes/监控/cAdvisor.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/IP协议/2.3.png","path":"img/article/TCPIP/tcpip/IP协议/2.3.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/IP协议/2.4.1.png","path":"img/article/TCPIP/tcpip/IP协议/2.4.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/IP协议/3.1.png","path":"img/article/TCPIP/tcpip/IP协议/3.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/TCP-IP与OSI参考模型.png","path":"img/article/TCPIP/tcpip/TCPIP基础/TCP-IP与OSI参考模型.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/image2017-3-3 14-12-58.png","path":"img/article/TCPIP/tcpip/TCPIP基础/image2017-3-3 14-12-58.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/数据传输流程.png","path":"img/article/TCPIP/tcpip/TCPIP基础/数据传输流程.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/1.2.1.png","path":"img/article/TCPIP/HTTP/HTTP基础/1.2.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/1.3.1.png","path":"img/article/TCPIP/HTTP/HTTP基础/1.3.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/1.3.4.png","path":"img/article/TCPIP/HTTP/HTTP基础/1.3.4.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.1.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.2.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.7.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.2.7.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.3.1.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.3.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.3.3.png","path":"img/article/TCPIP/HTTP/HTTP基础/2.3.3.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/3.5.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/3.5.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/web服务器/5.1.1.png","path":"img/article/TCPIP/HTTP/web服务器/5.1.1.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/web服务器/5.2.png","path":"img/article/TCPIP/HTTP/web服务器/5.2.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker源码之docker-client/docker-client流程图.jpg","path":"img/article/docker/docker源码之docker-client/docker-client流程图.jpg","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker源码分析之New Daemon/New Daemon流程图.jpg","path":"img/article/docker/docker源码分析之New Daemon/New Daemon流程图.jpg","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/k8s总架构/architecture.png","path":"img/article/kubernetes/k8s总架构/architecture.png","modified":0,"renderable":0},{"_id":"source/img/article/kubernetes/k8s总架构/k8s架构2.png","path":"img/article/kubernetes/k8s总架构/k8s架构2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/IP协议/3.2.png","path":"img/article/TCPIP/tcpip/IP协议/3.2.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/tcpip/TCP与UDP/2.3.png","path":"img/article/TCPIP/tcpip/TCP与UDP/2.3.png","modified":0,"renderable":0},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/3.2.2.png","path":"img/article/TCPIP/HTTP/HTTP报文及状态码/3.2.2.png","modified":0,"renderable":0},{"_id":"source/img/article/docker/docker源码分析之Docker Daemon网络/创建网桥流程.jpg","path":"img/article/docker/docker源码分析之Docker Daemon网络/创建网桥流程.jpg","modified":0,"renderable":0},{"_id":"source/img/article/golang/git/git.png","path":"img/article/golang/git/git.png","modified":0,"renderable":0},{"_id":"source/img/beantech-desktop.png","path":"img/beantech-desktop.png","modified":0,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":0,"renderable":0},{"_id":"source/img/article_header_img/article_header.png","path":"img/article_header_img/article_header.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-2-dark.png","path":"img/header_img/home-bg-2-dark.png","modified":0,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":0,"renderable":0},{"_id":"source/img/article/golang/http执行流程/http包执行流程图.png","path":"img/article/golang/http执行流程/http包执行流程图.png","modified":0,"renderable":0},{"_id":"source/img/article/golang/http执行流程/http连接处理流程图.png","path":"img/article/golang/http执行流程/http连接处理流程图.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1506742714871},{"_id":"source/CNAME","hash":"6ae3abe021ce550331dda0c8f2ec41b8b23c4aaa","modified":1506949647255},{"_id":"themes/beantech/_config.yml","hash":"6afd65c055d9b1c70ae67323cc869f1b4aa60348","modified":1506742714923},{"_id":"source/about/index.md","hash":"239150b9a27b86dc9a58c1c90b1eb840b464b409","modified":1507518544205},{"_id":"source/archive/index.md","hash":"279ff19668395f5c6b26417da99d2c1f3ecd5886","modified":1506742714883},{"_id":"themes/beantech/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1506742714922},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1506742714913},{"_id":"source/tags/index.md","hash":"9d558ce28d0d44c3463517088689bbca44bbb364","modified":1506742714921},{"_id":"source/img/胡伟煌.jpg","hash":"bb38b836d2fa4842e340dc27dd2b4776787ad33d","modified":1499570792712},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1506742714924},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1506742714924},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1506742714925},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1506742714925},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1506742714926},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1506742714927},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1506742714927},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1506742714926},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1506742714928},{"_id":"themes/beantech/layout/index.ejs","hash":"dc8a6eaa00d1e7c33a40979afe0953ed5d7b512e","modified":1506742714941},{"_id":"themes/beantech/layout/archive.ejs","hash":"72a150c8dff0031a9107d12eaa7c2e6c6ce950d2","modified":1506742714941},{"_id":"themes/beantech/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1506742714929},{"_id":"themes/beantech/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1506742714939},{"_id":"themes/beantech/layout/layout.ejs","hash":"a5af5b99ac3456ab5da1a319455904b979b91601","modified":1506742714943},{"_id":"themes/beantech/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1506742714944},{"_id":"source/_posts/Database/Mysql常用命令.md","hash":"63b56852d80cdd9c9e1a284cd04f730d51101556","modified":1506999334252},{"_id":"source/_posts/Database/Redis介绍.md","hash":"724ac07137239aed008740fee371aedbb1357b48","modified":1506999321357},{"_id":"source/_posts/Docker/Dockerfile使用说明.md","hash":"b7db0b87eedb24b3c5049f5361c19d19639ad6a6","modified":1506932706789},{"_id":"source/_posts/Docker/Docker常用命令原理图.md","hash":"3a23acb354b6ab39cf94aa899f8f69d260ffaac4","modified":1506999559506},{"_id":"source/_posts/Docker/Docker整体架构图.md","hash":"065abe20a87307e6889f37d4aaf1dc6b5e12a0d4","modified":1506931873186},{"_id":"source/_posts/Etcd/Etcd介绍.md","hash":"08c475746b7c4dec779d2bd8f1ab0a487774cb4d","modified":1506935563940},{"_id":"source/_posts/Etcd/Etcd常用命令.md","hash":"dfeaa84d715b2e3b459f1a48f4bcd6df635d9e61","modified":1506935397515},{"_id":"source/_posts/Etcd/Etcd访问控制.md","hash":"5cce23f46de6aa588ca10f7581422aa66d91fefe","modified":1506935488438},{"_id":"source/_posts/Flannel/Flannel介绍.md","hash":"f0992988951ad5d666e8648c4dc0d714fd86b872","modified":1506935965542},{"_id":"source/_posts/Kubernetes/Kubernetes基本概念.md","hash":"e117eda3c59f0c156fa2f7c6e1846250c6b2b320","modified":1506942798397},{"_id":"source/_posts/Kubernetes/Kubernetes常用命令.md","hash":"1e20d177c17396875eb5413d18b783b591255e65","modified":1506943687712},{"_id":"source/_posts/Kubernetes/Kubernetes总架构图.md","hash":"82366fd2b63b48bbd40b13938828bb850d94aec0","modified":1506949857596},{"_id":"source/_posts/Kubernetes/Kubernetes网络原理.md","hash":"14aba463cc2b1f7ef0437c486f8a3b0dd663004f","modified":1506943446819},{"_id":"source/_posts/Kubernetes/Kubernetes集群问题排查.md","hash":"79897e05510eae046bb274767ba156b2420689ad","modified":1506949913030},{"_id":"source/_posts/Kubernetes/基于Docker及Kubernetes技术构建容器云（PaaS）平台.md","hash":"a6c131b9c365532c2d4c0ab724c542d464b09e96","modified":1506949873277},{"_id":"source/_posts/Nginx/Nginx的部署与配置.md","hash":"140bcfa13d5991c481c3e14ad741dbe867b98d8f","modified":1506947973133},{"_id":"themes/beantech/layout/page.ejs","hash":"c90797e4394c5cb63c2515109480e766d04e486e","modified":1506742714943},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1506742714885},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"3542d15bdf73aa59f05f566b7ecd2255e83ee370","modified":1506742714930},{"_id":"themes/beantech/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1506742714942},{"_id":"themes/beantech/layout/post.ejs","hash":"2d55684fc539dc281f9e2ec0409f09ea6ca43949","modified":1506742714944},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1506742714932},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1506742714931},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1506742714932},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"aafb744601042f0270d2e6595129ac8a73ad2608","modified":1506742714931},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"837f01e8a20e5023b4b292d1b3141a399567da65","modified":1506742714933},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1506742714934},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1506742714935},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1506742714934},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1506742714935},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1506742714936},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"3b10bd768f6ef30a42b1703fbc9a88627f9bfdf1","modified":1506742714937},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"c31863b1fa66fd915bc4913440be6c610d12af80","modified":1506742714929},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1506742714959},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1506742714957},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1506742714960},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1506742714961},{"_id":"themes/beantech/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1506742714946},{"_id":"themes/beantech/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1506742714947},{"_id":"themes/beantech/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1506742714946},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1506742714951},{"_id":"themes/beantech/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1506742714954},{"_id":"themes/beantech/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1506742714954},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1506742714963},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1506742714963},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1506742714964},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1506742714968},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1506742714969},{"_id":"themes/beantech/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1506742714969},{"_id":"themes/beantech/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1506742714951},{"_id":"themes/beantech/source/css/toc.styl","hash":"6c9a2d5f6f981624e0c4b64323493e8614efea29","modified":1506742714955},{"_id":"source/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1506742714893},{"_id":"source/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1506742714915},{"_id":"themes/beantech/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1506742714970},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1506742714958},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1506742714950},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1506742714962},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1506742714968},{"_id":"source/_posts/Docker/Docker源码/Docker源码分析（三）之Docker Server.md","hash":"b892d372e96f4ec427a2ed12cf814ef57e6cd236","modified":1506934827113},{"_id":"source/_posts/Docker/Docker源码/Docker源码分析（一）之Docker Client.md","hash":"0b4d37f0b8461c878623b84fe28e6d95f35679cf","modified":1506934565788},{"_id":"source/_posts/Docker/Docker源码/Docker源码分析（二）之Docker Daemon.md","hash":"a186534dd4cc9a8a4f04ba3d4c627c7b9debbef1","modified":1506933761844},{"_id":"themes/beantech/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1506742714955},{"_id":"source/_posts/Kubernetes/kubernetes核心原理/kubernetes核心原理（一）之API Server.md","hash":"c474f3118630705d039925cf3a0a169fd4028a08","modified":1506949898351},{"_id":"source/_posts/Kubernetes/kubernetes核心原理/kubernetes核心原理（三）之Scheduler.md","hash":"aff7844a601045e962e3134502c10222d34d5e45","modified":1506944724995},{"_id":"source/_posts/Kubernetes/kubernetes核心原理/kubernetes核心原理（二）之Controller Manager.md","hash":"ba14cd29a5a867dccceb9ec43af2d24b570fafa1","modified":1506944624275},{"_id":"source/_posts/Kubernetes/kubernetes核心原理/kubernetes核心原理（四）之Kubelet.md","hash":"fc91fa294f6c7e52417537273be84c9fa945e2ea","modified":1506944834013},{"_id":"source/_posts/Kubernetes/监控/heapster.md","hash":"1f6f42d660ee9feb11c9a9f157abfe08e909ebe3","modified":1506945180429},{"_id":"source/_posts/Kubernetes/监控/cadvisor.md","hash":"502629ebd43746e158d13f9f636617e39cced635","modified":1506945124286},{"_id":"source/_posts/Kubernetes/监控/k8s集群监控.md","hash":"291bc3ab6830687b46e6c8ba71c574f10e511d33","modified":1506944993081},{"_id":"source/_posts/Kubernetes/监控/influxdb.md","hash":"953b740210d830486da397d72934aa12a53c44fa","modified":1506945248865},{"_id":"source/img/article/CaaS/docker.png","hash":"bbb16a1a2fa5b11eac0392832293037dadb8f7df","modified":1505551392171},{"_id":"source/img/article/CaaS/云计算三个层次.jpg","hash":"6aff8a6a0546f36dc3f34faaf7db9c364f0ed2a3","modified":1505551370978},{"_id":"source/img/article/CaaS/AppEngine.jpg","hash":"d273466adc52ea44705c874b6d6f586d0407c8e4","modified":1505551396085},{"_id":"source/img/article/CaaS/ContainerVSVMs.jpg","hash":"c77b2a9256ac86afaebe6bbc9b6033cccde9281c","modified":1505551393629},{"_id":"source/img/article/WAE/App Engine.jpg","hash":"d273466adc52ea44705c874b6d6f586d0407c8e4","modified":1505551429113},{"_id":"source/img/article/WAE/Container VS VMs.jpg","hash":"c77b2a9256ac86afaebe6bbc9b6033cccde9281c","modified":1505551427625},{"_id":"source/img/article/WAE/WAE架构.png","hash":"ebe552bc9db46a845c5afdea4a205303ffba2389","modified":1505551419403},{"_id":"source/img/article/WAE/WAE监控.png","hash":"991850b04945b53433edf2f9405c0395576e43df","modified":1505551416729},{"_id":"source/img/article/WAE/WAE网络.png","hash":"89500a95d7fb814faa798902c8c74684bf2580b8","modified":1505551414438},{"_id":"source/img/article/WAE/WAE应用模型.png","hash":"b15e0421f520aeb08245a6b6559fa9376879be75","modified":1505551412115},{"_id":"source/img/article/WAE/WAE部署图.png","hash":"84181794df2396bd3731a12eaf8824fbdec30189","modified":1505551425307},{"_id":"source/img/article/WAE/image2016-3-15 15-48-30.png","hash":"bbb16a1a2fa5b11eac0392832293037dadb8f7df","modified":1505551426784},{"_id":"source/img/article/WAE/云计算三个层次.jpg","hash":"6aff8a6a0546f36dc3f34faaf7db9c364f0ed2a3","modified":1505551397249},{"_id":"source/img/article/WAE/Pod网络.png","hash":"dde96640f328e44d91d3542f9d48dc7064681a01","modified":1505551425543},{"_id":"source/img/article/WAE/五元组.png","hash":"0006c1b3cd57cfa16e6f042d3a27e7ccca625941","modified":1505551399473},{"_id":"source/img/article/WAE/数据存储.png","hash":"f08ba2f6f10a22523f9c040ed362ec40596f71e2","modified":1505551401507},{"_id":"source/img/article/WAE/容器网络.png","hash":"8891d95c90a024016f1abbf1bfc2458d00814abc","modified":1505551404039},{"_id":"source/img/article/WAE/配置中心.png","hash":"e73818022e218995164f02d707f78f63d2e8809e","modified":1505551406717},{"_id":"source/img/article/flannel/docker启动参数.png","hash":"2f5e10035794e68c2ad2693cde446cb576f83e2d","modified":1505551442062},{"_id":"source/img/article/golang/位运算.png","hash":"705d26b570582679fcdbe856988759449b144a4c","modified":1505551433795},{"_id":"source/img/article/golang/字符串操作.png","hash":"7e0130df25d9e7b9427f958b23f612d946a3a3ee","modified":1505551431612},{"_id":"source/img/article/golang/整型.png","hash":"d940723806db26e207ff88d7616bdfb69c3336d0","modified":1505551434149},{"_id":"source/img/article/kubernetes/k8s-etcd-registry.png","hash":"180b6812f8a294e94bc46ee94af01f9db1a058cf","modified":1505551431108},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1506742714891},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1506742714920},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1506742714948},{"_id":"themes/beantech/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1506742714952},{"_id":"source/img/article/WAE/flannel.png","hash":"9e15d69e3fc923414579118f9f039a4b9de29aec","modified":1505551428970},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1506742714953},{"_id":"source/img/article/CaaS/PaaS.jpg","hash":"2956e52202ffac7888a8e6da4a4481ec7d6dd6a9","modified":1505551373552},{"_id":"source/img/article/WAE/WAE多机房.png","hash":"518c2b8000565bc4fbdf32fd0d23c301d4bbe428","modified":1505551422737},{"_id":"source/img/article/database/权限列表.jpg","hash":"1cf706a43f837a943e3dfec062e9497533b22913","modified":1505551369441},{"_id":"source/img/article/WAE/PaaS.jpg","hash":"2956e52202ffac7888a8e6da4a4481ec7d6dd6a9","modified":1505551426893},{"_id":"source/img/article/etcd/raft.png","hash":"f9f93175b07f5a2c32b49ad5ebcffd9f2dd44cce","modified":1505551444385},{"_id":"source/img/article/flannel/UDP封装.png","hash":"4ffc2b329b912074a42f4465e221c37c0d124e3b","modified":1505551441120},{"_id":"source/img/article/flannel/flannel.png","hash":"5cfb989b06b0ba7e37692c00c388bbe1ee869358","modified":1505551441287},{"_id":"source/img/article/flannel/动态路由.png","hash":"6511c900f4073a1a4927f7ba56bd992496b391ce","modified":1505551439024},{"_id":"source/img/article/flannel/数据接收节点路由表.png","hash":"b2b886bba17c2d1e3b2517a4ea828d39861b114c","modified":1505551436447},{"_id":"source/img/article/flannel/静态路由.png","hash":"96800a8b7a357c437073b6eadc83acaf864ae541","modified":1505551438831},{"_id":"source/img/article/flannel/数据发送节点路由表.png","hash":"ee94f43d5bcd83220af1e189496648b6958087e2","modified":1505551435524},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1506742714912},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1506742714918},{"_id":"themes/beantech/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1506742714966},{"_id":"source/img/article/WAE/传统运维.png","hash":"8677d6615de3e15b4e80e289dcebe3a9460ef1c7","modified":1505551409820},{"_id":"source/img/article/docker/docker常用命令原理图/1.png","hash":"9c17579a1f0d3fc9d426b22910938f363ad7756a","modified":1505551521414},{"_id":"source/img/article/docker/docker常用命令原理图/2.1.png","hash":"5362581d6f90b3da4bf012d99b9210d874008bf9","modified":1505551521857},{"_id":"source/img/article/docker/docker常用命令原理图/3.1.png","hash":"8340ba90be176750780840a6cceeb1f3eb010a0c","modified":1505551521258},{"_id":"source/img/article/docker/docker常用命令原理图/3.2.png","hash":"e24e29751173619168f0ddd9bdcdc418788832cb","modified":1505551519932},{"_id":"source/img/article/docker/docker常用命令原理图/4.1.2.png","hash":"e3d8d6932ec30c2913b169b78c8c4805b8e16b3f","modified":1505551519784},{"_id":"source/img/article/docker/docker常用命令原理图/4.1.3.png","hash":"cf8f295c541a96408d68e1bc63ed7afcbd4569ce","modified":1505551518277},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.1.png","hash":"d4133db87951fb74acdcdf2e17571b7e6d4aea0c","modified":1505551518387},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.2.png","hash":"952f40896bc71522dc4d751bd67335a755b7c3d7","modified":1505551518586},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.3.1.png","hash":"030953de07982750a705f5a1700996182dd293ba","modified":1505551516919},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.3.png","hash":"4a40ebbdedd46e19f91ab48eeb1f5a3ce95d8305","modified":1505551516769},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.4.png","hash":"20b509a0cc593f6e91e925c2d14d4e913d30bba8","modified":1505551516567},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.5.png","hash":"d4a49361846eccfc20774c9e63cfa6fd9bea61d2","modified":1505551515174},{"_id":"source/img/article/docker/docker常用命令原理图/4.1.1.png","hash":"9ac79ec240dc279da88ef03dbcbda2b2d3b73eb6","modified":1505551519628},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.7.2.png","hash":"9da8869e1e81741172f684b65e62117f29170f94","modified":1505551514382},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.7.png","hash":"17e8bb5791b979a4d6ec563ad41e3b543adc4b60","modified":1505551512992},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.8.2.png","hash":"4b4f967b588031dd1c7ee497c916b7dc9bb431fc","modified":1505551512874},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.8.1.png","hash":"e8959e4bc87e09eec462806ea2cd08abe8cb87b7","modified":1505551513155},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.2.1.2.png","hash":"165abbbdba85d33143dc72b30c33238143fc64fb","modified":1505551511234},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.2.1.1.png","hash":"20e22dd0c89c2a2a3ad926b8209723674baae1f6","modified":1505551511476},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.2.1.3.png","hash":"be232214fbf048b53943777fd9cc63f0ec59345e","modified":1505551510211},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.2.2.2.png","hash":"91401c7162fe5ff992c519ff16ccfd10890723cc","modified":1505551510781},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.2.3.1.png","hash":"c3c8d6566fe6b4856941cd46e75db553131075b4","modified":1505551509186},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.3.1.png","hash":"f65d1f88e785c861a23fbeabb1298696e98b9953","modified":1505551508269},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.3.3.png","hash":"bd05961839d55a718ee3a182203ac171b51d95db","modified":1505551506342},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.3.4.png","hash":"6f4c919047b91073a276a8e258efd90b3d314b27","modified":1505551506978},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.2.2.1.png","hash":"f7ac1e337d266e4a145a3d741de1669da66dde5d","modified":1505551509877},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.3.2.png","hash":"5cd4d0a86771c59d0c2579f49d7198e30932b3bd","modified":1505551508380},{"_id":"source/img/article/golang/git/git常用命令.png","hash":"558c5b3217f5613b3d6fbb7b27aaf2e68427fde9","modified":1505551466297},{"_id":"source/img/article/golang/模板处理/image2017-3-8 21-57-48.png","hash":"812a840079fdf499d6d90d5567caf94109af146a","modified":1505551465151},{"_id":"source/img/article/kubernetes/k8s基本概念/pod.png","hash":"b1158b7c08649b6f6aa01b284cf9165d44eb6dfd","modified":1505551464337},{"_id":"source/img/article/kubernetes/k8s基本概念/pod2.png","hash":"9e11ec188a107a9e939a3865abeba3247839e951","modified":1505551463509},{"_id":"source/img/article/kubernetes/k8s基本概念/service.png","hash":"9afcca17b2c92f9901c34e93ac6e404b6813b85e","modified":1505551463401},{"_id":"source/img/article/kubernetes/k8s总架构/kubelet.png","hash":"27114267b098f3be50c94a77455c75fef44ecc9d","modified":1505551456256},{"_id":"source/img/article/kubernetes/k8s总架构/master.png","hash":"b139359cde7c1dc8abb899930671d85cbbf9cd16","modified":1505551456086},{"_id":"source/img/article/golang/beego/flow.png","hash":"8a71e74c8daa1d6e3ee68bed22f60d8046c26147","modified":1505551468957},{"_id":"source/img/article/kubernetes/k8s网络/Pod网络.png","hash":"dde96640f328e44d91d3542f9d48dc7064681a01","modified":1505551460494},{"_id":"source/img/article/kubernetes/k8s网络/image2017-5-4 20-51-53.png","hash":"0aedd02c12e917298580fba4901d8470d2e602dc","modified":1505551462719},{"_id":"source/img/article/kubernetes/k8s网络/容器网络.png","hash":"8891d95c90a024016f1abbf1bfc2458d00814abc","modified":1505551459085},{"_id":"source/img/article/kubernetes/k8s网络/网络架构图.png","hash":"b14cc9ae9b1d2857daeb9387061339d49d0a6f6b","modified":1505551457926},{"_id":"source/img/article/kubernetes/kubernetes核心原理/EndpointController.png","hash":"fb65ae5bf2ea163277b4f43e8999c998e3b44e5a","modified":1505551454632},{"_id":"source/img/article/kubernetes/kubernetes核心原理/NodeController.png","hash":"55854a022813b9a99a53c9724d636d3968789c2e","modified":1505551453152},{"_id":"source/img/article/kubernetes/kubernetes核心原理/ResourceQuotaController.png","hash":"461c6d511b1d006517f450d025cc5571df43bdab","modified":1505551452634},{"_id":"source/img/article/kubernetes/kubernetes核心原理/controller-manager.png","hash":"7e0afe16a188927a72687697bc8b77f20eef96e9","modified":1505551456557},{"_id":"source/img/article/kubernetes/kubernetes核心原理/scheduler.png","hash":"a8ac198596f6cbc2b176f60a3af8ef770ba74986","modified":1505551450886},{"_id":"source/img/article/kubernetes/监控/k8s监控架构图.png","hash":"1de244ed4e477e3831e5e94ca912bac8b81d1dbd","modified":1505551449009},{"_id":"source/img/article/etcd/etcd的架构图.jpg","hash":"fe3e0706dc2fd19b8c11e0b36e30b5904e42b0ac","modified":1505551444563},{"_id":"source/img/article/docker/docker整体架构图/execdriver.jpg","hash":"e08315f67557b3a25d93e9a6e650d0039b064010","modified":1505551478146},{"_id":"source/img/article/docker/docker源码之Docker-Daemon/Daemon架构图.jpg","hash":"8b7a2e51a0c29cf26ffbc381a2d5c2574a2e1f6c","modified":1505551485853},{"_id":"source/img/article/docker/docker源码分析之Docker Daemon网络/Docker Daemon网络.jpg","hash":"648130b912d93a207ae4b5f7dcd3d69b70346bdf","modified":1505551502503},{"_id":"source/img/article/docker/docker常用命令原理图/4.2.1.6.png","hash":"0ebadc30bf80571d2c4fe635e5b4ee9343f4dc13","modified":1505551514517},{"_id":"source/img/article/golang/beego/architecture.png","hash":"7bc7773c096f0bb6767669bcf73fe9280b38f1c2","modified":1505551470079},{"_id":"source/img/article/golang/beego/init.png","hash":"dd5bfc631b2cefddd95de64c3ab7d427b96aaa3c","modified":1505551468376},{"_id":"source/img/article/docker/docker常用命令原理图/docker命令原理图.jpg","hash":"f3f7a04af914f44cc19c10849a2b0b90621bb073","modified":1505551504426},{"_id":"source/img/article/kubernetes/kubernetes核心原理/kube-apiserver.png","hash":"bb9168d917f833dec069dcb4def07110b998dadd","modified":1505551454503},{"_id":"source/img/article/CaaS/k8s架构.png","hash":"61683a1e538d59f89d803be9d9980cc2f76ba639","modified":1505551389806},{"_id":"source/img/article/TCPIP/tcpip/IP协议/1.1.png","hash":"b063aa57e4011b9616b05578a257c70be7301600","modified":1505551546750},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/打包解包过程.png","hash":"2555975cef7d6e730cb53bae134b97b685d79e1d","modified":1505551532965},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/文件传输.png","hash":"32ae6ad1337e4275d46aba44af2f0c0a4418574f","modified":1505551527039},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/电子邮件.png","hash":"0f3adeeb25b5e29fe72d040bb3942e44c3b22654","modified":1505551531346},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/远程登录.png","hash":"186a31828ba3df6a33a6ab45cb559eb5554abea9","modified":1505551526918},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/通信模型.png","hash":"603a93df0206dfd4a3e2d3cb22d8578da7a30d88","modified":1505551528504},{"_id":"source/img/article/TCPIP/tcpip/TCP与UDP/1.3.3.png","hash":"4f5af5a3d2d9edc333dd92f28d67f47f450d69a8","modified":1505551525497},{"_id":"source/img/article/TCPIP/tcpip/TCP与UDP/2.2.1.png","hash":"f50b5e0af27af00ffe7076971a73ab264591c08f","modified":1505551523519},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/1.4.1.png","hash":"0442867d276a14c80956207de49dd195babb3ac5","modified":1505551567477},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.2.1.png","hash":"f15ff170f42848ed552d79e9a91cbb0adddd6f01","modified":1505551562936},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.2.2.png","hash":"218f5cd51c32bf47d518ab9b2299a028b8b2d809","modified":1505551563081},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.5.1.png","hash":"8d91ef8adc60557af908751877fc979a2d7ef72a","modified":1505551560911},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.5.2.png","hash":"9f3da042dba4c1b2c1b369ff40a7df2c95925a24","modified":1505551560766},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.8.1.png","hash":"f8778fc60c774474fcb54af167766bd849aaafde","modified":1505551555979},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.3.3.2.png","hash":"bcf9ea2f7c1a31bf7281e7a4f1f11a0c7ce365fd","modified":1505551553674},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/3.5.2.png","hash":"628e1a3b53876a035e0ca09aa92257d9b2c0b684","modified":1505551586385},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.1.1.png","hash":"5d6aab4dd8ff13320c99b0e18d1360254fb0c951","modified":1505551585221},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.1.2.png","hash":"469c7c2e058170009fbbd6fd3783cb4167c7aa34","modified":1505551584973},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.1.3.png","hash":"8a00aaeb5467c3215f4a822088326319d2abda6e","modified":1505551582649},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.2.1.png","hash":"794c365dc2fd5b1080d2a272b0ab333cdd2ed19c","modified":1505551582507},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.2.2.png","hash":"5a670f427faa7e7fb464a36954190385ca7f41d8","modified":1505551582326},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.2.3.png","hash":"c4fada07f6d267b37f08188e418cf2cd02073c21","modified":1505551580689},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.2.4.png","hash":"3dd989f61fa2ebe4fd3297b9e45502b0e28c59e4","modified":1505551580562},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.3.1.png","hash":"928c7ebfa35965311d4fe65b8e901e3716f58bc1","modified":1505551578550},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.3.3.png","hash":"cad9ef4492acdcb6d81fb8f5879fb045c6ce44af","modified":1505551578913},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.4.1.png","hash":"10b83c29f13947db7889d150d6b4e4a753157706","modified":1505551576940},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.4.2.png","hash":"5cf701ce3040edb0d69850d14c3f53a53792c06e","modified":1505551575076},{"_id":"source/img/article/TCPIP/HTTP/web服务器/5.1.3.png","hash":"fd4b1fa45fe8b70e667f86952209a2d5d5fbdbe9","modified":1505551549169},{"_id":"source/img/article/TCPIP/HTTP/web服务器/5.2.2.png","hash":"279de4678050885aac3676f0264a8e9a145e95c6","modified":1505551548913},{"_id":"source/img/article/WAE/k8s架构.png","hash":"61683a1e538d59f89d803be9d9980cc2f76ba639","modified":1505551440331},{"_id":"source/img/article/docker/docker整体架构图/container.jpg","hash":"dd27ad7bbe499c33f373a57c6e22b48fc943350e","modified":1505551483613},{"_id":"source/img/article/docker/docker整体架构图/docker-daemon.jpg","hash":"a4b8a67caccd67ac8a49eacb2a70a06fdf5a7491","modified":1505551480696},{"_id":"source/img/article/docker/docker整体架构图/docker-server.jpg","hash":"e5e14de6f75118a683ed7ac1fe9fe5132eea6089","modified":1505551479817},{"_id":"source/img/article/docker/docker整体架构图/graphdriver.jpg","hash":"9bb1835c9a0ee385c1300e2cb36facab6cff1e1c","modified":1505551478634},{"_id":"source/img/article/docker/docker整体架构图/libcontainer.jpg","hash":"dfa6693a00fd5ff4ecb44e302ca4cdb2b6547370","modified":1505551471508},{"_id":"source/img/article/docker/docker整体架构图/networkdriver.jpg","hash":"3823cd56d01815f84f351b94b5f2c23f9731337a","modified":1505551473970},{"_id":"source/img/article/docker/docker源码之Docker-Daemon/Daemon启动流程.jpg","hash":"6321990f8b17129f73eb5e1fb069cf45daa66e74","modified":1505551491470},{"_id":"source/img/article/docker/docker源码分析之Docker-Server/流程图.jpg","hash":"c4ae7c277f8693dcd4d1d354df4d597ecbae80a8","modified":1505551495230},{"_id":"source/img/article/golang/http执行流程/image2017-3-5 22-46-35.png","hash":"1f3cd2c427ff675cfa2388ee66339ec3a0c1e197","modified":1505551467457},{"_id":"source/img/article/golang/http执行流程/image2017-3-5 23-50-6.png","hash":"bc03cfc24ba5b53292466dae8c267ffbbca886b6","modified":1505551466182},{"_id":"source/img/article/TCPIP/tcpip/IP协议/1.2.png","hash":"a79e85fb7f0ec6d41ea0772772e768dffa3b2796","modified":1505551546621},{"_id":"source/img/article/TCPIP/tcpip/IP协议/1.3.0.png","hash":"573faebebf285a1a4847b1374f1858754d0f9c0e","modified":1505551544965},{"_id":"source/img/article/TCPIP/tcpip/IP协议/1.3.1.png","hash":"9e72d61bb00b26fcfdcc08addbea807210ab7c14","modified":1505551544641},{"_id":"source/img/article/TCPIP/tcpip/IP协议/1.3.png","hash":"5dc9cfbb93d957c075c6812b96dd67b2e4836eed","modified":1505551544532},{"_id":"source/img/article/TCPIP/tcpip/IP协议/2.2.1.png","hash":"63d9314d1a6dc48d2c05aad66818e6d64b822fe6","modified":1505551542765},{"_id":"source/img/article/TCPIP/tcpip/IP协议/2.2.png","hash":"975d338302c51d494a1c88a799ca53379c324e1e","modified":1505551542582},{"_id":"source/img/article/TCPIP/tcpip/IP协议/4.1.png","hash":"bfb68eeab57295e084904c2da44f8b83f2dd99e1","modified":1505551538060},{"_id":"source/img/article/TCPIP/tcpip/IP协议/4.2.png","hash":"4a7cb280b0e6ad5533a5cc1efcda846b56ba67c5","modified":1505551537909},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/OSI各层功能.png","hash":"3c1c50fb874c2d86723b58f081a4e32516314fe2","modified":1505551535906},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/OSI通信.png","hash":"cd2f687276684e4fe12afc7aae87320e1c4d3305","modified":1505551536041},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/WWW.png","hash":"b90de4532db3d3df7dcdb172517f44902323cd40","modified":1505551533864},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/数据包结构.png","hash":"50cb7b5df6ed2ea86363a01ab03dd3978369635b","modified":1505551531944},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/网络构成.png","hash":"a5c6232813f9b83f906919873c673038617f7fbc","modified":1505551529579},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/网络管理.png","hash":"6b7e807ab8356648a6fa0e80634dea4bfbc4c964","modified":1505551528626},{"_id":"source/img/article/TCPIP/tcpip/TCP与UDP/1.1.png","hash":"53cf9fa6c1b024b537e40c9d1496a31be653595e","modified":1505551526526},{"_id":"source/img/article/TCPIP/tcpip/TCP与UDP/1.2.png","hash":"9918672eb6ee8943e552a523f848a5b51383a063","modified":1505551525652},{"_id":"source/img/article/TCPIP/tcpip/TCP与UDP/2.2.png","hash":"bfc7668e9458980075df6c421f9aea02f303c270","modified":1505551523823},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/1.1.png","hash":"912acfb9e51f3ec8025f1ea4f43e9a2ce8a530a5","modified":1505551574753},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/1.2.png","hash":"48b6fd53196f27c624be9520ef10af0f4a70e9dd","modified":1505551572801},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/1.3.2.png","hash":"f8b297bbf57bee3d449656fc439cbba33975aca0","modified":1505551570275},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/1.3.3.png","hash":"111bc4b5fbbe289470dbc3c940a786a630dfe501","modified":1505551570149},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/1.4.2.png","hash":"91cce33a9704b3335a97decb3d458f0ebb803c85","modified":1505551567657},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.1.1.png","hash":"fa9fcc4f7a8adb4c57e81c9aec0989323ecb84fb","modified":1505551566691},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.1.2.png","hash":"a95de751896924b1b756cf8ae86a8b9b3b4f290b","modified":1505551565480},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.1.png","hash":"b1031dfa7a538e3eaf1c612685cc5f8094bc23e1","modified":1505551565361},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.3.png","hash":"ee9c1676b24fe9c812730e0d4db61e96970b725d","modified":1505551563230},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.4.png","hash":"e068bb5f661478854f1b6fdc51d6469e69f56397","modified":1505551561246},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.6.png","hash":"18ebc7487fa2572302fb90f9ff309cda1a001f10","modified":1505551558552},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.8.2.png","hash":"1387baed4c8e49c18bbe9c64088817e97de5bc66","modified":1505551558270},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.3.2.png","hash":"ef814e9d2aae2c246076b0ac6b1a4399adf70f04","modified":1505551554679},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.3.3.3.png","hash":"a275960dc946e2e90dab378a22d4fcaa9222aca2","modified":1505551554567},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/3.1.png","hash":"900c0105bdb4585e416487f6eb96b718ba9cccd7","modified":1505551589785},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/3.2.png","hash":"f950194f99fe008642a479bdc03cd6ae0cd252b9","modified":1505551589038},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/3.3.2.png","hash":"ceff96c2c6d42472935db142f4b614a33b50b072","modified":1505551587506},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/3.3.3.png","hash":"fbbafaac0be68637927cb01485953a4a85c7f5f7","modified":1505551587637},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.3.2.png","hash":"3cacfae0271fe963222e783362a8adb7b907848b","modified":1505551579126},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.3.4.png","hash":"845bdbcf5b127683f070a1f16cd048733cd694a1","modified":1505551577063},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/4.png","hash":"61c8af1447515918759fd3eb922caeab762cddca","modified":1505551576834},{"_id":"source/img/article/TCPIP/HTTP/web服务器/5.1.2.png","hash":"fe97361cb534c4534189fad0c23098b093b37683","modified":1505551551692},{"_id":"source/img/article/TCPIP/HTTP/web服务器/5.2.1.png","hash":"8cb303897a9682fc5b3d7953ee85ffbf44a4968c","modified":1505551549043},{"_id":"source/img/article/docker/docker整体架构图/docker总架构图.jpg","hash":"574478332a680c4ea8c3cf1a57fee4f5f6c217aa","modified":1505551485963},{"_id":"source/img/article/docker/docker整体架构图/graph架构.jpg","hash":"55a0db4155edfaa5e725e8dc4924918bac4132dd","modified":1505551475523},{"_id":"source/img/article/docker/docker源码分析之Docker Daemon网络/网络初始化.jpg","hash":"08524bb1c091fb419582cd51aa22eb08f86791f0","modified":1505551500469},{"_id":"source/img/article/kubernetes/监控/cAdvisor.png","hash":"47af625a59df436b2295e5c525c1c23c829df915","modified":1505551451755},{"_id":"source/img/article/TCPIP/tcpip/IP协议/2.3.png","hash":"cbe970019d88fc992db6301845bfa8bd8ee7fbb9","modified":1505551542477},{"_id":"source/img/article/TCPIP/tcpip/IP协议/2.4.1.png","hash":"d428789da250258b0d0f4aba3f6f976203870165","modified":1505551540553},{"_id":"source/img/article/TCPIP/tcpip/IP协议/3.1.png","hash":"50d30ee487f65e72989f38200f009537aa42f252","modified":1505551540707},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/TCP-IP与OSI参考模型.png","hash":"c50d3452d40d320b19a931e9959dc3b9e22bf5e2","modified":1505551534579},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/image2017-3-3 14-12-58.png","hash":"d1d7912177c34892aa53db2270c2e9d1b50f7427","modified":1505551536567},{"_id":"source/img/article/TCPIP/tcpip/TCPIP基础/数据传输流程.png","hash":"4705e377b4cae54d418c09544965560e300ffddc","modified":1505551531789},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/1.2.1.png","hash":"3ffb1257ebc37478978060bd53e827a287614d76","modified":1505551572922},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/1.3.1.png","hash":"656c9681b3dbc14365f15fa92f8016e73059624d","modified":1505551572346},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/1.3.4.png","hash":"2e2e31f31178adc8450644e6d6fff990e8b8b851","modified":1505551568835},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.1.png","hash":"c94ffbbf3cc70c37ef65af9680957e1fa34a8d04","modified":1505551565011},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.2.7.png","hash":"5f7d1fcaf342f4a65e309c7a3b937f39ee684eaa","modified":1505551558387},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.3.1.png","hash":"12f6aebd0c08cc0db716b2384c6832dafac3daa3","modified":1505551555767},{"_id":"source/img/article/TCPIP/HTTP/HTTP基础/2.3.3.png","hash":"1717b278e08d75a5bf240fcf400e4bd3f3713cc4","modified":1505551551853},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/3.5.png","hash":"a6ddef4c54b881a5e97c67243a48e019b219f167","modified":1505551584733},{"_id":"source/img/article/TCPIP/HTTP/web服务器/5.1.1.png","hash":"a38b4d9dd84fe507ad3a5f354fbd649060436626","modified":1505551552074},{"_id":"source/img/article/TCPIP/HTTP/web服务器/5.2.png","hash":"597cad94f0237f7c62b5f27ec2d45e04e561b54e","modified":1505551547635},{"_id":"source/img/article/docker/docker源码之docker-client/docker-client流程图.jpg","hash":"9c08acb4956ea548045a234a3d20a4756086f489","modified":1505551500141},{"_id":"source/img/article/docker/docker源码分析之New Daemon/New Daemon流程图.jpg","hash":"3b02270d8d0d5e62477a73db19dffce0ea7e285a","modified":1505551492996},{"_id":"source/img/article/kubernetes/k8s总架构/architecture.png","hash":"e9fb85ddbffdbbe8e8f1fd972d52b3a6d3cd4c70","modified":1505551461955},{"_id":"source/img/article/kubernetes/k8s总架构/k8s架构2.png","hash":"61683a1e538d59f89d803be9d9980cc2f76ba639","modified":1505551461790},{"_id":"source/img/article/TCPIP/tcpip/IP协议/3.2.png","hash":"13a271307d196d5ed4ab97bfaac68fe0c81f516a","modified":1505551540419},{"_id":"source/img/article/TCPIP/tcpip/TCP与UDP/2.3.png","hash":"8807a383dc12057d5d12da2fcdb4def81569f0e9","modified":1505551523661},{"_id":"source/img/article/TCPIP/HTTP/HTTP报文及状态码/3.2.2.png","hash":"8cab39060cfc648f787ae45148e76c07eb35d7e9","modified":1505551590294},{"_id":"source/img/article/docker/docker源码分析之Docker Daemon网络/创建网桥流程.jpg","hash":"f4d105ef60af28b3cf32daa69bb49ff2fec5305a","modified":1505551506833},{"_id":"source/img/article/golang/git/git.png","hash":"6660a51d43eb7aeb5034483cc87ada67edbaee13","modified":1505551475969},{"_id":"source/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1506742714889},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1506742714911},{"_id":"source/img/article_header_img/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1506742714877},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1506742714908},{"_id":"source/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1506742714904},{"_id":"source/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1506742714899},{"_id":"source/_posts/Golang/Golang常用包.md","hash":"0a6dc8bc16bbdeb493205da61063e3c89f4e15a8","modified":1507011337155},{"_id":"source/_posts/Golang/Golang系列（一）之基础篇.md","hash":"46d685969010778474aa290d6d32c8fa4e1a4d37","modified":1506948922618},{"_id":"source/_posts/Golang/Golang系列（三）之并发编程.md","hash":"c098ab0a077a7da8ec0e7120bf187d9b5808a315","modified":1506949504451},{"_id":"source/_posts/Golang/Golang系列（二）之面向对象编程.md","hash":"b1ee843281734c784c586ee0e16142c738f1ba6a","modified":1507017965861},{"_id":"source/_posts/Golang/Go语言指针.md","hash":"bb0148fcdd1f1ceb318fb4e004ad73a98d3428f0","modified":1507011418702},{"_id":"source/_posts/Golang/govendor的使用.md","hash":"b75af1c3e8890415339026fda027e35737374dee","modified":1507011995944},{"_id":"source/_posts/Golang/beego/beego介绍.md","hash":"10cedc117e40434b689a32cdc14c39045c55bd47","modified":1507011155829},{"_id":"source/_posts/Golang/网络编程/Go http执行流程.md","hash":"dde8aeb84f66c96e7b6e727e7f9faf9d23aaf160","modified":1507017946351},{"_id":"source/_posts/Golang/Golang之GDB调试.md","hash":"b3ebd37fbbc467a8c893e26f4b0ee59efaa89cc0","modified":1507012047349},{"_id":"source/_posts/Golang/Golang模板处理.md","hash":"988bee603b2303d12e9cf2f7fda8ce040ec66852","modified":1507012256391},{"_id":"source/_posts/Golang/Golang模板语法.md","hash":"2ffa6f3cbf0893826559de1d3d256b83bef92398","modified":1507012181354},{"_id":"source/_posts/Golang/Golang测试用例.md","hash":"5b4b42164b0a7b88f6cc9dbc71fdd2559e8b05bc","modified":1507012313332},{"_id":"source/img/article/golang/http执行流程/http包执行流程图.png","hash":"1f3cd2c427ff675cfa2388ee66339ec3a0c1e197","modified":1505551467457},{"_id":"source/img/article/golang/http执行流程/http连接处理流程图.png","hash":"bc03cfc24ba5b53292466dae8c267ffbbca886b6","modified":1505551466182}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2017-10-01T14:22:57.210Z","updated":"2017-09-30T03:38:34.871Z","path":"404.html","title":"","comments":1,"_id":"cj8b740bb000030vuxgtzc4ja","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T20:48:33.000Z","description":"Wish for the Best, Prepare for the Worst","header-img":"img/header_img/Iron-Man-3.jpg","comments":1,"_content":"\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n\n### 兴趣\n\n容器云（Docker、Kubernetes等）相关生态技术研究。\n\n### 参与社区\n\n- CSDN博客:http://blog.csdn.net/huwh_\n- 阿里云栖社区:https://yq.aliyun.com/u/huweihuang\n- dockerone社区:http://dockone.io/people/胡伟煌\n- Github:https://github.com/huweihuang","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Wish for the Best, Prepare for the Worst\"\nheader-img: \"img/header_img/Iron-Man-3.jpg\"\ncomments: true\n---\n\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n\n### 兴趣\n\n容器云（Docker、Kubernetes等）相关生态技术研究。\n\n### 参与社区\n\n- CSDN博客:http://blog.csdn.net/huwh_\n- 阿里云栖社区:https://yq.aliyun.com/u/huweihuang\n- dockerone社区:http://dockone.io/people/胡伟煌\n- Github:https://github.com/huweihuang","updated":"2017-10-09T03:09:04.205Z","path":"about/index.html","_id":"cj8b740e4000130vu9w71chcj","content":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n<h3><span id=\"兴趣\">兴趣</span></h3>\n<p>容器云（Docker、Kubernetes等）相关生态技术研究。</p>\n<h3><span id=\"参与社区\">参与社区</span></h3>\n<ul>\n<li>CSDN博客:<a href=\"http://blog.csdn.net/huwh_\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/huwh_</a></li>\n<li>阿里云栖社区:<a href=\"https://yq.aliyun.com/u/huweihuang\" target=\"_blank\" rel=\"external\">https://yq.aliyun.com/u/huweihuang</a></li>\n<li>dockerone社区:<a href=\"http://dockone.io/people/%E8%83%A1%E4%BC%9F%E7%85%8C\" target=\"_blank\" rel=\"external\">http://dockone.io/people/胡伟煌</a></li>\n<li>Github:<a href=\"https://github.com/huweihuang\" target=\"_blank\" rel=\"external\">https://github.com/huweihuang</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n<h3>兴趣</h3>\n<p>容器云（Docker、Kubernetes等）相关生态技术研究。</p>\n<h3>参与社区</h3>\n<ul>\n<li>CSDN博客:<a href=\"http://blog.csdn.net/huwh_\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/huwh_</a></li>\n<li>阿里云栖社区:<a href=\"https://yq.aliyun.com/u/huweihuang\" target=\"_blank\" rel=\"external\">https://yq.aliyun.com/u/huweihuang</a></li>\n<li>dockerone社区:<a href=\"http://dockone.io/people/%E8%83%A1%E4%BC%9F%E7%85%8C\" target=\"_blank\" rel=\"external\">http://dockone.io/people/胡伟煌</a></li>\n<li>Github:<a href=\"https://github.com/huweihuang\" target=\"_blank\" rel=\"external\">https://github.com/huweihuang</a></li>\n</ul>\n"},{"layout":"archive","title":"Archives","header-img":"img/header_img/archive-bg.png","comments":0,"date":"2017-03-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"img/header_img/archive-bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2017-09-30T03:38:34.883Z","path":"archive/index.html","_id":"cj8b740e8000230vubvz6jx3e","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/header_img/tag-bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/header_img/tag-bg.png\"\n---\n","date":"2017-10-01T14:21:51.651Z","updated":"2017-09-30T03:38:34.921Z","path":"tags/index.html","comments":1,"_id":"cj8b740e9000330vuac0q9jl3","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"[Database] Mysql常用命令","catalog":true,"date":"2017-08-13T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Database"],"_content":"\n## 1. 系统管理\n\n### 1.1. 连接mysql\n\n格式： mysql -h主机地址 -u用户名 －p用户密码\n\n连接本地：mysql -h`localhost/127.0.0.1` -u用户名 －p用户密码\n\n连接远程：mysql -h`主机地址` -u用户名 －p用户密码\n退出连接：exit\n\n### 1.2. 备份数据库\n\n**1.导出整个数据库**\n\n导出文件默认是存在mysql\\bin目录下\n\nmysqldump -u 用户名 -p 数据库名 ` 导出的文件名\n\nmysqldump -u user_name -p123456 database_name ` outfile_name.sql\n\n**2.导出一个表**\n\nmysqldump -u 用户名 -p 数据库名 表名` 导出的文件名\n\nmysqldump -u user_name -p database_name table_name ` outfile_name.sql\n\n**3.导出一个数据库结构**\n\nmysqldump -u user_name -p -d –add-drop-table database_name ` outfile_name.sql\n\n-d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table\n\n**4.带语言参数导出**\n\nmysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name ` outfile_name.sql\n\n**5、导入数据库**\n\nmysql -u root –p ` [备份文件的保存路径] 或者source [备份文件的保存路径]\n\n### 1.3. 用户管理\n\n**1、创建用户**\n\n​    create user '用户名'@'IP地址' identified by '密码';\n\n**2、删除用户**\n\n​    drop user '用户名'@'IP地址';\n\n​    delete from user where user='用户名' and host='localhost';\n\n**3、修改用户**\n\n​    rename user '用户名'@'IP地址'; to '新用户名'@'IP地址';;\n\n**4、修改密码**\n\n​    set password for '用户名'@'IP地址' = Password('新密码')\n\n​    mysqladmin -u用户名 -p旧密码 password 新密码\n\n### 1.4. 权限管理\n\n#### 1.4.1. grant\n\n**1、grant 权限 on 数据库对象 to 用户**\n\n数据库对象的格式为`database`.`table`。`database`.*：表示授权数据库对象该数据库的所有表；*.*：表示授权数据库对象为所有数据库的所有表。\n\ngrant all privileges on *.* to `user`@'`ip`' identified by '`passwd`';如果`ip`为'%'表示不限制IP。\n\n**2、撤销权限**：\n\nrevoke all on *.* from `user`@`ip`; \n\n#### 1.4.2. 普通数据库用户\n\n查询、插入、更新、删除 数据库中所有表数据的权利\n\ngrant select, insert, update, delete on testdb.* to `user`@'`ip`';\n\n#### 1.4.3. DBA 用户\n\n**1、授权**\n\ngrant all privileges on *.* to `dba`@'`ip`' identified by '`passwd`';\n\n**2、刷新系统权限**\n\nflush privileges;\n\n#### 1.4.4. 查看用户权限\n\n1、查看当前用户（自己）权限\n\nshow grants;\n\n2、查看指定MySQL 用户权限\n\nshow grants for `user`@`localhost`;\n\n3、查看user和host\n\nselect user,host from mysql.user order by user;\n\n#### 1.4.5. 权限列表\n\n![img](/img/article/database/权限列表.jpg)\n\n#### 1.4.6. 查看主从关系\n\n登录主机：show slave hosts;\n\n登录从机：show slave status;\n\n## 2. 数据库操作\n\n**1、创建数据库**\n\ncreate database `数据库名`\n\n**2、显示数据库**\n\nshow databases\n\n**3、删除数据**\n\ndrop database `数据库名`\n\n## 3. 数据表操作\n\n**1、创建表**\n\n> create table 表名(\n>\n> ​    列名  类型  是否可以为空，\n>\n> ​    列名  类型  是否可以为空\n>\n> )ENGINE=InnoDB DEFAULT CHARSET=utf8\n\n- 默认值，创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值\n- 自增，如果为某列设置自增列，插入数据时无需设置此列，默认将自增（表中只能有一个自增列）注意：1、对于自增列，必须是索引（含主键）2、对于自增可以设置步长和起始值\n- 主键，一种特殊的唯一索引，不允许有空值，如果主键使用单个列，则它的值必须唯一，如果是多列，则其组合必须唯一。\n\n**2、查看表**\n\nshow tables;                    # 查看数据库全部表\n\nselect * from 表名;             # 查看表所有内容\n\n**3、删除表**\n\ndrop table 表名\n\n**4、清空表内容**\n\ndelete from 表名\n\ntruncate table 表名\n\n**5、查看表结构**\n\ndesc 表名\n\n**6、修改表**\n\n> 添加列：   alter table 表名 add 列名 类型\n>\n> 删除列：   alter table 表名 drop column 列名\n>\n> 修改列：\n>\n> ​          alter table 表名 modify column 列名 类型;  -- 类型\n>\n> ​          alter table 表名 change 原列名 新列名 类型; -- 列名，类型\n>\n>   \n>\n> 添加主键：\n>\n> ​          alter table 表名 add primary key(列名);\n>\n> 删除主键：\n>\n> ​          alter table 表名 drop primary key;\n>\n> ​          alter table 表名  modify  列名 int, drop primary key;\n>\n>   \n>\n> 添加外键： alter table 从表 add constraint 外键名称（形如：FK_从表_主表） foreign key 从表(外键字段) references 主表(主键字段);\n>\n> 删除外键： alter table 表名 drop foreign key 外键名称\n>\n>   \n>\n> 修改默认值：ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;\n>\n> 删除默认值：ALTER TABLE testalter_tbl ALTER i DROP DEFAULT;\n\n## 4. 表内容操作\n\n### 4.1. 增\n\n> insert into 表 (列名,列名...) values (值,值,...)\n>\n> insert into 表 (列名,列名...) values (值,值,...),(值,值,值...)\n>\n> insert into 表 (列名,列名...) select (列名,列名...) from 表\n>\n> 例：\n>\n> ​    insert into tab1(name,email) values('zhangyanlin','zhangyanlin8851@[163.com](http://163.com/)')\n\n### 4.2. 删\n\n> delete from 表                                      # 删除表里全部数据\n>\n> delete from 表 where id＝1 and name＝'zhangyanlin'   # 删除ID =1 和name='zhangyanlin' 那一行数据\n\n### 4.3. 改\n\n> update 表 set name ＝ 'zhangyanlin' where id`1\n\n### 4.4. 查\n\n> select * from 表\n>\n> select * from 表 where id ` 1\n>\n> select nid,name,gender as gg from 表 where id ` 1\n\n### 4.5. 条件判断\n\n#### 4.5.1. where\n\n```go\nselect * from `table` where id `1 and name!='huwh' and num =12;\nselect * from `table` where id between 5 and 6;\nselect * from `table` where id in (11,22,33);\nselect * from `table` where id not in (11,22,33);\nselect * from `table` where id in (select nid from `table`)\n```\n\n#### 4.5.2. 通配符like\n\n```go\nselect * from `table` where name like 'hu%';   #hu开头\nselect * from `table` where name like 'hu_'    #hu开头后接一个字符\n```\n\n#### 4.5.3. 限制limit\n\n```go\nselect * from `table` limit 5;   #前5行\nselect * from `table` limit 4,5  #从第四行开始的5行\nselect * from `table` limit 5 offset 4;#从第四行开始的5行\n```\n\n#### 4.5.4. 排序asc，desc\n\n```go\nselect * from `table` order by 列 asc;            #跟据“列”从小到大排序（不指定默认为从小到大排序）\nselect * from `table` order by 列 desc;           #根据“列”从大到小排序\nselect * from `table` order by 列1 desc,列2 asc;  #根据“列1”从大到小排序，如果相同则按“列2”从小到大排序\n```\n\n#### 4.5.5. 分组group by\n\ngroup by 必须在where之后，order by之前。\n\n```go\nselect num,from `table` group by num;     \nselect num,nid from `table` group by num,nid;\nselect num from `table` where nid ` 10 group by num,nid order nid desc;\nselect num,nid,count(*),sum(score),max(score) from `table` group by num;\nselect num from `table` group by num having max(id) ` 10;\nselect num from `table` group by num;\n```\n\n","source":"_posts/Database/Mysql常用命令.md","raw":"---\ntitle: \"[Database] Mysql常用命令\"\ncatalog: true\ndate: 2017-08-13 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Database\ncatagories:\n- Database\n---\n\n## 1. 系统管理\n\n### 1.1. 连接mysql\n\n格式： mysql -h主机地址 -u用户名 －p用户密码\n\n连接本地：mysql -h`localhost/127.0.0.1` -u用户名 －p用户密码\n\n连接远程：mysql -h`主机地址` -u用户名 －p用户密码\n退出连接：exit\n\n### 1.2. 备份数据库\n\n**1.导出整个数据库**\n\n导出文件默认是存在mysql\\bin目录下\n\nmysqldump -u 用户名 -p 数据库名 ` 导出的文件名\n\nmysqldump -u user_name -p123456 database_name ` outfile_name.sql\n\n**2.导出一个表**\n\nmysqldump -u 用户名 -p 数据库名 表名` 导出的文件名\n\nmysqldump -u user_name -p database_name table_name ` outfile_name.sql\n\n**3.导出一个数据库结构**\n\nmysqldump -u user_name -p -d –add-drop-table database_name ` outfile_name.sql\n\n-d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table\n\n**4.带语言参数导出**\n\nmysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name ` outfile_name.sql\n\n**5、导入数据库**\n\nmysql -u root –p ` [备份文件的保存路径] 或者source [备份文件的保存路径]\n\n### 1.3. 用户管理\n\n**1、创建用户**\n\n​    create user '用户名'@'IP地址' identified by '密码';\n\n**2、删除用户**\n\n​    drop user '用户名'@'IP地址';\n\n​    delete from user where user='用户名' and host='localhost';\n\n**3、修改用户**\n\n​    rename user '用户名'@'IP地址'; to '新用户名'@'IP地址';;\n\n**4、修改密码**\n\n​    set password for '用户名'@'IP地址' = Password('新密码')\n\n​    mysqladmin -u用户名 -p旧密码 password 新密码\n\n### 1.4. 权限管理\n\n#### 1.4.1. grant\n\n**1、grant 权限 on 数据库对象 to 用户**\n\n数据库对象的格式为`database`.`table`。`database`.*：表示授权数据库对象该数据库的所有表；*.*：表示授权数据库对象为所有数据库的所有表。\n\ngrant all privileges on *.* to `user`@'`ip`' identified by '`passwd`';如果`ip`为'%'表示不限制IP。\n\n**2、撤销权限**：\n\nrevoke all on *.* from `user`@`ip`; \n\n#### 1.4.2. 普通数据库用户\n\n查询、插入、更新、删除 数据库中所有表数据的权利\n\ngrant select, insert, update, delete on testdb.* to `user`@'`ip`';\n\n#### 1.4.3. DBA 用户\n\n**1、授权**\n\ngrant all privileges on *.* to `dba`@'`ip`' identified by '`passwd`';\n\n**2、刷新系统权限**\n\nflush privileges;\n\n#### 1.4.4. 查看用户权限\n\n1、查看当前用户（自己）权限\n\nshow grants;\n\n2、查看指定MySQL 用户权限\n\nshow grants for `user`@`localhost`;\n\n3、查看user和host\n\nselect user,host from mysql.user order by user;\n\n#### 1.4.5. 权限列表\n\n![img](/img/article/database/权限列表.jpg)\n\n#### 1.4.6. 查看主从关系\n\n登录主机：show slave hosts;\n\n登录从机：show slave status;\n\n## 2. 数据库操作\n\n**1、创建数据库**\n\ncreate database `数据库名`\n\n**2、显示数据库**\n\nshow databases\n\n**3、删除数据**\n\ndrop database `数据库名`\n\n## 3. 数据表操作\n\n**1、创建表**\n\n> create table 表名(\n>\n> ​    列名  类型  是否可以为空，\n>\n> ​    列名  类型  是否可以为空\n>\n> )ENGINE=InnoDB DEFAULT CHARSET=utf8\n\n- 默认值，创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值\n- 自增，如果为某列设置自增列，插入数据时无需设置此列，默认将自增（表中只能有一个自增列）注意：1、对于自增列，必须是索引（含主键）2、对于自增可以设置步长和起始值\n- 主键，一种特殊的唯一索引，不允许有空值，如果主键使用单个列，则它的值必须唯一，如果是多列，则其组合必须唯一。\n\n**2、查看表**\n\nshow tables;                    # 查看数据库全部表\n\nselect * from 表名;             # 查看表所有内容\n\n**3、删除表**\n\ndrop table 表名\n\n**4、清空表内容**\n\ndelete from 表名\n\ntruncate table 表名\n\n**5、查看表结构**\n\ndesc 表名\n\n**6、修改表**\n\n> 添加列：   alter table 表名 add 列名 类型\n>\n> 删除列：   alter table 表名 drop column 列名\n>\n> 修改列：\n>\n> ​          alter table 表名 modify column 列名 类型;  -- 类型\n>\n> ​          alter table 表名 change 原列名 新列名 类型; -- 列名，类型\n>\n>   \n>\n> 添加主键：\n>\n> ​          alter table 表名 add primary key(列名);\n>\n> 删除主键：\n>\n> ​          alter table 表名 drop primary key;\n>\n> ​          alter table 表名  modify  列名 int, drop primary key;\n>\n>   \n>\n> 添加外键： alter table 从表 add constraint 外键名称（形如：FK_从表_主表） foreign key 从表(外键字段) references 主表(主键字段);\n>\n> 删除外键： alter table 表名 drop foreign key 外键名称\n>\n>   \n>\n> 修改默认值：ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;\n>\n> 删除默认值：ALTER TABLE testalter_tbl ALTER i DROP DEFAULT;\n\n## 4. 表内容操作\n\n### 4.1. 增\n\n> insert into 表 (列名,列名...) values (值,值,...)\n>\n> insert into 表 (列名,列名...) values (值,值,...),(值,值,值...)\n>\n> insert into 表 (列名,列名...) select (列名,列名...) from 表\n>\n> 例：\n>\n> ​    insert into tab1(name,email) values('zhangyanlin','zhangyanlin8851@[163.com](http://163.com/)')\n\n### 4.2. 删\n\n> delete from 表                                      # 删除表里全部数据\n>\n> delete from 表 where id＝1 and name＝'zhangyanlin'   # 删除ID =1 和name='zhangyanlin' 那一行数据\n\n### 4.3. 改\n\n> update 表 set name ＝ 'zhangyanlin' where id`1\n\n### 4.4. 查\n\n> select * from 表\n>\n> select * from 表 where id ` 1\n>\n> select nid,name,gender as gg from 表 where id ` 1\n\n### 4.5. 条件判断\n\n#### 4.5.1. where\n\n```go\nselect * from `table` where id `1 and name!='huwh' and num =12;\nselect * from `table` where id between 5 and 6;\nselect * from `table` where id in (11,22,33);\nselect * from `table` where id not in (11,22,33);\nselect * from `table` where id in (select nid from `table`)\n```\n\n#### 4.5.2. 通配符like\n\n```go\nselect * from `table` where name like 'hu%';   #hu开头\nselect * from `table` where name like 'hu_'    #hu开头后接一个字符\n```\n\n#### 4.5.3. 限制limit\n\n```go\nselect * from `table` limit 5;   #前5行\nselect * from `table` limit 4,5  #从第四行开始的5行\nselect * from `table` limit 5 offset 4;#从第四行开始的5行\n```\n\n#### 4.5.4. 排序asc，desc\n\n```go\nselect * from `table` order by 列 asc;            #跟据“列”从小到大排序（不指定默认为从小到大排序）\nselect * from `table` order by 列 desc;           #根据“列”从大到小排序\nselect * from `table` order by 列1 desc,列2 asc;  #根据“列1”从大到小排序，如果相同则按“列2”从小到大排序\n```\n\n#### 4.5.5. 分组group by\n\ngroup by 必须在where之后，order by之前。\n\n```go\nselect num,from `table` group by num;     \nselect num,nid from `table` group by num,nid;\nselect num from `table` where nid ` 10 group by num,nid order nid desc;\nselect num,nid,count(*),sum(score),max(score) from `table` group by num;\nselect num from `table` group by num having max(id) ` 10;\nselect num from `table` group by num;\n```\n\n","slug":"Database/Mysql常用命令","published":1,"updated":"2017-10-03T02:55:34.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740gk000430vupvehoi44","content":"<h2><span id=\"1-系统管理\">1. 系统管理</span></h2>\n<h3><span id=\"11-连接mysql\">1.1. 连接mysql</span></h3>\n<p>格式： mysql -h主机地址 -u用户名 －p用户密码</p>\n<p>连接本地：mysql -h<code>localhost/127.0.0.1</code> -u用户名 －p用户密码</p>\n<p>连接远程：mysql -h<code>主机地址</code> -u用户名 －p用户密码<br>\n退出连接：exit</p>\n<h3><span id=\"12-备份数据库\">1.2. 备份数据库</span></h3>\n<p><strong>1.导出整个数据库</strong></p>\n<p>导出文件默认是存在mysql\\bin目录下</p>\n<p>mysqldump -u 用户名 -p 数据库名 ` 导出的文件名</p>\n<p>mysqldump -u user_name -p123456 database_name ` outfile_name.sql</p>\n<p><strong>2.导出一个表</strong></p>\n<p>mysqldump -u 用户名 -p 数据库名 表名` 导出的文件名</p>\n<p>mysqldump -u user_name -p database_name table_name ` outfile_name.sql</p>\n<p><strong>3.导出一个数据库结构</strong></p>\n<p>mysqldump -u user_name -p -d –add-drop-table database_name ` outfile_name.sql</p>\n<p>-d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table</p>\n<p><strong>4.带语言参数导出</strong></p>\n<p>mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name ` outfile_name.sql</p>\n<p><strong>5、导入数据库</strong></p>\n<p>mysql -u root –p ` [备份文件的保存路径] 或者source [备份文件的保存路径]</p>\n<h3><span id=\"13-用户管理\">1.3. 用户管理</span></h3>\n<p><strong>1、创建用户</strong></p>\n<p>​    create user ‘用户名’@‘IP地址’ identified by ‘密码’;</p>\n<p><strong>2、删除用户</strong></p>\n<p>​    drop user ‘用户名’@‘IP地址’;</p>\n<p>​    delete from user where user=‘用户名’ and host=‘localhost’;</p>\n<p><strong>3、修改用户</strong></p>\n<p>​    rename user ‘用户名’@‘IP地址’; to ‘新用户名’@‘IP地址’;;</p>\n<p><strong>4、修改密码</strong></p>\n<p>​    set password for ‘用户名’@‘IP地址’ = Password(‘新密码’)</p>\n<p>​    mysqladmin -u用户名 -p旧密码 password 新密码</p>\n<h3><span id=\"14-权限管理\">1.4. 权限管理</span></h3>\n<h4><span id=\"141-grant\">1.4.1. grant</span></h4>\n<p><strong>1、grant 权限 on 数据库对象 to 用户</strong></p>\n<p>数据库对象的格式为<code>database</code>.<code>table</code>。<code>database</code>.<em>：表示授权数据库对象该数据库的所有表；</em>.*：表示授权数据库对象为所有数据库的所有表。</p>\n<p>grant all privileges on <em>.</em> to <code>user</code>@’<code>ip</code>’ identified by ‘<code>passwd</code>’;如果<code>ip</code>为’%'表示不限制IP。</p>\n<p><strong>2、撤销权限</strong>：</p>\n<p>revoke all on <em>.</em> from <code>user</code>@<code>ip</code>;</p>\n<h4><span id=\"142-普通数据库用户\">1.4.2. 普通数据库用户</span></h4>\n<p>查询、插入、更新、删除 数据库中所有表数据的权利</p>\n<p>grant select, insert, update, delete on testdb.* to <code>user</code>@’<code>ip</code>’;</p>\n<h4><span id=\"143-dba-用户\">1.4.3. DBA 用户</span></h4>\n<p><strong>1、授权</strong></p>\n<p>grant all privileges on <em>.</em> to <code>dba</code>@’<code>ip</code>’ identified by ‘<code>passwd</code>’;</p>\n<p><strong>2、刷新系统权限</strong></p>\n<p>flush privileges;</p>\n<h4><span id=\"144-查看用户权限\">1.4.4. 查看用户权限</span></h4>\n<p>1、查看当前用户（自己）权限</p>\n<p>show grants;</p>\n<p>2、查看指定MySQL 用户权限</p>\n<p>show grants for <code>user</code>@<code>localhost</code>;</p>\n<p>3、查看user和host</p>\n<p>select user,host from mysql.user order by user;</p>\n<h4><span id=\"145-权限列表\">1.4.5. 权限列表</span></h4>\n<p><img src=\"/img/article/database/%E6%9D%83%E9%99%90%E5%88%97%E8%A1%A8.jpg\" alt=\"img\"></p>\n<h4><span id=\"146-查看主从关系\">1.4.6. 查看主从关系</span></h4>\n<p>登录主机：show slave hosts;</p>\n<p>登录从机：show slave status;</p>\n<h2><span id=\"2-数据库操作\">2. 数据库操作</span></h2>\n<p><strong>1、创建数据库</strong></p>\n<p>create database <code>数据库名</code></p>\n<p><strong>2、显示数据库</strong></p>\n<p>show databases</p>\n<p><strong>3、删除数据</strong></p>\n<p>drop database <code>数据库名</code></p>\n<h2><span id=\"3-数据表操作\">3. 数据表操作</span></h2>\n<p><strong>1、创建表</strong></p>\n<blockquote>\n<p>create table 表名(</p>\n<p>​    列名  类型  是否可以为空，</p>\n<p>​    列名  类型  是否可以为空</p>\n<p>)ENGINE=InnoDB DEFAULT CHARSET=utf8</p>\n</blockquote>\n<ul>\n<li>默认值，创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值</li>\n<li>自增，如果为某列设置自增列，插入数据时无需设置此列，默认将自增（表中只能有一个自增列）注意：1、对于自增列，必须是索引（含主键）2、对于自增可以设置步长和起始值</li>\n<li>主键，一种特殊的唯一索引，不允许有空值，如果主键使用单个列，则它的值必须唯一，如果是多列，则其组合必须唯一。</li>\n</ul>\n<p><strong>2、查看表</strong></p>\n<p>show tables;                    # 查看数据库全部表</p>\n<p>select * from 表名;             # 查看表所有内容</p>\n<p><strong>3、删除表</strong></p>\n<p>drop table 表名</p>\n<p><strong>4、清空表内容</strong></p>\n<p>delete from 表名</p>\n<p>truncate table 表名</p>\n<p><strong>5、查看表结构</strong></p>\n<p>desc 表名</p>\n<p><strong>6、修改表</strong></p>\n<blockquote>\n<p>添加列：   alter table 表名 add 列名 类型</p>\n<p>删除列：   alter table 表名 drop column 列名</p>\n<p>修改列：</p>\n<p>​          alter table 表名 modify column 列名 类型;  – 类型</p>\n<p>​          alter table 表名 change 原列名 新列名 类型; – 列名，类型</p>\n<p>添加主键：</p>\n<p>​          alter table 表名 add primary key(列名);</p>\n<p>删除主键：</p>\n<p>​          alter table 表名 drop primary key;</p>\n<p>​          alter table 表名  modify  列名 int, drop primary key;</p>\n<p>添加外键： alter table 从表 add constraint 外键名称（形如：FK_从表_主表） foreign key 从表(外键字段) references 主表(主键字段);</p>\n<p>删除外键： alter table 表名 drop foreign key 外键名称</p>\n<p>修改默认值：ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;</p>\n<p>删除默认值：ALTER TABLE testalter_tbl ALTER i DROP DEFAULT;</p>\n</blockquote>\n<h2><span id=\"4-表内容操作\">4. 表内容操作</span></h2>\n<h3><span id=\"41-增\">4.1. 增</span></h3>\n<blockquote>\n<p>insert into 表 (列名,列名…) values (值,值,…)</p>\n<p>insert into 表 (列名,列名…) values (值,值,…),(值,值,值…)</p>\n<p>insert into 表 (列名,列名…) select (列名,列名…) from 表</p>\n<p>例：</p>\n<p>​    insert into tab1(name,email) values(‘zhangyanlin’,‘zhangyanlin8851@<a href=\"http://163.com/\" target=\"_blank\" rel=\"external\">163.com</a>’)</p>\n</blockquote>\n<h3><span id=\"42-删\">4.2. 删</span></h3>\n<blockquote>\n<p>delete from 表                                      # 删除表里全部数据</p>\n<p>delete from 表 where id＝1 and name＝’zhangyanlin’   # 删除ID =1 和name=‘zhangyanlin’ 那一行数据</p>\n</blockquote>\n<h3><span id=\"43-改\">4.3. 改</span></h3>\n<blockquote>\n<p>update 表 set name ＝ ‘zhangyanlin’ where id`1</p>\n</blockquote>\n<h3><span id=\"44-查\">4.4. 查</span></h3>\n<blockquote>\n<p>select * from 表</p>\n<p>select * from 表 where id ` 1</p>\n<p>select nid,name,gender as gg from 表 where id ` 1</p>\n</blockquote>\n<h3><span id=\"45-条件判断\">4.5. 条件判断</span></h3>\n<h4><span id=\"451-where\">4.5.1. where</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">select</span> * from <span class=\"string\">`table`</span> where id <span class=\"string\">`1 and name!='huwh' and num =12;</span></div><div class=\"line\"><span class=\"string\">select * from `</span>table<span class=\"string\">` where id between 5 and 6;</span></div><div class=\"line\"><span class=\"string\">select * from `</span>table<span class=\"string\">` where id in (11,22,33);</span></div><div class=\"line\"><span class=\"string\">select * from `</span>table<span class=\"string\">` where id not in (11,22,33);</span></div><div class=\"line\"><span class=\"string\">select * from `</span>table<span class=\"string\">` where id in (select nid from `</span>table<span class=\"string\">`)</span></div></pre></td></tr></table></figure>\n<h4><span id=\"452-通配符like\">4.5.2. 通配符like</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">select</span> * from <span class=\"string\">`table`</span> where name like <span class=\"string\">'hu%'</span>;   #hu开头</div><div class=\"line\"><span class=\"keyword\">select</span> * from <span class=\"string\">`table`</span> where name like <span class=\"string\">'hu_'</span>    #hu开头后接一个字符</div></pre></td></tr></table></figure>\n<h4><span id=\"453-限制limit\">4.5.3. 限制limit</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">select</span> * from <span class=\"string\">`table`</span> limit <span class=\"number\">5</span>;   #前<span class=\"number\">5</span>行</div><div class=\"line\"><span class=\"keyword\">select</span> * from <span class=\"string\">`table`</span> limit <span class=\"number\">4</span>,<span class=\"number\">5</span>  #从第四行开始的<span class=\"number\">5</span>行</div><div class=\"line\"><span class=\"keyword\">select</span> * from <span class=\"string\">`table`</span> limit <span class=\"number\">5</span> offset <span class=\"number\">4</span>;#从第四行开始的<span class=\"number\">5</span>行</div></pre></td></tr></table></figure>\n<h4><span id=\"454-排序ascdesc\">4.5.4. 排序asc，desc</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">select</span> * from <span class=\"string\">`table`</span> order by 列 asc;            #跟据“列”从小到大排序（不指定默认为从小到大排序）</div><div class=\"line\"><span class=\"keyword\">select</span> * from <span class=\"string\">`table`</span> order by 列 desc;           #根据“列”从大到小排序</div><div class=\"line\"><span class=\"keyword\">select</span> * from <span class=\"string\">`table`</span> order by 列<span class=\"number\">1</span> desc,列<span class=\"number\">2</span> asc;  #根据“列<span class=\"number\">1</span>”从大到小排序，如果相同则按“列<span class=\"number\">2</span>”从小到大排序</div></pre></td></tr></table></figure>\n<h4><span id=\"455-分组group-by\">4.5.5. 分组group by</span></h4>\n<p>group by 必须在where之后，order by之前。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">select</span> num,from <span class=\"string\">`table`</span> group by num;     </div><div class=\"line\"><span class=\"keyword\">select</span> num,nid from <span class=\"string\">`table`</span> group by num,nid;</div><div class=\"line\"><span class=\"keyword\">select</span> num from <span class=\"string\">`table`</span> where nid <span class=\"string\">` 10 group by num,nid order nid desc;</span></div><div class=\"line\"><span class=\"string\">select num,nid,count(*),sum(score),max(score) from `</span>table<span class=\"string\">` group by num;</span></div><div class=\"line\"><span class=\"string\">select num from `</span>table<span class=\"string\">` group by num having max(id) `</span> <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"keyword\">select</span> num from <span class=\"string\">`table`</span> group by num;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 系统管理</h2>\n<h3>1.1. 连接mysql</h3>\n<p>格式： mysql -h主机地址 -u用户名 －p用户密码</p>\n<p>连接本地：mysql -h<code>localhost/127.0.0.1</code> -u用户名 －p用户密码</p>\n<p>连接远程：mysql -h<code>主机地址</code> -u用户名 －p用户密码<br>\n退出连接：exit</p>\n<h3>1.2. 备份数据库</h3>\n<p><strong>1.导出整个数据库</strong></p>\n<p>导出文件默认是存在mysql\\bin目录下</p>\n<p>mysqldump -u 用户名 -p 数据库名 ` 导出的文件名</p>\n<p>mysqldump -u user_name -p123456 database_name ` outfile_name.sql</p>\n<p><strong>2.导出一个表</strong></p>\n<p>mysqldump -u 用户名 -p 数据库名 表名` 导出的文件名</p>\n<p>mysqldump -u user_name -p database_name table_name ` outfile_name.sql</p>\n<p><strong>3.导出一个数据库结构</strong></p>\n<p>mysqldump -u user_name -p -d –add-drop-table database_name ` outfile_name.sql</p>\n<p>-d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table</p>\n<p><strong>4.带语言参数导出</strong></p>\n<p>mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name ` outfile_name.sql</p>\n<p><strong>5、导入数据库</strong></p>\n<p>mysql -u root –p ` [备份文件的保存路径] 或者source [备份文件的保存路径]</p>\n<h3>1.3. 用户管理</h3>\n<p><strong>1、创建用户</strong></p>\n<p>​    create user ‘用户名’@‘IP地址’ identified by ‘密码’;</p>\n<p><strong>2、删除用户</strong></p>\n<p>​    drop user ‘用户名’@‘IP地址’;</p>\n<p>​    delete from user where user=‘用户名’ and host=‘localhost’;</p>\n<p><strong>3、修改用户</strong></p>\n<p>​    rename user ‘用户名’@‘IP地址’; to ‘新用户名’@‘IP地址’;;</p>\n<p><strong>4、修改密码</strong></p>\n<p>​    set password for ‘用户名’@‘IP地址’ = Password(‘新密码’)</p>\n<p>​    mysqladmin -u用户名 -p旧密码 password 新密码</p>\n<h3>1.4. 权限管理</h3>\n<h4>1.4.1. grant</h4>\n<p><strong>1、grant 权限 on 数据库对象 to 用户</strong></p>\n<p>数据库对象的格式为<code>database</code>.<code>table</code>。<code>database</code>.<em>：表示授权数据库对象该数据库的所有表；</em>.*：表示授权数据库对象为所有数据库的所有表。</p>\n<p>grant all privileges on <em>.</em> to <code>user</code>@’<code>ip</code>’ identified by ‘<code>passwd</code>’;如果<code>ip</code>为’%'表示不限制IP。</p>\n<p><strong>2、撤销权限</strong>：</p>\n<p>revoke all on <em>.</em> from <code>user</code>@<code>ip</code>;</p>\n<h4>1.4.2. 普通数据库用户</h4>\n<p>查询、插入、更新、删除 数据库中所有表数据的权利</p>\n<p>grant select, insert, update, delete on testdb.* to <code>user</code>@’<code>ip</code>’;</p>\n<h4>1.4.3. DBA 用户</h4>\n<p><strong>1、授权</strong></p>\n<p>grant all privileges on <em>.</em> to <code>dba</code>@’<code>ip</code>’ identified by ‘<code>passwd</code>’;</p>\n<p><strong>2、刷新系统权限</strong></p>\n<p>flush privileges;</p>\n<h4>1.4.4. 查看用户权限</h4>\n<p>1、查看当前用户（自己）权限</p>\n<p>show grants;</p>\n<p>2、查看指定MySQL 用户权限</p>\n<p>show grants for <code>user</code>@<code>localhost</code>;</p>\n<p>3、查看user和host</p>\n<p>select user,host from mysql.user order by user;</p>\n<h4>1.4.5. 权限列表</h4>\n<p><img src=\"/img/article/database/%E6%9D%83%E9%99%90%E5%88%97%E8%A1%A8.jpg\" alt=\"img\"></p>\n<h4>1.4.6. 查看主从关系</h4>\n<p>登录主机：show slave hosts;</p>\n<p>登录从机：show slave status;</p>\n<h2>2. 数据库操作</h2>\n<p><strong>1、创建数据库</strong></p>\n<p>create database <code>数据库名</code></p>\n<p><strong>2、显示数据库</strong></p>\n<p>show databases</p>\n<p><strong>3、删除数据</strong></p>\n<p>drop database <code>数据库名</code></p>\n<h2>3. 数据表操作</h2>\n<p><strong>1、创建表</strong></p>\n<blockquote>\n<p>create table 表名(</p>\n<p>​    列名  类型  是否可以为空，</p>\n<p>​    列名  类型  是否可以为空</p>\n<p>)ENGINE=InnoDB DEFAULT CHARSET=utf8</p>\n</blockquote>\n<ul>\n<li>默认值，创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值</li>\n<li>自增，如果为某列设置自增列，插入数据时无需设置此列，默认将自增（表中只能有一个自增列）注意：1、对于自增列，必须是索引（含主键）2、对于自增可以设置步长和起始值</li>\n<li>主键，一种特殊的唯一索引，不允许有空值，如果主键使用单个列，则它的值必须唯一，如果是多列，则其组合必须唯一。</li>\n</ul>\n<p><strong>2、查看表</strong></p>\n<p>show tables;                    # 查看数据库全部表</p>\n<p>select * from 表名;             # 查看表所有内容</p>\n<p><strong>3、删除表</strong></p>\n<p>drop table 表名</p>\n<p><strong>4、清空表内容</strong></p>\n<p>delete from 表名</p>\n<p>truncate table 表名</p>\n<p><strong>5、查看表结构</strong></p>\n<p>desc 表名</p>\n<p><strong>6、修改表</strong></p>\n<blockquote>\n<p>添加列：   alter table 表名 add 列名 类型</p>\n<p>删除列：   alter table 表名 drop column 列名</p>\n<p>修改列：</p>\n<p>​          alter table 表名 modify column 列名 类型;  – 类型</p>\n<p>​          alter table 表名 change 原列名 新列名 类型; – 列名，类型</p>\n<p>添加主键：</p>\n<p>​          alter table 表名 add primary key(列名);</p>\n<p>删除主键：</p>\n<p>​          alter table 表名 drop primary key;</p>\n<p>​          alter table 表名  modify  列名 int, drop primary key;</p>\n<p>添加外键： alter table 从表 add constraint 外键名称（形如：FK_从表_主表） foreign key 从表(外键字段) references 主表(主键字段);</p>\n<p>删除外键： alter table 表名 drop foreign key 外键名称</p>\n<p>修改默认值：ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;</p>\n<p>删除默认值：ALTER TABLE testalter_tbl ALTER i DROP DEFAULT;</p>\n</blockquote>\n<h2>4. 表内容操作</h2>\n<h3>4.1. 增</h3>\n<blockquote>\n<p>insert into 表 (列名,列名…) values (值,值,…)</p>\n<p>insert into 表 (列名,列名…) values (值,值,…),(值,值,值…)</p>\n<p>insert into 表 (列名,列名…) select (列名,列名…) from 表</p>\n<p>例：</p>\n<p>​    insert into tab1(name,email) values(‘zhangyanlin’,‘zhangyanlin8851@<a href=\"http://163.com/\" target=\"_blank\" rel=\"external\">163.com</a>’)</p>\n</blockquote>\n<h3>4.2. 删</h3>\n<blockquote>\n<p>delete from 表                                      # 删除表里全部数据</p>\n<p>delete from 表 where id＝1 and name＝’zhangyanlin’   # 删除ID =1 和name=‘zhangyanlin’ 那一行数据</p>\n</blockquote>\n<h3>4.3. 改</h3>\n<blockquote>\n<p>update 表 set name ＝ ‘zhangyanlin’ where id`1</p>\n</blockquote>\n<h3>4.4. 查</h3>\n<blockquote>\n<p>select * from 表</p>\n<p>select * from 表 where id ` 1</p>\n<p>select nid,name,gender as gg from 表 where id ` 1</p>\n</blockquote>\n<h3>4.5. 条件判断</h3>\n<h4>4.5.1. where</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">select</span> * from <span class=\"string\">`table`</span> where id <span class=\"string\">`1 and name!='huwh' and num =12;</span></div><div class=\"line\"><span class=\"string\">select * from `</span>table<span class=\"string\">` where id between 5 and 6;</span></div><div class=\"line\"><span class=\"string\">select * from `</span>table<span class=\"string\">` where id in (11,22,33);</span></div><div class=\"line\"><span class=\"string\">select * from `</span>table<span class=\"string\">` where id not in (11,22,33);</span></div><div class=\"line\"><span class=\"string\">select * from `</span>table<span class=\"string\">` where id in (select nid from `</span>table<span class=\"string\">`)</span></div></pre></td></tr></table></figure>\n<h4>4.5.2. 通配符like</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">select</span> * from <span class=\"string\">`table`</span> where name like <span class=\"string\">'hu%'</span>;   #hu开头</div><div class=\"line\"><span class=\"keyword\">select</span> * from <span class=\"string\">`table`</span> where name like <span class=\"string\">'hu_'</span>    #hu开头后接一个字符</div></pre></td></tr></table></figure>\n<h4>4.5.3. 限制limit</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">select</span> * from <span class=\"string\">`table`</span> limit <span class=\"number\">5</span>;   #前<span class=\"number\">5</span>行</div><div class=\"line\"><span class=\"keyword\">select</span> * from <span class=\"string\">`table`</span> limit <span class=\"number\">4</span>,<span class=\"number\">5</span>  #从第四行开始的<span class=\"number\">5</span>行</div><div class=\"line\"><span class=\"keyword\">select</span> * from <span class=\"string\">`table`</span> limit <span class=\"number\">5</span> offset <span class=\"number\">4</span>;#从第四行开始的<span class=\"number\">5</span>行</div></pre></td></tr></table></figure>\n<h4>4.5.4. 排序asc，desc</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">select</span> * from <span class=\"string\">`table`</span> order by 列 asc;            #跟据“列”从小到大排序（不指定默认为从小到大排序）</div><div class=\"line\"><span class=\"keyword\">select</span> * from <span class=\"string\">`table`</span> order by 列 desc;           #根据“列”从大到小排序</div><div class=\"line\"><span class=\"keyword\">select</span> * from <span class=\"string\">`table`</span> order by 列<span class=\"number\">1</span> desc,列<span class=\"number\">2</span> asc;  #根据“列<span class=\"number\">1</span>”从大到小排序，如果相同则按“列<span class=\"number\">2</span>”从小到大排序</div></pre></td></tr></table></figure>\n<h4>4.5.5. 分组group by</h4>\n<p>group by 必须在where之后，order by之前。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">select</span> num,from <span class=\"string\">`table`</span> group by num;     </div><div class=\"line\"><span class=\"keyword\">select</span> num,nid from <span class=\"string\">`table`</span> group by num,nid;</div><div class=\"line\"><span class=\"keyword\">select</span> num from <span class=\"string\">`table`</span> where nid <span class=\"string\">` 10 group by num,nid order nid desc;</span></div><div class=\"line\"><span class=\"string\">select num,nid,count(*),sum(score),max(score) from `</span>table<span class=\"string\">` group by num;</span></div><div class=\"line\"><span class=\"string\">select num from `</span>table<span class=\"string\">` group by num having max(id) `</span> <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"keyword\">select</span> num from <span class=\"string\">`table`</span> group by num;</div></pre></td></tr></table></figure>\n"},{"title":"[Database] Redis介绍","catalog":true,"date":"2017-07-15T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Database"],"_content":"\n## 一、redis是什么？（what）\n\nRedis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。\n\nRedis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\n\n## 二、为什么使用redis？（why）\n\n### （一）redis的特点\n\n1. Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。\n2. Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。\n3. Redis支持数据的备份，即master-slave模式的数据备份。\n\n### （二）redis的优势\n\n1. 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。\n2. 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。\n3. 原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。\n4. 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。\n\n### （三）redis与其他key-value存储有什么不同\n\n1. Redis有着更为复杂的数据结构并且提供对他们的原子性操作，Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。\n2. Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。\n3. 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。\n4. 在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。\n\n## 三、如何使用redis？（how）\n\n### （一）redis的数据类型\n\n| 数据类型                  | 概念                                       | 常用命令               |\n| --------------------- | ---------------------------------------- | ------------------ |\n| String(字符串)           | key-value型                               | SET ，GET           |\n| Hash(哈希)              | field-value,适用于存储对象类型（对象名-对象属性值）         | HMSET，HEGTALL      |\n| List(列表)              | string类型的有序列表，按照插入顺序排序                   | lpush，lrange       |\n| Set(集合)               | string类型的无序集合                            | sadd，smembers      |\n| zset(sorted set：有序集合) | string类型元素的集合,且不允许重复的成员。每个元素关联一个double值来进行排序，double值可以重复但元素不能重复。 | zadd，ZRANGEBYSCORE |\n\n### （二）redis常用命令","source":"_posts/Database/Redis介绍.md","raw":"---\ntitle: \"[Database] Redis介绍\"\ncatalog: true\ndate: 2017-07-15 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Database\ncatagories:\n- Database\n---\n\n## 一、redis是什么？（what）\n\nRedis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。\n\nRedis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\n\n## 二、为什么使用redis？（why）\n\n### （一）redis的特点\n\n1. Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。\n2. Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。\n3. Redis支持数据的备份，即master-slave模式的数据备份。\n\n### （二）redis的优势\n\n1. 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。\n2. 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。\n3. 原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。\n4. 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。\n\n### （三）redis与其他key-value存储有什么不同\n\n1. Redis有着更为复杂的数据结构并且提供对他们的原子性操作，Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。\n2. Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。\n3. 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。\n4. 在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。\n\n## 三、如何使用redis？（how）\n\n### （一）redis的数据类型\n\n| 数据类型                  | 概念                                       | 常用命令               |\n| --------------------- | ---------------------------------------- | ------------------ |\n| String(字符串)           | key-value型                               | SET ，GET           |\n| Hash(哈希)              | field-value,适用于存储对象类型（对象名-对象属性值）         | HMSET，HEGTALL      |\n| List(列表)              | string类型的有序列表，按照插入顺序排序                   | lpush，lrange       |\n| Set(集合)               | string类型的无序集合                            | sadd，smembers      |\n| zset(sorted set：有序集合) | string类型元素的集合,且不允许重复的成员。每个元素关联一个double值来进行排序，double值可以重复但元素不能重复。 | zadd，ZRANGEBYSCORE |\n\n### （二）redis常用命令","slug":"Database/Redis介绍","published":1,"updated":"2017-10-03T02:55:21.357Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740gr000530vu16jczmf6","content":"<h2><span id=\"一-redis是什么what\">一、redis是什么？（what）</span></h2>\n<p>Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p>\n<p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>\n<h2><span id=\"二-为什么使用rediswhy\">二、为什么使用redis？（why）</span></h2>\n<h3><span id=\"一redis的特点\">（一）redis的特点</span></h3>\n<ol>\n<li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li>\n<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>\n<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>\n</ol>\n<h3><span id=\"二redis的优势\">（二）redis的优势</span></h3>\n<ol>\n<li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>\n<li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>\n<li>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li>\n<li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li>\n</ol>\n<h3><span id=\"三redis与其他key-value存储有什么不同\">（三）redis与其他key-value存储有什么不同</span></h3>\n<ol>\n<li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li>\n<li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。</li>\n<li>相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。</li>\n<li>在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</li>\n</ol>\n<h2><span id=\"三-如何使用redishow\">三、如何使用redis？（how）</span></h2>\n<h3><span id=\"一redis的数据类型\">（一）redis的数据类型</span></h3>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>概念</th>\n<th>常用命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>String(字符串)</td>\n<td>key-value型</td>\n<td>SET ，GET</td>\n</tr>\n<tr>\n<td>Hash(哈希)</td>\n<td>field-value,适用于存储对象类型（对象名-对象属性值）</td>\n<td>HMSET，HEGTALL</td>\n</tr>\n<tr>\n<td>List(列表)</td>\n<td>string类型的有序列表，按照插入顺序排序</td>\n<td>lpush，lrange</td>\n</tr>\n<tr>\n<td>Set(集合)</td>\n<td>string类型的无序集合</td>\n<td>sadd，smembers</td>\n</tr>\n<tr>\n<td>zset(sorted set：有序集合)</td>\n<td>string类型元素的集合,且不允许重复的成员。每个元素关联一个double值来进行排序，double值可以重复但元素不能重复。</td>\n<td>zadd，ZRANGEBYSCORE</td>\n</tr>\n</tbody>\n</table>\n<h3><span id=\"二redis常用命令\">（二）redis常用命令</span></h3>\n","site":{"data":{}},"excerpt":"","more":"<h2>一、redis是什么？（what）</h2>\n<p>Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p>\n<p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>\n<h2>二、为什么使用redis？（why）</h2>\n<h3>（一）redis的特点</h3>\n<ol>\n<li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li>\n<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>\n<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>\n</ol>\n<h3>（二）redis的优势</h3>\n<ol>\n<li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>\n<li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>\n<li>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li>\n<li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li>\n</ol>\n<h3>（三）redis与其他key-value存储有什么不同</h3>\n<ol>\n<li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li>\n<li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。</li>\n<li>相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。</li>\n<li>在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</li>\n</ol>\n<h2>三、如何使用redis？（how）</h2>\n<h3>（一）redis的数据类型</h3>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>概念</th>\n<th>常用命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>String(字符串)</td>\n<td>key-value型</td>\n<td>SET ，GET</td>\n</tr>\n<tr>\n<td>Hash(哈希)</td>\n<td>field-value,适用于存储对象类型（对象名-对象属性值）</td>\n<td>HMSET，HEGTALL</td>\n</tr>\n<tr>\n<td>List(列表)</td>\n<td>string类型的有序列表，按照插入顺序排序</td>\n<td>lpush，lrange</td>\n</tr>\n<tr>\n<td>Set(集合)</td>\n<td>string类型的无序集合</td>\n<td>sadd，smembers</td>\n</tr>\n<tr>\n<td>zset(sorted set：有序集合)</td>\n<td>string类型元素的集合,且不允许重复的成员。每个元素关联一个double值来进行排序，double值可以重复但元素不能重复。</td>\n<td>zadd，ZRANGEBYSCORE</td>\n</tr>\n</tbody>\n</table>\n<h3>（二）redis常用命令</h3>\n"},{"title":"[Docker] Dockerfile使用说明","catalog":true,"date":"2017-07-09T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Docker"],"_content":"\n## 一、Dockerfile的说明\n\ndockerfile指令忽略大小写，建议大写，#作为注释，每行只支持一条指令，指令可以带多个参数。\n\ndockerfile指令分为构建指令和设置指令。\n\n1. 构建指令：用于构建image，其指定的操作不会在运行image的容器中执行。\n2. 设置指令：用于设置image的属性，其指定的操作会在运行image的容器中执行。\n\n## 二、Dockerfile指令说明\n\n### 1、FROM（指定基础镜像）[构建指令]\n\n该命令用来指定基础镜像，在基础镜像的基础上修改数据从而构建新的镜像。基础镜像可以是本地仓库也可以是远程仓库。\n\n指令有两种格式：\n\n1. FROM `image`   【默认为latest版本】\n2. FROM `image`:`tag`     【指定版本】\n\n### 2、MAINTAINER（镜像创建者信息）[构建指令]\n\n将镜像制作者（维护者）的信息写入image中，执行docker inspect时会输出该信息。\n\n格式：MAINTAINER `name`\n\n### 3、RUN（安装软件用）[构建指令]\n\nRUN可以运行任何被基础镜像支持的命令（即在基础镜像上执行一个进程），可以使用多条RUN指令，指令较长可以使用\\来换行。\n\n指令有两种格式：\n\n1. RUN `command` (the command is run in a shell - `/bin/sh -c`)\n2. RUN [\"executable\", \"param1\", \"param2\" ... ] (exec form) \n   - 指定使用其他终端实现，使用exec执行。\n   - 例子：RUN[\"/bin/bash\",\"-c\",\"echo hello\"]\n\n### 4、CMD（设置container启动时执行的操作）[设置指令]\n\n用于容器启动时的指定操作，可以是自定义脚本或命令，只执行一次，多个默认执行最后一个。\n\n指令有三种格式：\n\n1. CMD [\"executable\",\"param1\",\"param2\"] (like an exec, this is the preferred form) \n   - 运行一个可执行文件并提供参数。\n2. CMD command param1 param2 (as a shell) \n   - 直接执行shell命令，默认以/bin/sh -c执行。\n3. CMD [\"param1\",\"param2\"] (as default parameters to ENTRYPOINT) \n   - 和ENTRYPOINT配合使用，只作为完整命令的参数部分。\n\n### 5、ENTRYPOINT（设置container启动时执行的操作）[设置指令]\n\n指定容器启动时执行的命令，若多次设置只执行最后一次。\n\nENTRYPOINT翻译为“进入点”，它的功能可以让容器表现得像一个可执行程序一样。\n\n例子：ENTRYPOINT [\"/bin/echo\"] ，那么docker build出来的镜像以后的容器功能就像一个/bin/echo程序，docker run -it imageecho “this is a test”，就会输出对应的字符串。这个imageecho镜像对应的容器表现出来的功能就像一个echo程序一样。\n\n指令有两种格式：\n\n1. ENTRYPOINT [\"executable\", \"param1\", \"param2\"] (like an exec, the preferred form)\n\n   - 和CMD配合使用，CMD则作为完整命令的参数部分，ENTRYPOINT以JSON格式指定执行的命令部分。CMD可以为ENTRYPOINT提供可变参数，不需要变动的参数可以写在ENTRYPOINT里面。\n\n   - 例子：\n\n     ENTRYPOINT [\"/usr/bin/ls\",\"-a\"]\n\n     CMD [\"-l\"] \n\n2. ENTRYPOINT command param1 param2 (as a shell)\n\n   - 独自使用，即和CMD类似，如果CMD也是个完整命令[CMD command param1 param2 (as a shell) ]，那么会相互覆盖，只执行最后一个CMD或ENTRYPOINT。\n   - 例子：ENTRYPOINT ls -l\n\n### 6、USER（设置container容器启动的登录用户）[设置指令]\n\n设置启动容器的用户，默认为root用户。\n\n格式：USER daemon\n\n### 7、EXPOSE（指定容器需要映射到宿主机的端口）[设置指令]\n\n该指令会将容器中的端口映射为宿主机中的端口[确保宿主机的端口号没有被使用]。通过宿主机IP和映射后的端口即可访问容器[避免每次运行容器时IP随机生成不固定的问题]。前提是EXPOSE设置映射端口，运行容器时加上-p参数指定EXPOSE设置的端口。EXPOSE可以设置多个端口号，相应地运行容器配套多次使用-p参数。可以通过docker port +容器需要映射的端口号和容器ID来参考宿主机的映射端口。\n\n格式：EXPOSE `port` [`port`...]\n\n### 8、ENV（用于设置环境变量）[构建指令]\n\n在image中设置环境变量[以键值对的形式]，设置之后RUN命令可以使用该环境变量，在容器启动后也可以通过docker inspect查看环境变量或者通过 docker run --env key=value设置或修改环境变量。\n\n格式：ENV `key` `value` \n\n例子：ENV JAVA_HOME /path/to/java/dirent\n\n### 9、ADD（从src复制文件到container的dest路径）[构建指令]\n\n复制指定的src到容器中的dest，其中src是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件url。`dest` 是container中的绝对路径。所有拷贝到container中的文件和文件夹权限为0755，uid和gid为0。\n\n- 如果src是一个目录，那么会将该目录下的所有文件添加到container中，不包括目录；\n- 如果src文件是可识别的压缩格式，则docker会帮忙解压缩（注意压缩格式）；\n- 如果`src`是文件且`dest`中不使用斜杠结束，则会将`dest`视为文件，`src`的内容会写入`dest`；\n- 如果`src`是文件且`dest`中使用斜杠结束，则会`src`文件拷贝到`dest`目录下。\n\n格式：ADD `src` `dest` \n\n### 10、COPY（复制文件）\n\n复制本地主机的src为容器中的dest，目标路径不存在时会自动创建。\n\n格式：COPY `src` `dest`\n\n### 11、VOLUME（指定挂载点）[设置指令]\n\n创建一个可以从本地主机或其他容器挂载的挂载点，使容器中的一个目录具有持久化存储数据的功能，该目录可以被容器本身使用也可以被其他容器使用。\n\n格式：VOLUME [\"`mountpoint`\"] \n\n其他容器使用共享数据卷：docker run -t -i -rm -volumes-from container1 image2 bash [container1为第一个容器的ID，image2为第二个容器运行image的名字。]\n\n### 12、WORKDIR（切换目录）[设置指令]\n\n相当于cd命令，可以多次切换目录，为RUN,CMD,ENTRYPOINT配置工作目录。可以使用多个WORKDIR的命令，后续命令如果是相对路径则是在上一级路径的基础上执行[类似cd的功能]。\n\n格式：WORKDIR /path/to/workdir\n\n### 13、ONBUILD（在子镜像中执行）\n\n当所创建的镜像作为其他新创建镜像的基础镜像时执行的操作命令，即在创建本镜像时不运行，当作为别人的基础镜像时再在构建时运行（可认为基础镜像为父镜像，而该命令即在它的子镜像构建时运行，相当于在子镜像构建时多加了一些命令）。\n\n格式：ONBUILD `Dockerfile关键字` \n\n## 三、docker build\n\n```shell\nUsage: docker build [OPTIONS] PATH | URL | -\n\nBuild a new image from the source code at PATH\n\n-c, --cpu-shares=0                      CPU shares (relative weight)\n\n--cgroup-parent=                       Optional parent cgroup for the container\n\n--cpu-period=0                           Limit the CPU CFS (Completely Fair Scheduler) period\n\n--cpu-quota=0                            Limit the CPU CFS (Completely Fair Scheduler) quota\n\n--cpuset-cpus=                           CPUs in which to allow execution (0-3, 0,1)\n\n--cpuset-mems=                         MEMs in which to allow execution (0-3, 0,1)\n\n--disable-content-trust=true       Skip image verification\n\n-f, --file=                                     Name of the Dockerfile (Default is 'PATH/Dockerfile')\n\n--force-rm=false                          Always remove intermediate containers\n\n--help=false                                 Print usage\n\n-m, --memory=                          Memory limit\n\n--memory-swap=                       Total memory (memory + swap), '-1' to disable swap\n\n--no-cache=false                        Do not use cache when building the image\n\n--pull=false                                 Always attempt to pull a newer version of the image\n\n-q, --quiet=false                         Suppress the verbose output generated by the containers\n\n--rm=true                                  Remove intermediate containers after a successful build\n\n-t, --tag=                                   Repository name (and optionally a tag) for the image\n\n--ulimit=[] Ulimit options\n```\n\n ","source":"_posts/Docker/Dockerfile使用说明.md","raw":"---\ntitle: \"[Docker] Dockerfile使用说明\"\ncatalog: true\ndate: 2017-07-09 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Docker\ncatagories:\n- Docker\n---\n\n## 一、Dockerfile的说明\n\ndockerfile指令忽略大小写，建议大写，#作为注释，每行只支持一条指令，指令可以带多个参数。\n\ndockerfile指令分为构建指令和设置指令。\n\n1. 构建指令：用于构建image，其指定的操作不会在运行image的容器中执行。\n2. 设置指令：用于设置image的属性，其指定的操作会在运行image的容器中执行。\n\n## 二、Dockerfile指令说明\n\n### 1、FROM（指定基础镜像）[构建指令]\n\n该命令用来指定基础镜像，在基础镜像的基础上修改数据从而构建新的镜像。基础镜像可以是本地仓库也可以是远程仓库。\n\n指令有两种格式：\n\n1. FROM `image`   【默认为latest版本】\n2. FROM `image`:`tag`     【指定版本】\n\n### 2、MAINTAINER（镜像创建者信息）[构建指令]\n\n将镜像制作者（维护者）的信息写入image中，执行docker inspect时会输出该信息。\n\n格式：MAINTAINER `name`\n\n### 3、RUN（安装软件用）[构建指令]\n\nRUN可以运行任何被基础镜像支持的命令（即在基础镜像上执行一个进程），可以使用多条RUN指令，指令较长可以使用\\来换行。\n\n指令有两种格式：\n\n1. RUN `command` (the command is run in a shell - `/bin/sh -c`)\n2. RUN [\"executable\", \"param1\", \"param2\" ... ] (exec form) \n   - 指定使用其他终端实现，使用exec执行。\n   - 例子：RUN[\"/bin/bash\",\"-c\",\"echo hello\"]\n\n### 4、CMD（设置container启动时执行的操作）[设置指令]\n\n用于容器启动时的指定操作，可以是自定义脚本或命令，只执行一次，多个默认执行最后一个。\n\n指令有三种格式：\n\n1. CMD [\"executable\",\"param1\",\"param2\"] (like an exec, this is the preferred form) \n   - 运行一个可执行文件并提供参数。\n2. CMD command param1 param2 (as a shell) \n   - 直接执行shell命令，默认以/bin/sh -c执行。\n3. CMD [\"param1\",\"param2\"] (as default parameters to ENTRYPOINT) \n   - 和ENTRYPOINT配合使用，只作为完整命令的参数部分。\n\n### 5、ENTRYPOINT（设置container启动时执行的操作）[设置指令]\n\n指定容器启动时执行的命令，若多次设置只执行最后一次。\n\nENTRYPOINT翻译为“进入点”，它的功能可以让容器表现得像一个可执行程序一样。\n\n例子：ENTRYPOINT [\"/bin/echo\"] ，那么docker build出来的镜像以后的容器功能就像一个/bin/echo程序，docker run -it imageecho “this is a test”，就会输出对应的字符串。这个imageecho镜像对应的容器表现出来的功能就像一个echo程序一样。\n\n指令有两种格式：\n\n1. ENTRYPOINT [\"executable\", \"param1\", \"param2\"] (like an exec, the preferred form)\n\n   - 和CMD配合使用，CMD则作为完整命令的参数部分，ENTRYPOINT以JSON格式指定执行的命令部分。CMD可以为ENTRYPOINT提供可变参数，不需要变动的参数可以写在ENTRYPOINT里面。\n\n   - 例子：\n\n     ENTRYPOINT [\"/usr/bin/ls\",\"-a\"]\n\n     CMD [\"-l\"] \n\n2. ENTRYPOINT command param1 param2 (as a shell)\n\n   - 独自使用，即和CMD类似，如果CMD也是个完整命令[CMD command param1 param2 (as a shell) ]，那么会相互覆盖，只执行最后一个CMD或ENTRYPOINT。\n   - 例子：ENTRYPOINT ls -l\n\n### 6、USER（设置container容器启动的登录用户）[设置指令]\n\n设置启动容器的用户，默认为root用户。\n\n格式：USER daemon\n\n### 7、EXPOSE（指定容器需要映射到宿主机的端口）[设置指令]\n\n该指令会将容器中的端口映射为宿主机中的端口[确保宿主机的端口号没有被使用]。通过宿主机IP和映射后的端口即可访问容器[避免每次运行容器时IP随机生成不固定的问题]。前提是EXPOSE设置映射端口，运行容器时加上-p参数指定EXPOSE设置的端口。EXPOSE可以设置多个端口号，相应地运行容器配套多次使用-p参数。可以通过docker port +容器需要映射的端口号和容器ID来参考宿主机的映射端口。\n\n格式：EXPOSE `port` [`port`...]\n\n### 8、ENV（用于设置环境变量）[构建指令]\n\n在image中设置环境变量[以键值对的形式]，设置之后RUN命令可以使用该环境变量，在容器启动后也可以通过docker inspect查看环境变量或者通过 docker run --env key=value设置或修改环境变量。\n\n格式：ENV `key` `value` \n\n例子：ENV JAVA_HOME /path/to/java/dirent\n\n### 9、ADD（从src复制文件到container的dest路径）[构建指令]\n\n复制指定的src到容器中的dest，其中src是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件url。`dest` 是container中的绝对路径。所有拷贝到container中的文件和文件夹权限为0755，uid和gid为0。\n\n- 如果src是一个目录，那么会将该目录下的所有文件添加到container中，不包括目录；\n- 如果src文件是可识别的压缩格式，则docker会帮忙解压缩（注意压缩格式）；\n- 如果`src`是文件且`dest`中不使用斜杠结束，则会将`dest`视为文件，`src`的内容会写入`dest`；\n- 如果`src`是文件且`dest`中使用斜杠结束，则会`src`文件拷贝到`dest`目录下。\n\n格式：ADD `src` `dest` \n\n### 10、COPY（复制文件）\n\n复制本地主机的src为容器中的dest，目标路径不存在时会自动创建。\n\n格式：COPY `src` `dest`\n\n### 11、VOLUME（指定挂载点）[设置指令]\n\n创建一个可以从本地主机或其他容器挂载的挂载点，使容器中的一个目录具有持久化存储数据的功能，该目录可以被容器本身使用也可以被其他容器使用。\n\n格式：VOLUME [\"`mountpoint`\"] \n\n其他容器使用共享数据卷：docker run -t -i -rm -volumes-from container1 image2 bash [container1为第一个容器的ID，image2为第二个容器运行image的名字。]\n\n### 12、WORKDIR（切换目录）[设置指令]\n\n相当于cd命令，可以多次切换目录，为RUN,CMD,ENTRYPOINT配置工作目录。可以使用多个WORKDIR的命令，后续命令如果是相对路径则是在上一级路径的基础上执行[类似cd的功能]。\n\n格式：WORKDIR /path/to/workdir\n\n### 13、ONBUILD（在子镜像中执行）\n\n当所创建的镜像作为其他新创建镜像的基础镜像时执行的操作命令，即在创建本镜像时不运行，当作为别人的基础镜像时再在构建时运行（可认为基础镜像为父镜像，而该命令即在它的子镜像构建时运行，相当于在子镜像构建时多加了一些命令）。\n\n格式：ONBUILD `Dockerfile关键字` \n\n## 三、docker build\n\n```shell\nUsage: docker build [OPTIONS] PATH | URL | -\n\nBuild a new image from the source code at PATH\n\n-c, --cpu-shares=0                      CPU shares (relative weight)\n\n--cgroup-parent=                       Optional parent cgroup for the container\n\n--cpu-period=0                           Limit the CPU CFS (Completely Fair Scheduler) period\n\n--cpu-quota=0                            Limit the CPU CFS (Completely Fair Scheduler) quota\n\n--cpuset-cpus=                           CPUs in which to allow execution (0-3, 0,1)\n\n--cpuset-mems=                         MEMs in which to allow execution (0-3, 0,1)\n\n--disable-content-trust=true       Skip image verification\n\n-f, --file=                                     Name of the Dockerfile (Default is 'PATH/Dockerfile')\n\n--force-rm=false                          Always remove intermediate containers\n\n--help=false                                 Print usage\n\n-m, --memory=                          Memory limit\n\n--memory-swap=                       Total memory (memory + swap), '-1' to disable swap\n\n--no-cache=false                        Do not use cache when building the image\n\n--pull=false                                 Always attempt to pull a newer version of the image\n\n-q, --quiet=false                         Suppress the verbose output generated by the containers\n\n--rm=true                                  Remove intermediate containers after a successful build\n\n-t, --tag=                                   Repository name (and optionally a tag) for the image\n\n--ulimit=[] Ulimit options\n```\n\n ","slug":"Docker/Dockerfile使用说明","published":1,"updated":"2017-10-02T08:25:06.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740gx000630vuk3goojul","content":"<h2><span id=\"一-dockerfile的说明\">一、Dockerfile的说明</span></h2>\n<p>dockerfile指令忽略大小写，建议大写，#作为注释，每行只支持一条指令，指令可以带多个参数。</p>\n<p>dockerfile指令分为构建指令和设置指令。</p>\n<ol>\n<li>构建指令：用于构建image，其指定的操作不会在运行image的容器中执行。</li>\n<li>设置指令：用于设置image的属性，其指定的操作会在运行image的容器中执行。</li>\n</ol>\n<h2><span id=\"二-dockerfile指令说明\">二、Dockerfile指令说明</span></h2>\n<h3><span id=\"1-from指定基础镜像构建指令\">1、FROM（指定基础镜像）[构建指令]</span></h3>\n<p>该命令用来指定基础镜像，在基础镜像的基础上修改数据从而构建新的镜像。基础镜像可以是本地仓库也可以是远程仓库。</p>\n<p>指令有两种格式：</p>\n<ol>\n<li>FROM <code>image</code>   【默认为latest版本】</li>\n<li>FROM <code>image</code>:<code>tag</code>     【指定版本】</li>\n</ol>\n<h3><span id=\"2-maintainer镜像创建者信息构建指令\">2、MAINTAINER（镜像创建者信息）[构建指令]</span></h3>\n<p>将镜像制作者（维护者）的信息写入image中，执行docker inspect时会输出该信息。</p>\n<p>格式：MAINTAINER <code>name</code></p>\n<h3><span id=\"3-run安装软件用构建指令\">3、RUN（安装软件用）[构建指令]</span></h3>\n<p>RUN可以运行任何被基础镜像支持的命令（即在基础镜像上执行一个进程），可以使用多条RUN指令，指令较长可以使用\\来换行。</p>\n<p>指令有两种格式：</p>\n<ol>\n<li>RUN <code>command</code> (the command is run in a shell - <code>/bin/sh -c</code>)</li>\n<li>RUN [“executable”, “param1”, “param2” … ] (exec form)\n<ul>\n<li>指定使用其他终端实现，使用exec执行。</li>\n<li>例子：RUN[&quot;/bin/bash&quot;,&quot;-c&quot;,“echo hello”]</li>\n</ul>\n</li>\n</ol>\n<h3><span id=\"4-cmd设置container启动时执行的操作设置指令\">4、CMD（设置container启动时执行的操作）[设置指令]</span></h3>\n<p>用于容器启动时的指定操作，可以是自定义脚本或命令，只执行一次，多个默认执行最后一个。</p>\n<p>指令有三种格式：</p>\n<ol>\n<li>CMD [“executable”,“param1”,“param2”] (like an exec, this is the preferred form)\n<ul>\n<li>运行一个可执行文件并提供参数。</li>\n</ul>\n</li>\n<li>CMD command param1 param2 (as a shell)\n<ul>\n<li>直接执行shell命令，默认以/bin/sh -c执行。</li>\n</ul>\n</li>\n<li>CMD [“param1”,“param2”] (as default parameters to ENTRYPOINT)\n<ul>\n<li>和ENTRYPOINT配合使用，只作为完整命令的参数部分。</li>\n</ul>\n</li>\n</ol>\n<h3><span id=\"5-entrypoint设置container启动时执行的操作设置指令\">5、ENTRYPOINT（设置container启动时执行的操作）[设置指令]</span></h3>\n<p>指定容器启动时执行的命令，若多次设置只执行最后一次。</p>\n<p>ENTRYPOINT翻译为“进入点”，它的功能可以让容器表现得像一个可执行程序一样。</p>\n<p>例子：ENTRYPOINT [&quot;/bin/echo&quot;] ，那么docker build出来的镜像以后的容器功能就像一个/bin/echo程序，docker run -it imageecho “this is a test”，就会输出对应的字符串。这个imageecho镜像对应的容器表现出来的功能就像一个echo程序一样。</p>\n<p>指令有两种格式：</p>\n<ol>\n<li>\n<p>ENTRYPOINT [“executable”, “param1”, “param2”] (like an exec, the preferred form)</p>\n<ul>\n<li>\n<p>和CMD配合使用，CMD则作为完整命令的参数部分，ENTRYPOINT以JSON格式指定执行的命令部分。CMD可以为ENTRYPOINT提供可变参数，不需要变动的参数可以写在ENTRYPOINT里面。</p>\n</li>\n<li>\n<p>例子：</p>\n<p>ENTRYPOINT [&quot;/usr/bin/ls&quot;,&quot;-a&quot;]</p>\n<p>CMD [&quot;-l&quot;]</p>\n</li>\n</ul>\n</li>\n<li>\n<p>ENTRYPOINT command param1 param2 (as a shell)</p>\n<ul>\n<li>独自使用，即和CMD类似，如果CMD也是个完整命令[CMD command param1 param2 (as a shell) ]，那么会相互覆盖，只执行最后一个CMD或ENTRYPOINT。</li>\n<li>例子：ENTRYPOINT ls -l</li>\n</ul>\n</li>\n</ol>\n<h3><span id=\"6-user设置container容器启动的登录用户设置指令\">6、USER（设置container容器启动的登录用户）[设置指令]</span></h3>\n<p>设置启动容器的用户，默认为root用户。</p>\n<p>格式：USER daemon</p>\n<h3><span id=\"7-expose指定容器需要映射到宿主机的端口设置指令\">7、EXPOSE（指定容器需要映射到宿主机的端口）[设置指令]</span></h3>\n<p>该指令会将容器中的端口映射为宿主机中的端口[确保宿主机的端口号没有被使用]。通过宿主机IP和映射后的端口即可访问容器[避免每次运行容器时IP随机生成不固定的问题]。前提是EXPOSE设置映射端口，运行容器时加上-p参数指定EXPOSE设置的端口。EXPOSE可以设置多个端口号，相应地运行容器配套多次使用-p参数。可以通过docker port +容器需要映射的端口号和容器ID来参考宿主机的映射端口。</p>\n<p>格式：EXPOSE <code>port</code> [<code>port</code>…]</p>\n<h3><span id=\"8-env用于设置环境变量构建指令\">8、ENV（用于设置环境变量）[构建指令]</span></h3>\n<p>在image中设置环境变量[以键值对的形式]，设置之后RUN命令可以使用该环境变量，在容器启动后也可以通过docker inspect查看环境变量或者通过 docker run --env key=value设置或修改环境变量。</p>\n<p>格式：ENV <code>key</code> <code>value</code></p>\n<p>例子：ENV JAVA_HOME /path/to/java/dirent</p>\n<h3><span id=\"9-add从src复制文件到container的dest路径构建指令\">9、ADD（从src复制文件到container的dest路径）[构建指令]</span></h3>\n<p>复制指定的src到容器中的dest，其中src是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件url。<code>dest</code> 是container中的绝对路径。所有拷贝到container中的文件和文件夹权限为0755，uid和gid为0。</p>\n<ul>\n<li>如果src是一个目录，那么会将该目录下的所有文件添加到container中，不包括目录；</li>\n<li>如果src文件是可识别的压缩格式，则docker会帮忙解压缩（注意压缩格式）；</li>\n<li>如果<code>src</code>是文件且<code>dest</code>中不使用斜杠结束，则会将<code>dest</code>视为文件，<code>src</code>的内容会写入<code>dest</code>；</li>\n<li>如果<code>src</code>是文件且<code>dest</code>中使用斜杠结束，则会<code>src</code>文件拷贝到<code>dest</code>目录下。</li>\n</ul>\n<p>格式：ADD <code>src</code> <code>dest</code></p>\n<h3><span id=\"10-copy复制文件\">10、COPY（复制文件）</span></h3>\n<p>复制本地主机的src为容器中的dest，目标路径不存在时会自动创建。</p>\n<p>格式：COPY <code>src</code> <code>dest</code></p>\n<h3><span id=\"11-volume指定挂载点设置指令\">11、VOLUME（指定挂载点）[设置指令]</span></h3>\n<p>创建一个可以从本地主机或其他容器挂载的挂载点，使容器中的一个目录具有持久化存储数据的功能，该目录可以被容器本身使用也可以被其他容器使用。</p>\n<p>格式：VOLUME [&quot;<code>mountpoint</code>&quot;]</p>\n<p>其他容器使用共享数据卷：docker run -t -i -rm -volumes-from container1 image2 bash [container1为第一个容器的ID，image2为第二个容器运行image的名字。]</p>\n<h3><span id=\"12-workdir切换目录设置指令\">12、WORKDIR（切换目录）[设置指令]</span></h3>\n<p>相当于cd命令，可以多次切换目录，为RUN,CMD,ENTRYPOINT配置工作目录。可以使用多个WORKDIR的命令，后续命令如果是相对路径则是在上一级路径的基础上执行[类似cd的功能]。</p>\n<p>格式：WORKDIR /path/to/workdir</p>\n<h3><span id=\"13-onbuild在子镜像中执行\">13、ONBUILD（在子镜像中执行）</span></h3>\n<p>当所创建的镜像作为其他新创建镜像的基础镜像时执行的操作命令，即在创建本镜像时不运行，当作为别人的基础镜像时再在构建时运行（可认为基础镜像为父镜像，而该命令即在它的子镜像构建时运行，相当于在子镜像构建时多加了一些命令）。</p>\n<p>格式：ONBUILD <code>Dockerfile关键字</code></p>\n<h2><span id=\"三-docker-build\">三、docker build</span></h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">Usage: docker build [OPTIONS] PATH | URL | -</div><div class=\"line\"></div><div class=\"line\">Build a new image from the source code at PATH</div><div class=\"line\"></div><div class=\"line\">-c, --cpu-shares=0                      CPU shares (relative weight)</div><div class=\"line\"></div><div class=\"line\">--cgroup-parent=                       Optional parent cgroup for the container</div><div class=\"line\"></div><div class=\"line\">--cpu-period=0                           Limit the CPU CFS (Completely Fair Scheduler) period</div><div class=\"line\"></div><div class=\"line\">--cpu-quota=0                            Limit the CPU CFS (Completely Fair Scheduler) quota</div><div class=\"line\"></div><div class=\"line\">--cpuset-cpus=                           CPUs in which to allow execution (0-3, 0,1)</div><div class=\"line\"></div><div class=\"line\">--cpuset-mems=                         MEMs in which to allow execution (0-3, 0,1)</div><div class=\"line\"></div><div class=\"line\">--disable-content-trust=true       Skip image verification</div><div class=\"line\"></div><div class=\"line\">-f, --file=                                     Name of the Dockerfile (Default is 'PATH/Dockerfile')</div><div class=\"line\"></div><div class=\"line\">--force-rm=false                          Always remove intermediate containers</div><div class=\"line\"></div><div class=\"line\">--help=false                                 Print usage</div><div class=\"line\"></div><div class=\"line\">-m, --memory=                          Memory limit</div><div class=\"line\"></div><div class=\"line\">--memory-swap=                       Total memory (memory + swap), '-1' to disable swap</div><div class=\"line\"></div><div class=\"line\">--no-cache=false                        Do not use cache when building the image</div><div class=\"line\"></div><div class=\"line\">--pull=false                                 Always attempt to pull a newer version of the image</div><div class=\"line\"></div><div class=\"line\">-q, --quiet=false                         Suppress the verbose output generated by the containers</div><div class=\"line\"></div><div class=\"line\">--rm=true                                  Remove intermediate containers after a successful build</div><div class=\"line\"></div><div class=\"line\">-t, --tag=                                   Repository name (and optionally a tag) for the image</div><div class=\"line\"></div><div class=\"line\">--ulimit=[] Ulimit options</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2>一、Dockerfile的说明</h2>\n<p>dockerfile指令忽略大小写，建议大写，#作为注释，每行只支持一条指令，指令可以带多个参数。</p>\n<p>dockerfile指令分为构建指令和设置指令。</p>\n<ol>\n<li>构建指令：用于构建image，其指定的操作不会在运行image的容器中执行。</li>\n<li>设置指令：用于设置image的属性，其指定的操作会在运行image的容器中执行。</li>\n</ol>\n<h2>二、Dockerfile指令说明</h2>\n<h3>1、FROM（指定基础镜像）[构建指令]</h3>\n<p>该命令用来指定基础镜像，在基础镜像的基础上修改数据从而构建新的镜像。基础镜像可以是本地仓库也可以是远程仓库。</p>\n<p>指令有两种格式：</p>\n<ol>\n<li>FROM <code>image</code>   【默认为latest版本】</li>\n<li>FROM <code>image</code>:<code>tag</code>     【指定版本】</li>\n</ol>\n<h3>2、MAINTAINER（镜像创建者信息）[构建指令]</h3>\n<p>将镜像制作者（维护者）的信息写入image中，执行docker inspect时会输出该信息。</p>\n<p>格式：MAINTAINER <code>name</code></p>\n<h3>3、RUN（安装软件用）[构建指令]</h3>\n<p>RUN可以运行任何被基础镜像支持的命令（即在基础镜像上执行一个进程），可以使用多条RUN指令，指令较长可以使用\\来换行。</p>\n<p>指令有两种格式：</p>\n<ol>\n<li>RUN <code>command</code> (the command is run in a shell - <code>/bin/sh -c</code>)</li>\n<li>RUN [“executable”, “param1”, “param2” … ] (exec form)\n<ul>\n<li>指定使用其他终端实现，使用exec执行。</li>\n<li>例子：RUN[&quot;/bin/bash&quot;,&quot;-c&quot;,“echo hello”]</li>\n</ul>\n</li>\n</ol>\n<h3>4、CMD（设置container启动时执行的操作）[设置指令]</h3>\n<p>用于容器启动时的指定操作，可以是自定义脚本或命令，只执行一次，多个默认执行最后一个。</p>\n<p>指令有三种格式：</p>\n<ol>\n<li>CMD [“executable”,“param1”,“param2”] (like an exec, this is the preferred form)\n<ul>\n<li>运行一个可执行文件并提供参数。</li>\n</ul>\n</li>\n<li>CMD command param1 param2 (as a shell)\n<ul>\n<li>直接执行shell命令，默认以/bin/sh -c执行。</li>\n</ul>\n</li>\n<li>CMD [“param1”,“param2”] (as default parameters to ENTRYPOINT)\n<ul>\n<li>和ENTRYPOINT配合使用，只作为完整命令的参数部分。</li>\n</ul>\n</li>\n</ol>\n<h3>5、ENTRYPOINT（设置container启动时执行的操作）[设置指令]</h3>\n<p>指定容器启动时执行的命令，若多次设置只执行最后一次。</p>\n<p>ENTRYPOINT翻译为“进入点”，它的功能可以让容器表现得像一个可执行程序一样。</p>\n<p>例子：ENTRYPOINT [&quot;/bin/echo&quot;] ，那么docker build出来的镜像以后的容器功能就像一个/bin/echo程序，docker run -it imageecho “this is a test”，就会输出对应的字符串。这个imageecho镜像对应的容器表现出来的功能就像一个echo程序一样。</p>\n<p>指令有两种格式：</p>\n<ol>\n<li>\n<p>ENTRYPOINT [“executable”, “param1”, “param2”] (like an exec, the preferred form)</p>\n<ul>\n<li>\n<p>和CMD配合使用，CMD则作为完整命令的参数部分，ENTRYPOINT以JSON格式指定执行的命令部分。CMD可以为ENTRYPOINT提供可变参数，不需要变动的参数可以写在ENTRYPOINT里面。</p>\n</li>\n<li>\n<p>例子：</p>\n<p>ENTRYPOINT [&quot;/usr/bin/ls&quot;,&quot;-a&quot;]</p>\n<p>CMD [&quot;-l&quot;]</p>\n</li>\n</ul>\n</li>\n<li>\n<p>ENTRYPOINT command param1 param2 (as a shell)</p>\n<ul>\n<li>独自使用，即和CMD类似，如果CMD也是个完整命令[CMD command param1 param2 (as a shell) ]，那么会相互覆盖，只执行最后一个CMD或ENTRYPOINT。</li>\n<li>例子：ENTRYPOINT ls -l</li>\n</ul>\n</li>\n</ol>\n<h3>6、USER（设置container容器启动的登录用户）[设置指令]</h3>\n<p>设置启动容器的用户，默认为root用户。</p>\n<p>格式：USER daemon</p>\n<h3>7、EXPOSE（指定容器需要映射到宿主机的端口）[设置指令]</h3>\n<p>该指令会将容器中的端口映射为宿主机中的端口[确保宿主机的端口号没有被使用]。通过宿主机IP和映射后的端口即可访问容器[避免每次运行容器时IP随机生成不固定的问题]。前提是EXPOSE设置映射端口，运行容器时加上-p参数指定EXPOSE设置的端口。EXPOSE可以设置多个端口号，相应地运行容器配套多次使用-p参数。可以通过docker port +容器需要映射的端口号和容器ID来参考宿主机的映射端口。</p>\n<p>格式：EXPOSE <code>port</code> [<code>port</code>…]</p>\n<h3>8、ENV（用于设置环境变量）[构建指令]</h3>\n<p>在image中设置环境变量[以键值对的形式]，设置之后RUN命令可以使用该环境变量，在容器启动后也可以通过docker inspect查看环境变量或者通过 docker run --env key=value设置或修改环境变量。</p>\n<p>格式：ENV <code>key</code> <code>value</code></p>\n<p>例子：ENV JAVA_HOME /path/to/java/dirent</p>\n<h3>9、ADD（从src复制文件到container的dest路径）[构建指令]</h3>\n<p>复制指定的src到容器中的dest，其中src是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件url。<code>dest</code> 是container中的绝对路径。所有拷贝到container中的文件和文件夹权限为0755，uid和gid为0。</p>\n<ul>\n<li>如果src是一个目录，那么会将该目录下的所有文件添加到container中，不包括目录；</li>\n<li>如果src文件是可识别的压缩格式，则docker会帮忙解压缩（注意压缩格式）；</li>\n<li>如果<code>src</code>是文件且<code>dest</code>中不使用斜杠结束，则会将<code>dest</code>视为文件，<code>src</code>的内容会写入<code>dest</code>；</li>\n<li>如果<code>src</code>是文件且<code>dest</code>中使用斜杠结束，则会<code>src</code>文件拷贝到<code>dest</code>目录下。</li>\n</ul>\n<p>格式：ADD <code>src</code> <code>dest</code></p>\n<h3>10、COPY（复制文件）</h3>\n<p>复制本地主机的src为容器中的dest，目标路径不存在时会自动创建。</p>\n<p>格式：COPY <code>src</code> <code>dest</code></p>\n<h3>11、VOLUME（指定挂载点）[设置指令]</h3>\n<p>创建一个可以从本地主机或其他容器挂载的挂载点，使容器中的一个目录具有持久化存储数据的功能，该目录可以被容器本身使用也可以被其他容器使用。</p>\n<p>格式：VOLUME [&quot;<code>mountpoint</code>&quot;]</p>\n<p>其他容器使用共享数据卷：docker run -t -i -rm -volumes-from container1 image2 bash [container1为第一个容器的ID，image2为第二个容器运行image的名字。]</p>\n<h3>12、WORKDIR（切换目录）[设置指令]</h3>\n<p>相当于cd命令，可以多次切换目录，为RUN,CMD,ENTRYPOINT配置工作目录。可以使用多个WORKDIR的命令，后续命令如果是相对路径则是在上一级路径的基础上执行[类似cd的功能]。</p>\n<p>格式：WORKDIR /path/to/workdir</p>\n<h3>13、ONBUILD（在子镜像中执行）</h3>\n<p>当所创建的镜像作为其他新创建镜像的基础镜像时执行的操作命令，即在创建本镜像时不运行，当作为别人的基础镜像时再在构建时运行（可认为基础镜像为父镜像，而该命令即在它的子镜像构建时运行，相当于在子镜像构建时多加了一些命令）。</p>\n<p>格式：ONBUILD <code>Dockerfile关键字</code></p>\n<h2>三、docker build</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">Usage: docker build [OPTIONS] PATH | URL | -</div><div class=\"line\"></div><div class=\"line\">Build a new image from the source code at PATH</div><div class=\"line\"></div><div class=\"line\">-c, --cpu-shares=0                      CPU shares (relative weight)</div><div class=\"line\"></div><div class=\"line\">--cgroup-parent=                       Optional parent cgroup for the container</div><div class=\"line\"></div><div class=\"line\">--cpu-period=0                           Limit the CPU CFS (Completely Fair Scheduler) period</div><div class=\"line\"></div><div class=\"line\">--cpu-quota=0                            Limit the CPU CFS (Completely Fair Scheduler) quota</div><div class=\"line\"></div><div class=\"line\">--cpuset-cpus=                           CPUs in which to allow execution (0-3, 0,1)</div><div class=\"line\"></div><div class=\"line\">--cpuset-mems=                         MEMs in which to allow execution (0-3, 0,1)</div><div class=\"line\"></div><div class=\"line\">--disable-content-trust=true       Skip image verification</div><div class=\"line\"></div><div class=\"line\">-f, --file=                                     Name of the Dockerfile (Default is 'PATH/Dockerfile')</div><div class=\"line\"></div><div class=\"line\">--force-rm=false                          Always remove intermediate containers</div><div class=\"line\"></div><div class=\"line\">--help=false                                 Print usage</div><div class=\"line\"></div><div class=\"line\">-m, --memory=                          Memory limit</div><div class=\"line\"></div><div class=\"line\">--memory-swap=                       Total memory (memory + swap), '-1' to disable swap</div><div class=\"line\"></div><div class=\"line\">--no-cache=false                        Do not use cache when building the image</div><div class=\"line\"></div><div class=\"line\">--pull=false                                 Always attempt to pull a newer version of the image</div><div class=\"line\"></div><div class=\"line\">-q, --quiet=false                         Suppress the verbose output generated by the containers</div><div class=\"line\"></div><div class=\"line\">--rm=true                                  Remove intermediate containers after a successful build</div><div class=\"line\"></div><div class=\"line\">-t, --tag=                                   Repository name (and optionally a tag) for the image</div><div class=\"line\"></div><div class=\"line\">--ulimit=[] Ulimit options</div></pre></td></tr></table></figure>"},{"title":"[Docker] Docker常用命令原理图","catalog":true,"date":"2017-07-09T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Docker"],"_content":"\n## docker常用命令原理图概览：\n\n![docker命令原理图](/img/article/docker/docker常用命令原理图/docker命令原理图.jpg)\n\n## （一）image layer（镜像层）\n\n镜像可以看成是由多个镜像层叠加起来的一个文件系统，镜像层也可以简单理解为一个基本的镜像，而每个镜像层之间通过指针的形式进行叠加。\n\n![1](/img/article/docker/docker常用命令原理图/1.png)\n\n根据上图，镜像层的主要组成部分包括镜像层id，镜像层指针【指向父层】，元数据【layer metadata】包含了docker构建和运行的信息还有父层的层次信息。\n\n只读层和读写层【top layer】的组成部分基本一致。同时读写层可以转换成只读层【docker commit操作实现】\n\n## （二）image（镜像）---【只读层的集合】\n\n1、镜像是一堆只读层的统一视角，除了最底层没有指向外，每一层都指向它的父层，统一文件系统（union file system）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。而每一层都是不可写的，就是只读层。\n\n![2.1](/img/article/docker/docker常用命令原理图/2.1.png)\n\n## （三）container（容器）---【一层读写层+多层只读层】\n\n1、容器和镜像的区别在于容器的最上面一层是读写层【top layer】，而这边并没有区分容器是否在运行。运行状态的容器【running container】即一个可读写的文件系统【静态容器】+隔离的进程空间和其中的进程。\n\n ![3.1](/img/article/docker/docker常用命令原理图/3.1.png)\n\n隔离的进程空间中的进程可以对该读写层进行增删改，其运行状态容器的进程操作都作用在该读写层上。每个容器只能有一个进程隔离空间。\n\n![3.2](/img/article/docker/docker常用命令原理图/3.2.png)\n\n## （四）docker常用命令说明\n\n### 1、标识说明\n\n#### 1）image---（统一只读文件系统）\n\n![4.1.1](/img/article/docker/docker常用命令原理图/4.1.1.png)\n\n#### 2）静态容器【未运行的容器】---（统一可读写文件系统）\n\n![4.1.2](/img/article/docker/docker常用命令原理图/4.1.2.png)\n\n#### 3）动态容器【running container】---（进程空间（包括进程）+统一可读写文件系统）\n\n![4.1.3](/img/article/docker/docker常用命令原理图/4.1.3.png)\n\n### 2、命令说明\n\n#### a）docker生命周期相关命令:\n\n##### 1）docker create <image-id>\n\n![4.2.1.1](/img/article/docker/docker常用命令原理图/4.2.1.1.png)\n\n即为只读文件系统添加一层可读写层【top layer】，生成可读写文件系统，该命令状态下容器为静态容器，并没有运行。\n\n##### 2）docker start（restart） <container-id>        【docker stop即为docker start的逆过程】\n\n![4.2.1.2](/img/article/docker/docker常用命令原理图/4.2.1.2.png)\n\n即为可读写文件系统添加一个进程空间【包括进程】，生成动态容器【running container】\n\n##### 3）docker run <image-id>\n\n![4.2.1.3](/img/article/docker/docker常用命令原理图/4.2.1.3.png)\n\n\n\ndocker run=docker create+docker start\n\n类似流程如下 ：\n\n![4.2.1.3.1](/img/article/docker/docker常用命令原理图/4.2.1.3.1.png)\n\n##### 4）docker stop <container-id>\n\n![4.2.1.4](/img/article/docker/docker常用命令原理图/4.2.1.4.png)\n\n向运行的容器中发一个SIGTERM的信号，然后停止所有的进程。即为docker start的逆过程。\n\n##### 5）docker kill <container-id>\n\n![4.2.1.5](/img/article/docker/docker常用命令原理图/4.2.1.5.png)\n\ndocker kill向容器发送不友好的SIGKILL的信号，相当于快速强制关闭容器，与docker stop的区别在于docker stop是正常关闭，先发SIGTERM信号，清理进程，再发SIGKILL信号退出。\n\n##### 6）docker pause <container-id>    【docker unpause为逆过程】---比较少使用\n\n![4.2.1.6](/img/article/docker/docker常用命令原理图/4.2.1.6.png)\n\n暂停容器中的所有进程，使用cgroup的freezer顺序暂停容器里的所有进程，docker unpause为逆过程即恢复所有进程。比较少使用。\n\n##### 7）docker commit <container-id>\n\n![4.2.1.7](/img/article/docker/docker常用命令原理图/4.2.1.7.png)\n\n![4.2.1.7.2](/img/article/docker/docker常用命令原理图/4.2.1.7.2.png)\n\n把容器的可读写层转化成只读层，即从容器状态【可读写文件系统】变为镜像状态【只读文件系统】，可理解为【固化】。\n\n##### 8）docker build\n\n![4.2.1.8.1](/img/article/docker/docker常用命令原理图/4.2.1.8.1.png)\n\n![4.2.1.8.2](/img/article/docker/docker常用命令原理图/4.2.1.8.2.png)\n\n**docker build=docker run【运行容器】+【进程修改数据】+docker commit【固化数据】，不断循环直至生成所需镜像。**\n\n循环一次便会形成新的层（镜像）【原镜像层+已固化的可读写层】\n\ndocker build 一般作用在dockerfile文件上。\n\n#### b）docker查询类命令：【查询对象：①image，②container，③image/container中的数据，④系统信息[容器数，镜像数及其他]】\n\n##### 1.1）docker images\n\n![4.2.2.1.1](/img/article/docker/docker常用命令原理图/4.2.2.1.1.png)\n\ndocker images 列出当前镜像【以顶层镜像id来表示整个完整镜像】，每个顶层镜像下面隐藏多个镜像层。\n\n##### 1.2）docker images -a\n\n![4.2.2.1.2](/img/article/docker/docker常用命令原理图/4.2.2.1.2.png)\n\ndocker images -a列出所有镜像层【排序以每个顶层镜像id为首后接该镜像下的所有镜像层】，依次列出每个镜像的所有镜像层。\n\n##### 1.3）docker history <image-id>\n\n![4.2.2.1.3](/img/article/docker/docker常用命令原理图/4.2.2.1.3.png)\n\ndocker history 列出该镜像id下的所有历史镜像。\n\n##### 2.1）docker ps\n\n![4.2.2.2.1](/img/article/docker/docker常用命令原理图/4.2.2.2.1.png)\n\n列出所有运行的容器【running container】\n\n##### 2.2）docker ps -a \n\n![4.2.2.2.2](/img/article/docker/docker常用命令原理图/4.2.2.2.2.png)\n\n列出所有容器，包括静态容器【未运行的容器】和动态容器【running container】\n\n##### 3.1）docker inspect <container-id> or <image-id>\n\n![4.2.2.3.1](/img/article/docker/docker常用命令原理图/4.2.2.3.1.png)\n\n提取出容器或镜像最顶层的元数据。\n\n##### 3.2）docker info\n\n显示 Docker 系统信息，包括镜像和容器数。\n\n#### c）docker操作类命令：\n\n##### 1）docker rm <container-id>\n\n![4.2.3.1](/img/article/docker/docker常用命令原理图/4.2.3.1.png)\n\ndocker rm会移除镜像，该命令只能对静态容器【非运行状态】进行操作。\n\n通过docker rm -f <container-id>的-f （force）参数可以强制删除运行状态的容器【running container】。\n\n##### 2）docker rmi <image-id>\n\n![4.2.3.2](/img/article/docker/docker常用命令原理图/4.2.3.2.png)\n\n##### 3）docker exec <running-container-id>\n\n![4.2.3.3](/img/article/docker/docker常用命令原理图/4.2.3.3.png)\n\ndocker exec会在运行状态的容器中执行一个新的进程。\n\n##### 4）docker export <container-id>\n\n![4.2.3.4](/img/article/docker/docker常用命令原理图/4.2.3.4.png)\n\ndocker export命令创建一个tar文件，并且移除了元数据和不必要的层，将多个层整合成了一个层，只保存了当前统一视角看到的内容。\n\n \n\n附：本文在[http://dockone.io/article/783](http://dockone.io/article/783)的基础上做整理和修改。","source":"_posts/Docker/Docker常用命令原理图.md","raw":"---\ntitle: \"[Docker] Docker常用命令原理图\"\ncatalog: true\ndate: 2017-07-09 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Docker\ncatagories:\n- Docker\n---\n\n## docker常用命令原理图概览：\n\n![docker命令原理图](/img/article/docker/docker常用命令原理图/docker命令原理图.jpg)\n\n## （一）image layer（镜像层）\n\n镜像可以看成是由多个镜像层叠加起来的一个文件系统，镜像层也可以简单理解为一个基本的镜像，而每个镜像层之间通过指针的形式进行叠加。\n\n![1](/img/article/docker/docker常用命令原理图/1.png)\n\n根据上图，镜像层的主要组成部分包括镜像层id，镜像层指针【指向父层】，元数据【layer metadata】包含了docker构建和运行的信息还有父层的层次信息。\n\n只读层和读写层【top layer】的组成部分基本一致。同时读写层可以转换成只读层【docker commit操作实现】\n\n## （二）image（镜像）---【只读层的集合】\n\n1、镜像是一堆只读层的统一视角，除了最底层没有指向外，每一层都指向它的父层，统一文件系统（union file system）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。而每一层都是不可写的，就是只读层。\n\n![2.1](/img/article/docker/docker常用命令原理图/2.1.png)\n\n## （三）container（容器）---【一层读写层+多层只读层】\n\n1、容器和镜像的区别在于容器的最上面一层是读写层【top layer】，而这边并没有区分容器是否在运行。运行状态的容器【running container】即一个可读写的文件系统【静态容器】+隔离的进程空间和其中的进程。\n\n ![3.1](/img/article/docker/docker常用命令原理图/3.1.png)\n\n隔离的进程空间中的进程可以对该读写层进行增删改，其运行状态容器的进程操作都作用在该读写层上。每个容器只能有一个进程隔离空间。\n\n![3.2](/img/article/docker/docker常用命令原理图/3.2.png)\n\n## （四）docker常用命令说明\n\n### 1、标识说明\n\n#### 1）image---（统一只读文件系统）\n\n![4.1.1](/img/article/docker/docker常用命令原理图/4.1.1.png)\n\n#### 2）静态容器【未运行的容器】---（统一可读写文件系统）\n\n![4.1.2](/img/article/docker/docker常用命令原理图/4.1.2.png)\n\n#### 3）动态容器【running container】---（进程空间（包括进程）+统一可读写文件系统）\n\n![4.1.3](/img/article/docker/docker常用命令原理图/4.1.3.png)\n\n### 2、命令说明\n\n#### a）docker生命周期相关命令:\n\n##### 1）docker create <image-id>\n\n![4.2.1.1](/img/article/docker/docker常用命令原理图/4.2.1.1.png)\n\n即为只读文件系统添加一层可读写层【top layer】，生成可读写文件系统，该命令状态下容器为静态容器，并没有运行。\n\n##### 2）docker start（restart） <container-id>        【docker stop即为docker start的逆过程】\n\n![4.2.1.2](/img/article/docker/docker常用命令原理图/4.2.1.2.png)\n\n即为可读写文件系统添加一个进程空间【包括进程】，生成动态容器【running container】\n\n##### 3）docker run <image-id>\n\n![4.2.1.3](/img/article/docker/docker常用命令原理图/4.2.1.3.png)\n\n\n\ndocker run=docker create+docker start\n\n类似流程如下 ：\n\n![4.2.1.3.1](/img/article/docker/docker常用命令原理图/4.2.1.3.1.png)\n\n##### 4）docker stop <container-id>\n\n![4.2.1.4](/img/article/docker/docker常用命令原理图/4.2.1.4.png)\n\n向运行的容器中发一个SIGTERM的信号，然后停止所有的进程。即为docker start的逆过程。\n\n##### 5）docker kill <container-id>\n\n![4.2.1.5](/img/article/docker/docker常用命令原理图/4.2.1.5.png)\n\ndocker kill向容器发送不友好的SIGKILL的信号，相当于快速强制关闭容器，与docker stop的区别在于docker stop是正常关闭，先发SIGTERM信号，清理进程，再发SIGKILL信号退出。\n\n##### 6）docker pause <container-id>    【docker unpause为逆过程】---比较少使用\n\n![4.2.1.6](/img/article/docker/docker常用命令原理图/4.2.1.6.png)\n\n暂停容器中的所有进程，使用cgroup的freezer顺序暂停容器里的所有进程，docker unpause为逆过程即恢复所有进程。比较少使用。\n\n##### 7）docker commit <container-id>\n\n![4.2.1.7](/img/article/docker/docker常用命令原理图/4.2.1.7.png)\n\n![4.2.1.7.2](/img/article/docker/docker常用命令原理图/4.2.1.7.2.png)\n\n把容器的可读写层转化成只读层，即从容器状态【可读写文件系统】变为镜像状态【只读文件系统】，可理解为【固化】。\n\n##### 8）docker build\n\n![4.2.1.8.1](/img/article/docker/docker常用命令原理图/4.2.1.8.1.png)\n\n![4.2.1.8.2](/img/article/docker/docker常用命令原理图/4.2.1.8.2.png)\n\n**docker build=docker run【运行容器】+【进程修改数据】+docker commit【固化数据】，不断循环直至生成所需镜像。**\n\n循环一次便会形成新的层（镜像）【原镜像层+已固化的可读写层】\n\ndocker build 一般作用在dockerfile文件上。\n\n#### b）docker查询类命令：【查询对象：①image，②container，③image/container中的数据，④系统信息[容器数，镜像数及其他]】\n\n##### 1.1）docker images\n\n![4.2.2.1.1](/img/article/docker/docker常用命令原理图/4.2.2.1.1.png)\n\ndocker images 列出当前镜像【以顶层镜像id来表示整个完整镜像】，每个顶层镜像下面隐藏多个镜像层。\n\n##### 1.2）docker images -a\n\n![4.2.2.1.2](/img/article/docker/docker常用命令原理图/4.2.2.1.2.png)\n\ndocker images -a列出所有镜像层【排序以每个顶层镜像id为首后接该镜像下的所有镜像层】，依次列出每个镜像的所有镜像层。\n\n##### 1.3）docker history <image-id>\n\n![4.2.2.1.3](/img/article/docker/docker常用命令原理图/4.2.2.1.3.png)\n\ndocker history 列出该镜像id下的所有历史镜像。\n\n##### 2.1）docker ps\n\n![4.2.2.2.1](/img/article/docker/docker常用命令原理图/4.2.2.2.1.png)\n\n列出所有运行的容器【running container】\n\n##### 2.2）docker ps -a \n\n![4.2.2.2.2](/img/article/docker/docker常用命令原理图/4.2.2.2.2.png)\n\n列出所有容器，包括静态容器【未运行的容器】和动态容器【running container】\n\n##### 3.1）docker inspect <container-id> or <image-id>\n\n![4.2.2.3.1](/img/article/docker/docker常用命令原理图/4.2.2.3.1.png)\n\n提取出容器或镜像最顶层的元数据。\n\n##### 3.2）docker info\n\n显示 Docker 系统信息，包括镜像和容器数。\n\n#### c）docker操作类命令：\n\n##### 1）docker rm <container-id>\n\n![4.2.3.1](/img/article/docker/docker常用命令原理图/4.2.3.1.png)\n\ndocker rm会移除镜像，该命令只能对静态容器【非运行状态】进行操作。\n\n通过docker rm -f <container-id>的-f （force）参数可以强制删除运行状态的容器【running container】。\n\n##### 2）docker rmi <image-id>\n\n![4.2.3.2](/img/article/docker/docker常用命令原理图/4.2.3.2.png)\n\n##### 3）docker exec <running-container-id>\n\n![4.2.3.3](/img/article/docker/docker常用命令原理图/4.2.3.3.png)\n\ndocker exec会在运行状态的容器中执行一个新的进程。\n\n##### 4）docker export <container-id>\n\n![4.2.3.4](/img/article/docker/docker常用命令原理图/4.2.3.4.png)\n\ndocker export命令创建一个tar文件，并且移除了元数据和不必要的层，将多个层整合成了一个层，只保存了当前统一视角看到的内容。\n\n \n\n附：本文在[http://dockone.io/article/783](http://dockone.io/article/783)的基础上做整理和修改。","slug":"Docker/Docker常用命令原理图","published":1,"updated":"2017-10-03T02:59:19.506Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740gz000730vutha76aan","content":"<h2><span id=\"docker常用命令原理图概览\">docker常用命令原理图概览：</span></h2>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/docker%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE.jpg\" alt=\"docker命令原理图\"></p>\n<h2><span id=\"一image-layer镜像层\">（一）image layer（镜像层）</span></h2>\n<p>镜像可以看成是由多个镜像层叠加起来的一个文件系统，镜像层也可以简单理解为一个基本的镜像，而每个镜像层之间通过指针的形式进行叠加。</p>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/1.png\" alt=\"1\"></p>\n<p>根据上图，镜像层的主要组成部分包括镜像层id，镜像层指针【指向父层】，元数据【layer metadata】包含了docker构建和运行的信息还有父层的层次信息。</p>\n<p>只读层和读写层【top layer】的组成部分基本一致。同时读写层可以转换成只读层【docker commit操作实现】</p>\n<h2><span id=\"二image镜像只读层的集合\">（二）image（镜像）—【只读层的集合】</span></h2>\n<p>1、镜像是一堆只读层的统一视角，除了最底层没有指向外，每一层都指向它的父层，统一文件系统（union file system）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。而每一层都是不可写的，就是只读层。</p>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/2.1.png\" alt=\"2.1\"></p>\n<h2><span id=\"三container容器一层读写层多层只读层\">（三）container（容器）—【一层读写层+多层只读层】</span></h2>\n<p>1、容器和镜像的区别在于容器的最上面一层是读写层【top layer】，而这边并没有区分容器是否在运行。运行状态的容器【running container】即一个可读写的文件系统【静态容器】+隔离的进程空间和其中的进程。</p>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/3.1.png\" alt=\"3.1\"></p>\n<p>隔离的进程空间中的进程可以对该读写层进行增删改，其运行状态容器的进程操作都作用在该读写层上。每个容器只能有一个进程隔离空间。</p>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/3.2.png\" alt=\"3.2\"></p>\n<h2><span id=\"四docker常用命令说明\">（四）docker常用命令说明</span></h2>\n<h3><span id=\"1-标识说明\">1、标识说明</span></h3>\n<h4><span id=\"1image统一只读文件系统\">1）image—（统一只读文件系统）</span></h4>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.1.1.png\" alt=\"4.1.1\"></p>\n<h4><span id=\"2静态容器未运行的容器统一可读写文件系统\">2）静态容器【未运行的容器】—（统一可读写文件系统）</span></h4>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.1.2.png\" alt=\"4.1.2\"></p>\n<h4><span id=\"3动态容器running-container进程空间包括进程统一可读写文件系统\">3）动态容器【running container】—（进程空间（包括进程）+统一可读写文件系统）</span></h4>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.1.3.png\" alt=\"4.1.3\"></p>\n<h3><span id=\"2-命令说明\">2、命令说明</span></h3>\n<h4><span id=\"adocker生命周期相关命令\">a）docker生命周期相关命令:</span></h4>\n<h5><span id=\"1docker-create\">1）docker create <image-id></image-id></span></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.1.png\" alt=\"4.2.1.1\"></p>\n<p>即为只读文件系统添加一层可读写层【top layer】，生成可读写文件系统，该命令状态下容器为静态容器，并没有运行。</p>\n<h5><span id=\"2docker-startrestart-docker-stop即为docker-start的逆过程\">2）docker start（restart） <container-id>        【docker stop即为docker start的逆过程】</container-id></span></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.2.png\" alt=\"4.2.1.2\"></p>\n<p>即为可读写文件系统添加一个进程空间【包括进程】，生成动态容器【running container】</p>\n<h5><span id=\"3docker-run\">3）docker run <image-id></image-id></span></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.3.png\" alt=\"4.2.1.3\"></p>\n<p>docker run=docker create+docker start</p>\n<p>类似流程如下 ：</p>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.3.1.png\" alt=\"4.2.1.3.1\"></p>\n<h5><span id=\"4docker-stop\">4）docker stop <container-id></container-id></span></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.4.png\" alt=\"4.2.1.4\"></p>\n<p>向运行的容器中发一个SIGTERM的信号，然后停止所有的进程。即为docker start的逆过程。</p>\n<h5><span id=\"5docker-kill\">5）docker kill <container-id></container-id></span></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.5.png\" alt=\"4.2.1.5\"></p>\n<p>docker kill向容器发送不友好的SIGKILL的信号，相当于快速强制关闭容器，与docker stop的区别在于docker stop是正常关闭，先发SIGTERM信号，清理进程，再发SIGKILL信号退出。</p>\n<h5><span id=\"6docker-pause-docker-unpause为逆过程比较少使用\">6）docker pause <container-id>    【docker unpause为逆过程】—比较少使用</container-id></span></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.6.png\" alt=\"4.2.1.6\"></p>\n<p>暂停容器中的所有进程，使用cgroup的freezer顺序暂停容器里的所有进程，docker unpause为逆过程即恢复所有进程。比较少使用。</p>\n<h5><span id=\"7docker-commit\">7）docker commit <container-id></container-id></span></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.7.png\" alt=\"4.2.1.7\"></p>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.7.2.png\" alt=\"4.2.1.7.2\"></p>\n<p>把容器的可读写层转化成只读层，即从容器状态【可读写文件系统】变为镜像状态【只读文件系统】，可理解为【固化】。</p>\n<h5><span id=\"8docker-build\">8）docker build</span></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.8.1.png\" alt=\"4.2.1.8.1\"></p>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.8.2.png\" alt=\"4.2.1.8.2\"></p>\n<p><strong>docker build=docker run【运行容器】+【进程修改数据】+docker commit【固化数据】，不断循环直至生成所需镜像。</strong></p>\n<p>循环一次便会形成新的层（镜像）【原镜像层+已固化的可读写层】</p>\n<p>docker build 一般作用在dockerfile文件上。</p>\n<h4><span id=\"bdocker查询类命令查询对象1image2container3imagecontainer中的数据4系统信息容器数镜像数及其他\">b）docker查询类命令：【查询对象：①image，②container，③image/container中的数据，④系统信息[容器数，镜像数及其他]】</span></h4>\n<h5><span id=\"11docker-images\">1.1）docker images</span></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.2.1.1.png\" alt=\"4.2.2.1.1\"></p>\n<p>docker images 列出当前镜像【以顶层镜像id来表示整个完整镜像】，每个顶层镜像下面隐藏多个镜像层。</p>\n<h5><span id=\"12docker-images-a\">1.2）docker images -a</span></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.2.1.2.png\" alt=\"4.2.2.1.2\"></p>\n<p>docker images -a列出所有镜像层【排序以每个顶层镜像id为首后接该镜像下的所有镜像层】，依次列出每个镜像的所有镜像层。</p>\n<h5><span id=\"13docker-history\">1.3）docker history <image-id></image-id></span></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.2.1.3.png\" alt=\"4.2.2.1.3\"></p>\n<p>docker history 列出该镜像id下的所有历史镜像。</p>\n<h5><span id=\"21docker-ps\">2.1）docker ps</span></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.2.2.1.png\" alt=\"4.2.2.2.1\"></p>\n<p>列出所有运行的容器【running container】</p>\n<h5><span id=\"22docker-ps-a\">2.2）docker ps -a</span></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.2.2.2.png\" alt=\"4.2.2.2.2\"></p>\n<p>列出所有容器，包括静态容器【未运行的容器】和动态容器【running container】</p>\n<h5><span id=\"31docker-inspect-or\">3.1）docker inspect <container-id> or <image-id></image-id></container-id></span></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.2.3.1.png\" alt=\"4.2.2.3.1\"></p>\n<p>提取出容器或镜像最顶层的元数据。</p>\n<h5><span id=\"32docker-info\">3.2）docker info</span></h5>\n<p>显示 Docker 系统信息，包括镜像和容器数。</p>\n<h4><span id=\"cdocker操作类命令\">c）docker操作类命令：</span></h4>\n<h5><span id=\"1docker-rm\">1）docker rm <container-id></container-id></span></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.3.1.png\" alt=\"4.2.3.1\"></p>\n<p>docker rm会移除镜像，该命令只能对静态容器【非运行状态】进行操作。</p>\n<p>通过docker rm -f <container-id>的-f （force）参数可以强制删除运行状态的容器【running container】。</container-id></p>\n<h5><span id=\"2docker-rmi\">2）docker rmi <image-id></image-id></span></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.3.2.png\" alt=\"4.2.3.2\"></p>\n<h5><span id=\"3docker-exec\">3）docker exec <running-container-id></running-container-id></span></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.3.3.png\" alt=\"4.2.3.3\"></p>\n<p>docker exec会在运行状态的容器中执行一个新的进程。</p>\n<h5><span id=\"4docker-export\">4）docker export <container-id></container-id></span></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.3.4.png\" alt=\"4.2.3.4\"></p>\n<p>docker export命令创建一个tar文件，并且移除了元数据和不必要的层，将多个层整合成了一个层，只保存了当前统一视角看到的内容。</p>\n<p>附：本文在<a href=\"http://dockone.io/article/783\" target=\"_blank\" rel=\"external\">http://dockone.io/article/783</a>的基础上做整理和修改。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>docker常用命令原理图概览：</h2>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/docker%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE.jpg\" alt=\"docker命令原理图\"></p>\n<h2>（一）image layer（镜像层）</h2>\n<p>镜像可以看成是由多个镜像层叠加起来的一个文件系统，镜像层也可以简单理解为一个基本的镜像，而每个镜像层之间通过指针的形式进行叠加。</p>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/1.png\" alt=\"1\"></p>\n<p>根据上图，镜像层的主要组成部分包括镜像层id，镜像层指针【指向父层】，元数据【layer metadata】包含了docker构建和运行的信息还有父层的层次信息。</p>\n<p>只读层和读写层【top layer】的组成部分基本一致。同时读写层可以转换成只读层【docker commit操作实现】</p>\n<h2>（二）image（镜像）—【只读层的集合】</h2>\n<p>1、镜像是一堆只读层的统一视角，除了最底层没有指向外，每一层都指向它的父层，统一文件系统（union file system）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。而每一层都是不可写的，就是只读层。</p>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/2.1.png\" alt=\"2.1\"></p>\n<h2>（三）container（容器）—【一层读写层+多层只读层】</h2>\n<p>1、容器和镜像的区别在于容器的最上面一层是读写层【top layer】，而这边并没有区分容器是否在运行。运行状态的容器【running container】即一个可读写的文件系统【静态容器】+隔离的进程空间和其中的进程。</p>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/3.1.png\" alt=\"3.1\"></p>\n<p>隔离的进程空间中的进程可以对该读写层进行增删改，其运行状态容器的进程操作都作用在该读写层上。每个容器只能有一个进程隔离空间。</p>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/3.2.png\" alt=\"3.2\"></p>\n<h2>（四）docker常用命令说明</h2>\n<h3>1、标识说明</h3>\n<h4>1）image—（统一只读文件系统）</h4>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.1.1.png\" alt=\"4.1.1\"></p>\n<h4>2）静态容器【未运行的容器】—（统一可读写文件系统）</h4>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.1.2.png\" alt=\"4.1.2\"></p>\n<h4>3）动态容器【running container】—（进程空间（包括进程）+统一可读写文件系统）</h4>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.1.3.png\" alt=\"4.1.3\"></p>\n<h3>2、命令说明</h3>\n<h4>a）docker生命周期相关命令:</h4>\n<h5>1）docker create <image-id></image-id></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.1.png\" alt=\"4.2.1.1\"></p>\n<p>即为只读文件系统添加一层可读写层【top layer】，生成可读写文件系统，该命令状态下容器为静态容器，并没有运行。</p>\n<h5>2）docker start（restart） <container-id>        【docker stop即为docker start的逆过程】</container-id></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.2.png\" alt=\"4.2.1.2\"></p>\n<p>即为可读写文件系统添加一个进程空间【包括进程】，生成动态容器【running container】</p>\n<h5>3）docker run <image-id></image-id></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.3.png\" alt=\"4.2.1.3\"></p>\n<p>docker run=docker create+docker start</p>\n<p>类似流程如下 ：</p>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.3.1.png\" alt=\"4.2.1.3.1\"></p>\n<h5>4）docker stop <container-id></container-id></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.4.png\" alt=\"4.2.1.4\"></p>\n<p>向运行的容器中发一个SIGTERM的信号，然后停止所有的进程。即为docker start的逆过程。</p>\n<h5>5）docker kill <container-id></container-id></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.5.png\" alt=\"4.2.1.5\"></p>\n<p>docker kill向容器发送不友好的SIGKILL的信号，相当于快速强制关闭容器，与docker stop的区别在于docker stop是正常关闭，先发SIGTERM信号，清理进程，再发SIGKILL信号退出。</p>\n<h5>6）docker pause <container-id>    【docker unpause为逆过程】—比较少使用</container-id></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.6.png\" alt=\"4.2.1.6\"></p>\n<p>暂停容器中的所有进程，使用cgroup的freezer顺序暂停容器里的所有进程，docker unpause为逆过程即恢复所有进程。比较少使用。</p>\n<h5>7）docker commit <container-id></container-id></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.7.png\" alt=\"4.2.1.7\"></p>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.7.2.png\" alt=\"4.2.1.7.2\"></p>\n<p>把容器的可读写层转化成只读层，即从容器状态【可读写文件系统】变为镜像状态【只读文件系统】，可理解为【固化】。</p>\n<h5>8）docker build</h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.8.1.png\" alt=\"4.2.1.8.1\"></p>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.1.8.2.png\" alt=\"4.2.1.8.2\"></p>\n<p><strong>docker build=docker run【运行容器】+【进程修改数据】+docker commit【固化数据】，不断循环直至生成所需镜像。</strong></p>\n<p>循环一次便会形成新的层（镜像）【原镜像层+已固化的可读写层】</p>\n<p>docker build 一般作用在dockerfile文件上。</p>\n<h4>b）docker查询类命令：【查询对象：①image，②container，③image/container中的数据，④系统信息[容器数，镜像数及其他]】</h4>\n<h5>1.1）docker images</h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.2.1.1.png\" alt=\"4.2.2.1.1\"></p>\n<p>docker images 列出当前镜像【以顶层镜像id来表示整个完整镜像】，每个顶层镜像下面隐藏多个镜像层。</p>\n<h5>1.2）docker images -a</h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.2.1.2.png\" alt=\"4.2.2.1.2\"></p>\n<p>docker images -a列出所有镜像层【排序以每个顶层镜像id为首后接该镜像下的所有镜像层】，依次列出每个镜像的所有镜像层。</p>\n<h5>1.3）docker history <image-id></image-id></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.2.1.3.png\" alt=\"4.2.2.1.3\"></p>\n<p>docker history 列出该镜像id下的所有历史镜像。</p>\n<h5>2.1）docker ps</h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.2.2.1.png\" alt=\"4.2.2.2.1\"></p>\n<p>列出所有运行的容器【running container】</p>\n<h5>2.2）docker ps -a</h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.2.2.2.png\" alt=\"4.2.2.2.2\"></p>\n<p>列出所有容器，包括静态容器【未运行的容器】和动态容器【running container】</p>\n<h5>3.1）docker inspect <container-id> or <image-id></image-id></container-id></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.2.3.1.png\" alt=\"4.2.2.3.1\"></p>\n<p>提取出容器或镜像最顶层的元数据。</p>\n<h5>3.2）docker info</h5>\n<p>显示 Docker 系统信息，包括镜像和容器数。</p>\n<h4>c）docker操作类命令：</h4>\n<h5>1）docker rm <container-id></container-id></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.3.1.png\" alt=\"4.2.3.1\"></p>\n<p>docker rm会移除镜像，该命令只能对静态容器【非运行状态】进行操作。</p>\n<p>通过docker rm -f <container-id>的-f （force）参数可以强制删除运行状态的容器【running container】。</container-id></p>\n<h5>2）docker rmi <image-id></image-id></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.3.2.png\" alt=\"4.2.3.2\"></p>\n<h5>3）docker exec <running-container-id></running-container-id></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.3.3.png\" alt=\"4.2.3.3\"></p>\n<p>docker exec会在运行状态的容器中执行一个新的进程。</p>\n<h5>4）docker export <container-id></container-id></h5>\n<p><img src=\"/img/article/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86%E5%9B%BE/4.2.3.4.png\" alt=\"4.2.3.4\"></p>\n<p>docker export命令创建一个tar文件，并且移除了元数据和不必要的层，将多个层整合成了一个层，只保存了当前统一视角看到的内容。</p>\n<p>附：本文在<a href=\"http://dockone.io/article/783\" target=\"_blank\" rel=\"external\">http://dockone.io/article/783</a>的基础上做整理和修改。</p>\n"},{"title":"[Docker] Docker整体架构图","catalog":true,"date":"2017-07-09T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Docker"],"_content":"\n## 一、Docker的总架构图 \n\n![docker总架构图](/img/article/docker/docker整体架构图/docker总架构图.jpg)\n\ndocker是一个C/S模式的架构，后端是一个松耦合架构，模块各司其职。\n\n1. 用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。\n2. Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以接受Docker Client的请求；\n3. Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。\n4. Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；\n5. 当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；\n6. 当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。\n7. libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。\n\n## 二、Docker各模块组件分析\n\n### （一）Docker Client[发起请求]\n\n1. Docker Client是和Docker Daemon建立通信的客户端。用户使用的可执行文件为docker（类似可执行脚本的命令），docker命令后接参数的形式来实现一个完整的请求命令（例如docker images，docker为命令不可变，images为参数可变）。\n2. Docker Client可以通过以下三种方式和Docker Daemon建立通信：[tcp://host:port，unix://path_to_socket和fd://socketfd。]()\n3. Docker Client发送容器管理请求后，由Docker Daemon接受并处理请求，当Docker Client接收到返回的请求相应并简单处理后，Docker Client一次完整的生命周期就结束了。[一次完整的请求：发送请求→处理请求→返回结果]，与传统的C/S架构请求流程并无不同。\n\n### （二）Docker Daemon[后台守护进程]\n\n- Docker Daemon的架构图\n\n  ![docker daemon](/img/article/docker/docker整体架构图/docker-daemon.jpg)\n\n1. #### Docker Server[调度分发请求]\n\n   - Docker Server的架构图\n\n   ![docker server](/img/article/docker/docker整体架构图/docker-server.jpg)\n\n   1. Docker Server相当于C/S架构的服务端。功能为接受并调度分发Docker Client发送的请求。接受请求后，Server通过路由与分发调度，找到相应的Handler来执行请求。\n   2. 在Docker的启动过程中，通过包gorilla/mux，创建了一个mux.Router，提供请求的路由功能。在Golang中，gorilla/mux是一个强大的URL路由器以及调度分发器。该mux.Router中添加了众多的路由项，每一个路由项由HTTP请求方法（PUT、POST、GET或DELETE）、URL、Handler三部分组成。\n   3. 创建完mux.Router之后，Docker将Server的监听地址以及mux.Router作为参数，创建一个httpSrv=http.Server{}，最终执行httpSrv.Serve()为请求服务。\n   4. 在Server的服务过程中，Server在listener上接受Docker Client的访问请求，并创建一个全新的goroutine来服务该请求。在goroutine中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的Handler来处理该请求，最后Handler处理完请求之后回复该请求。\n\n2. #### Engine\n\n   1. Engine是Docker架构中的运行引擎，同时也Docker运行的核心模块。它扮演Docker container存储仓库的角色，并且通过执行job的方式来操纵管理这些容器。\n   2. 在Engine数据结构的设计与实现过程中，有一个handler对象。该handler对象存储的都是关于众多特定job的handler处理访问。举例说明，Engine的handler对象中有一项为：{\"create\": daemon.ContainerCreate,}，则说明当名为\"create\"的job在运行时，执行的是daemon.ContainerCreate的handler。\n\n3. #### job\n\n   1. 一个Job可以认为是Docker架构中Engine内部最基本的工作执行单元。Docker可以做的每一项工作，都可以抽象为一个job。例如：在容器内部运行一个进程，这是一个job；创建一个新的容器，这是一个job。Docker Server的运行过程也是一个job，名为serveapi。\n   2. Job的设计者，把Job设计得与Unix进程相仿。比如说：Job有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等。\n\n### （三）Docker Registry[镜像注册中心]\n\n1. Docker Registry是一个存储容器镜像的仓库（注册中心），可理解为云端镜像仓库，按repository来分类，docker pull 按照[repository]:[tag]来精确定义一个image。\n2. 在Docker的运行过程中，Docker Daemon会与Docker Registry通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的job名称分别为\"search\"，\"pull\" 与 \"push\"。\n3. 可分为公有仓库（docker hub）和私有仓库。\n\n### （四）Graph[docker内部数据库]\n\n- Graph的架构图\n\n  ![graph架构](/img/article/docker/docker整体架构图/graph架构.jpg)\n\n1. #### Repository\n\n   1. 已下载镜像的保管者（包括下载镜像和dockerfile构建的镜像）。\n   2. 一个repository表示某类镜像的仓库（例如Ubuntu），同一个repository内的镜像用tag来区分（表示同一类镜像的不同标签或版本）。一个registry包含多个repository，一个repository包含同类型的多个image。\n   3. 镜像的存储类型有aufs，devicemapper,Btrfs，Vfs等。其中centos系统使用devicemapper的存储类型。\n   4. 同时在Graph的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体rootfs。\n\n2. #### GraphDB\n\n   1. 已下载容器镜像之间关系的记录者。\n   2. GraphDB是一个构建在SQLite之上的小型图数据库，实现了节点的命名以及节点之间关联关系的记录\n\n### （五）Driver[执行部分]\n\nDriver是Docker架构中的驱动模块。通过Driver驱动，Docker可以实现对Docker容器执行环境的定制。即Graph负责镜像的存储，Driver负责容器的执行。\n\n1. #### graphdriver\n\n   - graphdriver架构图\n\n      ![graphdriver](/img/article/docker/docker整体架构图/graphdriver.jpg)\n\n   1. graphdriver主要用于完成容器镜像的管理，包括存储与获取。\n   2. 存储：docker pull下载的镜像由graphdriver存储到本地的指定目录（Graph中）。\n   3. 获取：docker run（create）用镜像来创建容器的时候由graphdriver到本地Graph中获取镜像。\n\n\n1. #### networkdriver\n\n   - networkdriver的架构图\n\n      ![networkdriver](/img/article/docker/docker整体架构图/networkdriver.jpg)\n\n   1. networkdriver的用途是完成Docker容器网络环境的配置，其中包括\n      - Docker启动时为Docker环境创建网桥；\n      - Docker容器创建时为其创建专属虚拟网卡设备；\n      - Docker容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。\n\n2. #### execdriver\n\n   - execdriver的架构图\n\n      ![execdriver](/img/article/docker/docker整体架构图/execdriver.jpg)\n\n   1. execdriver作为Docker容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。\n   2. 现在execdriver默认使用native驱动，不依赖于LXC。\n\n### （六）libcontainer[函数库]\n\n- libcontainer的架构图\n\n   ![libcontainer](/img/article/docker/docker整体架构图/libcontainer.jpg)\n\n1. libcontainer是Docker架构中一个使用Go语言设计实现的库，设计初衷是希望该库可以不依靠任何依赖，直接访问内核中与容器相关的API。\n2. Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。\n3. libcontainer提供了一整套标准的接口来满足上层对容器管理的需求。或者说，libcontainer屏蔽了Docker上层对容器的直接管理。\n\n### （七）docker container[服务交付的最终形式]\n\n- container架构\n\n  ![container](/img/article/docker/docker整体架构图/container.jpg)\n\n1. Docker container（Docker容器）是Docker架构中服务交付的最终体现形式。\n\n2. Docker按照用户的需求与指令，订制相应的Docker容器：\n\n3. - 用户通过指定容器镜像，使得Docker容器可以自定义rootfs等文件系统；\n   - 用户通过指定计算资源的配额，使得Docker容器使用指定的计算资源；\n   - 用户通过配置网络及其安全策略，使得Docker容器拥有独立且安全的网络环境；\n   - 用户通过指定运行的命令，使得Docker容器执行指定的工作。\n\n\n\n附：本文在《docker源码分析》基础上进行整理。","source":"_posts/Docker/Docker整体架构图.md","raw":"---\ntitle: \"[Docker] Docker整体架构图\"\ncatalog: true\ndate: 2017-07-09 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Docker\ncatagories:\n- Docker\n\n---\n\n## 一、Docker的总架构图 \n\n![docker总架构图](/img/article/docker/docker整体架构图/docker总架构图.jpg)\n\ndocker是一个C/S模式的架构，后端是一个松耦合架构，模块各司其职。\n\n1. 用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。\n2. Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以接受Docker Client的请求；\n3. Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。\n4. Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；\n5. 当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；\n6. 当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。\n7. libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。\n\n## 二、Docker各模块组件分析\n\n### （一）Docker Client[发起请求]\n\n1. Docker Client是和Docker Daemon建立通信的客户端。用户使用的可执行文件为docker（类似可执行脚本的命令），docker命令后接参数的形式来实现一个完整的请求命令（例如docker images，docker为命令不可变，images为参数可变）。\n2. Docker Client可以通过以下三种方式和Docker Daemon建立通信：[tcp://host:port，unix://path_to_socket和fd://socketfd。]()\n3. Docker Client发送容器管理请求后，由Docker Daemon接受并处理请求，当Docker Client接收到返回的请求相应并简单处理后，Docker Client一次完整的生命周期就结束了。[一次完整的请求：发送请求→处理请求→返回结果]，与传统的C/S架构请求流程并无不同。\n\n### （二）Docker Daemon[后台守护进程]\n\n- Docker Daemon的架构图\n\n  ![docker daemon](/img/article/docker/docker整体架构图/docker-daemon.jpg)\n\n1. #### Docker Server[调度分发请求]\n\n   - Docker Server的架构图\n\n   ![docker server](/img/article/docker/docker整体架构图/docker-server.jpg)\n\n   1. Docker Server相当于C/S架构的服务端。功能为接受并调度分发Docker Client发送的请求。接受请求后，Server通过路由与分发调度，找到相应的Handler来执行请求。\n   2. 在Docker的启动过程中，通过包gorilla/mux，创建了一个mux.Router，提供请求的路由功能。在Golang中，gorilla/mux是一个强大的URL路由器以及调度分发器。该mux.Router中添加了众多的路由项，每一个路由项由HTTP请求方法（PUT、POST、GET或DELETE）、URL、Handler三部分组成。\n   3. 创建完mux.Router之后，Docker将Server的监听地址以及mux.Router作为参数，创建一个httpSrv=http.Server{}，最终执行httpSrv.Serve()为请求服务。\n   4. 在Server的服务过程中，Server在listener上接受Docker Client的访问请求，并创建一个全新的goroutine来服务该请求。在goroutine中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的Handler来处理该请求，最后Handler处理完请求之后回复该请求。\n\n2. #### Engine\n\n   1. Engine是Docker架构中的运行引擎，同时也Docker运行的核心模块。它扮演Docker container存储仓库的角色，并且通过执行job的方式来操纵管理这些容器。\n   2. 在Engine数据结构的设计与实现过程中，有一个handler对象。该handler对象存储的都是关于众多特定job的handler处理访问。举例说明，Engine的handler对象中有一项为：{\"create\": daemon.ContainerCreate,}，则说明当名为\"create\"的job在运行时，执行的是daemon.ContainerCreate的handler。\n\n3. #### job\n\n   1. 一个Job可以认为是Docker架构中Engine内部最基本的工作执行单元。Docker可以做的每一项工作，都可以抽象为一个job。例如：在容器内部运行一个进程，这是一个job；创建一个新的容器，这是一个job。Docker Server的运行过程也是一个job，名为serveapi。\n   2. Job的设计者，把Job设计得与Unix进程相仿。比如说：Job有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等。\n\n### （三）Docker Registry[镜像注册中心]\n\n1. Docker Registry是一个存储容器镜像的仓库（注册中心），可理解为云端镜像仓库，按repository来分类，docker pull 按照[repository]:[tag]来精确定义一个image。\n2. 在Docker的运行过程中，Docker Daemon会与Docker Registry通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的job名称分别为\"search\"，\"pull\" 与 \"push\"。\n3. 可分为公有仓库（docker hub）和私有仓库。\n\n### （四）Graph[docker内部数据库]\n\n- Graph的架构图\n\n  ![graph架构](/img/article/docker/docker整体架构图/graph架构.jpg)\n\n1. #### Repository\n\n   1. 已下载镜像的保管者（包括下载镜像和dockerfile构建的镜像）。\n   2. 一个repository表示某类镜像的仓库（例如Ubuntu），同一个repository内的镜像用tag来区分（表示同一类镜像的不同标签或版本）。一个registry包含多个repository，一个repository包含同类型的多个image。\n   3. 镜像的存储类型有aufs，devicemapper,Btrfs，Vfs等。其中centos系统使用devicemapper的存储类型。\n   4. 同时在Graph的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体rootfs。\n\n2. #### GraphDB\n\n   1. 已下载容器镜像之间关系的记录者。\n   2. GraphDB是一个构建在SQLite之上的小型图数据库，实现了节点的命名以及节点之间关联关系的记录\n\n### （五）Driver[执行部分]\n\nDriver是Docker架构中的驱动模块。通过Driver驱动，Docker可以实现对Docker容器执行环境的定制。即Graph负责镜像的存储，Driver负责容器的执行。\n\n1. #### graphdriver\n\n   - graphdriver架构图\n\n      ![graphdriver](/img/article/docker/docker整体架构图/graphdriver.jpg)\n\n   1. graphdriver主要用于完成容器镜像的管理，包括存储与获取。\n   2. 存储：docker pull下载的镜像由graphdriver存储到本地的指定目录（Graph中）。\n   3. 获取：docker run（create）用镜像来创建容器的时候由graphdriver到本地Graph中获取镜像。\n\n\n1. #### networkdriver\n\n   - networkdriver的架构图\n\n      ![networkdriver](/img/article/docker/docker整体架构图/networkdriver.jpg)\n\n   1. networkdriver的用途是完成Docker容器网络环境的配置，其中包括\n      - Docker启动时为Docker环境创建网桥；\n      - Docker容器创建时为其创建专属虚拟网卡设备；\n      - Docker容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。\n\n2. #### execdriver\n\n   - execdriver的架构图\n\n      ![execdriver](/img/article/docker/docker整体架构图/execdriver.jpg)\n\n   1. execdriver作为Docker容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。\n   2. 现在execdriver默认使用native驱动，不依赖于LXC。\n\n### （六）libcontainer[函数库]\n\n- libcontainer的架构图\n\n   ![libcontainer](/img/article/docker/docker整体架构图/libcontainer.jpg)\n\n1. libcontainer是Docker架构中一个使用Go语言设计实现的库，设计初衷是希望该库可以不依靠任何依赖，直接访问内核中与容器相关的API。\n2. Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。\n3. libcontainer提供了一整套标准的接口来满足上层对容器管理的需求。或者说，libcontainer屏蔽了Docker上层对容器的直接管理。\n\n### （七）docker container[服务交付的最终形式]\n\n- container架构\n\n  ![container](/img/article/docker/docker整体架构图/container.jpg)\n\n1. Docker container（Docker容器）是Docker架构中服务交付的最终体现形式。\n\n2. Docker按照用户的需求与指令，订制相应的Docker容器：\n\n3. - 用户通过指定容器镜像，使得Docker容器可以自定义rootfs等文件系统；\n   - 用户通过指定计算资源的配额，使得Docker容器使用指定的计算资源；\n   - 用户通过配置网络及其安全策略，使得Docker容器拥有独立且安全的网络环境；\n   - 用户通过指定运行的命令，使得Docker容器执行指定的工作。\n\n\n\n附：本文在《docker源码分析》基础上进行整理。","slug":"Docker/Docker整体架构图","published":1,"updated":"2017-10-02T08:11:13.186Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740h0000830vusqvqwox2","content":"<h2><span id=\"一-docker的总架构图\">一、Docker的总架构图</span></h2>\n<p><img src=\"/img/article/docker/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/docker%E6%80%BB%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg\" alt=\"docker总架构图\"></p>\n<p>docker是一个C/S模式的架构，后端是一个松耦合架构，模块各司其职。</p>\n<ol>\n<li>用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。</li>\n<li>Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以接受Docker Client的请求；</li>\n<li>Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。</li>\n<li>Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；</li>\n<li>当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；</li>\n<li>当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。</li>\n<li>libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。</li>\n</ol>\n<h2><span id=\"二-docker各模块组件分析\">二、Docker各模块组件分析</span></h2>\n<h3><span id=\"一docker-client发起请求\">（一）Docker Client[发起请求]</span></h3>\n<ol>\n<li>Docker Client是和Docker Daemon建立通信的客户端。用户使用的可执行文件为docker（类似可执行脚本的命令），docker命令后接参数的形式来实现一个完整的请求命令（例如docker images，docker为命令不可变，images为参数可变）。</li>\n<li>Docker Client可以通过以下三种方式和Docker Daemon建立通信：<a href=\"\">tcp://host:port，unix://path_to_socket和fd://socketfd。</a></li>\n<li>Docker Client发送容器管理请求后，由Docker Daemon接受并处理请求，当Docker Client接收到返回的请求相应并简单处理后，Docker Client一次完整的生命周期就结束了。[一次完整的请求：发送请求→处理请求→返回结果]，与传统的C/S架构请求流程并无不同。</li>\n</ol>\n<h3><span id=\"二docker-daemon后台守护进程\">（二）Docker Daemon[后台守护进程]</span></h3>\n<ul>\n<li>\n<p>Docker Daemon的架构图</p>\n<p><img src=\"/img/article/docker/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/docker-daemon.jpg\" alt=\"docker daemon\"></p>\n</li>\n</ul>\n<ol>\n<li>\n<h4><span id=\"docker-server调度分发请求\">Docker Server[调度分发请求]</span></h4>\n<ul>\n<li>Docker Server的架构图</li>\n</ul>\n<p><img src=\"/img/article/docker/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/docker-server.jpg\" alt=\"docker server\"></p>\n<ol>\n<li>Docker Server相当于C/S架构的服务端。功能为接受并调度分发Docker Client发送的请求。接受请求后，Server通过路由与分发调度，找到相应的Handler来执行请求。</li>\n<li>在Docker的启动过程中，通过包gorilla/mux，创建了一个mux.Router，提供请求的路由功能。在Golang中，gorilla/mux是一个强大的URL路由器以及调度分发器。该mux.Router中添加了众多的路由项，每一个路由项由HTTP请求方法（PUT、POST、GET或DELETE）、URL、Handler三部分组成。</li>\n<li>创建完mux.Router之后，Docker将Server的监听地址以及mux.Router作为参数，创建一个httpSrv=http.Server{}，最终执行httpSrv.Serve()为请求服务。</li>\n<li>在Server的服务过程中，Server在listener上接受Docker Client的访问请求，并创建一个全新的goroutine来服务该请求。在goroutine中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的Handler来处理该请求，最后Handler处理完请求之后回复该请求。</li>\n</ol>\n</li>\n<li>\n<h4><span id=\"engine\">Engine</span></h4>\n<ol>\n<li>Engine是Docker架构中的运行引擎，同时也Docker运行的核心模块。它扮演Docker container存储仓库的角色，并且通过执行job的方式来操纵管理这些容器。</li>\n<li>在Engine数据结构的设计与实现过程中，有一个handler对象。该handler对象存储的都是关于众多特定job的handler处理访问。举例说明，Engine的handler对象中有一项为：{“create”: daemon.ContainerCreate,}，则说明当名为&quot;create&quot;的job在运行时，执行的是daemon.ContainerCreate的handler。</li>\n</ol>\n</li>\n<li>\n<h4><span id=\"job\">job</span></h4>\n<ol>\n<li>一个Job可以认为是Docker架构中Engine内部最基本的工作执行单元。Docker可以做的每一项工作，都可以抽象为一个job。例如：在容器内部运行一个进程，这是一个job；创建一个新的容器，这是一个job。Docker Server的运行过程也是一个job，名为serveapi。</li>\n<li>Job的设计者，把Job设计得与Unix进程相仿。比如说：Job有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等。</li>\n</ol>\n</li>\n</ol>\n<h3><span id=\"三docker-registry镜像注册中心\">（三）Docker Registry[镜像注册中心]</span></h3>\n<ol>\n<li>Docker Registry是一个存储容器镜像的仓库（注册中心），可理解为云端镜像仓库，按repository来分类，docker pull 按照[repository]:[tag]来精确定义一个image。</li>\n<li>在Docker的运行过程中，Docker Daemon会与Docker Registry通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的job名称分别为&quot;search&quot;，“pull” 与 “push”。</li>\n<li>可分为公有仓库（docker hub）和私有仓库。</li>\n</ol>\n<h3><span id=\"四graphdocker内部数据库\">（四）Graph[docker内部数据库]</span></h3>\n<ul>\n<li>\n<p>Graph的架构图</p>\n<p><img src=\"/img/article/docker/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/graph%E6%9E%B6%E6%9E%84.jpg\" alt=\"graph架构\"></p>\n</li>\n</ul>\n<ol>\n<li>\n<h4><span id=\"repository\">Repository</span></h4>\n<ol>\n<li>已下载镜像的保管者（包括下载镜像和dockerfile构建的镜像）。</li>\n<li>一个repository表示某类镜像的仓库（例如Ubuntu），同一个repository内的镜像用tag来区分（表示同一类镜像的不同标签或版本）。一个registry包含多个repository，一个repository包含同类型的多个image。</li>\n<li>镜像的存储类型有aufs，devicemapper,Btrfs，Vfs等。其中centos系统使用devicemapper的存储类型。</li>\n<li>同时在Graph的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体rootfs。</li>\n</ol>\n</li>\n<li>\n<h4><span id=\"graphdb\">GraphDB</span></h4>\n<ol>\n<li>已下载容器镜像之间关系的记录者。</li>\n<li>GraphDB是一个构建在SQLite之上的小型图数据库，实现了节点的命名以及节点之间关联关系的记录</li>\n</ol>\n</li>\n</ol>\n<h3><span id=\"五driver执行部分\">（五）Driver[执行部分]</span></h3>\n<p>Driver是Docker架构中的驱动模块。通过Driver驱动，Docker可以实现对Docker容器执行环境的定制。即Graph负责镜像的存储，Driver负责容器的执行。</p>\n<ol>\n<li>\n<h4><span id=\"graphdriver\">graphdriver</span></h4>\n<ul>\n<li>\n<p>graphdriver架构图</p>\n<p><img src=\"/img/article/docker/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/graphdriver.jpg\" alt=\"graphdriver\"></p>\n</li>\n</ul>\n<ol>\n<li>graphdriver主要用于完成容器镜像的管理，包括存储与获取。</li>\n<li>存储：docker pull下载的镜像由graphdriver存储到本地的指定目录（Graph中）。</li>\n<li>获取：docker run（create）用镜像来创建容器的时候由graphdriver到本地Graph中获取镜像。</li>\n</ol>\n</li>\n</ol>\n<ol>\n<li>\n<h4><span id=\"networkdriver\">networkdriver</span></h4>\n<ul>\n<li>\n<p>networkdriver的架构图</p>\n<p><img src=\"/img/article/docker/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/networkdriver.jpg\" alt=\"networkdriver\"></p>\n</li>\n</ul>\n<ol>\n<li>networkdriver的用途是完成Docker容器网络环境的配置，其中包括\n<ul>\n<li>Docker启动时为Docker环境创建网桥；</li>\n<li>Docker容器创建时为其创建专属虚拟网卡设备；</li>\n<li>Docker容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<h4><span id=\"execdriver\">execdriver</span></h4>\n<ul>\n<li>\n<p>execdriver的架构图</p>\n<p><img src=\"/img/article/docker/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/execdriver.jpg\" alt=\"execdriver\"></p>\n</li>\n</ul>\n<ol>\n<li>execdriver作为Docker容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。</li>\n<li>现在execdriver默认使用native驱动，不依赖于LXC。</li>\n</ol>\n</li>\n</ol>\n<h3><span id=\"六libcontainer函数库\">（六）libcontainer[函数库]</span></h3>\n<ul>\n<li>\n<p>libcontainer的架构图</p>\n<p><img src=\"/img/article/docker/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/libcontainer.jpg\" alt=\"libcontainer\"></p>\n</li>\n</ul>\n<ol>\n<li>libcontainer是Docker架构中一个使用Go语言设计实现的库，设计初衷是希望该库可以不依靠任何依赖，直接访问内核中与容器相关的API。</li>\n<li>Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。</li>\n<li>libcontainer提供了一整套标准的接口来满足上层对容器管理的需求。或者说，libcontainer屏蔽了Docker上层对容器的直接管理。</li>\n</ol>\n<h3><span id=\"七docker-container服务交付的最终形式\">（七）docker container[服务交付的最终形式]</span></h3>\n<ul>\n<li>\n<p>container架构</p>\n<p><img src=\"/img/article/docker/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/container.jpg\" alt=\"container\"></p>\n</li>\n</ul>\n<ol>\n<li>\n<p>Docker container（Docker容器）是Docker架构中服务交付的最终体现形式。</p>\n</li>\n<li>\n<p>Docker按照用户的需求与指令，订制相应的Docker容器：</p>\n</li>\n<li>\n<ul>\n<li>用户通过指定容器镜像，使得Docker容器可以自定义rootfs等文件系统；</li>\n<li>用户通过指定计算资源的配额，使得Docker容器使用指定的计算资源；</li>\n<li>用户通过配置网络及其安全策略，使得Docker容器拥有独立且安全的网络环境；</li>\n<li>用户通过指定运行的命令，使得Docker容器执行指定的工作。</li>\n</ul>\n</li>\n</ol>\n<p>附：本文在《docker源码分析》基础上进行整理。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>一、Docker的总架构图</h2>\n<p><img src=\"/img/article/docker/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/docker%E6%80%BB%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg\" alt=\"docker总架构图\"></p>\n<p>docker是一个C/S模式的架构，后端是一个松耦合架构，模块各司其职。</p>\n<ol>\n<li>用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。</li>\n<li>Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以接受Docker Client的请求；</li>\n<li>Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。</li>\n<li>Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；</li>\n<li>当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；</li>\n<li>当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。</li>\n<li>libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。</li>\n</ol>\n<h2>二、Docker各模块组件分析</h2>\n<h3>（一）Docker Client[发起请求]</h3>\n<ol>\n<li>Docker Client是和Docker Daemon建立通信的客户端。用户使用的可执行文件为docker（类似可执行脚本的命令），docker命令后接参数的形式来实现一个完整的请求命令（例如docker images，docker为命令不可变，images为参数可变）。</li>\n<li>Docker Client可以通过以下三种方式和Docker Daemon建立通信：<a href=\"\">tcp://host:port，unix://path_to_socket和fd://socketfd。</a></li>\n<li>Docker Client发送容器管理请求后，由Docker Daemon接受并处理请求，当Docker Client接收到返回的请求相应并简单处理后，Docker Client一次完整的生命周期就结束了。[一次完整的请求：发送请求→处理请求→返回结果]，与传统的C/S架构请求流程并无不同。</li>\n</ol>\n<h3>（二）Docker Daemon[后台守护进程]</h3>\n<ul>\n<li>\n<p>Docker Daemon的架构图</p>\n<p><img src=\"/img/article/docker/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/docker-daemon.jpg\" alt=\"docker daemon\"></p>\n</li>\n</ul>\n<ol>\n<li>\n<h4>Docker Server[调度分发请求]</h4>\n<ul>\n<li>Docker Server的架构图</li>\n</ul>\n<p><img src=\"/img/article/docker/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/docker-server.jpg\" alt=\"docker server\"></p>\n<ol>\n<li>Docker Server相当于C/S架构的服务端。功能为接受并调度分发Docker Client发送的请求。接受请求后，Server通过路由与分发调度，找到相应的Handler来执行请求。</li>\n<li>在Docker的启动过程中，通过包gorilla/mux，创建了一个mux.Router，提供请求的路由功能。在Golang中，gorilla/mux是一个强大的URL路由器以及调度分发器。该mux.Router中添加了众多的路由项，每一个路由项由HTTP请求方法（PUT、POST、GET或DELETE）、URL、Handler三部分组成。</li>\n<li>创建完mux.Router之后，Docker将Server的监听地址以及mux.Router作为参数，创建一个httpSrv=http.Server{}，最终执行httpSrv.Serve()为请求服务。</li>\n<li>在Server的服务过程中，Server在listener上接受Docker Client的访问请求，并创建一个全新的goroutine来服务该请求。在goroutine中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的Handler来处理该请求，最后Handler处理完请求之后回复该请求。</li>\n</ol>\n</li>\n<li>\n<h4>Engine</h4>\n<ol>\n<li>Engine是Docker架构中的运行引擎，同时也Docker运行的核心模块。它扮演Docker container存储仓库的角色，并且通过执行job的方式来操纵管理这些容器。</li>\n<li>在Engine数据结构的设计与实现过程中，有一个handler对象。该handler对象存储的都是关于众多特定job的handler处理访问。举例说明，Engine的handler对象中有一项为：{“create”: daemon.ContainerCreate,}，则说明当名为&quot;create&quot;的job在运行时，执行的是daemon.ContainerCreate的handler。</li>\n</ol>\n</li>\n<li>\n<h4>job</h4>\n<ol>\n<li>一个Job可以认为是Docker架构中Engine内部最基本的工作执行单元。Docker可以做的每一项工作，都可以抽象为一个job。例如：在容器内部运行一个进程，这是一个job；创建一个新的容器，这是一个job。Docker Server的运行过程也是一个job，名为serveapi。</li>\n<li>Job的设计者，把Job设计得与Unix进程相仿。比如说：Job有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等。</li>\n</ol>\n</li>\n</ol>\n<h3>（三）Docker Registry[镜像注册中心]</h3>\n<ol>\n<li>Docker Registry是一个存储容器镜像的仓库（注册中心），可理解为云端镜像仓库，按repository来分类，docker pull 按照[repository]:[tag]来精确定义一个image。</li>\n<li>在Docker的运行过程中，Docker Daemon会与Docker Registry通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的job名称分别为&quot;search&quot;，“pull” 与 “push”。</li>\n<li>可分为公有仓库（docker hub）和私有仓库。</li>\n</ol>\n<h3>（四）Graph[docker内部数据库]</h3>\n<ul>\n<li>\n<p>Graph的架构图</p>\n<p><img src=\"/img/article/docker/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/graph%E6%9E%B6%E6%9E%84.jpg\" alt=\"graph架构\"></p>\n</li>\n</ul>\n<ol>\n<li>\n<h4>Repository</h4>\n<ol>\n<li>已下载镜像的保管者（包括下载镜像和dockerfile构建的镜像）。</li>\n<li>一个repository表示某类镜像的仓库（例如Ubuntu），同一个repository内的镜像用tag来区分（表示同一类镜像的不同标签或版本）。一个registry包含多个repository，一个repository包含同类型的多个image。</li>\n<li>镜像的存储类型有aufs，devicemapper,Btrfs，Vfs等。其中centos系统使用devicemapper的存储类型。</li>\n<li>同时在Graph的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体rootfs。</li>\n</ol>\n</li>\n<li>\n<h4>GraphDB</h4>\n<ol>\n<li>已下载容器镜像之间关系的记录者。</li>\n<li>GraphDB是一个构建在SQLite之上的小型图数据库，实现了节点的命名以及节点之间关联关系的记录</li>\n</ol>\n</li>\n</ol>\n<h3>（五）Driver[执行部分]</h3>\n<p>Driver是Docker架构中的驱动模块。通过Driver驱动，Docker可以实现对Docker容器执行环境的定制。即Graph负责镜像的存储，Driver负责容器的执行。</p>\n<ol>\n<li>\n<h4>graphdriver</h4>\n<ul>\n<li>\n<p>graphdriver架构图</p>\n<p><img src=\"/img/article/docker/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/graphdriver.jpg\" alt=\"graphdriver\"></p>\n</li>\n</ul>\n<ol>\n<li>graphdriver主要用于完成容器镜像的管理，包括存储与获取。</li>\n<li>存储：docker pull下载的镜像由graphdriver存储到本地的指定目录（Graph中）。</li>\n<li>获取：docker run（create）用镜像来创建容器的时候由graphdriver到本地Graph中获取镜像。</li>\n</ol>\n</li>\n</ol>\n<ol>\n<li>\n<h4>networkdriver</h4>\n<ul>\n<li>\n<p>networkdriver的架构图</p>\n<p><img src=\"/img/article/docker/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/networkdriver.jpg\" alt=\"networkdriver\"></p>\n</li>\n</ul>\n<ol>\n<li>networkdriver的用途是完成Docker容器网络环境的配置，其中包括\n<ul>\n<li>Docker启动时为Docker环境创建网桥；</li>\n<li>Docker容器创建时为其创建专属虚拟网卡设备；</li>\n<li>Docker容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<h4>execdriver</h4>\n<ul>\n<li>\n<p>execdriver的架构图</p>\n<p><img src=\"/img/article/docker/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/execdriver.jpg\" alt=\"execdriver\"></p>\n</li>\n</ul>\n<ol>\n<li>execdriver作为Docker容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。</li>\n<li>现在execdriver默认使用native驱动，不依赖于LXC。</li>\n</ol>\n</li>\n</ol>\n<h3>（六）libcontainer[函数库]</h3>\n<ul>\n<li>\n<p>libcontainer的架构图</p>\n<p><img src=\"/img/article/docker/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/libcontainer.jpg\" alt=\"libcontainer\"></p>\n</li>\n</ul>\n<ol>\n<li>libcontainer是Docker架构中一个使用Go语言设计实现的库，设计初衷是希望该库可以不依靠任何依赖，直接访问内核中与容器相关的API。</li>\n<li>Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。</li>\n<li>libcontainer提供了一整套标准的接口来满足上层对容器管理的需求。或者说，libcontainer屏蔽了Docker上层对容器的直接管理。</li>\n</ol>\n<h3>（七）docker container[服务交付的最终形式]</h3>\n<ul>\n<li>\n<p>container架构</p>\n<p><img src=\"/img/article/docker/docker%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE/container.jpg\" alt=\"container\"></p>\n</li>\n</ul>\n<ol>\n<li>\n<p>Docker container（Docker容器）是Docker架构中服务交付的最终体现形式。</p>\n</li>\n<li>\n<p>Docker按照用户的需求与指令，订制相应的Docker容器：</p>\n</li>\n<li>\n<ul>\n<li>用户通过指定容器镜像，使得Docker容器可以自定义rootfs等文件系统；</li>\n<li>用户通过指定计算资源的配额，使得Docker容器使用指定的计算资源；</li>\n<li>用户通过配置网络及其安全策略，使得Docker容器拥有独立且安全的网络环境；</li>\n<li>用户通过指定运行的命令，使得Docker容器执行指定的工作。</li>\n</ul>\n</li>\n</ol>\n<p>附：本文在《docker源码分析》基础上进行整理。</p>\n"},{"title":"[Etcd] Etcd介绍","catalog":true,"date":"2017-07-10T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Etcd"],"_content":"\n## 一、Etcd是什么（what）\n\n### （一）概述\n\netcd is a distributed, consistent key-value store for shared configuration and service discovery, with a focus on being:\n\n- Secure: automatic TLS with optional client cert authentication[可选的SSL客户端证书认证：支持https访问 ]\n- Fast: benchmarked 10,000 writes/sec[单实例每秒 1000 次写操作]\n- Reliable: properly distributed using Raft[使用Raft保证一致性]\n\netcd是一个分布式、一致性的键值存储系统，主要用于配置共享和服务发现。[以上内容来自etcd官网]\n\n### （二）Raft协议[分布式一致性算法]\n\n![raft](/img/article/etcd/raft.png)\n\n## 二、为什么使用Etcd（why）\n\n### （一）Etcd的优势\n\n1. 简单。使用Go语言编写部署简单；使用HTTP作为接口使用简单；使用Raft算法保证强一致性让用户易于理解。\n2. 数据持久化。etcd默认数据一更新就进行持久化。\n3. 安全。etcd支持SSL客户端安全认证。\n\n## 三、如何实现Etcd架构（how）\n\n### （一）Etcd的相关名词解释\n\n- Raft：etcd所采用的保证分布式系统强一致性的算法。\n- Node：一个Raft状态机实例。\n- Member： 一个etcd实例。它管理着一个Node，并且可以为客户端请求提供服务。\n- Cluster：由多个Member构成可以协同工作的etcd集群。\n- Peer：对同一个etcd集群中另外一个Member的称呼。\n- Client： 向etcd集群发送HTTP请求的客户端。\n- WAL：预写式日志，etcd用于持久化存储的日志格式。\n- snapshot：etcd防止WAL文件过多而设置的快照，存储etcd数据状态。\n- Proxy：etcd的一种模式，为etcd集群提供反向代理服务。\n- Leader：Raft算法中通过竞选而产生的处理所有数据提交的节点。\n- Follower：竞选失败的节点作为Raft中的从属节点，为算法提供强一致性保证。\n- Candidate：当Follower超过一定时间接收不到Leader的心跳时转变为Candidate开始竞选。【候选人】\n- Term：某个节点成为Leader到下一次竞选时间，称为一个Term。【任期】\n- Index：数据项编号。Raft中通过Term和Index来定位数据。\n\n### （二）Etcd的架构图\n\n![etcd的架构图](/img/article/etcd/etcd的架构图.jpg)\n\n一个用户的请求发送过来，会经由HTTP Server转发给Store进行具体的事务处理，如果涉及到节点的修改，则交给Raft模块进行状态的变更、日志的记录，然后再同步给别的etcd节点以确认数据提交，最后进行数据的提交，再次同步。\n\n#### 1、HTTP Server:\n\n用于处理用户发送的API请求以及其它etcd节点的同步与心跳信息请求。\n\n#### 2、Raft:\n\nRaft强一致性算法的具体实现，是etcd的核心。\n\n#### 3、WAL:\n\nWrite Ahead Log（预写式日志），是etcd的数据存储方式，用于系统提供原子性和持久性的一系列技术。除了在内存中存有所有数据的状态以及节点的索引以外，etcd就通过WAL进行持久化存储。WAL中，所有的数据提交前都会事先记录日志。\n\n1. Entry[日志内容]:\n\n   负责存储具体日志的内容。\n\n2. Snapshot[快照内容]:\n\n   Snapshot是为了防止数据过多而进行的状态快照，日志内容发生变化时保存Raft的状态。\n\n#### 4、Store:\n\n用于处理etcd支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、事件处理与执行等等，是etcd对用户提供的大多数API功能的具体实现。","source":"_posts/Etcd/Etcd介绍.md","raw":"---\ntitle: \"[Etcd] Etcd介绍\"\ncatalog: true\ndate: 2017-07-10 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Etcd\ncatagories:\n- Etcd\n---\n\n## 一、Etcd是什么（what）\n\n### （一）概述\n\netcd is a distributed, consistent key-value store for shared configuration and service discovery, with a focus on being:\n\n- Secure: automatic TLS with optional client cert authentication[可选的SSL客户端证书认证：支持https访问 ]\n- Fast: benchmarked 10,000 writes/sec[单实例每秒 1000 次写操作]\n- Reliable: properly distributed using Raft[使用Raft保证一致性]\n\netcd是一个分布式、一致性的键值存储系统，主要用于配置共享和服务发现。[以上内容来自etcd官网]\n\n### （二）Raft协议[分布式一致性算法]\n\n![raft](/img/article/etcd/raft.png)\n\n## 二、为什么使用Etcd（why）\n\n### （一）Etcd的优势\n\n1. 简单。使用Go语言编写部署简单；使用HTTP作为接口使用简单；使用Raft算法保证强一致性让用户易于理解。\n2. 数据持久化。etcd默认数据一更新就进行持久化。\n3. 安全。etcd支持SSL客户端安全认证。\n\n## 三、如何实现Etcd架构（how）\n\n### （一）Etcd的相关名词解释\n\n- Raft：etcd所采用的保证分布式系统强一致性的算法。\n- Node：一个Raft状态机实例。\n- Member： 一个etcd实例。它管理着一个Node，并且可以为客户端请求提供服务。\n- Cluster：由多个Member构成可以协同工作的etcd集群。\n- Peer：对同一个etcd集群中另外一个Member的称呼。\n- Client： 向etcd集群发送HTTP请求的客户端。\n- WAL：预写式日志，etcd用于持久化存储的日志格式。\n- snapshot：etcd防止WAL文件过多而设置的快照，存储etcd数据状态。\n- Proxy：etcd的一种模式，为etcd集群提供反向代理服务。\n- Leader：Raft算法中通过竞选而产生的处理所有数据提交的节点。\n- Follower：竞选失败的节点作为Raft中的从属节点，为算法提供强一致性保证。\n- Candidate：当Follower超过一定时间接收不到Leader的心跳时转变为Candidate开始竞选。【候选人】\n- Term：某个节点成为Leader到下一次竞选时间，称为一个Term。【任期】\n- Index：数据项编号。Raft中通过Term和Index来定位数据。\n\n### （二）Etcd的架构图\n\n![etcd的架构图](/img/article/etcd/etcd的架构图.jpg)\n\n一个用户的请求发送过来，会经由HTTP Server转发给Store进行具体的事务处理，如果涉及到节点的修改，则交给Raft模块进行状态的变更、日志的记录，然后再同步给别的etcd节点以确认数据提交，最后进行数据的提交，再次同步。\n\n#### 1、HTTP Server:\n\n用于处理用户发送的API请求以及其它etcd节点的同步与心跳信息请求。\n\n#### 2、Raft:\n\nRaft强一致性算法的具体实现，是etcd的核心。\n\n#### 3、WAL:\n\nWrite Ahead Log（预写式日志），是etcd的数据存储方式，用于系统提供原子性和持久性的一系列技术。除了在内存中存有所有数据的状态以及节点的索引以外，etcd就通过WAL进行持久化存储。WAL中，所有的数据提交前都会事先记录日志。\n\n1. Entry[日志内容]:\n\n   负责存储具体日志的内容。\n\n2. Snapshot[快照内容]:\n\n   Snapshot是为了防止数据过多而进行的状态快照，日志内容发生变化时保存Raft的状态。\n\n#### 4、Store:\n\n用于处理etcd支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、事件处理与执行等等，是etcd对用户提供的大多数API功能的具体实现。","slug":"Etcd/Etcd介绍","published":1,"updated":"2017-10-02T09:12:43.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740h3000930vuzfopey4s","content":"<h2><span id=\"一-etcd是什么what\">一、Etcd是什么（what）</span></h2>\n<h3><span id=\"一概述\">（一）概述</span></h3>\n<p>etcd is a distributed, consistent key-value store for shared configuration and service discovery, with a focus on being:</p>\n<ul>\n<li>Secure: automatic TLS with optional client cert authentication[可选的SSL客户端证书认证：支持https访问 ]</li>\n<li>Fast: benchmarked 10,000 writes/sec[单实例每秒 1000 次写操作]</li>\n<li>Reliable: properly distributed using Raft[使用Raft保证一致性]</li>\n</ul>\n<p>etcd是一个分布式、一致性的键值存储系统，主要用于配置共享和服务发现。[以上内容来自etcd官网]</p>\n<h3><span id=\"二raft协议分布式一致性算法\">（二）Raft协议[分布式一致性算法]</span></h3>\n<p><img src=\"/img/article/etcd/raft.png\" alt=\"raft\"></p>\n<h2><span id=\"二-为什么使用etcdwhy\">二、为什么使用Etcd（why）</span></h2>\n<h3><span id=\"一etcd的优势\">（一）Etcd的优势</span></h3>\n<ol>\n<li>简单。使用Go语言编写部署简单；使用HTTP作为接口使用简单；使用Raft算法保证强一致性让用户易于理解。</li>\n<li>数据持久化。etcd默认数据一更新就进行持久化。</li>\n<li>安全。etcd支持SSL客户端安全认证。</li>\n</ol>\n<h2><span id=\"三-如何实现etcd架构how\">三、如何实现Etcd架构（how）</span></h2>\n<h3><span id=\"一etcd的相关名词解释\">（一）Etcd的相关名词解释</span></h3>\n<ul>\n<li>Raft：etcd所采用的保证分布式系统强一致性的算法。</li>\n<li>Node：一个Raft状态机实例。</li>\n<li>Member： 一个etcd实例。它管理着一个Node，并且可以为客户端请求提供服务。</li>\n<li>Cluster：由多个Member构成可以协同工作的etcd集群。</li>\n<li>Peer：对同一个etcd集群中另外一个Member的称呼。</li>\n<li>Client： 向etcd集群发送HTTP请求的客户端。</li>\n<li>WAL：预写式日志，etcd用于持久化存储的日志格式。</li>\n<li>snapshot：etcd防止WAL文件过多而设置的快照，存储etcd数据状态。</li>\n<li>Proxy：etcd的一种模式，为etcd集群提供反向代理服务。</li>\n<li>Leader：Raft算法中通过竞选而产生的处理所有数据提交的节点。</li>\n<li>Follower：竞选失败的节点作为Raft中的从属节点，为算法提供强一致性保证。</li>\n<li>Candidate：当Follower超过一定时间接收不到Leader的心跳时转变为Candidate开始竞选。【候选人】</li>\n<li>Term：某个节点成为Leader到下一次竞选时间，称为一个Term。【任期】</li>\n<li>Index：数据项编号。Raft中通过Term和Index来定位数据。</li>\n</ul>\n<h3><span id=\"二etcd的架构图\">（二）Etcd的架构图</span></h3>\n<p><img src=\"/img/article/etcd/etcd%E7%9A%84%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg\" alt=\"etcd的架构图\"></p>\n<p>一个用户的请求发送过来，会经由HTTP Server转发给Store进行具体的事务处理，如果涉及到节点的修改，则交给Raft模块进行状态的变更、日志的记录，然后再同步给别的etcd节点以确认数据提交，最后进行数据的提交，再次同步。</p>\n<h4><span id=\"1-http-server\">1、HTTP Server:</span></h4>\n<p>用于处理用户发送的API请求以及其它etcd节点的同步与心跳信息请求。</p>\n<h4><span id=\"2-raft\">2、Raft:</span></h4>\n<p>Raft强一致性算法的具体实现，是etcd的核心。</p>\n<h4><span id=\"3-wal\">3、WAL:</span></h4>\n<p>Write Ahead Log（预写式日志），是etcd的数据存储方式，用于系统提供原子性和持久性的一系列技术。除了在内存中存有所有数据的状态以及节点的索引以外，etcd就通过WAL进行持久化存储。WAL中，所有的数据提交前都会事先记录日志。</p>\n<ol>\n<li>\n<p>Entry[日志内容]:</p>\n<p>负责存储具体日志的内容。</p>\n</li>\n<li>\n<p>Snapshot[快照内容]:</p>\n<p>Snapshot是为了防止数据过多而进行的状态快照，日志内容发生变化时保存Raft的状态。</p>\n</li>\n</ol>\n<h4><span id=\"4-store\">4、Store:</span></h4>\n<p>用于处理etcd支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、事件处理与执行等等，是etcd对用户提供的大多数API功能的具体实现。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>一、Etcd是什么（what）</h2>\n<h3>（一）概述</h3>\n<p>etcd is a distributed, consistent key-value store for shared configuration and service discovery, with a focus on being:</p>\n<ul>\n<li>Secure: automatic TLS with optional client cert authentication[可选的SSL客户端证书认证：支持https访问 ]</li>\n<li>Fast: benchmarked 10,000 writes/sec[单实例每秒 1000 次写操作]</li>\n<li>Reliable: properly distributed using Raft[使用Raft保证一致性]</li>\n</ul>\n<p>etcd是一个分布式、一致性的键值存储系统，主要用于配置共享和服务发现。[以上内容来自etcd官网]</p>\n<h3>（二）Raft协议[分布式一致性算法]</h3>\n<p><img src=\"/img/article/etcd/raft.png\" alt=\"raft\"></p>\n<h2>二、为什么使用Etcd（why）</h2>\n<h3>（一）Etcd的优势</h3>\n<ol>\n<li>简单。使用Go语言编写部署简单；使用HTTP作为接口使用简单；使用Raft算法保证强一致性让用户易于理解。</li>\n<li>数据持久化。etcd默认数据一更新就进行持久化。</li>\n<li>安全。etcd支持SSL客户端安全认证。</li>\n</ol>\n<h2>三、如何实现Etcd架构（how）</h2>\n<h3>（一）Etcd的相关名词解释</h3>\n<ul>\n<li>Raft：etcd所采用的保证分布式系统强一致性的算法。</li>\n<li>Node：一个Raft状态机实例。</li>\n<li>Member： 一个etcd实例。它管理着一个Node，并且可以为客户端请求提供服务。</li>\n<li>Cluster：由多个Member构成可以协同工作的etcd集群。</li>\n<li>Peer：对同一个etcd集群中另外一个Member的称呼。</li>\n<li>Client： 向etcd集群发送HTTP请求的客户端。</li>\n<li>WAL：预写式日志，etcd用于持久化存储的日志格式。</li>\n<li>snapshot：etcd防止WAL文件过多而设置的快照，存储etcd数据状态。</li>\n<li>Proxy：etcd的一种模式，为etcd集群提供反向代理服务。</li>\n<li>Leader：Raft算法中通过竞选而产生的处理所有数据提交的节点。</li>\n<li>Follower：竞选失败的节点作为Raft中的从属节点，为算法提供强一致性保证。</li>\n<li>Candidate：当Follower超过一定时间接收不到Leader的心跳时转变为Candidate开始竞选。【候选人】</li>\n<li>Term：某个节点成为Leader到下一次竞选时间，称为一个Term。【任期】</li>\n<li>Index：数据项编号。Raft中通过Term和Index来定位数据。</li>\n</ul>\n<h3>（二）Etcd的架构图</h3>\n<p><img src=\"/img/article/etcd/etcd%E7%9A%84%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg\" alt=\"etcd的架构图\"></p>\n<p>一个用户的请求发送过来，会经由HTTP Server转发给Store进行具体的事务处理，如果涉及到节点的修改，则交给Raft模块进行状态的变更、日志的记录，然后再同步给别的etcd节点以确认数据提交，最后进行数据的提交，再次同步。</p>\n<h4>1、HTTP Server:</h4>\n<p>用于处理用户发送的API请求以及其它etcd节点的同步与心跳信息请求。</p>\n<h4>2、Raft:</h4>\n<p>Raft强一致性算法的具体实现，是etcd的核心。</p>\n<h4>3、WAL:</h4>\n<p>Write Ahead Log（预写式日志），是etcd的数据存储方式，用于系统提供原子性和持久性的一系列技术。除了在内存中存有所有数据的状态以及节点的索引以外，etcd就通过WAL进行持久化存储。WAL中，所有的数据提交前都会事先记录日志。</p>\n<ol>\n<li>\n<p>Entry[日志内容]:</p>\n<p>负责存储具体日志的内容。</p>\n</li>\n<li>\n<p>Snapshot[快照内容]:</p>\n<p>Snapshot是为了防止数据过多而进行的状态快照，日志内容发生变化时保存Raft的状态。</p>\n</li>\n</ol>\n<h4>4、Store:</h4>\n<p>用于处理etcd支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、事件处理与执行等等，是etcd对用户提供的大多数API功能的具体实现。</p>\n"},{"title":"[Etcd] Etcd常用命令","catalog":true,"date":"2017-07-10T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Etcd"],"_content":"\n## 一、etcdctl介绍\n\netcdctl是一个命令行的客户端，它提供了一下简洁的命令，可理解为命令工具集，可以方便我们在对服务进行测试或者手动修改数据库内容。etcdctl与其他xxxctl的命令原理及操作类似（例如kubectl，systemctl）。\n\n用法：etcdctl [global options] command [command options][args...]\n\n## 二、Etcd常用命令\n\n### （一）数据库操作命令\n\netcd 在键的组织上采用了层次化的空间结构（类似于文件系统中目录的概念），数据库操作围绕对键值和目录的 CRUD [增删改查]（符合 REST 风格的一套操作：Create, Read, Update, Delete）完整生命周期的管理。\n\n具体的命令选项参数可以通过 etcdctl command --help来获取相关帮助。\n\n#### 1）对象为键值\n\n1. ##### set[增:无论是否存在]:etcdctl set key value\n\n2. ##### mk[增:必须不存在]:etcdctl mk key value\n\n3. ##### rm[删]:etcdctl rm key\n\n4. ##### update[改]:etcdctl update key value\n\n5. ##### get[查]:etcdctl get key\n\n#### 2）对象为目录\n\n1. ##### setdir[增:无论是否存在]:etcdctl setdir dir\n\n2. ##### mkdir[增:必须不存在]: etcdctl mkdir dir\n\n3. ##### rmdir[删]:etcdctl rmdir dir\n\n4. ##### updatedir[改]:etcdctl updatedir dir\n\n5. ##### ls[查]:etcdclt ls\n\n### （二）非数据库操作命令\n\n1. ##### backup[备份 etcd 的数据]\n\n   etcdctl backup\n\n2. ##### watch[监测一个键值的变化，一旦键值发生更新，就会输出最新的值并退出]\n\n   etcdctl watch key\n\n3. ##### exec-watch[监测一个键值的变化，一旦键值发生更新，就执行给定命令]\n\n   etcdctl exec-watch key --sh -c \"ls\"\n\n4. ##### member[通过 list、add、remove、update 命令列出、添加、删除 、更新etcd 实例到 etcd 集群中]\n\n   etcdctl member list；etcdctl member add 实例；etcdctl member remove 实例；etcdctl member update 实例。\n\n5. ##### etcdctl cluster-health[检查集群健康状态]\n\n### （三）常用配置参数\n\n设置配置文件，默认为/etc/etcd/etcd.conf。\n\n| 配置参数                         | 参数说明                                     |\n| ---------------------------- | ---------------------------------------- |\n| 配置参数                         | 参数说明                                     |\n| -name                        | 节点名称                                     |\n| -data-dir                    | 保存日志和快照的目录，默认为当前工作目录，指定节点的数据存储目录         |\n| -addr                        | 公布的ip地址和端口。 默认为127.0.0.1:2379            |\n| -bind-addr                   | 用于客户端连接的监听地址，默认为-addr配置                  |\n| -peers                       | 集群成员逗号分隔的列表，例如 127.0.0.1:2380,127.0.0.1:2381 |\n| -peer-addr                   | 集群服务通讯的公布的IP地址，默认为 127.0.0.1:2380.       |\n| -peer-bind-addr              | 集群服务通讯的监听地址，默认为-peer-addr配置              |\n| -wal-dir                     | 指定节点的was文件的存储目录，若指定了该参数，wal文件会和其他数据文件分开存储 |\n| -listen-client-urls          |                                          |\n| -listen-peer-urls            | 监听URL，用于与其他节点通讯                          |\n| -initial-advertise-peer-urls | 告知集群其他节点url.                             |\n| -advertise-client-urls       | 告知客户端url, 也就是服务的url                      |\n| -initial-cluster-token       | 集群的ID                                    |\n| -initial-cluster             | 集群中所有节点                                  |\n| -initial-cluster-state       | -initial-cluster-state=new 表示从无到有搭建etcd集群 |\n| -discovery-srv               | 用于DNS动态服务发现，指定DNS SRV域名                  |\n| -discovery                   | 用于etcd动态发现，指定etcd发现服务的URL [https://discovery.etcd.io/],用环境变量表示 |\n\n ","source":"_posts/Etcd/Etcd常用命令.md","raw":"---\ntitle: \"[Etcd] Etcd常用命令\"\ncatalog: true\ndate: 2017-07-10 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Etcd\ncatagories:\n- Etcd\n---\n\n## 一、etcdctl介绍\n\netcdctl是一个命令行的客户端，它提供了一下简洁的命令，可理解为命令工具集，可以方便我们在对服务进行测试或者手动修改数据库内容。etcdctl与其他xxxctl的命令原理及操作类似（例如kubectl，systemctl）。\n\n用法：etcdctl [global options] command [command options][args...]\n\n## 二、Etcd常用命令\n\n### （一）数据库操作命令\n\netcd 在键的组织上采用了层次化的空间结构（类似于文件系统中目录的概念），数据库操作围绕对键值和目录的 CRUD [增删改查]（符合 REST 风格的一套操作：Create, Read, Update, Delete）完整生命周期的管理。\n\n具体的命令选项参数可以通过 etcdctl command --help来获取相关帮助。\n\n#### 1）对象为键值\n\n1. ##### set[增:无论是否存在]:etcdctl set key value\n\n2. ##### mk[增:必须不存在]:etcdctl mk key value\n\n3. ##### rm[删]:etcdctl rm key\n\n4. ##### update[改]:etcdctl update key value\n\n5. ##### get[查]:etcdctl get key\n\n#### 2）对象为目录\n\n1. ##### setdir[增:无论是否存在]:etcdctl setdir dir\n\n2. ##### mkdir[增:必须不存在]: etcdctl mkdir dir\n\n3. ##### rmdir[删]:etcdctl rmdir dir\n\n4. ##### updatedir[改]:etcdctl updatedir dir\n\n5. ##### ls[查]:etcdclt ls\n\n### （二）非数据库操作命令\n\n1. ##### backup[备份 etcd 的数据]\n\n   etcdctl backup\n\n2. ##### watch[监测一个键值的变化，一旦键值发生更新，就会输出最新的值并退出]\n\n   etcdctl watch key\n\n3. ##### exec-watch[监测一个键值的变化，一旦键值发生更新，就执行给定命令]\n\n   etcdctl exec-watch key --sh -c \"ls\"\n\n4. ##### member[通过 list、add、remove、update 命令列出、添加、删除 、更新etcd 实例到 etcd 集群中]\n\n   etcdctl member list；etcdctl member add 实例；etcdctl member remove 实例；etcdctl member update 实例。\n\n5. ##### etcdctl cluster-health[检查集群健康状态]\n\n### （三）常用配置参数\n\n设置配置文件，默认为/etc/etcd/etcd.conf。\n\n| 配置参数                         | 参数说明                                     |\n| ---------------------------- | ---------------------------------------- |\n| 配置参数                         | 参数说明                                     |\n| -name                        | 节点名称                                     |\n| -data-dir                    | 保存日志和快照的目录，默认为当前工作目录，指定节点的数据存储目录         |\n| -addr                        | 公布的ip地址和端口。 默认为127.0.0.1:2379            |\n| -bind-addr                   | 用于客户端连接的监听地址，默认为-addr配置                  |\n| -peers                       | 集群成员逗号分隔的列表，例如 127.0.0.1:2380,127.0.0.1:2381 |\n| -peer-addr                   | 集群服务通讯的公布的IP地址，默认为 127.0.0.1:2380.       |\n| -peer-bind-addr              | 集群服务通讯的监听地址，默认为-peer-addr配置              |\n| -wal-dir                     | 指定节点的was文件的存储目录，若指定了该参数，wal文件会和其他数据文件分开存储 |\n| -listen-client-urls          |                                          |\n| -listen-peer-urls            | 监听URL，用于与其他节点通讯                          |\n| -initial-advertise-peer-urls | 告知集群其他节点url.                             |\n| -advertise-client-urls       | 告知客户端url, 也就是服务的url                      |\n| -initial-cluster-token       | 集群的ID                                    |\n| -initial-cluster             | 集群中所有节点                                  |\n| -initial-cluster-state       | -initial-cluster-state=new 表示从无到有搭建etcd集群 |\n| -discovery-srv               | 用于DNS动态服务发现，指定DNS SRV域名                  |\n| -discovery                   | 用于etcd动态发现，指定etcd发现服务的URL [https://discovery.etcd.io/],用环境变量表示 |\n\n ","slug":"Etcd/Etcd常用命令","published":1,"updated":"2017-10-02T09:09:57.515Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740h5000a30vurgsoxmtp","content":"<h2><span id=\"一-etcdctl介绍\">一、etcdctl介绍</span></h2>\n<p>etcdctl是一个命令行的客户端，它提供了一下简洁的命令，可理解为命令工具集，可以方便我们在对服务进行测试或者手动修改数据库内容。etcdctl与其他xxxctl的命令原理及操作类似（例如kubectl，systemctl）。</p>\n<p>用法：etcdctl [global options] command [command options][args…]</p>\n<h2><span id=\"二-etcd常用命令\">二、Etcd常用命令</span></h2>\n<h3><span id=\"一数据库操作命令\">（一）数据库操作命令</span></h3>\n<p>etcd 在键的组织上采用了层次化的空间结构（类似于文件系统中目录的概念），数据库操作围绕对键值和目录的 CRUD [增删改查]（符合 REST 风格的一套操作：Create, Read, Update, Delete）完整生命周期的管理。</p>\n<p>具体的命令选项参数可以通过 etcdctl command --help来获取相关帮助。</p>\n<h4><span id=\"1对象为键值\">1）对象为键值</span></h4>\n<ol>\n<li>\n<h5><span id=\"set增无论是否存在etcdctl-set-key-value\">set[增:无论是否存在]:etcdctl set key value</span></h5>\n</li>\n<li>\n<h5><span id=\"mk增必须不存在etcdctl-mk-key-value\">mk[增:必须不存在]:etcdctl mk key value</span></h5>\n</li>\n<li>\n<h5><span id=\"rm删etcdctl-rm-key\">rm[删]:etcdctl rm key</span></h5>\n</li>\n<li>\n<h5><span id=\"update改etcdctl-update-key-value\">update[改]:etcdctl update key value</span></h5>\n</li>\n<li>\n<h5><span id=\"get查etcdctl-get-key\">get[查]:etcdctl get key</span></h5>\n</li>\n</ol>\n<h4><span id=\"2对象为目录\">2）对象为目录</span></h4>\n<ol>\n<li>\n<h5><span id=\"setdir增无论是否存在etcdctl-setdir-dir\">setdir[增:无论是否存在]:etcdctl setdir dir</span></h5>\n</li>\n<li>\n<h5><span id=\"mkdir增必须不存在-etcdctl-mkdir-dir\">mkdir[增:必须不存在]: etcdctl mkdir dir</span></h5>\n</li>\n<li>\n<h5><span id=\"rmdir删etcdctl-rmdir-dir\">rmdir[删]:etcdctl rmdir dir</span></h5>\n</li>\n<li>\n<h5><span id=\"updatedir改etcdctl-updatedir-dir\">updatedir[改]:etcdctl updatedir dir</span></h5>\n</li>\n<li>\n<h5><span id=\"ls查etcdclt-ls\">ls[查]:etcdclt ls</span></h5>\n</li>\n</ol>\n<h3><span id=\"二非数据库操作命令\">（二）非数据库操作命令</span></h3>\n<ol>\n<li>\n<h5><span id=\"backup备份-etcd-的数据\">backup[备份 etcd 的数据]</span></h5>\n<p>etcdctl backup</p>\n</li>\n<li>\n<h5><span id=\"watch监测一个键值的变化一旦键值发生更新就会输出最新的值并退出\">watch[监测一个键值的变化，一旦键值发生更新，就会输出最新的值并退出]</span></h5>\n<p>etcdctl watch key</p>\n</li>\n<li>\n<h5><span id=\"exec-watch监测一个键值的变化一旦键值发生更新就执行给定命令\">exec-watch[监测一个键值的变化，一旦键值发生更新，就执行给定命令]</span></h5>\n<p>etcdctl exec-watch key --sh -c “ls”</p>\n</li>\n<li>\n<h5><span id=\"member通过-list-add-remove-update-命令列出-添加-删除-更新etcd-实例到-etcd-集群中\">member[通过 list、add、remove、update 命令列出、添加、删除 、更新etcd 实例到 etcd 集群中]</span></h5>\n<p>etcdctl member list；etcdctl member add 实例；etcdctl member remove 实例；etcdctl member update 实例。</p>\n</li>\n<li>\n<h5><span id=\"etcdctl-cluster-health检查集群健康状态\">etcdctl cluster-health[检查集群健康状态]</span></h5>\n</li>\n</ol>\n<h3><span id=\"三常用配置参数\">（三）常用配置参数</span></h3>\n<p>设置配置文件，默认为/etc/etcd/etcd.conf。</p>\n<table>\n<thead>\n<tr>\n<th>配置参数</th>\n<th>参数说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>配置参数</td>\n<td>参数说明</td>\n</tr>\n<tr>\n<td>-name</td>\n<td>节点名称</td>\n</tr>\n<tr>\n<td>-data-dir</td>\n<td>保存日志和快照的目录，默认为当前工作目录，指定节点的数据存储目录</td>\n</tr>\n<tr>\n<td>-addr</td>\n<td>公布的ip地址和端口。 默认为127.0.0.1:2379</td>\n</tr>\n<tr>\n<td>-bind-addr</td>\n<td>用于客户端连接的监听地址，默认为-addr配置</td>\n</tr>\n<tr>\n<td>-peers</td>\n<td>集群成员逗号分隔的列表，例如 127.0.0.1:2380,127.0.0.1:2381</td>\n</tr>\n<tr>\n<td>-peer-addr</td>\n<td>集群服务通讯的公布的IP地址，默认为 127.0.0.1:2380.</td>\n</tr>\n<tr>\n<td>-peer-bind-addr</td>\n<td>集群服务通讯的监听地址，默认为-peer-addr配置</td>\n</tr>\n<tr>\n<td>-wal-dir</td>\n<td>指定节点的was文件的存储目录，若指定了该参数，wal文件会和其他数据文件分开存储</td>\n</tr>\n<tr>\n<td>-listen-client-urls</td>\n<td></td>\n</tr>\n<tr>\n<td>-listen-peer-urls</td>\n<td>监听URL，用于与其他节点通讯</td>\n</tr>\n<tr>\n<td>-initial-advertise-peer-urls</td>\n<td>告知集群其他节点url.</td>\n</tr>\n<tr>\n<td>-advertise-client-urls</td>\n<td>告知客户端url, 也就是服务的url</td>\n</tr>\n<tr>\n<td>-initial-cluster-token</td>\n<td>集群的ID</td>\n</tr>\n<tr>\n<td>-initial-cluster</td>\n<td>集群中所有节点</td>\n</tr>\n<tr>\n<td>-initial-cluster-state</td>\n<td>-initial-cluster-state=new 表示从无到有搭建etcd集群</td>\n</tr>\n<tr>\n<td>-discovery-srv</td>\n<td>用于DNS动态服务发现，指定DNS SRV域名</td>\n</tr>\n<tr>\n<td>-discovery</td>\n<td>用于etcd动态发现，指定etcd发现服务的URL [<a href=\"https://discovery.etcd.io/\" target=\"_blank\" rel=\"external\">https://discovery.etcd.io/</a>],用环境变量表示</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h2>一、etcdctl介绍</h2>\n<p>etcdctl是一个命令行的客户端，它提供了一下简洁的命令，可理解为命令工具集，可以方便我们在对服务进行测试或者手动修改数据库内容。etcdctl与其他xxxctl的命令原理及操作类似（例如kubectl，systemctl）。</p>\n<p>用法：etcdctl [global options] command [command options][args…]</p>\n<h2>二、Etcd常用命令</h2>\n<h3>（一）数据库操作命令</h3>\n<p>etcd 在键的组织上采用了层次化的空间结构（类似于文件系统中目录的概念），数据库操作围绕对键值和目录的 CRUD [增删改查]（符合 REST 风格的一套操作：Create, Read, Update, Delete）完整生命周期的管理。</p>\n<p>具体的命令选项参数可以通过 etcdctl command --help来获取相关帮助。</p>\n<h4>1）对象为键值</h4>\n<ol>\n<li>\n<h5>set[增:无论是否存在]:etcdctl set key value</h5>\n</li>\n<li>\n<h5>mk[增:必须不存在]:etcdctl mk key value</h5>\n</li>\n<li>\n<h5>rm[删]:etcdctl rm key</h5>\n</li>\n<li>\n<h5>update[改]:etcdctl update key value</h5>\n</li>\n<li>\n<h5>get[查]:etcdctl get key</h5>\n</li>\n</ol>\n<h4>2）对象为目录</h4>\n<ol>\n<li>\n<h5>setdir[增:无论是否存在]:etcdctl setdir dir</h5>\n</li>\n<li>\n<h5>mkdir[增:必须不存在]: etcdctl mkdir dir</h5>\n</li>\n<li>\n<h5>rmdir[删]:etcdctl rmdir dir</h5>\n</li>\n<li>\n<h5>updatedir[改]:etcdctl updatedir dir</h5>\n</li>\n<li>\n<h5>ls[查]:etcdclt ls</h5>\n</li>\n</ol>\n<h3>（二）非数据库操作命令</h3>\n<ol>\n<li>\n<h5>backup[备份 etcd 的数据]</h5>\n<p>etcdctl backup</p>\n</li>\n<li>\n<h5>watch[监测一个键值的变化，一旦键值发生更新，就会输出最新的值并退出]</h5>\n<p>etcdctl watch key</p>\n</li>\n<li>\n<h5>exec-watch[监测一个键值的变化，一旦键值发生更新，就执行给定命令]</h5>\n<p>etcdctl exec-watch key --sh -c “ls”</p>\n</li>\n<li>\n<h5>member[通过 list、add、remove、update 命令列出、添加、删除 、更新etcd 实例到 etcd 集群中]</h5>\n<p>etcdctl member list；etcdctl member add 实例；etcdctl member remove 实例；etcdctl member update 实例。</p>\n</li>\n<li>\n<h5>etcdctl cluster-health[检查集群健康状态]</h5>\n</li>\n</ol>\n<h3>（三）常用配置参数</h3>\n<p>设置配置文件，默认为/etc/etcd/etcd.conf。</p>\n<table>\n<thead>\n<tr>\n<th>配置参数</th>\n<th>参数说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>配置参数</td>\n<td>参数说明</td>\n</tr>\n<tr>\n<td>-name</td>\n<td>节点名称</td>\n</tr>\n<tr>\n<td>-data-dir</td>\n<td>保存日志和快照的目录，默认为当前工作目录，指定节点的数据存储目录</td>\n</tr>\n<tr>\n<td>-addr</td>\n<td>公布的ip地址和端口。 默认为127.0.0.1:2379</td>\n</tr>\n<tr>\n<td>-bind-addr</td>\n<td>用于客户端连接的监听地址，默认为-addr配置</td>\n</tr>\n<tr>\n<td>-peers</td>\n<td>集群成员逗号分隔的列表，例如 127.0.0.1:2380,127.0.0.1:2381</td>\n</tr>\n<tr>\n<td>-peer-addr</td>\n<td>集群服务通讯的公布的IP地址，默认为 127.0.0.1:2380.</td>\n</tr>\n<tr>\n<td>-peer-bind-addr</td>\n<td>集群服务通讯的监听地址，默认为-peer-addr配置</td>\n</tr>\n<tr>\n<td>-wal-dir</td>\n<td>指定节点的was文件的存储目录，若指定了该参数，wal文件会和其他数据文件分开存储</td>\n</tr>\n<tr>\n<td>-listen-client-urls</td>\n<td></td>\n</tr>\n<tr>\n<td>-listen-peer-urls</td>\n<td>监听URL，用于与其他节点通讯</td>\n</tr>\n<tr>\n<td>-initial-advertise-peer-urls</td>\n<td>告知集群其他节点url.</td>\n</tr>\n<tr>\n<td>-advertise-client-urls</td>\n<td>告知客户端url, 也就是服务的url</td>\n</tr>\n<tr>\n<td>-initial-cluster-token</td>\n<td>集群的ID</td>\n</tr>\n<tr>\n<td>-initial-cluster</td>\n<td>集群中所有节点</td>\n</tr>\n<tr>\n<td>-initial-cluster-state</td>\n<td>-initial-cluster-state=new 表示从无到有搭建etcd集群</td>\n</tr>\n<tr>\n<td>-discovery-srv</td>\n<td>用于DNS动态服务发现，指定DNS SRV域名</td>\n</tr>\n<tr>\n<td>-discovery</td>\n<td>用于etcd动态发现，指定etcd发现服务的URL [<a href=\"https://discovery.etcd.io/\" target=\"_blank\" rel=\"external\">https://discovery.etcd.io/</a>],用环境变量表示</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"[Etcd] Etcd访问控制","catalog":true,"date":"2017-07-10T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Etcd"],"_content":"\n## 1. ETCD资源类型\n\nThere are three types of resources in etcd\n\npermission resources: users and roles in the user store\nkey-value resources: key-value pairs in the key-value store\nsettings resources: security settings, auth settings, and dynamic etcd cluster settings (election/heartbeat)\n\n## 2. 权限资源\n\n**Users**：user用来设置身份认证（user：passwd），一个用户可以拥有多个角色，每个角色被分配一定的权限（只读、只写、可读写），用户分为root用户和非root用户。\n\n**Roles**：角色用来关联权限，角色主要三类：root角色。默认创建root用户时即创建了root角色，该角色拥有所有权限；guest角色，默认自动创建，主要用于非认证使用。普通角色，由root用户创建角色，并分配指定权限。\n\n注意：如果没有指定任何验证方式，即没显示指定以什么用户进行访问，那么默认会设定为 guest 角色。默认情况下 guest 也是具有全局访问权限的。如果不希望未授权就获取或修改etcd的数据，则可收回guest角色的权限或删除该角色，etcdctl role revoke 。\n\n**Permissions：**权限分为只读、只写、可读写三种权限，权限即对指定目录或key的读写权限。\n\n## 3. ETCD访问控制\n\n### 3.1. 访问控制相关命令\n\n```shell\nNAME:\n   etcdctl - A simple command line client for etcd.\nUSAGE:\n   etcdctl [global options] command [command options] [arguments...]\nVERSION:\n   2.2.0\nCOMMANDS:\n   user         user add, grant and revoke subcommands\n   role         role add, grant and revoke subcommands\n   auth         overall auth controls  \nGLOBAL OPTIONS:\n   --peers, -C          a comma-delimited list of machine addresses in the cluster (default: \"http://127.0.0.1:4001,http://127.0.0.1:2379\")\n   --endpoint           a comma-delimited list of machine addresses in the cluster (default: \"http://127.0.0.1:4001,http://127.0.0.1:2379\")\n   --cert-file          identify HTTPS client using this SSL certificate file\n   --key-file           identify HTTPS client using this SSL key file\n   --ca-file            verify certificates of HTTPS-enabled servers using this CA bundle\n   --username, -u       provide username[:password] and prompt if password is not supplied.\n   --timeout '1s'       connection timeout per request\n```\n\n### 3.2. user相关命令\n\n```shell\n[root@localhost etcd]# etcdctl user --help\nNAME:\n   etcdctl user - user add, grant and revoke subcommands\nUSAGE:\n   etcdctl user command [command options] [arguments...]\nCOMMANDS:\n   add      add a new user for the etcd cluster\n   get      get details for a user\n   list     list all current users\n   remove   remove a user for the etcd cluster\n   grant    grant roles to an etcd user\n   revoke   revoke roles for an etcd user\n   passwd   change password for a user\n   help, h  Shows a list of commands or help for one command\n    \nOPTIONS:\n   --help, -h   show help\n```\n\n#### 3.2.1. 添加root用户并设置密码\n\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) user add root\n\n#### 3.2.2. 添加非root用户并设置密码\n\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) --username root:123 user add huwh\n\n#### 3.2.3. 查看当前所有用户\n\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) --username root:123 user list\n\n#### 3.2.4. 将用户添加到对应角色\n\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) --username root:123 user grant --roles test1 phpor\n\n#### 3.2.5. 查看用户拥有哪些角色\n\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) --username root:123 user get phpor\n\n### 3.3. role相关命令\n\n```shell\n[root@localhost etcd]# etcdctl role --help\nNAME:\n   etcdctl role - role add, grant and revoke subcommands\nUSAGE:\n   etcdctl role command [command options] [arguments...]\nCOMMANDS:\n   add      add a new role for the etcd cluster\n   get      get details for a role\n   list     list all roles\n   remove   remove a role from the etcd cluster\n   grant    grant path matches to an etcd role\n   revoke   revoke path matches for an etcd role\n   help, h  Shows a list of commands or help for one command\n    \nOPTIONS:\n   --help, -h   show help\n```\n\n#### 3.3.1. 添加角色\n\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) --username root:2379 role add test1\n\n#### 3.3.2. 查看所有角色\n\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) --username root:123 role list\n\n#### 3.3.3. 给角色分配权限\n\n```shell\n[root@localhost etcd]# etcdctl role grant --help\nNAME:\n   grant - grant path matches to an etcd role\nUSAGE:\n   command grant [command options] [arguments...]\nOPTIONS:\n   --path   Path granted for the role to access\n   --read   Grant read-only access\n   --write  Grant write-only access\n   --readwrite  Grant read-write access\n```\n\n1、只包含目录\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) --username root:123 role grant --readwrite --path /test1 test1\n\n2、包括目录和子目录或文件 \netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) --username root:123 role grant --readwrite --path /test1/* test1\n\n### 3.3.4. 查看角色所拥有的权限\n\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) --username root:2379 role get test1\n\n### 3.4. auth相关操作\n\n```shell\n[root@localhost etcd]# etcdctl auth --help\nNAME:\n   etcdctl auth - overall auth controls\nUSAGE:\n   etcdctl auth command [command options] [arguments...]\nCOMMANDS:\n   enable   enable auth access controls\n   disable  disable auth access controls\n   help, h  Shows a list of commands or help for one command\n    \nOPTIONS:\n   --help, -h   show help\n```\n\n#### 3.4.1. 开启认证\n\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) auth enable\n\n## 4. 访问控制设置步骤\n\n| 顺序   | 步骤                   | 命令                                       |\n| ---- | -------------------- | ---------------------------------------- |\n| 1    | 添加root用户             | etcdctl --endpoints http://<ip>:<port> user add root |\n| 2    | 开启认证                 | etcdctl --endpoints http://<ip>:<port> auth enable |\n| 3    | 添加非root用户            | etcdctl --endpoints http://<ip>:<port> –username root:<passwd> user add <user> |\n| 4    | 添加角色                 | etcdctl --endpoints http://<ip>:<port> –username root:<passwd> role add <role> |\n| 5    | 给角色授权（只读、只写、可读写）     | etcdctl --endpoints http://<ip>:<port> –username root:<passwd> role grant --readwrite --path <path> <role> |\n| 6    | 给用户分配角色（即分配了角色对应的权限） | etcdctl --endpoints http://<ip>:<port> –username root:<passwd> user grant --roles <role> <user> |\n\n## 5. 访问认证的API调用\n\n更多参考[https://coreos.com/etcd/docs/latest/v2/auth_api.html](https://coreos.com/etcd/docs/latest/v2/auth_api.html)","source":"_posts/Etcd/Etcd访问控制.md","raw":"---\ntitle: \"[Etcd] Etcd访问控制\"\ncatalog: true\ndate: 2017-07-10 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Etcd\ncatagories:\n- Etcd\n---\n\n## 1. ETCD资源类型\n\nThere are three types of resources in etcd\n\npermission resources: users and roles in the user store\nkey-value resources: key-value pairs in the key-value store\nsettings resources: security settings, auth settings, and dynamic etcd cluster settings (election/heartbeat)\n\n## 2. 权限资源\n\n**Users**：user用来设置身份认证（user：passwd），一个用户可以拥有多个角色，每个角色被分配一定的权限（只读、只写、可读写），用户分为root用户和非root用户。\n\n**Roles**：角色用来关联权限，角色主要三类：root角色。默认创建root用户时即创建了root角色，该角色拥有所有权限；guest角色，默认自动创建，主要用于非认证使用。普通角色，由root用户创建角色，并分配指定权限。\n\n注意：如果没有指定任何验证方式，即没显示指定以什么用户进行访问，那么默认会设定为 guest 角色。默认情况下 guest 也是具有全局访问权限的。如果不希望未授权就获取或修改etcd的数据，则可收回guest角色的权限或删除该角色，etcdctl role revoke 。\n\n**Permissions：**权限分为只读、只写、可读写三种权限，权限即对指定目录或key的读写权限。\n\n## 3. ETCD访问控制\n\n### 3.1. 访问控制相关命令\n\n```shell\nNAME:\n   etcdctl - A simple command line client for etcd.\nUSAGE:\n   etcdctl [global options] command [command options] [arguments...]\nVERSION:\n   2.2.0\nCOMMANDS:\n   user         user add, grant and revoke subcommands\n   role         role add, grant and revoke subcommands\n   auth         overall auth controls  \nGLOBAL OPTIONS:\n   --peers, -C          a comma-delimited list of machine addresses in the cluster (default: \"http://127.0.0.1:4001,http://127.0.0.1:2379\")\n   --endpoint           a comma-delimited list of machine addresses in the cluster (default: \"http://127.0.0.1:4001,http://127.0.0.1:2379\")\n   --cert-file          identify HTTPS client using this SSL certificate file\n   --key-file           identify HTTPS client using this SSL key file\n   --ca-file            verify certificates of HTTPS-enabled servers using this CA bundle\n   --username, -u       provide username[:password] and prompt if password is not supplied.\n   --timeout '1s'       connection timeout per request\n```\n\n### 3.2. user相关命令\n\n```shell\n[root@localhost etcd]# etcdctl user --help\nNAME:\n   etcdctl user - user add, grant and revoke subcommands\nUSAGE:\n   etcdctl user command [command options] [arguments...]\nCOMMANDS:\n   add      add a new user for the etcd cluster\n   get      get details for a user\n   list     list all current users\n   remove   remove a user for the etcd cluster\n   grant    grant roles to an etcd user\n   revoke   revoke roles for an etcd user\n   passwd   change password for a user\n   help, h  Shows a list of commands or help for one command\n    \nOPTIONS:\n   --help, -h   show help\n```\n\n#### 3.2.1. 添加root用户并设置密码\n\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) user add root\n\n#### 3.2.2. 添加非root用户并设置密码\n\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) --username root:123 user add huwh\n\n#### 3.2.3. 查看当前所有用户\n\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) --username root:123 user list\n\n#### 3.2.4. 将用户添加到对应角色\n\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) --username root:123 user grant --roles test1 phpor\n\n#### 3.2.5. 查看用户拥有哪些角色\n\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) --username root:123 user get phpor\n\n### 3.3. role相关命令\n\n```shell\n[root@localhost etcd]# etcdctl role --help\nNAME:\n   etcdctl role - role add, grant and revoke subcommands\nUSAGE:\n   etcdctl role command [command options] [arguments...]\nCOMMANDS:\n   add      add a new role for the etcd cluster\n   get      get details for a role\n   list     list all roles\n   remove   remove a role from the etcd cluster\n   grant    grant path matches to an etcd role\n   revoke   revoke path matches for an etcd role\n   help, h  Shows a list of commands or help for one command\n    \nOPTIONS:\n   --help, -h   show help\n```\n\n#### 3.3.1. 添加角色\n\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) --username root:2379 role add test1\n\n#### 3.3.2. 查看所有角色\n\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) --username root:123 role list\n\n#### 3.3.3. 给角色分配权限\n\n```shell\n[root@localhost etcd]# etcdctl role grant --help\nNAME:\n   grant - grant path matches to an etcd role\nUSAGE:\n   command grant [command options] [arguments...]\nOPTIONS:\n   --path   Path granted for the role to access\n   --read   Grant read-only access\n   --write  Grant write-only access\n   --readwrite  Grant read-write access\n```\n\n1、只包含目录\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) --username root:123 role grant --readwrite --path /test1 test1\n\n2、包括目录和子目录或文件 \netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) --username root:123 role grant --readwrite --path /test1/* test1\n\n### 3.3.4. 查看角色所拥有的权限\n\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) --username root:2379 role get test1\n\n### 3.4. auth相关操作\n\n```shell\n[root@localhost etcd]# etcdctl auth --help\nNAME:\n   etcdctl auth - overall auth controls\nUSAGE:\n   etcdctl auth command [command options] [arguments...]\nCOMMANDS:\n   enable   enable auth access controls\n   disable  disable auth access controls\n   help, h  Shows a list of commands or help for one command\n    \nOPTIONS:\n   --help, -h   show help\n```\n\n#### 3.4.1. 开启认证\n\netcdctl --endpoints [http://172.16.22.36:2379](http://172.16.22.36:2379/) auth enable\n\n## 4. 访问控制设置步骤\n\n| 顺序   | 步骤                   | 命令                                       |\n| ---- | -------------------- | ---------------------------------------- |\n| 1    | 添加root用户             | etcdctl --endpoints http://<ip>:<port> user add root |\n| 2    | 开启认证                 | etcdctl --endpoints http://<ip>:<port> auth enable |\n| 3    | 添加非root用户            | etcdctl --endpoints http://<ip>:<port> –username root:<passwd> user add <user> |\n| 4    | 添加角色                 | etcdctl --endpoints http://<ip>:<port> –username root:<passwd> role add <role> |\n| 5    | 给角色授权（只读、只写、可读写）     | etcdctl --endpoints http://<ip>:<port> –username root:<passwd> role grant --readwrite --path <path> <role> |\n| 6    | 给用户分配角色（即分配了角色对应的权限） | etcdctl --endpoints http://<ip>:<port> –username root:<passwd> user grant --roles <role> <user> |\n\n## 5. 访问认证的API调用\n\n更多参考[https://coreos.com/etcd/docs/latest/v2/auth_api.html](https://coreos.com/etcd/docs/latest/v2/auth_api.html)","slug":"Etcd/Etcd访问控制","published":1,"updated":"2017-10-02T09:11:28.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740h7000b30vugk2e2w5n","content":"<h2><span id=\"1-etcd资源类型\">1. ETCD资源类型</span></h2>\n<p>There are three types of resources in etcd</p>\n<p>permission resources: users and roles in the user store<br>\nkey-value resources: key-value pairs in the key-value store<br>\nsettings resources: security settings, auth settings, and dynamic etcd cluster settings (election/heartbeat)</p>\n<h2><span id=\"2-权限资源\">2. 权限资源</span></h2>\n<p><strong>Users</strong>：user用来设置身份认证（user：passwd），一个用户可以拥有多个角色，每个角色被分配一定的权限（只读、只写、可读写），用户分为root用户和非root用户。</p>\n<p><strong>Roles</strong>：角色用来关联权限，角色主要三类：root角色。默认创建root用户时即创建了root角色，该角色拥有所有权限；guest角色，默认自动创建，主要用于非认证使用。普通角色，由root用户创建角色，并分配指定权限。</p>\n<p>注意：如果没有指定任何验证方式，即没显示指定以什么用户进行访问，那么默认会设定为 guest 角色。默认情况下 guest 也是具有全局访问权限的。如果不希望未授权就获取或修改etcd的数据，则可收回guest角色的权限或删除该角色，etcdctl role revoke 。</p>\n<p>**Permissions：**权限分为只读、只写、可读写三种权限，权限即对指定目录或key的读写权限。</p>\n<h2><span id=\"3-etcd访问控制\">3. ETCD访问控制</span></h2>\n<h3><span id=\"31-访问控制相关命令\">3.1. 访问控制相关命令</span></h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">NAME:</div><div class=\"line\">   etcdctl - A simple command line client for etcd.</div><div class=\"line\">USAGE:</div><div class=\"line\">   etcdctl [global options] command [command options] [arguments...]</div><div class=\"line\">VERSION:</div><div class=\"line\">   2.2.0</div><div class=\"line\">COMMANDS:</div><div class=\"line\">   user         user add, grant and revoke subcommands</div><div class=\"line\">   role         role add, grant and revoke subcommands</div><div class=\"line\">   auth         overall auth controls  </div><div class=\"line\">GLOBAL OPTIONS:</div><div class=\"line\">   --peers, -C          a comma-delimited list of machine addresses in the cluster (default: \"http://127.0.0.1:4001,http://127.0.0.1:2379\")</div><div class=\"line\">   --endpoint           a comma-delimited list of machine addresses in the cluster (default: \"http://127.0.0.1:4001,http://127.0.0.1:2379\")</div><div class=\"line\">   --cert-file          identify HTTPS client using this SSL certificate file</div><div class=\"line\">   --key-file           identify HTTPS client using this SSL key file</div><div class=\"line\">   --ca-file            verify certificates of HTTPS-enabled servers using this CA bundle</div><div class=\"line\">   --username, -u       provide username[:password] and prompt if password is not supplied.</div><div class=\"line\">   --timeout '1s'       connection timeout per request</div></pre></td></tr></table></figure>\n<h3><span id=\"32-user相关命令\">3.2. user相关命令</span></h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@localhost etcd]# etcdctl user --help</div><div class=\"line\">NAME:</div><div class=\"line\">   etcdctl user - user add, grant and revoke subcommands</div><div class=\"line\">USAGE:</div><div class=\"line\">   etcdctl user command [command options] [arguments...]</div><div class=\"line\">COMMANDS:</div><div class=\"line\">   add      add a new user for the etcd cluster</div><div class=\"line\">   get      get details for a user</div><div class=\"line\">   list     list all current users</div><div class=\"line\">   remove   remove a user for the etcd cluster</div><div class=\"line\">   grant    grant roles to an etcd user</div><div class=\"line\">   revoke   revoke roles for an etcd user</div><div class=\"line\">   passwd   change password for a user</div><div class=\"line\">   help, h  Shows a list of commands or help for one command</div><div class=\"line\">    </div><div class=\"line\">OPTIONS:</div><div class=\"line\">   --help, -h   show help</div></pre></td></tr></table></figure>\n<h4><span id=\"321-添加root用户并设置密码\">3.2.1. 添加root用户并设置密码</span></h4>\n<p>etcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> user add root</p>\n<h4><span id=\"322-添加非root用户并设置密码\">3.2.2. 添加非root用户并设置密码</span></h4>\n<p>etcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> --username root:123 user add huwh</p>\n<h4><span id=\"323-查看当前所有用户\">3.2.3. 查看当前所有用户</span></h4>\n<p>etcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> --username root:123 user list</p>\n<h4><span id=\"324-将用户添加到对应角色\">3.2.4. 将用户添加到对应角色</span></h4>\n<p>etcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> --username root:123 user grant --roles test1 phpor</p>\n<h4><span id=\"325-查看用户拥有哪些角色\">3.2.5. 查看用户拥有哪些角色</span></h4>\n<p>etcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> --username root:123 user get phpor</p>\n<h3><span id=\"33-role相关命令\">3.3. role相关命令</span></h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@localhost etcd]# etcdctl role --help</div><div class=\"line\">NAME:</div><div class=\"line\">   etcdctl role - role add, grant and revoke subcommands</div><div class=\"line\">USAGE:</div><div class=\"line\">   etcdctl role command [command options] [arguments...]</div><div class=\"line\">COMMANDS:</div><div class=\"line\">   add      add a new role for the etcd cluster</div><div class=\"line\">   get      get details for a role</div><div class=\"line\">   list     list all roles</div><div class=\"line\">   remove   remove a role from the etcd cluster</div><div class=\"line\">   grant    grant path matches to an etcd role</div><div class=\"line\">   revoke   revoke path matches for an etcd role</div><div class=\"line\">   help, h  Shows a list of commands or help for one command</div><div class=\"line\">    </div><div class=\"line\">OPTIONS:</div><div class=\"line\">   --help, -h   show help</div></pre></td></tr></table></figure>\n<h4><span id=\"331-添加角色\">3.3.1. 添加角色</span></h4>\n<p>etcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> --username root:2379 role add test1</p>\n<h4><span id=\"332-查看所有角色\">3.3.2. 查看所有角色</span></h4>\n<p>etcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> --username root:123 role list</p>\n<h4><span id=\"333-给角色分配权限\">3.3.3. 给角色分配权限</span></h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@localhost etcd]# etcdctl role grant --help</div><div class=\"line\">NAME:</div><div class=\"line\">   grant - grant path matches to an etcd role</div><div class=\"line\">USAGE:</div><div class=\"line\">   command grant [command options] [arguments...]</div><div class=\"line\">OPTIONS:</div><div class=\"line\">   --path   Path granted for the role to access</div><div class=\"line\">   --read   Grant read-only access</div><div class=\"line\">   --write  Grant write-only access</div><div class=\"line\">   --readwrite  Grant read-write access</div></pre></td></tr></table></figure>\n<p>1、只包含目录<br>\netcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> --username root:123 role grant --readwrite --path /test1 test1</p>\n<p>2、包括目录和子目录或文件<br>\netcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> --username root:123 role grant --readwrite --path /test1/* test1</p>\n<h3><span id=\"334-查看角色所拥有的权限\">3.3.4. 查看角色所拥有的权限</span></h3>\n<p>etcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> --username root:2379 role get test1</p>\n<h3><span id=\"34-auth相关操作\">3.4. auth相关操作</span></h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@localhost etcd]# etcdctl auth --help</div><div class=\"line\">NAME:</div><div class=\"line\">   etcdctl auth - overall auth controls</div><div class=\"line\">USAGE:</div><div class=\"line\">   etcdctl auth command [command options] [arguments...]</div><div class=\"line\">COMMANDS:</div><div class=\"line\">   enable   enable auth access controls</div><div class=\"line\">   disable  disable auth access controls</div><div class=\"line\">   help, h  Shows a list of commands or help for one command</div><div class=\"line\">    </div><div class=\"line\">OPTIONS:</div><div class=\"line\">   --help, -h   show help</div></pre></td></tr></table></figure>\n<h4><span id=\"341-开启认证\">3.4.1. 开启认证</span></h4>\n<p>etcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> auth enable</p>\n<h2><span id=\"4-访问控制设置步骤\">4. 访问控制设置步骤</span></h2>\n<table>\n<thead>\n<tr>\n<th>顺序</th>\n<th>步骤</th>\n<th>命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>添加root用户</td>\n<td>etcdctl --endpoints http://<ip>:<port> user add root</port></ip></td>\n</tr>\n<tr>\n<td>2</td>\n<td>开启认证</td>\n<td>etcdctl --endpoints http://<ip>:<port> auth enable</port></ip></td>\n</tr>\n<tr>\n<td>3</td>\n<td>添加非root用户</td>\n<td>etcdctl --endpoints http://<ip>:<port> –username root:<passwd> user add <user></user></passwd></port></ip></td>\n</tr>\n<tr>\n<td>4</td>\n<td>添加角色</td>\n<td>etcdctl --endpoints http://<ip>:<port> –username root:<passwd> role add <role></role></passwd></port></ip></td>\n</tr>\n<tr>\n<td>5</td>\n<td>给角色授权（只读、只写、可读写）</td>\n<td>etcdctl --endpoints http://<ip>:<port> –username root:<passwd> role grant --readwrite --path <path></path> <role></role></passwd></port></ip></td>\n</tr>\n<tr>\n<td>6</td>\n<td>给用户分配角色（即分配了角色对应的权限）</td>\n<td>etcdctl --endpoints http://<ip>:<port> –username root:<passwd> user grant --roles <role> <user></user></role></passwd></port></ip></td>\n</tr>\n</tbody>\n</table>\n<h2><span id=\"5-访问认证的api调用\">5. 访问认证的API调用</span></h2>\n<p>更多参考<a href=\"https://coreos.com/etcd/docs/latest/v2/auth_api.html\" target=\"_blank\" rel=\"external\">https://coreos.com/etcd/docs/latest/v2/auth_api.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. ETCD资源类型</h2>\n<p>There are three types of resources in etcd</p>\n<p>permission resources: users and roles in the user store<br>\nkey-value resources: key-value pairs in the key-value store<br>\nsettings resources: security settings, auth settings, and dynamic etcd cluster settings (election/heartbeat)</p>\n<h2>2. 权限资源</h2>\n<p><strong>Users</strong>：user用来设置身份认证（user：passwd），一个用户可以拥有多个角色，每个角色被分配一定的权限（只读、只写、可读写），用户分为root用户和非root用户。</p>\n<p><strong>Roles</strong>：角色用来关联权限，角色主要三类：root角色。默认创建root用户时即创建了root角色，该角色拥有所有权限；guest角色，默认自动创建，主要用于非认证使用。普通角色，由root用户创建角色，并分配指定权限。</p>\n<p>注意：如果没有指定任何验证方式，即没显示指定以什么用户进行访问，那么默认会设定为 guest 角色。默认情况下 guest 也是具有全局访问权限的。如果不希望未授权就获取或修改etcd的数据，则可收回guest角色的权限或删除该角色，etcdctl role revoke 。</p>\n<p>**Permissions：**权限分为只读、只写、可读写三种权限，权限即对指定目录或key的读写权限。</p>\n<h2>3. ETCD访问控制</h2>\n<h3>3.1. 访问控制相关命令</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">NAME:</div><div class=\"line\">   etcdctl - A simple command line client for etcd.</div><div class=\"line\">USAGE:</div><div class=\"line\">   etcdctl [global options] command [command options] [arguments...]</div><div class=\"line\">VERSION:</div><div class=\"line\">   2.2.0</div><div class=\"line\">COMMANDS:</div><div class=\"line\">   user         user add, grant and revoke subcommands</div><div class=\"line\">   role         role add, grant and revoke subcommands</div><div class=\"line\">   auth         overall auth controls  </div><div class=\"line\">GLOBAL OPTIONS:</div><div class=\"line\">   --peers, -C          a comma-delimited list of machine addresses in the cluster (default: \"http://127.0.0.1:4001,http://127.0.0.1:2379\")</div><div class=\"line\">   --endpoint           a comma-delimited list of machine addresses in the cluster (default: \"http://127.0.0.1:4001,http://127.0.0.1:2379\")</div><div class=\"line\">   --cert-file          identify HTTPS client using this SSL certificate file</div><div class=\"line\">   --key-file           identify HTTPS client using this SSL key file</div><div class=\"line\">   --ca-file            verify certificates of HTTPS-enabled servers using this CA bundle</div><div class=\"line\">   --username, -u       provide username[:password] and prompt if password is not supplied.</div><div class=\"line\">   --timeout '1s'       connection timeout per request</div></pre></td></tr></table></figure>\n<h3>3.2. user相关命令</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@localhost etcd]# etcdctl user --help</div><div class=\"line\">NAME:</div><div class=\"line\">   etcdctl user - user add, grant and revoke subcommands</div><div class=\"line\">USAGE:</div><div class=\"line\">   etcdctl user command [command options] [arguments...]</div><div class=\"line\">COMMANDS:</div><div class=\"line\">   add      add a new user for the etcd cluster</div><div class=\"line\">   get      get details for a user</div><div class=\"line\">   list     list all current users</div><div class=\"line\">   remove   remove a user for the etcd cluster</div><div class=\"line\">   grant    grant roles to an etcd user</div><div class=\"line\">   revoke   revoke roles for an etcd user</div><div class=\"line\">   passwd   change password for a user</div><div class=\"line\">   help, h  Shows a list of commands or help for one command</div><div class=\"line\">    </div><div class=\"line\">OPTIONS:</div><div class=\"line\">   --help, -h   show help</div></pre></td></tr></table></figure>\n<h4>3.2.1. 添加root用户并设置密码</h4>\n<p>etcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> user add root</p>\n<h4>3.2.2. 添加非root用户并设置密码</h4>\n<p>etcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> --username root:123 user add huwh</p>\n<h4>3.2.3. 查看当前所有用户</h4>\n<p>etcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> --username root:123 user list</p>\n<h4>3.2.4. 将用户添加到对应角色</h4>\n<p>etcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> --username root:123 user grant --roles test1 phpor</p>\n<h4>3.2.5. 查看用户拥有哪些角色</h4>\n<p>etcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> --username root:123 user get phpor</p>\n<h3>3.3. role相关命令</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@localhost etcd]# etcdctl role --help</div><div class=\"line\">NAME:</div><div class=\"line\">   etcdctl role - role add, grant and revoke subcommands</div><div class=\"line\">USAGE:</div><div class=\"line\">   etcdctl role command [command options] [arguments...]</div><div class=\"line\">COMMANDS:</div><div class=\"line\">   add      add a new role for the etcd cluster</div><div class=\"line\">   get      get details for a role</div><div class=\"line\">   list     list all roles</div><div class=\"line\">   remove   remove a role from the etcd cluster</div><div class=\"line\">   grant    grant path matches to an etcd role</div><div class=\"line\">   revoke   revoke path matches for an etcd role</div><div class=\"line\">   help, h  Shows a list of commands or help for one command</div><div class=\"line\">    </div><div class=\"line\">OPTIONS:</div><div class=\"line\">   --help, -h   show help</div></pre></td></tr></table></figure>\n<h4>3.3.1. 添加角色</h4>\n<p>etcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> --username root:2379 role add test1</p>\n<h4>3.3.2. 查看所有角色</h4>\n<p>etcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> --username root:123 role list</p>\n<h4>3.3.3. 给角色分配权限</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@localhost etcd]# etcdctl role grant --help</div><div class=\"line\">NAME:</div><div class=\"line\">   grant - grant path matches to an etcd role</div><div class=\"line\">USAGE:</div><div class=\"line\">   command grant [command options] [arguments...]</div><div class=\"line\">OPTIONS:</div><div class=\"line\">   --path   Path granted for the role to access</div><div class=\"line\">   --read   Grant read-only access</div><div class=\"line\">   --write  Grant write-only access</div><div class=\"line\">   --readwrite  Grant read-write access</div></pre></td></tr></table></figure>\n<p>1、只包含目录<br>\netcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> --username root:123 role grant --readwrite --path /test1 test1</p>\n<p>2、包括目录和子目录或文件<br>\netcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> --username root:123 role grant --readwrite --path /test1/* test1</p>\n<h3>3.3.4. 查看角色所拥有的权限</h3>\n<p>etcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> --username root:2379 role get test1</p>\n<h3>3.4. auth相关操作</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@localhost etcd]# etcdctl auth --help</div><div class=\"line\">NAME:</div><div class=\"line\">   etcdctl auth - overall auth controls</div><div class=\"line\">USAGE:</div><div class=\"line\">   etcdctl auth command [command options] [arguments...]</div><div class=\"line\">COMMANDS:</div><div class=\"line\">   enable   enable auth access controls</div><div class=\"line\">   disable  disable auth access controls</div><div class=\"line\">   help, h  Shows a list of commands or help for one command</div><div class=\"line\">    </div><div class=\"line\">OPTIONS:</div><div class=\"line\">   --help, -h   show help</div></pre></td></tr></table></figure>\n<h4>3.4.1. 开启认证</h4>\n<p>etcdctl --endpoints <a href=\"http://172.16.22.36:2379/\" target=\"_blank\" rel=\"external\">http://172.16.22.36:2379</a> auth enable</p>\n<h2>4. 访问控制设置步骤</h2>\n<table>\n<thead>\n<tr>\n<th>顺序</th>\n<th>步骤</th>\n<th>命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>添加root用户</td>\n<td>etcdctl --endpoints http://<ip>:<port> user add root</port></ip></td>\n</tr>\n<tr>\n<td>2</td>\n<td>开启认证</td>\n<td>etcdctl --endpoints http://<ip>:<port> auth enable</port></ip></td>\n</tr>\n<tr>\n<td>3</td>\n<td>添加非root用户</td>\n<td>etcdctl --endpoints http://<ip>:<port> –username root:<passwd> user add <user></user></passwd></port></ip></td>\n</tr>\n<tr>\n<td>4</td>\n<td>添加角色</td>\n<td>etcdctl --endpoints http://<ip>:<port> –username root:<passwd> role add <role></role></passwd></port></ip></td>\n</tr>\n<tr>\n<td>5</td>\n<td>给角色授权（只读、只写、可读写）</td>\n<td>etcdctl --endpoints http://<ip>:<port> –username root:<passwd> role grant --readwrite --path <path></path> <role></role></passwd></port></ip></td>\n</tr>\n<tr>\n<td>6</td>\n<td>给用户分配角色（即分配了角色对应的权限）</td>\n<td>etcdctl --endpoints http://<ip>:<port> –username root:<passwd> user grant --roles <role> <user></user></role></passwd></port></ip></td>\n</tr>\n</tbody>\n</table>\n<h2>5. 访问认证的API调用</h2>\n<p>更多参考<a href=\"https://coreos.com/etcd/docs/latest/v2/auth_api.html\" target=\"_blank\" rel=\"external\">https://coreos.com/etcd/docs/latest/v2/auth_api.html</a></p>\n"},{"title":"[Kubernetes] Flannel介绍","catalog":true,"date":"2017-07-08T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Kubernetes"],"_content":"\n## 一、flannel是什么（what）\n\n### （一）概述\n\nFlannel是CoreOS团队针对Kubernetes设计的一个网络规划服务，简单来说，它的功能是让集群中的不同节点主机创建的Docker容器都具有全集群唯一的虚拟IP地址。\nFlannel官网：https://github.com/coreos/flannel\n\n### （二）补充知识点\n\n#### **1、覆盖网络[overlay network]**\n\n运行在一个网上的网（应用层网络），并不依靠ip地址来传递消息，而是采用一种映射机制，把ip地址和identifiers做映射来资源定位。\n\n#### **2、路由**\n\n互联网是由路由器连接的网络组合而成，路由器按照路由表、路由协议等机制实现对数据包正确地转发，从而到达目标主机。路由器根据数据包中目标主机的IP地址和路由控制表比较得出下一个接收数据的路由器。\n\n**1）静态路由：事先设置好路由器和主机中的路由表信息。** \n\n ![静态路由](/img/article/flannel/静态路由.png)\n\n**2）动态路由：让路由协议在运行中自动修改并设置路由表信息。**\n\n![动态路由](/img/article/flannel/动态路由.png)\n\n## 二、为什么使用flannel（why）\n\n在默认的Docker配置中，每个节点上的Docker服务会分别负责所在节点容器的IP分配。这样导致的一个问题是，不同节点上容器可能获得相同的内外IP地址。\n\nFlannel的设计目的就是为集群中的所有节点重新规划IP地址的使用规则，从而使得不同节点上的容器能够获得“同属一个内网”且”不重复的”IP地址，并让属于不同节点上的容器能够直接通过内网IP通信。\n\n## 三、如何实现flannel（how）\n\nFlannel实质上是一种“覆盖网络(overlay network)”，也就是将TCP数据包装在另一种网络包里面进行路由转发和通信，目前已经支持UDP、VxLAN、AWS VPC和GCE路由等数据转发方式，默认的节点间数据通信方式是UDP转发。\n\n### （一）flannel原理图\n\n![flannel](/img/article\\flannel\\flannel.png)\n\n1. 数据从源容器中发出后，经由所在主机的docker0虚拟网卡转发到flannel0虚拟网卡，这是个P2P的虚拟网卡，flanneld服务监听在网卡的另外一端。\n2. Flannel通过Etcd服务维护了一张节点间的路由表。\n3. 源主机的flanneld服务将原本的数据内容UDP封装后根据自己的路由表投递给目的节点的flanneld服务，数据到达以后被解包，然后直 接进入目的节点的flannel0虚拟网卡，然后被转发到目的主机的docker0虚拟网卡，最后就像本机容器通信一下的有docker0路由到达目标容 器。\n\n### （二）实现说明\n\n#### **1、UDP封装**\n\n原始数据是在起始节点的Flannel服务上进行UDP封装的，投递到目的节点后就被另一端的Flannel服务还原成了原始的数据包，两边的Docker服务都感觉不到这个过程的存在。 UDP的数据内容部分其实是另一个ICMP（也就是ping命令）的数据包。\n\n![UDP封装](/img/article/flannel/UDP封装.png)\n\n#### **2、为docker分配不同的IP段**\n\nFlannel通过Etcd分配了每个节点可用的IP地址段后，偷偷的修改了Docker的启动参数。\n\n![docker启动参数](/img/article/flannel/docker启动参数.png)\n\n注意其中的“--bip=172.17.18.1/24”这个参数，它限制了所在节点容器获得的IP范围。\n\n这个IP范围是由Flannel自动分配的，由Flannel通过保存在Etcd服务中的记录确保它们不会重复。\n\n#### **3、路由规则**\n\n1）数据发送节点的路由表 \n\n![数据发送节点路由表](/img/article/flannel/数据发送节点路由表.png)\n\n2）数据接收节点的路由表 \n\n![数据接收节点路由表](/img/article/flannel/数据接收节点路由表.png)\n\n例如现在有一个数据包要从IP为172.17.18.2的容器发到IP为172.17.46.2的容器。根据数据发送节点的路由表，它只与 172.17.0.0/16匹配这条记录匹配，因此数据从docker0出来以后就被投递到了flannel0。同理在目标节点，由于投递的地址是一个容 器，因此目的地址一定会落在docker0对于的172.17.46.0/24这个记录上，自然的被投递到了docker0网卡。\n\n### （三）flannel的安装与配置\n#### **1、安装**\n```\nwget http://<官网>/flannel/flannel-0.2.0-10.el7.x86_64.rpm\nyum localinstall -y flannel-0.2.0-10.el7.x86_64.rpm\n```\n#### **2、配置**\nvi /etc/sysconfig/flanneld\n```shell\n# Flanneld configuration options\n \n# etcd url location. Point this to the server where etcd runs\nFLANNEL_ETCD=\"http://127.0.0.1:4001\"\n  \n# etcd config key. This is the configuration key that flannel queries\n# For address range assignment\nFLANNEL_ETCD_KEY=\"/wae/flannel/product/network\"\n  \n# Any additional options that you want to pass\nFLANNEL_OPTIONS=\" -iface=eth0\"\n```\n#### **3、初始化flannel的etcd配置**\n```\netcdctl set /wae/flannel/network/config '{\n   \"Network\": \"10.0.0.0/16\",\n   \"Backend\": {\n       \"Type\": \"vxlan\"\n   }\n}'\n```\n","source":"_posts/Flannel/Flannel介绍.md","raw":"---\ntitle: \"[Kubernetes] Flannel介绍\"\ncatalog: true\ndate: 2017-07-08 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Kubernetes\ncatagories:\n- Kubernetes\n\n---\n\n## 一、flannel是什么（what）\n\n### （一）概述\n\nFlannel是CoreOS团队针对Kubernetes设计的一个网络规划服务，简单来说，它的功能是让集群中的不同节点主机创建的Docker容器都具有全集群唯一的虚拟IP地址。\nFlannel官网：https://github.com/coreos/flannel\n\n### （二）补充知识点\n\n#### **1、覆盖网络[overlay network]**\n\n运行在一个网上的网（应用层网络），并不依靠ip地址来传递消息，而是采用一种映射机制，把ip地址和identifiers做映射来资源定位。\n\n#### **2、路由**\n\n互联网是由路由器连接的网络组合而成，路由器按照路由表、路由协议等机制实现对数据包正确地转发，从而到达目标主机。路由器根据数据包中目标主机的IP地址和路由控制表比较得出下一个接收数据的路由器。\n\n**1）静态路由：事先设置好路由器和主机中的路由表信息。** \n\n ![静态路由](/img/article/flannel/静态路由.png)\n\n**2）动态路由：让路由协议在运行中自动修改并设置路由表信息。**\n\n![动态路由](/img/article/flannel/动态路由.png)\n\n## 二、为什么使用flannel（why）\n\n在默认的Docker配置中，每个节点上的Docker服务会分别负责所在节点容器的IP分配。这样导致的一个问题是，不同节点上容器可能获得相同的内外IP地址。\n\nFlannel的设计目的就是为集群中的所有节点重新规划IP地址的使用规则，从而使得不同节点上的容器能够获得“同属一个内网”且”不重复的”IP地址，并让属于不同节点上的容器能够直接通过内网IP通信。\n\n## 三、如何实现flannel（how）\n\nFlannel实质上是一种“覆盖网络(overlay network)”，也就是将TCP数据包装在另一种网络包里面进行路由转发和通信，目前已经支持UDP、VxLAN、AWS VPC和GCE路由等数据转发方式，默认的节点间数据通信方式是UDP转发。\n\n### （一）flannel原理图\n\n![flannel](/img/article\\flannel\\flannel.png)\n\n1. 数据从源容器中发出后，经由所在主机的docker0虚拟网卡转发到flannel0虚拟网卡，这是个P2P的虚拟网卡，flanneld服务监听在网卡的另外一端。\n2. Flannel通过Etcd服务维护了一张节点间的路由表。\n3. 源主机的flanneld服务将原本的数据内容UDP封装后根据自己的路由表投递给目的节点的flanneld服务，数据到达以后被解包，然后直 接进入目的节点的flannel0虚拟网卡，然后被转发到目的主机的docker0虚拟网卡，最后就像本机容器通信一下的有docker0路由到达目标容 器。\n\n### （二）实现说明\n\n#### **1、UDP封装**\n\n原始数据是在起始节点的Flannel服务上进行UDP封装的，投递到目的节点后就被另一端的Flannel服务还原成了原始的数据包，两边的Docker服务都感觉不到这个过程的存在。 UDP的数据内容部分其实是另一个ICMP（也就是ping命令）的数据包。\n\n![UDP封装](/img/article/flannel/UDP封装.png)\n\n#### **2、为docker分配不同的IP段**\n\nFlannel通过Etcd分配了每个节点可用的IP地址段后，偷偷的修改了Docker的启动参数。\n\n![docker启动参数](/img/article/flannel/docker启动参数.png)\n\n注意其中的“--bip=172.17.18.1/24”这个参数，它限制了所在节点容器获得的IP范围。\n\n这个IP范围是由Flannel自动分配的，由Flannel通过保存在Etcd服务中的记录确保它们不会重复。\n\n#### **3、路由规则**\n\n1）数据发送节点的路由表 \n\n![数据发送节点路由表](/img/article/flannel/数据发送节点路由表.png)\n\n2）数据接收节点的路由表 \n\n![数据接收节点路由表](/img/article/flannel/数据接收节点路由表.png)\n\n例如现在有一个数据包要从IP为172.17.18.2的容器发到IP为172.17.46.2的容器。根据数据发送节点的路由表，它只与 172.17.0.0/16匹配这条记录匹配，因此数据从docker0出来以后就被投递到了flannel0。同理在目标节点，由于投递的地址是一个容 器，因此目的地址一定会落在docker0对于的172.17.46.0/24这个记录上，自然的被投递到了docker0网卡。\n\n### （三）flannel的安装与配置\n#### **1、安装**\n```\nwget http://<官网>/flannel/flannel-0.2.0-10.el7.x86_64.rpm\nyum localinstall -y flannel-0.2.0-10.el7.x86_64.rpm\n```\n#### **2、配置**\nvi /etc/sysconfig/flanneld\n```shell\n# Flanneld configuration options\n \n# etcd url location. Point this to the server where etcd runs\nFLANNEL_ETCD=\"http://127.0.0.1:4001\"\n  \n# etcd config key. This is the configuration key that flannel queries\n# For address range assignment\nFLANNEL_ETCD_KEY=\"/wae/flannel/product/network\"\n  \n# Any additional options that you want to pass\nFLANNEL_OPTIONS=\" -iface=eth0\"\n```\n#### **3、初始化flannel的etcd配置**\n```\netcdctl set /wae/flannel/network/config '{\n   \"Network\": \"10.0.0.0/16\",\n   \"Backend\": {\n       \"Type\": \"vxlan\"\n   }\n}'\n```\n","slug":"Flannel/Flannel介绍","published":1,"updated":"2017-10-02T09:19:25.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740h9000c30vuagm3vh2i","content":"<h2><span id=\"一-flannel是什么what\">一、flannel是什么（what）</span></h2>\n<h3><span id=\"一概述\">（一）概述</span></h3>\n<p>Flannel是CoreOS团队针对Kubernetes设计的一个网络规划服务，简单来说，它的功能是让集群中的不同节点主机创建的Docker容器都具有全集群唯一的虚拟IP地址。<br>\nFlannel官网：<a href=\"https://github.com/coreos/flannel\" target=\"_blank\" rel=\"external\">https://github.com/coreos/flannel</a></p>\n<h3><span id=\"二补充知识点\">（二）补充知识点</span></h3>\n<h4><span id=\"1-覆盖网络overlay-network\"><strong>1、覆盖网络[overlay network]</strong></span></h4>\n<p>运行在一个网上的网（应用层网络），并不依靠ip地址来传递消息，而是采用一种映射机制，把ip地址和identifiers做映射来资源定位。</p>\n<h4><span id=\"2-路由\"><strong>2、路由</strong></span></h4>\n<p>互联网是由路由器连接的网络组合而成，路由器按照路由表、路由协议等机制实现对数据包正确地转发，从而到达目标主机。路由器根据数据包中目标主机的IP地址和路由控制表比较得出下一个接收数据的路由器。</p>\n<p><strong>1）静态路由：事先设置好路由器和主机中的路由表信息。</strong></p>\n<p><img src=\"/img/article/flannel/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1.png\" alt=\"静态路由\"></p>\n<p><strong>2）动态路由：让路由协议在运行中自动修改并设置路由表信息。</strong></p>\n<p><img src=\"/img/article/flannel/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1.png\" alt=\"动态路由\"></p>\n<h2><span id=\"二-为什么使用flannelwhy\">二、为什么使用flannel（why）</span></h2>\n<p>在默认的Docker配置中，每个节点上的Docker服务会分别负责所在节点容器的IP分配。这样导致的一个问题是，不同节点上容器可能获得相同的内外IP地址。</p>\n<p>Flannel的设计目的就是为集群中的所有节点重新规划IP地址的使用规则，从而使得不同节点上的容器能够获得“同属一个内网”且”不重复的”IP地址，并让属于不同节点上的容器能够直接通过内网IP通信。</p>\n<h2><span id=\"三-如何实现flannelhow\">三、如何实现flannel（how）</span></h2>\n<p>Flannel实质上是一种“覆盖网络(overlay network)”，也就是将TCP数据包装在另一种网络包里面进行路由转发和通信，目前已经支持UDP、VxLAN、AWS VPC和GCE路由等数据转发方式，默认的节点间数据通信方式是UDP转发。</p>\n<h3><span id=\"一flannel原理图\">（一）flannel原理图</span></h3>\n<p><img src=\"/img/article%5Cflannel%5Cflannel.png\" alt=\"flannel\"></p>\n<ol>\n<li>数据从源容器中发出后，经由所在主机的docker0虚拟网卡转发到flannel0虚拟网卡，这是个P2P的虚拟网卡，flanneld服务监听在网卡的另外一端。</li>\n<li>Flannel通过Etcd服务维护了一张节点间的路由表。</li>\n<li>源主机的flanneld服务将原本的数据内容UDP封装后根据自己的路由表投递给目的节点的flanneld服务，数据到达以后被解包，然后直 接进入目的节点的flannel0虚拟网卡，然后被转发到目的主机的docker0虚拟网卡，最后就像本机容器通信一下的有docker0路由到达目标容 器。</li>\n</ol>\n<h3><span id=\"二实现说明\">（二）实现说明</span></h3>\n<h4><span id=\"1-udp封装\"><strong>1、UDP封装</strong></span></h4>\n<p>原始数据是在起始节点的Flannel服务上进行UDP封装的，投递到目的节点后就被另一端的Flannel服务还原成了原始的数据包，两边的Docker服务都感觉不到这个过程的存在。 UDP的数据内容部分其实是另一个ICMP（也就是ping命令）的数据包。</p>\n<p><img src=\"/img/article/flannel/UDP%E5%B0%81%E8%A3%85.png\" alt=\"UDP封装\"></p>\n<h4><span id=\"2-为docker分配不同的ip段\"><strong>2、为docker分配不同的IP段</strong></span></h4>\n<p>Flannel通过Etcd分配了每个节点可用的IP地址段后，偷偷的修改了Docker的启动参数。</p>\n<p><img src=\"/img/article/flannel/docker%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0.png\" alt=\"docker启动参数\"></p>\n<p>注意其中的“–bip=172.17.18.1/24”这个参数，它限制了所在节点容器获得的IP范围。</p>\n<p>这个IP范围是由Flannel自动分配的，由Flannel通过保存在Etcd服务中的记录确保它们不会重复。</p>\n<h4><span id=\"3-路由规则\"><strong>3、路由规则</strong></span></h4>\n<p>1）数据发送节点的路由表</p>\n<p><img src=\"/img/article/flannel/%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E8%8A%82%E7%82%B9%E8%B7%AF%E7%94%B1%E8%A1%A8.png\" alt=\"数据发送节点路由表\"></p>\n<p>2）数据接收节点的路由表</p>\n<p><img src=\"/img/article/flannel/%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E8%8A%82%E7%82%B9%E8%B7%AF%E7%94%B1%E8%A1%A8.png\" alt=\"数据接收节点路由表\"></p>\n<p>例如现在有一个数据包要从IP为172.17.18.2的容器发到IP为172.17.46.2的容器。根据数据发送节点的路由表，它只与 172.17.0.0/16匹配这条记录匹配，因此数据从docker0出来以后就被投递到了flannel0。同理在目标节点，由于投递的地址是一个容 器，因此目的地址一定会落在docker0对于的172.17.46.0/24这个记录上，自然的被投递到了docker0网卡。</p>\n<h3><span id=\"三flannel的安装与配置\">（三）flannel的安装与配置</span></h3>\n<h4><span id=\"1-安装\"><strong>1、安装</strong></span></h4>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http:<span class=\"comment\">//&lt;官网&gt;/flannel/flannel-0.2.0-10.el7.x86_64.rpm</span></div><div class=\"line\">yum localinstall -y flannel-<span class=\"number\">0.2</span>.<span class=\"number\">0</span>-<span class=\"number\">10</span><span class=\"selector-class\">.el7</span><span class=\"selector-class\">.x86_64</span><span class=\"selector-class\">.rpm</span></div></pre></td></tr></table></figure>\n<h4><span id=\"2-配置\"><strong>2、配置</strong></span></h4>\n<p>vi /etc/sysconfig/flanneld</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Flanneld configuration options</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> etcd url location. Point this to the server <span class=\"built_in\">where</span> etcd runs</span></div><div class=\"line\">FLANNEL_ETCD=\"http://127.0.0.1:4001\"</div><div class=\"line\">  </div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> etcd config key. This is the configuration key that flannel queries</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> For address range assignment</span></div><div class=\"line\">FLANNEL_ETCD_KEY=\"/wae/flannel/product/network\"</div><div class=\"line\">  </div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Any additional options that you want to pass</span></div><div class=\"line\">FLANNEL_OPTIONS=\" -iface=eth0\"</div></pre></td></tr></table></figure>\n<h4><span id=\"3-初始化flannel的etcd配置\"><strong>3、初始化flannel的etcd配置</strong></span></h4>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">etcdctl <span class=\"keyword\">set</span> <span class=\"string\">/wae/flannel/network/config</span> '&#123;</div><div class=\"line\">   <span class=\"string\">\"Network\"</span>: <span class=\"string\">\"10.0.0.0/16\"</span>,</div><div class=\"line\">   <span class=\"string\">\"Backend\"</span>: &#123;</div><div class=\"line\">       <span class=\"string\">\"Type\"</span>: <span class=\"string\">\"vxlan\"</span></div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;'</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2>一、flannel是什么（what）</h2>\n<h3>（一）概述</h3>\n<p>Flannel是CoreOS团队针对Kubernetes设计的一个网络规划服务，简单来说，它的功能是让集群中的不同节点主机创建的Docker容器都具有全集群唯一的虚拟IP地址。<br>\nFlannel官网：<a href=\"https://github.com/coreos/flannel\" target=\"_blank\" rel=\"external\">https://github.com/coreos/flannel</a></p>\n<h3>（二）补充知识点</h3>\n<h4><strong>1、覆盖网络[overlay network]</strong></h4>\n<p>运行在一个网上的网（应用层网络），并不依靠ip地址来传递消息，而是采用一种映射机制，把ip地址和identifiers做映射来资源定位。</p>\n<h4><strong>2、路由</strong></h4>\n<p>互联网是由路由器连接的网络组合而成，路由器按照路由表、路由协议等机制实现对数据包正确地转发，从而到达目标主机。路由器根据数据包中目标主机的IP地址和路由控制表比较得出下一个接收数据的路由器。</p>\n<p><strong>1）静态路由：事先设置好路由器和主机中的路由表信息。</strong></p>\n<p><img src=\"/img/article/flannel/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1.png\" alt=\"静态路由\"></p>\n<p><strong>2）动态路由：让路由协议在运行中自动修改并设置路由表信息。</strong></p>\n<p><img src=\"/img/article/flannel/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1.png\" alt=\"动态路由\"></p>\n<h2>二、为什么使用flannel（why）</h2>\n<p>在默认的Docker配置中，每个节点上的Docker服务会分别负责所在节点容器的IP分配。这样导致的一个问题是，不同节点上容器可能获得相同的内外IP地址。</p>\n<p>Flannel的设计目的就是为集群中的所有节点重新规划IP地址的使用规则，从而使得不同节点上的容器能够获得“同属一个内网”且”不重复的”IP地址，并让属于不同节点上的容器能够直接通过内网IP通信。</p>\n<h2>三、如何实现flannel（how）</h2>\n<p>Flannel实质上是一种“覆盖网络(overlay network)”，也就是将TCP数据包装在另一种网络包里面进行路由转发和通信，目前已经支持UDP、VxLAN、AWS VPC和GCE路由等数据转发方式，默认的节点间数据通信方式是UDP转发。</p>\n<h3>（一）flannel原理图</h3>\n<p><img src=\"/img/article%5Cflannel%5Cflannel.png\" alt=\"flannel\"></p>\n<ol>\n<li>数据从源容器中发出后，经由所在主机的docker0虚拟网卡转发到flannel0虚拟网卡，这是个P2P的虚拟网卡，flanneld服务监听在网卡的另外一端。</li>\n<li>Flannel通过Etcd服务维护了一张节点间的路由表。</li>\n<li>源主机的flanneld服务将原本的数据内容UDP封装后根据自己的路由表投递给目的节点的flanneld服务，数据到达以后被解包，然后直 接进入目的节点的flannel0虚拟网卡，然后被转发到目的主机的docker0虚拟网卡，最后就像本机容器通信一下的有docker0路由到达目标容 器。</li>\n</ol>\n<h3>（二）实现说明</h3>\n<h4><strong>1、UDP封装</strong></h4>\n<p>原始数据是在起始节点的Flannel服务上进行UDP封装的，投递到目的节点后就被另一端的Flannel服务还原成了原始的数据包，两边的Docker服务都感觉不到这个过程的存在。 UDP的数据内容部分其实是另一个ICMP（也就是ping命令）的数据包。</p>\n<p><img src=\"/img/article/flannel/UDP%E5%B0%81%E8%A3%85.png\" alt=\"UDP封装\"></p>\n<h4><strong>2、为docker分配不同的IP段</strong></h4>\n<p>Flannel通过Etcd分配了每个节点可用的IP地址段后，偷偷的修改了Docker的启动参数。</p>\n<p><img src=\"/img/article/flannel/docker%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0.png\" alt=\"docker启动参数\"></p>\n<p>注意其中的“–bip=172.17.18.1/24”这个参数，它限制了所在节点容器获得的IP范围。</p>\n<p>这个IP范围是由Flannel自动分配的，由Flannel通过保存在Etcd服务中的记录确保它们不会重复。</p>\n<h4><strong>3、路由规则</strong></h4>\n<p>1）数据发送节点的路由表</p>\n<p><img src=\"/img/article/flannel/%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E8%8A%82%E7%82%B9%E8%B7%AF%E7%94%B1%E8%A1%A8.png\" alt=\"数据发送节点路由表\"></p>\n<p>2）数据接收节点的路由表</p>\n<p><img src=\"/img/article/flannel/%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E8%8A%82%E7%82%B9%E8%B7%AF%E7%94%B1%E8%A1%A8.png\" alt=\"数据接收节点路由表\"></p>\n<p>例如现在有一个数据包要从IP为172.17.18.2的容器发到IP为172.17.46.2的容器。根据数据发送节点的路由表，它只与 172.17.0.0/16匹配这条记录匹配，因此数据从docker0出来以后就被投递到了flannel0。同理在目标节点，由于投递的地址是一个容 器，因此目的地址一定会落在docker0对于的172.17.46.0/24这个记录上，自然的被投递到了docker0网卡。</p>\n<h3>（三）flannel的安装与配置</h3>\n<h4><strong>1、安装</strong></h4>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http:<span class=\"comment\">//&lt;官网&gt;/flannel/flannel-0.2.0-10.el7.x86_64.rpm</span></div><div class=\"line\">yum localinstall -y flannel-<span class=\"number\">0.2</span>.<span class=\"number\">0</span>-<span class=\"number\">10</span><span class=\"selector-class\">.el7</span><span class=\"selector-class\">.x86_64</span><span class=\"selector-class\">.rpm</span></div></pre></td></tr></table></figure>\n<h4><strong>2、配置</strong></h4>\n<p>vi /etc/sysconfig/flanneld</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Flanneld configuration options</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> etcd url location. Point this to the server <span class=\"built_in\">where</span> etcd runs</span></div><div class=\"line\">FLANNEL_ETCD=\"http://127.0.0.1:4001\"</div><div class=\"line\">  </div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> etcd config key. This is the configuration key that flannel queries</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> For address range assignment</span></div><div class=\"line\">FLANNEL_ETCD_KEY=\"/wae/flannel/product/network\"</div><div class=\"line\">  </div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Any additional options that you want to pass</span></div><div class=\"line\">FLANNEL_OPTIONS=\" -iface=eth0\"</div></pre></td></tr></table></figure>\n<h4><strong>3、初始化flannel的etcd配置</strong></h4>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">etcdctl <span class=\"keyword\">set</span> <span class=\"string\">/wae/flannel/network/config</span> '&#123;</div><div class=\"line\">   <span class=\"string\">\"Network\"</span>: <span class=\"string\">\"10.0.0.0/16\"</span>,</div><div class=\"line\">   <span class=\"string\">\"Backend\"</span>: &#123;</div><div class=\"line\">       <span class=\"string\">\"Type\"</span>: <span class=\"string\">\"vxlan\"</span></div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;'</div></pre></td></tr></table></figure>\n"},{"title":"[Kubernetes] Kubernetes基本概念","catalog":true,"date":"2017-08-13T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Kubernetes"],"_content":"\n## 1. Master\n\n集群的控制节点，负责整个集群的管理和控制，kubernetes的所有的命令基本都是发给Master，由它来负责具体的执行过程。\n\n### 1.1. Master的组件\n\n- kube-apiserver：资源增删改查的入口\n- kube-controller-manager：资源对象的大总管\n- kube-scheduler：负责资源调度（Pod调度）\n- etcd Server:kubernetes的所有的资源对象的数据保存在etcd中。\n\n## 2. Node\n\nNode是集群的工作负载节点，默认情况kubelet会向Master注册自己，一旦Node被纳入集群管理范围，kubelet会定时向Master汇报自身的情报，包括操作系统，Docker版本，机器资源情况等。\n\n如果Node超过指定时间不上报信息，会被Master判断为“失联”，标记为Not Ready，随后Master会触发Pod转移。\n\n### 2.1. Node的组件\n\n- kubelet:Pod的管家，与Master通信\n- kube-proxy：实现kubernetes Service的通信与负载均衡机制的重要组件\n- Docker：容器的创建和管理\n\n### 2.2. Node相关命令\n\nkubectl get nodes\n\nkuebctl describe node {node_name}\n\n### 2.3. describe命令的Node信息\n\n- Node基本信息：名称、标签、创建时间等\n- Node当前的状态，Node启动后会进行自检工作，磁盘是否满，内存是否不足，若都正常则切换为Ready状态。\n- Node的主机地址与主机名\n- Node上的资源总量：CPU,内存，最大可调度Pod数量等\n- Node可分配资源量：当前Node可用于分配的资源量\n- 主机系统信息：主机唯一标识符UUID，Linux kernel版本号，操作系统，kubernetes版本，kubelet与kube-proxy版本\n- 当前正在运行的Pod列表及概要信息\n- 已分配的资源使用概要，例如资源申请的最低、最大允许使用量占系统总量的百分比\n- Node相关的Event信息。\n\n## 3. Pod\n\nPod是Kubernetes中操作的基本单元。每个Pod中有个根容器(Pause容器)，Pause容器的状态代表整个容器组的状态，其他业务容器共享Pause的IP，即Pod IP，共享Pause挂载的Volume，这样简化了同个Pod中不同容器之间的网络问题和文件共享问题。\n\n![pod](/img/article/kubernetes/k8s基本概念/pod.png)\n\n1. Kubernetes集群中，同宿主机的或不同宿主机的Pod之间要求能够TCP/IP直接通信，因此采用虚拟二层网络技术来实现，例如Flannel，Openvswitch(OVS)等，这样在同个集群中，不同的宿主机的Pod IP为不同IP段的IP，集群中的所有Pod IP都是唯一的，不同Pod之间可以直接通信。\n2. Pod有两种类型：普通Pod和静态Pod。静态Pod即不通过K8S调度和创建，直接在某个具体的Node机器上通过具体的文件来启动。普通Pod则是由K8S创建、调度，同时数据存放在ETCD中。\n3. Pod IP和具体的容器端口（ContainnerPort）组成一个具体的通信地址，即Endpoint。一个Pod中可以存在多个容器，可以有多个端口，Pod IP一样，即有多个Endpoint。\n4. Pod Volume是定义在Pod之上，被各个容器挂载到自己的文件系统中，可以用分布式文件系统实现后端存储功能。\n5. Pod中的Event事件可以用来排查问题，可以通过kubectl describe pod xxx 来查看对应的事件。\n6. 每个Pod可以对其能使用的服务器上的计算资源设置限额，一般为CPU和Memory。K8S中一般将千分之一个的CPU配置作为最小单位，用m表示，是一个绝对值，即100m对于一个Core的机器还是48个Core的机器都是一样的大小。Memory配额也是个绝对值，单位为内存字节数。\n7. 资源配额的两个参数\n\n- Requests:该资源的最小申请量，系统必须满足要求。\n- Limits:该资源最大允许使用量，当超过该量，K8S会kill并重启Pod。\n\n![pod2](/img/article/kubernetes/k8s基本概念/pod2.png)\n\n## 4. Label\n\n1. Label是一个键值对，可以附加在任何对象上，比如Node,Pod,Service,RC等。Label和资源对象是多对多的关系，即一个Label可以被添加到多个对象上，一个对象也可以定义多个Label。\n2. Label的作用主要用来实现精细的、多维度的资源分组管理，以便进行资源分配，调度，配置，部署等工作。\n3. Label通俗理解就是“标签”，通过标签来过滤筛选指定的对象，进行具体的操作。k8s通过Label Selector(标签选择器)来筛选指定Label的资源对象，类似SQL语句中的条件查询（WHERE语句）。\n4. Label Selector有基于等式和基于集合的两种表达方式，可以多个条件进行组合使用。\n\n- 基于等式：name=redis-slave（匹配name=redis-slave的资源对象）;env!=product(匹配所有不具有标签env=product的资源对象)\n- 基于集合：name in (redis-slave,redis-master);name not in (php-frontend)（匹配所有不具有标签name=php-frontend的资源对象）\n\n**使用场景**\n\n1. kube-controller进程通过资源对象RC上定义的Label Selector来筛选要监控的Pod副本数，从而实现副本数始终保持预期数目。\n2. kube-proxy进程通过Service的Label Selector来选择对应Pod，自动建立每个Service到对应Pod的请求转发路由表，从而实现Service的智能负载均衡机制。\n3. kube-scheduler实现Pod定向调度：对Node定义特定的Label，并且在Pod定义文件中使用NodeSelector标签调度策略。\n\n## 5. Replication Controller(RC)\n\nRC是k8s系统中的核心概念，定义了一个期望的场景。\n\n主要包括：\n\n- Pod期望的副本数（replicas）\n- 用于筛选目标Pod的Label Selector\n- 用于创建Pod的模板（template）\n\nRC特性说明：\n\n1. Pod的缩放可以通过以下命令实现：kubectl scale rc redis-slave --replicas=3\n2. 删除RC并不会删除该RC创建的Pod，可以将副本数设置为0，即可删除对应Pod。或者通过kubectl stop /delete命令来一次性删除RC和其创建的Pod。\n3. 改变RC中Pod模板的镜像版本可以实现滚动升级（Rolling Update）。具体操作见[https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/](https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/)\n4. Kubernetes1.2以上版本将RC升级为Replica Set，它与当前RC的唯一区别在于Replica Set支持基于集合的Label Selector(Set-based selector)，而旧版本RC只支持基于等式的Label Selector(equality-based selector)。\n5. Kubernetes1.2以上版本通过Deployment来维护Replica Set而不是单独使用Replica Set。即控制流为：Delpoyment→Replica Set→Pod。即新版本的Deployment+Replica Set替代了RC的作用。\n\n## 6. Deployment\n\nDeployment是kubernetes 1.2引入的概念，用来解决Pod的编排问题。Deployment可以理解为RC的升级版（RC+Reolicat Set）。特点在于可以随时知道Pod的部署进度，即对Pod的创建、调度、绑定节点、启动容器完整过程的进度展示。\n\n**使用场景**\n\n1. 创建一个Deployment对象来生成对应的Replica Set并完成Pod副本的创建过程。\n2. 检查Deployment的状态来确认部署动作是否完成（Pod副本的数量是否达到预期值）。\n3. 更新Deployment以创建新的Pod(例如镜像升级的场景)。\n4. 如果当前Deployment不稳定，回退到上一个Deployment版本。\n5. 挂起或恢复一个Deployment。\n\n可以通过kubectl describe deployment来查看Deployment控制的Pod的水平拓展过程。\n\n## 7. Horizontal Pod Autoscaler(HPA)\n\nHorizontal Pod Autoscaler(HPA)即Pod横向自动扩容，与RC一样也属于k8s的资源对象。\n\nHPA原理：通过追踪分析RC控制的所有目标Pod的负载变化情况，来确定是否针对性调整Pod的副本数。\n\nPod负载度量指标：\n\n- CPUUtilizationPercentage：Pod所有副本自身的CPU利用率的平均值。即当前Pod的CPU使用量除以Pod Request的值。\n- 应用自定义的度量指标，比如服务每秒内响应的请求数（TPS/QPS）。\n\n## 8. Service(服务)\n\n### 8.1. Service概述\n\n![service](/img/article/kubernetes/k8s基本概念/service.png)\n\nService定义了一个服务的访问入口地址，前端应用通过这个入口地址访问其背后的一组由Pod副本组成的集群实例，Service与其后端的Pod副本集群之间是通过Label Selector来实现“无缝对接”。RC保证Service的Pod副本实例数目保持预期水平。\n\n### 8.2. kubernetes的服务发现机制\n\n主要通过kube-dns这个组件来进行DNS方式的服务发现。\n\n### 8.3. 外部系统访问Service的问题\n\n| IP类型       | 说明           |\n| ---------- | ------------ |\n| Node IP    | Node节点的IP地址  |\n| Pod IP     | Pod的IP地址     |\n| Cluster IP | Service的IP地址 |\n\n#### 8.3.1. Node IP\n\nNodeIP是集群中每个节点的物理网卡IP地址，是真实存在的物理网络，kubernetes集群之外的节点访问kubernetes内的某个节点或TCP/IP服务的时候，需要通过NodeIP进行通信。\n\n#### 8.3.2. Pod IP\n\nPod IP是每个Pod的IP地址，是Docker Engine根据docker0网桥的IP段地址进行分配的，是一个虚拟二层网络，集群中一个Pod的容器访问另一个Pod中的容器，是通过Pod IP进行通信的，而真实的TCP/IP流量是通过Node IP所在的网卡流出的。\n\n#### 8.3.3. Cluster IP\n\n1. Service的Cluster IP是一个虚拟IP，只作用于Service这个对象，由kubernetes管理和分配IP地址（来源于Cluster IP地址池）。\n2. Cluster IP无法被ping通，因为没有一个实体网络对象来响应。\n3. Cluster IP结合Service Port组成的具体通信端口才具备TCP/IP通信基础，属于kubernetes集群内，集群外访问该IP和端口需要额外处理。\n4. k8s集群内Node IP 、Pod IP、Cluster IP之间的通信采取k8s自己的特殊的路由规则，与传统IP路由不同。\n\n#### 8.3.4. 外部访问Kubernetes集群\n\n通过宿主机与容器端口映射的方式进行访问，例如：Service定位文件如下：\n\n可以通过任意Node的IP 加端口访问该服务。也可以通过Nginx或HAProxy来设置负载均衡。\n\n## 9. Volume(存储卷)\n\n### 9.1. Volume的功能\n\n1. Volume是Pod中能够被多个容器访问的共享目录，可以让容器的数据写到宿主机上或者写文件到网络存储中\n2. 可以实现容器配置文件集中化定义与管理，通过ConfigMap资源对象来实现。\n\n### 9.2. Volume的特点\n\nk8s中的Volume与Docker的Volume相似，但不完全相同。\n\n1. k8s上Volume定义在Pod上，然后被一个Pod中的多个容器挂载到具体的文件目录下。\n2. k8s的Volume与Pod生命周期相关而不是容器是生命周期，即容器挂掉，数据不会丢失但是Pod挂掉，数据则会丢失。\n3. k8s中的Volume支持多种类型的Volume：Ceph、GlusterFS等分布式系统。\n\n### 9.3. Volume的使用方式\n\n先在Pod上声明一个Volume，然后容器引用该Volume并Mount到容器的某个目录。\n\n### 9.4. Volume类型\n\n#### 9.4.1. emptyDir\n\nemptyDir Volume是在Pod分配到Node时创建的，初始内容为空，无须指定宿主机上对应的目录文件，由K8S自动分配一个目录，当Pod被删除时，对应的emptyDir数据也会永久删除。\n\n**作用**：\n\n1. 临时空间，例如程序的临时文件，无须永久保留\n2. 长时间任务的中间过程CheckPoint的临时保存目录\n3. 一个容器需要从另一个容器中获取数据的目录（即多容器共享目录）\n\n**说明**：\n\n目前用户无法设置emptyVolume的使用介质，如果kubelet的配置使用硬盘则emptyDir将创建在该硬盘上。\n\n#### 9.4.2. hostPath\n\nhostPath是在Pod上挂载宿主机上的文件或目录。\n\n**作用**：\n\n1. 容器应用日志需要持久化时，可以使用宿主机的高速文件系统进行存储\n2. 需要访问宿主机上Docker引擎内部数据结构的容器应用时，可以通过定义hostPath为宿主机/var/lib/docker目录，使容器内部应用可以直接访问Docker的文件系统。\n\n**注意点：**\n\n1. 在不同的Node上具有相同配置的Pod可能会因为宿主机上的目录或文件不同导致对Volume上目录或文件的访问结果不一致。\n2. 如果使用了资源配额管理，则kubernetes无法将hostPath在宿主机上使用的资源纳入管理。\n\n#### 9.4.3. gcePersistentDisk\n\n表示使用谷歌公有云提供的永久磁盘（Persistent Disk ,PD）存放Volume的数据，它与EmptyDir不同，PD上的内容会被永久保存。当Pod被删除时，PD只是被卸载时，但不会被删除。需要先创建一个永久磁盘，才能使用gcePersistentDisk。\n\n使用gcePersistentDisk的限制条件：\n\n- Node(运行kubelet的节点)需要是GCE虚拟机。\n- 虚拟机需要与PD存在于相同的GCE项目中和Zone中。\n\n## 10. Persistent Volume\n\nVolume定义在Pod上，属于“计算资源”的一部分，而Persistent Volume和Persistent Volume Claim是网络存储，简称PV和PVC，可以理解为k8s集群中某个网络存储中对应的一块存储。\n\n- PV是网络存储，不属于任何Node，但可以在每个Node上访问。\n- PV不是定义在Pod上，而是独立于Pod之外定义。\n- PV常见类型：GCE Persistent Disks、NFS、RBD等。\n\nPV是有状态的对象，状态类型如下：\n\n- Available:空闲状态\n- Bound:已经绑定到某个PVC上\n- Released:对应的PVC已经删除，但资源还没有回收\n- Failed:PV自动回收失败\n\n## 11. Namespace\n\nNamespace即命名空间，主要用于多租户的资源隔离，通过将资源对象分配到不同的Namespace上，便于不同的分组在共享资源的同时可以被分别管理。\n\nk8s集群启动后会默认创建一个“default”的Namespace。可以通过kubectl get namespaecs查看。\n\n可以通过kubectl config use-context `namespace`配置当前k8s客户端的环境，通过kubectl get pods获取当前namespace的Pod。或者通过kubectl get pods --namespace=`NAMESPACE`来获取指定namespace的Pod。\n\n**Namespace yaml文件的定义**\n\n## 12. Annotation(注解)\n\nAnnotation与Label类似，也使用key/value的形式进行定义，Label定义元数据（Metadata）,Annotation定义“附加”信息。\n\n通常Annotation记录信息如下：\n\n- build信息，release信息，Docker镜像信息等。\n- 日志库、监控库等。\n\n\n\n参考《Kubernetes权威指南》","source":"_posts/Kubernetes/Kubernetes基本概念.md","raw":"---\ntitle: \"[Kubernetes] Kubernetes基本概念\"\ncatalog: true\ndate: 2017-08-13 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Kubernetes\ncatagories:\n- Kubernetes\n---\n\n## 1. Master\n\n集群的控制节点，负责整个集群的管理和控制，kubernetes的所有的命令基本都是发给Master，由它来负责具体的执行过程。\n\n### 1.1. Master的组件\n\n- kube-apiserver：资源增删改查的入口\n- kube-controller-manager：资源对象的大总管\n- kube-scheduler：负责资源调度（Pod调度）\n- etcd Server:kubernetes的所有的资源对象的数据保存在etcd中。\n\n## 2. Node\n\nNode是集群的工作负载节点，默认情况kubelet会向Master注册自己，一旦Node被纳入集群管理范围，kubelet会定时向Master汇报自身的情报，包括操作系统，Docker版本，机器资源情况等。\n\n如果Node超过指定时间不上报信息，会被Master判断为“失联”，标记为Not Ready，随后Master会触发Pod转移。\n\n### 2.1. Node的组件\n\n- kubelet:Pod的管家，与Master通信\n- kube-proxy：实现kubernetes Service的通信与负载均衡机制的重要组件\n- Docker：容器的创建和管理\n\n### 2.2. Node相关命令\n\nkubectl get nodes\n\nkuebctl describe node {node_name}\n\n### 2.3. describe命令的Node信息\n\n- Node基本信息：名称、标签、创建时间等\n- Node当前的状态，Node启动后会进行自检工作，磁盘是否满，内存是否不足，若都正常则切换为Ready状态。\n- Node的主机地址与主机名\n- Node上的资源总量：CPU,内存，最大可调度Pod数量等\n- Node可分配资源量：当前Node可用于分配的资源量\n- 主机系统信息：主机唯一标识符UUID，Linux kernel版本号，操作系统，kubernetes版本，kubelet与kube-proxy版本\n- 当前正在运行的Pod列表及概要信息\n- 已分配的资源使用概要，例如资源申请的最低、最大允许使用量占系统总量的百分比\n- Node相关的Event信息。\n\n## 3. Pod\n\nPod是Kubernetes中操作的基本单元。每个Pod中有个根容器(Pause容器)，Pause容器的状态代表整个容器组的状态，其他业务容器共享Pause的IP，即Pod IP，共享Pause挂载的Volume，这样简化了同个Pod中不同容器之间的网络问题和文件共享问题。\n\n![pod](/img/article/kubernetes/k8s基本概念/pod.png)\n\n1. Kubernetes集群中，同宿主机的或不同宿主机的Pod之间要求能够TCP/IP直接通信，因此采用虚拟二层网络技术来实现，例如Flannel，Openvswitch(OVS)等，这样在同个集群中，不同的宿主机的Pod IP为不同IP段的IP，集群中的所有Pod IP都是唯一的，不同Pod之间可以直接通信。\n2. Pod有两种类型：普通Pod和静态Pod。静态Pod即不通过K8S调度和创建，直接在某个具体的Node机器上通过具体的文件来启动。普通Pod则是由K8S创建、调度，同时数据存放在ETCD中。\n3. Pod IP和具体的容器端口（ContainnerPort）组成一个具体的通信地址，即Endpoint。一个Pod中可以存在多个容器，可以有多个端口，Pod IP一样，即有多个Endpoint。\n4. Pod Volume是定义在Pod之上，被各个容器挂载到自己的文件系统中，可以用分布式文件系统实现后端存储功能。\n5. Pod中的Event事件可以用来排查问题，可以通过kubectl describe pod xxx 来查看对应的事件。\n6. 每个Pod可以对其能使用的服务器上的计算资源设置限额，一般为CPU和Memory。K8S中一般将千分之一个的CPU配置作为最小单位，用m表示，是一个绝对值，即100m对于一个Core的机器还是48个Core的机器都是一样的大小。Memory配额也是个绝对值，单位为内存字节数。\n7. 资源配额的两个参数\n\n- Requests:该资源的最小申请量，系统必须满足要求。\n- Limits:该资源最大允许使用量，当超过该量，K8S会kill并重启Pod。\n\n![pod2](/img/article/kubernetes/k8s基本概念/pod2.png)\n\n## 4. Label\n\n1. Label是一个键值对，可以附加在任何对象上，比如Node,Pod,Service,RC等。Label和资源对象是多对多的关系，即一个Label可以被添加到多个对象上，一个对象也可以定义多个Label。\n2. Label的作用主要用来实现精细的、多维度的资源分组管理，以便进行资源分配，调度，配置，部署等工作。\n3. Label通俗理解就是“标签”，通过标签来过滤筛选指定的对象，进行具体的操作。k8s通过Label Selector(标签选择器)来筛选指定Label的资源对象，类似SQL语句中的条件查询（WHERE语句）。\n4. Label Selector有基于等式和基于集合的两种表达方式，可以多个条件进行组合使用。\n\n- 基于等式：name=redis-slave（匹配name=redis-slave的资源对象）;env!=product(匹配所有不具有标签env=product的资源对象)\n- 基于集合：name in (redis-slave,redis-master);name not in (php-frontend)（匹配所有不具有标签name=php-frontend的资源对象）\n\n**使用场景**\n\n1. kube-controller进程通过资源对象RC上定义的Label Selector来筛选要监控的Pod副本数，从而实现副本数始终保持预期数目。\n2. kube-proxy进程通过Service的Label Selector来选择对应Pod，自动建立每个Service到对应Pod的请求转发路由表，从而实现Service的智能负载均衡机制。\n3. kube-scheduler实现Pod定向调度：对Node定义特定的Label，并且在Pod定义文件中使用NodeSelector标签调度策略。\n\n## 5. Replication Controller(RC)\n\nRC是k8s系统中的核心概念，定义了一个期望的场景。\n\n主要包括：\n\n- Pod期望的副本数（replicas）\n- 用于筛选目标Pod的Label Selector\n- 用于创建Pod的模板（template）\n\nRC特性说明：\n\n1. Pod的缩放可以通过以下命令实现：kubectl scale rc redis-slave --replicas=3\n2. 删除RC并不会删除该RC创建的Pod，可以将副本数设置为0，即可删除对应Pod。或者通过kubectl stop /delete命令来一次性删除RC和其创建的Pod。\n3. 改变RC中Pod模板的镜像版本可以实现滚动升级（Rolling Update）。具体操作见[https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/](https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/)\n4. Kubernetes1.2以上版本将RC升级为Replica Set，它与当前RC的唯一区别在于Replica Set支持基于集合的Label Selector(Set-based selector)，而旧版本RC只支持基于等式的Label Selector(equality-based selector)。\n5. Kubernetes1.2以上版本通过Deployment来维护Replica Set而不是单独使用Replica Set。即控制流为：Delpoyment→Replica Set→Pod。即新版本的Deployment+Replica Set替代了RC的作用。\n\n## 6. Deployment\n\nDeployment是kubernetes 1.2引入的概念，用来解决Pod的编排问题。Deployment可以理解为RC的升级版（RC+Reolicat Set）。特点在于可以随时知道Pod的部署进度，即对Pod的创建、调度、绑定节点、启动容器完整过程的进度展示。\n\n**使用场景**\n\n1. 创建一个Deployment对象来生成对应的Replica Set并完成Pod副本的创建过程。\n2. 检查Deployment的状态来确认部署动作是否完成（Pod副本的数量是否达到预期值）。\n3. 更新Deployment以创建新的Pod(例如镜像升级的场景)。\n4. 如果当前Deployment不稳定，回退到上一个Deployment版本。\n5. 挂起或恢复一个Deployment。\n\n可以通过kubectl describe deployment来查看Deployment控制的Pod的水平拓展过程。\n\n## 7. Horizontal Pod Autoscaler(HPA)\n\nHorizontal Pod Autoscaler(HPA)即Pod横向自动扩容，与RC一样也属于k8s的资源对象。\n\nHPA原理：通过追踪分析RC控制的所有目标Pod的负载变化情况，来确定是否针对性调整Pod的副本数。\n\nPod负载度量指标：\n\n- CPUUtilizationPercentage：Pod所有副本自身的CPU利用率的平均值。即当前Pod的CPU使用量除以Pod Request的值。\n- 应用自定义的度量指标，比如服务每秒内响应的请求数（TPS/QPS）。\n\n## 8. Service(服务)\n\n### 8.1. Service概述\n\n![service](/img/article/kubernetes/k8s基本概念/service.png)\n\nService定义了一个服务的访问入口地址，前端应用通过这个入口地址访问其背后的一组由Pod副本组成的集群实例，Service与其后端的Pod副本集群之间是通过Label Selector来实现“无缝对接”。RC保证Service的Pod副本实例数目保持预期水平。\n\n### 8.2. kubernetes的服务发现机制\n\n主要通过kube-dns这个组件来进行DNS方式的服务发现。\n\n### 8.3. 外部系统访问Service的问题\n\n| IP类型       | 说明           |\n| ---------- | ------------ |\n| Node IP    | Node节点的IP地址  |\n| Pod IP     | Pod的IP地址     |\n| Cluster IP | Service的IP地址 |\n\n#### 8.3.1. Node IP\n\nNodeIP是集群中每个节点的物理网卡IP地址，是真实存在的物理网络，kubernetes集群之外的节点访问kubernetes内的某个节点或TCP/IP服务的时候，需要通过NodeIP进行通信。\n\n#### 8.3.2. Pod IP\n\nPod IP是每个Pod的IP地址，是Docker Engine根据docker0网桥的IP段地址进行分配的，是一个虚拟二层网络，集群中一个Pod的容器访问另一个Pod中的容器，是通过Pod IP进行通信的，而真实的TCP/IP流量是通过Node IP所在的网卡流出的。\n\n#### 8.3.3. Cluster IP\n\n1. Service的Cluster IP是一个虚拟IP，只作用于Service这个对象，由kubernetes管理和分配IP地址（来源于Cluster IP地址池）。\n2. Cluster IP无法被ping通，因为没有一个实体网络对象来响应。\n3. Cluster IP结合Service Port组成的具体通信端口才具备TCP/IP通信基础，属于kubernetes集群内，集群外访问该IP和端口需要额外处理。\n4. k8s集群内Node IP 、Pod IP、Cluster IP之间的通信采取k8s自己的特殊的路由规则，与传统IP路由不同。\n\n#### 8.3.4. 外部访问Kubernetes集群\n\n通过宿主机与容器端口映射的方式进行访问，例如：Service定位文件如下：\n\n可以通过任意Node的IP 加端口访问该服务。也可以通过Nginx或HAProxy来设置负载均衡。\n\n## 9. Volume(存储卷)\n\n### 9.1. Volume的功能\n\n1. Volume是Pod中能够被多个容器访问的共享目录，可以让容器的数据写到宿主机上或者写文件到网络存储中\n2. 可以实现容器配置文件集中化定义与管理，通过ConfigMap资源对象来实现。\n\n### 9.2. Volume的特点\n\nk8s中的Volume与Docker的Volume相似，但不完全相同。\n\n1. k8s上Volume定义在Pod上，然后被一个Pod中的多个容器挂载到具体的文件目录下。\n2. k8s的Volume与Pod生命周期相关而不是容器是生命周期，即容器挂掉，数据不会丢失但是Pod挂掉，数据则会丢失。\n3. k8s中的Volume支持多种类型的Volume：Ceph、GlusterFS等分布式系统。\n\n### 9.3. Volume的使用方式\n\n先在Pod上声明一个Volume，然后容器引用该Volume并Mount到容器的某个目录。\n\n### 9.4. Volume类型\n\n#### 9.4.1. emptyDir\n\nemptyDir Volume是在Pod分配到Node时创建的，初始内容为空，无须指定宿主机上对应的目录文件，由K8S自动分配一个目录，当Pod被删除时，对应的emptyDir数据也会永久删除。\n\n**作用**：\n\n1. 临时空间，例如程序的临时文件，无须永久保留\n2. 长时间任务的中间过程CheckPoint的临时保存目录\n3. 一个容器需要从另一个容器中获取数据的目录（即多容器共享目录）\n\n**说明**：\n\n目前用户无法设置emptyVolume的使用介质，如果kubelet的配置使用硬盘则emptyDir将创建在该硬盘上。\n\n#### 9.4.2. hostPath\n\nhostPath是在Pod上挂载宿主机上的文件或目录。\n\n**作用**：\n\n1. 容器应用日志需要持久化时，可以使用宿主机的高速文件系统进行存储\n2. 需要访问宿主机上Docker引擎内部数据结构的容器应用时，可以通过定义hostPath为宿主机/var/lib/docker目录，使容器内部应用可以直接访问Docker的文件系统。\n\n**注意点：**\n\n1. 在不同的Node上具有相同配置的Pod可能会因为宿主机上的目录或文件不同导致对Volume上目录或文件的访问结果不一致。\n2. 如果使用了资源配额管理，则kubernetes无法将hostPath在宿主机上使用的资源纳入管理。\n\n#### 9.4.3. gcePersistentDisk\n\n表示使用谷歌公有云提供的永久磁盘（Persistent Disk ,PD）存放Volume的数据，它与EmptyDir不同，PD上的内容会被永久保存。当Pod被删除时，PD只是被卸载时，但不会被删除。需要先创建一个永久磁盘，才能使用gcePersistentDisk。\n\n使用gcePersistentDisk的限制条件：\n\n- Node(运行kubelet的节点)需要是GCE虚拟机。\n- 虚拟机需要与PD存在于相同的GCE项目中和Zone中。\n\n## 10. Persistent Volume\n\nVolume定义在Pod上，属于“计算资源”的一部分，而Persistent Volume和Persistent Volume Claim是网络存储，简称PV和PVC，可以理解为k8s集群中某个网络存储中对应的一块存储。\n\n- PV是网络存储，不属于任何Node，但可以在每个Node上访问。\n- PV不是定义在Pod上，而是独立于Pod之外定义。\n- PV常见类型：GCE Persistent Disks、NFS、RBD等。\n\nPV是有状态的对象，状态类型如下：\n\n- Available:空闲状态\n- Bound:已经绑定到某个PVC上\n- Released:对应的PVC已经删除，但资源还没有回收\n- Failed:PV自动回收失败\n\n## 11. Namespace\n\nNamespace即命名空间，主要用于多租户的资源隔离，通过将资源对象分配到不同的Namespace上，便于不同的分组在共享资源的同时可以被分别管理。\n\nk8s集群启动后会默认创建一个“default”的Namespace。可以通过kubectl get namespaecs查看。\n\n可以通过kubectl config use-context `namespace`配置当前k8s客户端的环境，通过kubectl get pods获取当前namespace的Pod。或者通过kubectl get pods --namespace=`NAMESPACE`来获取指定namespace的Pod。\n\n**Namespace yaml文件的定义**\n\n## 12. Annotation(注解)\n\nAnnotation与Label类似，也使用key/value的形式进行定义，Label定义元数据（Metadata）,Annotation定义“附加”信息。\n\n通常Annotation记录信息如下：\n\n- build信息，release信息，Docker镜像信息等。\n- 日志库、监控库等。\n\n\n\n参考《Kubernetes权威指南》","slug":"Kubernetes/Kubernetes基本概念","published":1,"updated":"2017-10-02T11:13:18.397Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740hd000d30vu7l4vcit4","content":"<h2><span id=\"1-master\">1. Master</span></h2>\n<p>集群的控制节点，负责整个集群的管理和控制，kubernetes的所有的命令基本都是发给Master，由它来负责具体的执行过程。</p>\n<h3><span id=\"11-master的组件\">1.1. Master的组件</span></h3>\n<ul>\n<li>kube-apiserver：资源增删改查的入口</li>\n<li>kube-controller-manager：资源对象的大总管</li>\n<li>kube-scheduler：负责资源调度（Pod调度）</li>\n<li>etcd Server:kubernetes的所有的资源对象的数据保存在etcd中。</li>\n</ul>\n<h2><span id=\"2-node\">2. Node</span></h2>\n<p>Node是集群的工作负载节点，默认情况kubelet会向Master注册自己，一旦Node被纳入集群管理范围，kubelet会定时向Master汇报自身的情报，包括操作系统，Docker版本，机器资源情况等。</p>\n<p>如果Node超过指定时间不上报信息，会被Master判断为“失联”，标记为Not Ready，随后Master会触发Pod转移。</p>\n<h3><span id=\"21-node的组件\">2.1. Node的组件</span></h3>\n<ul>\n<li>kubelet:Pod的管家，与Master通信</li>\n<li>kube-proxy：实现kubernetes Service的通信与负载均衡机制的重要组件</li>\n<li>Docker：容器的创建和管理</li>\n</ul>\n<h3><span id=\"22-node相关命令\">2.2. Node相关命令</span></h3>\n<p>kubectl get nodes</p>\n<p>kuebctl describe node {node_name}</p>\n<h3><span id=\"23-describe命令的node信息\">2.3. describe命令的Node信息</span></h3>\n<ul>\n<li>Node基本信息：名称、标签、创建时间等</li>\n<li>Node当前的状态，Node启动后会进行自检工作，磁盘是否满，内存是否不足，若都正常则切换为Ready状态。</li>\n<li>Node的主机地址与主机名</li>\n<li>Node上的资源总量：CPU,内存，最大可调度Pod数量等</li>\n<li>Node可分配资源量：当前Node可用于分配的资源量</li>\n<li>主机系统信息：主机唯一标识符UUID，Linux kernel版本号，操作系统，kubernetes版本，kubelet与kube-proxy版本</li>\n<li>当前正在运行的Pod列表及概要信息</li>\n<li>已分配的资源使用概要，例如资源申请的最低、最大允许使用量占系统总量的百分比</li>\n<li>Node相关的Event信息。</li>\n</ul>\n<h2><span id=\"3-pod\">3. Pod</span></h2>\n<p>Pod是Kubernetes中操作的基本单元。每个Pod中有个根容器(Pause容器)，Pause容器的状态代表整个容器组的状态，其他业务容器共享Pause的IP，即Pod IP，共享Pause挂载的Volume，这样简化了同个Pod中不同容器之间的网络问题和文件共享问题。</p>\n<p><img src=\"/img/article/kubernetes/k8s%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/pod.png\" alt=\"pod\"></p>\n<ol>\n<li>Kubernetes集群中，同宿主机的或不同宿主机的Pod之间要求能够TCP/IP直接通信，因此采用虚拟二层网络技术来实现，例如Flannel，Openvswitch(OVS)等，这样在同个集群中，不同的宿主机的Pod IP为不同IP段的IP，集群中的所有Pod IP都是唯一的，不同Pod之间可以直接通信。</li>\n<li>Pod有两种类型：普通Pod和静态Pod。静态Pod即不通过K8S调度和创建，直接在某个具体的Node机器上通过具体的文件来启动。普通Pod则是由K8S创建、调度，同时数据存放在ETCD中。</li>\n<li>Pod IP和具体的容器端口（ContainnerPort）组成一个具体的通信地址，即Endpoint。一个Pod中可以存在多个容器，可以有多个端口，Pod IP一样，即有多个Endpoint。</li>\n<li>Pod Volume是定义在Pod之上，被各个容器挂载到自己的文件系统中，可以用分布式文件系统实现后端存储功能。</li>\n<li>Pod中的Event事件可以用来排查问题，可以通过kubectl describe pod xxx 来查看对应的事件。</li>\n<li>每个Pod可以对其能使用的服务器上的计算资源设置限额，一般为CPU和Memory。K8S中一般将千分之一个的CPU配置作为最小单位，用m表示，是一个绝对值，即100m对于一个Core的机器还是48个Core的机器都是一样的大小。Memory配额也是个绝对值，单位为内存字节数。</li>\n<li>资源配额的两个参数</li>\n</ol>\n<ul>\n<li>Requests:该资源的最小申请量，系统必须满足要求。</li>\n<li>Limits:该资源最大允许使用量，当超过该量，K8S会kill并重启Pod。</li>\n</ul>\n<p><img src=\"/img/article/kubernetes/k8s%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/pod2.png\" alt=\"pod2\"></p>\n<h2><span id=\"4-label\">4. Label</span></h2>\n<ol>\n<li>Label是一个键值对，可以附加在任何对象上，比如Node,Pod,Service,RC等。Label和资源对象是多对多的关系，即一个Label可以被添加到多个对象上，一个对象也可以定义多个Label。</li>\n<li>Label的作用主要用来实现精细的、多维度的资源分组管理，以便进行资源分配，调度，配置，部署等工作。</li>\n<li>Label通俗理解就是“标签”，通过标签来过滤筛选指定的对象，进行具体的操作。k8s通过Label Selector(标签选择器)来筛选指定Label的资源对象，类似SQL语句中的条件查询（WHERE语句）。</li>\n<li>Label Selector有基于等式和基于集合的两种表达方式，可以多个条件进行组合使用。</li>\n</ol>\n<ul>\n<li>基于等式：name=redis-slave（匹配name=redis-slave的资源对象）;env!=product(匹配所有不具有标签env=product的资源对象)</li>\n<li>基于集合：name in (redis-slave,redis-master);name not in (php-frontend)（匹配所有不具有标签name=php-frontend的资源对象）</li>\n</ul>\n<p><strong>使用场景</strong></p>\n<ol>\n<li>kube-controller进程通过资源对象RC上定义的Label Selector来筛选要监控的Pod副本数，从而实现副本数始终保持预期数目。</li>\n<li>kube-proxy进程通过Service的Label Selector来选择对应Pod，自动建立每个Service到对应Pod的请求转发路由表，从而实现Service的智能负载均衡机制。</li>\n<li>kube-scheduler实现Pod定向调度：对Node定义特定的Label，并且在Pod定义文件中使用NodeSelector标签调度策略。</li>\n</ol>\n<h2><span id=\"5-replication-controllerrc\">5. Replication Controller(RC)</span></h2>\n<p>RC是k8s系统中的核心概念，定义了一个期望的场景。</p>\n<p>主要包括：</p>\n<ul>\n<li>Pod期望的副本数（replicas）</li>\n<li>用于筛选目标Pod的Label Selector</li>\n<li>用于创建Pod的模板（template）</li>\n</ul>\n<p>RC特性说明：</p>\n<ol>\n<li>Pod的缩放可以通过以下命令实现：kubectl scale rc redis-slave --replicas=3</li>\n<li>删除RC并不会删除该RC创建的Pod，可以将副本数设置为0，即可删除对应Pod。或者通过kubectl stop /delete命令来一次性删除RC和其创建的Pod。</li>\n<li>改变RC中Pod模板的镜像版本可以实现滚动升级（Rolling Update）。具体操作见<a href=\"https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/\" target=\"_blank\" rel=\"external\">https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/</a></li>\n<li>Kubernetes1.2以上版本将RC升级为Replica Set，它与当前RC的唯一区别在于Replica Set支持基于集合的Label Selector(Set-based selector)，而旧版本RC只支持基于等式的Label Selector(equality-based selector)。</li>\n<li>Kubernetes1.2以上版本通过Deployment来维护Replica Set而不是单独使用Replica Set。即控制流为：Delpoyment→Replica Set→Pod。即新版本的Deployment+Replica Set替代了RC的作用。</li>\n</ol>\n<h2><span id=\"6-deployment\">6. Deployment</span></h2>\n<p>Deployment是kubernetes 1.2引入的概念，用来解决Pod的编排问题。Deployment可以理解为RC的升级版（RC+Reolicat Set）。特点在于可以随时知道Pod的部署进度，即对Pod的创建、调度、绑定节点、启动容器完整过程的进度展示。</p>\n<p><strong>使用场景</strong></p>\n<ol>\n<li>创建一个Deployment对象来生成对应的Replica Set并完成Pod副本的创建过程。</li>\n<li>检查Deployment的状态来确认部署动作是否完成（Pod副本的数量是否达到预期值）。</li>\n<li>更新Deployment以创建新的Pod(例如镜像升级的场景)。</li>\n<li>如果当前Deployment不稳定，回退到上一个Deployment版本。</li>\n<li>挂起或恢复一个Deployment。</li>\n</ol>\n<p>可以通过kubectl describe deployment来查看Deployment控制的Pod的水平拓展过程。</p>\n<h2><span id=\"7-horizontal-pod-autoscalerhpa\">7. Horizontal Pod Autoscaler(HPA)</span></h2>\n<p>Horizontal Pod Autoscaler(HPA)即Pod横向自动扩容，与RC一样也属于k8s的资源对象。</p>\n<p>HPA原理：通过追踪分析RC控制的所有目标Pod的负载变化情况，来确定是否针对性调整Pod的副本数。</p>\n<p>Pod负载度量指标：</p>\n<ul>\n<li>CPUUtilizationPercentage：Pod所有副本自身的CPU利用率的平均值。即当前Pod的CPU使用量除以Pod Request的值。</li>\n<li>应用自定义的度量指标，比如服务每秒内响应的请求数（TPS/QPS）。</li>\n</ul>\n<h2><span id=\"8-service服务\">8. Service(服务)</span></h2>\n<h3><span id=\"81-service概述\">8.1. Service概述</span></h3>\n<p><img src=\"/img/article/kubernetes/k8s%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/service.png\" alt=\"service\"></p>\n<p>Service定义了一个服务的访问入口地址，前端应用通过这个入口地址访问其背后的一组由Pod副本组成的集群实例，Service与其后端的Pod副本集群之间是通过Label Selector来实现“无缝对接”。RC保证Service的Pod副本实例数目保持预期水平。</p>\n<h3><span id=\"82-kubernetes的服务发现机制\">8.2. kubernetes的服务发现机制</span></h3>\n<p>主要通过kube-dns这个组件来进行DNS方式的服务发现。</p>\n<h3><span id=\"83-外部系统访问service的问题\">8.3. 外部系统访问Service的问题</span></h3>\n<table>\n<thead>\n<tr>\n<th>IP类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Node IP</td>\n<td>Node节点的IP地址</td>\n</tr>\n<tr>\n<td>Pod IP</td>\n<td>Pod的IP地址</td>\n</tr>\n<tr>\n<td>Cluster IP</td>\n<td>Service的IP地址</td>\n</tr>\n</tbody>\n</table>\n<h4><span id=\"831-node-ip\">8.3.1. Node IP</span></h4>\n<p>NodeIP是集群中每个节点的物理网卡IP地址，是真实存在的物理网络，kubernetes集群之外的节点访问kubernetes内的某个节点或TCP/IP服务的时候，需要通过NodeIP进行通信。</p>\n<h4><span id=\"832-pod-ip\">8.3.2. Pod IP</span></h4>\n<p>Pod IP是每个Pod的IP地址，是Docker Engine根据docker0网桥的IP段地址进行分配的，是一个虚拟二层网络，集群中一个Pod的容器访问另一个Pod中的容器，是通过Pod IP进行通信的，而真实的TCP/IP流量是通过Node IP所在的网卡流出的。</p>\n<h4><span id=\"833-cluster-ip\">8.3.3. Cluster IP</span></h4>\n<ol>\n<li>Service的Cluster IP是一个虚拟IP，只作用于Service这个对象，由kubernetes管理和分配IP地址（来源于Cluster IP地址池）。</li>\n<li>Cluster IP无法被ping通，因为没有一个实体网络对象来响应。</li>\n<li>Cluster IP结合Service Port组成的具体通信端口才具备TCP/IP通信基础，属于kubernetes集群内，集群外访问该IP和端口需要额外处理。</li>\n<li>k8s集群内Node IP 、Pod IP、Cluster IP之间的通信采取k8s自己的特殊的路由规则，与传统IP路由不同。</li>\n</ol>\n<h4><span id=\"834-外部访问kubernetes集群\">8.3.4. 外部访问Kubernetes集群</span></h4>\n<p>通过宿主机与容器端口映射的方式进行访问，例如：Service定位文件如下：</p>\n<p>可以通过任意Node的IP 加端口访问该服务。也可以通过Nginx或HAProxy来设置负载均衡。</p>\n<h2><span id=\"9-volume存储卷\">9. Volume(存储卷)</span></h2>\n<h3><span id=\"91-volume的功能\">9.1. Volume的功能</span></h3>\n<ol>\n<li>Volume是Pod中能够被多个容器访问的共享目录，可以让容器的数据写到宿主机上或者写文件到网络存储中</li>\n<li>可以实现容器配置文件集中化定义与管理，通过ConfigMap资源对象来实现。</li>\n</ol>\n<h3><span id=\"92-volume的特点\">9.2. Volume的特点</span></h3>\n<p>k8s中的Volume与Docker的Volume相似，但不完全相同。</p>\n<ol>\n<li>k8s上Volume定义在Pod上，然后被一个Pod中的多个容器挂载到具体的文件目录下。</li>\n<li>k8s的Volume与Pod生命周期相关而不是容器是生命周期，即容器挂掉，数据不会丢失但是Pod挂掉，数据则会丢失。</li>\n<li>k8s中的Volume支持多种类型的Volume：Ceph、GlusterFS等分布式系统。</li>\n</ol>\n<h3><span id=\"93-volume的使用方式\">9.3. Volume的使用方式</span></h3>\n<p>先在Pod上声明一个Volume，然后容器引用该Volume并Mount到容器的某个目录。</p>\n<h3><span id=\"94-volume类型\">9.4. Volume类型</span></h3>\n<h4><span id=\"941-emptydir\">9.4.1. emptyDir</span></h4>\n<p>emptyDir Volume是在Pod分配到Node时创建的，初始内容为空，无须指定宿主机上对应的目录文件，由K8S自动分配一个目录，当Pod被删除时，对应的emptyDir数据也会永久删除。</p>\n<p><strong>作用</strong>：</p>\n<ol>\n<li>临时空间，例如程序的临时文件，无须永久保留</li>\n<li>长时间任务的中间过程CheckPoint的临时保存目录</li>\n<li>一个容器需要从另一个容器中获取数据的目录（即多容器共享目录）</li>\n</ol>\n<p><strong>说明</strong>：</p>\n<p>目前用户无法设置emptyVolume的使用介质，如果kubelet的配置使用硬盘则emptyDir将创建在该硬盘上。</p>\n<h4><span id=\"942-hostpath\">9.4.2. hostPath</span></h4>\n<p>hostPath是在Pod上挂载宿主机上的文件或目录。</p>\n<p><strong>作用</strong>：</p>\n<ol>\n<li>容器应用日志需要持久化时，可以使用宿主机的高速文件系统进行存储</li>\n<li>需要访问宿主机上Docker引擎内部数据结构的容器应用时，可以通过定义hostPath为宿主机/var/lib/docker目录，使容器内部应用可以直接访问Docker的文件系统。</li>\n</ol>\n<p><strong>注意点：</strong></p>\n<ol>\n<li>在不同的Node上具有相同配置的Pod可能会因为宿主机上的目录或文件不同导致对Volume上目录或文件的访问结果不一致。</li>\n<li>如果使用了资源配额管理，则kubernetes无法将hostPath在宿主机上使用的资源纳入管理。</li>\n</ol>\n<h4><span id=\"943-gcepersistentdisk\">9.4.3. gcePersistentDisk</span></h4>\n<p>表示使用谷歌公有云提供的永久磁盘（Persistent Disk ,PD）存放Volume的数据，它与EmptyDir不同，PD上的内容会被永久保存。当Pod被删除时，PD只是被卸载时，但不会被删除。需要先创建一个永久磁盘，才能使用gcePersistentDisk。</p>\n<p>使用gcePersistentDisk的限制条件：</p>\n<ul>\n<li>Node(运行kubelet的节点)需要是GCE虚拟机。</li>\n<li>虚拟机需要与PD存在于相同的GCE项目中和Zone中。</li>\n</ul>\n<h2><span id=\"10-persistent-volume\">10. Persistent Volume</span></h2>\n<p>Volume定义在Pod上，属于“计算资源”的一部分，而Persistent Volume和Persistent Volume Claim是网络存储，简称PV和PVC，可以理解为k8s集群中某个网络存储中对应的一块存储。</p>\n<ul>\n<li>PV是网络存储，不属于任何Node，但可以在每个Node上访问。</li>\n<li>PV不是定义在Pod上，而是独立于Pod之外定义。</li>\n<li>PV常见类型：GCE Persistent Disks、NFS、RBD等。</li>\n</ul>\n<p>PV是有状态的对象，状态类型如下：</p>\n<ul>\n<li>Available:空闲状态</li>\n<li>Bound:已经绑定到某个PVC上</li>\n<li>Released:对应的PVC已经删除，但资源还没有回收</li>\n<li>Failed:PV自动回收失败</li>\n</ul>\n<h2><span id=\"11-namespace\">11. Namespace</span></h2>\n<p>Namespace即命名空间，主要用于多租户的资源隔离，通过将资源对象分配到不同的Namespace上，便于不同的分组在共享资源的同时可以被分别管理。</p>\n<p>k8s集群启动后会默认创建一个“default”的Namespace。可以通过kubectl get namespaecs查看。</p>\n<p>可以通过kubectl config use-context <code>namespace</code>配置当前k8s客户端的环境，通过kubectl get pods获取当前namespace的Pod。或者通过kubectl get pods --namespace=<code>NAMESPACE</code>来获取指定namespace的Pod。</p>\n<p><strong>Namespace yaml文件的定义</strong></p>\n<h2><span id=\"12-annotation注解\">12. Annotation(注解)</span></h2>\n<p>Annotation与Label类似，也使用key/value的形式进行定义，Label定义元数据（Metadata）,Annotation定义“附加”信息。</p>\n<p>通常Annotation记录信息如下：</p>\n<ul>\n<li>build信息，release信息，Docker镜像信息等。</li>\n<li>日志库、监控库等。</li>\n</ul>\n<p>参考《Kubernetes权威指南》</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. Master</h2>\n<p>集群的控制节点，负责整个集群的管理和控制，kubernetes的所有的命令基本都是发给Master，由它来负责具体的执行过程。</p>\n<h3>1.1. Master的组件</h3>\n<ul>\n<li>kube-apiserver：资源增删改查的入口</li>\n<li>kube-controller-manager：资源对象的大总管</li>\n<li>kube-scheduler：负责资源调度（Pod调度）</li>\n<li>etcd Server:kubernetes的所有的资源对象的数据保存在etcd中。</li>\n</ul>\n<h2>2. Node</h2>\n<p>Node是集群的工作负载节点，默认情况kubelet会向Master注册自己，一旦Node被纳入集群管理范围，kubelet会定时向Master汇报自身的情报，包括操作系统，Docker版本，机器资源情况等。</p>\n<p>如果Node超过指定时间不上报信息，会被Master判断为“失联”，标记为Not Ready，随后Master会触发Pod转移。</p>\n<h3>2.1. Node的组件</h3>\n<ul>\n<li>kubelet:Pod的管家，与Master通信</li>\n<li>kube-proxy：实现kubernetes Service的通信与负载均衡机制的重要组件</li>\n<li>Docker：容器的创建和管理</li>\n</ul>\n<h3>2.2. Node相关命令</h3>\n<p>kubectl get nodes</p>\n<p>kuebctl describe node {node_name}</p>\n<h3>2.3. describe命令的Node信息</h3>\n<ul>\n<li>Node基本信息：名称、标签、创建时间等</li>\n<li>Node当前的状态，Node启动后会进行自检工作，磁盘是否满，内存是否不足，若都正常则切换为Ready状态。</li>\n<li>Node的主机地址与主机名</li>\n<li>Node上的资源总量：CPU,内存，最大可调度Pod数量等</li>\n<li>Node可分配资源量：当前Node可用于分配的资源量</li>\n<li>主机系统信息：主机唯一标识符UUID，Linux kernel版本号，操作系统，kubernetes版本，kubelet与kube-proxy版本</li>\n<li>当前正在运行的Pod列表及概要信息</li>\n<li>已分配的资源使用概要，例如资源申请的最低、最大允许使用量占系统总量的百分比</li>\n<li>Node相关的Event信息。</li>\n</ul>\n<h2>3. Pod</h2>\n<p>Pod是Kubernetes中操作的基本单元。每个Pod中有个根容器(Pause容器)，Pause容器的状态代表整个容器组的状态，其他业务容器共享Pause的IP，即Pod IP，共享Pause挂载的Volume，这样简化了同个Pod中不同容器之间的网络问题和文件共享问题。</p>\n<p><img src=\"/img/article/kubernetes/k8s%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/pod.png\" alt=\"pod\"></p>\n<ol>\n<li>Kubernetes集群中，同宿主机的或不同宿主机的Pod之间要求能够TCP/IP直接通信，因此采用虚拟二层网络技术来实现，例如Flannel，Openvswitch(OVS)等，这样在同个集群中，不同的宿主机的Pod IP为不同IP段的IP，集群中的所有Pod IP都是唯一的，不同Pod之间可以直接通信。</li>\n<li>Pod有两种类型：普通Pod和静态Pod。静态Pod即不通过K8S调度和创建，直接在某个具体的Node机器上通过具体的文件来启动。普通Pod则是由K8S创建、调度，同时数据存放在ETCD中。</li>\n<li>Pod IP和具体的容器端口（ContainnerPort）组成一个具体的通信地址，即Endpoint。一个Pod中可以存在多个容器，可以有多个端口，Pod IP一样，即有多个Endpoint。</li>\n<li>Pod Volume是定义在Pod之上，被各个容器挂载到自己的文件系统中，可以用分布式文件系统实现后端存储功能。</li>\n<li>Pod中的Event事件可以用来排查问题，可以通过kubectl describe pod xxx 来查看对应的事件。</li>\n<li>每个Pod可以对其能使用的服务器上的计算资源设置限额，一般为CPU和Memory。K8S中一般将千分之一个的CPU配置作为最小单位，用m表示，是一个绝对值，即100m对于一个Core的机器还是48个Core的机器都是一样的大小。Memory配额也是个绝对值，单位为内存字节数。</li>\n<li>资源配额的两个参数</li>\n</ol>\n<ul>\n<li>Requests:该资源的最小申请量，系统必须满足要求。</li>\n<li>Limits:该资源最大允许使用量，当超过该量，K8S会kill并重启Pod。</li>\n</ul>\n<p><img src=\"/img/article/kubernetes/k8s%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/pod2.png\" alt=\"pod2\"></p>\n<h2>4. Label</h2>\n<ol>\n<li>Label是一个键值对，可以附加在任何对象上，比如Node,Pod,Service,RC等。Label和资源对象是多对多的关系，即一个Label可以被添加到多个对象上，一个对象也可以定义多个Label。</li>\n<li>Label的作用主要用来实现精细的、多维度的资源分组管理，以便进行资源分配，调度，配置，部署等工作。</li>\n<li>Label通俗理解就是“标签”，通过标签来过滤筛选指定的对象，进行具体的操作。k8s通过Label Selector(标签选择器)来筛选指定Label的资源对象，类似SQL语句中的条件查询（WHERE语句）。</li>\n<li>Label Selector有基于等式和基于集合的两种表达方式，可以多个条件进行组合使用。</li>\n</ol>\n<ul>\n<li>基于等式：name=redis-slave（匹配name=redis-slave的资源对象）;env!=product(匹配所有不具有标签env=product的资源对象)</li>\n<li>基于集合：name in (redis-slave,redis-master);name not in (php-frontend)（匹配所有不具有标签name=php-frontend的资源对象）</li>\n</ul>\n<p><strong>使用场景</strong></p>\n<ol>\n<li>kube-controller进程通过资源对象RC上定义的Label Selector来筛选要监控的Pod副本数，从而实现副本数始终保持预期数目。</li>\n<li>kube-proxy进程通过Service的Label Selector来选择对应Pod，自动建立每个Service到对应Pod的请求转发路由表，从而实现Service的智能负载均衡机制。</li>\n<li>kube-scheduler实现Pod定向调度：对Node定义特定的Label，并且在Pod定义文件中使用NodeSelector标签调度策略。</li>\n</ol>\n<h2>5. Replication Controller(RC)</h2>\n<p>RC是k8s系统中的核心概念，定义了一个期望的场景。</p>\n<p>主要包括：</p>\n<ul>\n<li>Pod期望的副本数（replicas）</li>\n<li>用于筛选目标Pod的Label Selector</li>\n<li>用于创建Pod的模板（template）</li>\n</ul>\n<p>RC特性说明：</p>\n<ol>\n<li>Pod的缩放可以通过以下命令实现：kubectl scale rc redis-slave --replicas=3</li>\n<li>删除RC并不会删除该RC创建的Pod，可以将副本数设置为0，即可删除对应Pod。或者通过kubectl stop /delete命令来一次性删除RC和其创建的Pod。</li>\n<li>改变RC中Pod模板的镜像版本可以实现滚动升级（Rolling Update）。具体操作见<a href=\"https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/\" target=\"_blank\" rel=\"external\">https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/</a></li>\n<li>Kubernetes1.2以上版本将RC升级为Replica Set，它与当前RC的唯一区别在于Replica Set支持基于集合的Label Selector(Set-based selector)，而旧版本RC只支持基于等式的Label Selector(equality-based selector)。</li>\n<li>Kubernetes1.2以上版本通过Deployment来维护Replica Set而不是单独使用Replica Set。即控制流为：Delpoyment→Replica Set→Pod。即新版本的Deployment+Replica Set替代了RC的作用。</li>\n</ol>\n<h2>6. Deployment</h2>\n<p>Deployment是kubernetes 1.2引入的概念，用来解决Pod的编排问题。Deployment可以理解为RC的升级版（RC+Reolicat Set）。特点在于可以随时知道Pod的部署进度，即对Pod的创建、调度、绑定节点、启动容器完整过程的进度展示。</p>\n<p><strong>使用场景</strong></p>\n<ol>\n<li>创建一个Deployment对象来生成对应的Replica Set并完成Pod副本的创建过程。</li>\n<li>检查Deployment的状态来确认部署动作是否完成（Pod副本的数量是否达到预期值）。</li>\n<li>更新Deployment以创建新的Pod(例如镜像升级的场景)。</li>\n<li>如果当前Deployment不稳定，回退到上一个Deployment版本。</li>\n<li>挂起或恢复一个Deployment。</li>\n</ol>\n<p>可以通过kubectl describe deployment来查看Deployment控制的Pod的水平拓展过程。</p>\n<h2>7. Horizontal Pod Autoscaler(HPA)</h2>\n<p>Horizontal Pod Autoscaler(HPA)即Pod横向自动扩容，与RC一样也属于k8s的资源对象。</p>\n<p>HPA原理：通过追踪分析RC控制的所有目标Pod的负载变化情况，来确定是否针对性调整Pod的副本数。</p>\n<p>Pod负载度量指标：</p>\n<ul>\n<li>CPUUtilizationPercentage：Pod所有副本自身的CPU利用率的平均值。即当前Pod的CPU使用量除以Pod Request的值。</li>\n<li>应用自定义的度量指标，比如服务每秒内响应的请求数（TPS/QPS）。</li>\n</ul>\n<h2>8. Service(服务)</h2>\n<h3>8.1. Service概述</h3>\n<p><img src=\"/img/article/kubernetes/k8s%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/service.png\" alt=\"service\"></p>\n<p>Service定义了一个服务的访问入口地址，前端应用通过这个入口地址访问其背后的一组由Pod副本组成的集群实例，Service与其后端的Pod副本集群之间是通过Label Selector来实现“无缝对接”。RC保证Service的Pod副本实例数目保持预期水平。</p>\n<h3>8.2. kubernetes的服务发现机制</h3>\n<p>主要通过kube-dns这个组件来进行DNS方式的服务发现。</p>\n<h3>8.3. 外部系统访问Service的问题</h3>\n<table>\n<thead>\n<tr>\n<th>IP类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Node IP</td>\n<td>Node节点的IP地址</td>\n</tr>\n<tr>\n<td>Pod IP</td>\n<td>Pod的IP地址</td>\n</tr>\n<tr>\n<td>Cluster IP</td>\n<td>Service的IP地址</td>\n</tr>\n</tbody>\n</table>\n<h4>8.3.1. Node IP</h4>\n<p>NodeIP是集群中每个节点的物理网卡IP地址，是真实存在的物理网络，kubernetes集群之外的节点访问kubernetes内的某个节点或TCP/IP服务的时候，需要通过NodeIP进行通信。</p>\n<h4>8.3.2. Pod IP</h4>\n<p>Pod IP是每个Pod的IP地址，是Docker Engine根据docker0网桥的IP段地址进行分配的，是一个虚拟二层网络，集群中一个Pod的容器访问另一个Pod中的容器，是通过Pod IP进行通信的，而真实的TCP/IP流量是通过Node IP所在的网卡流出的。</p>\n<h4>8.3.3. Cluster IP</h4>\n<ol>\n<li>Service的Cluster IP是一个虚拟IP，只作用于Service这个对象，由kubernetes管理和分配IP地址（来源于Cluster IP地址池）。</li>\n<li>Cluster IP无法被ping通，因为没有一个实体网络对象来响应。</li>\n<li>Cluster IP结合Service Port组成的具体通信端口才具备TCP/IP通信基础，属于kubernetes集群内，集群外访问该IP和端口需要额外处理。</li>\n<li>k8s集群内Node IP 、Pod IP、Cluster IP之间的通信采取k8s自己的特殊的路由规则，与传统IP路由不同。</li>\n</ol>\n<h4>8.3.4. 外部访问Kubernetes集群</h4>\n<p>通过宿主机与容器端口映射的方式进行访问，例如：Service定位文件如下：</p>\n<p>可以通过任意Node的IP 加端口访问该服务。也可以通过Nginx或HAProxy来设置负载均衡。</p>\n<h2>9. Volume(存储卷)</h2>\n<h3>9.1. Volume的功能</h3>\n<ol>\n<li>Volume是Pod中能够被多个容器访问的共享目录，可以让容器的数据写到宿主机上或者写文件到网络存储中</li>\n<li>可以实现容器配置文件集中化定义与管理，通过ConfigMap资源对象来实现。</li>\n</ol>\n<h3>9.2. Volume的特点</h3>\n<p>k8s中的Volume与Docker的Volume相似，但不完全相同。</p>\n<ol>\n<li>k8s上Volume定义在Pod上，然后被一个Pod中的多个容器挂载到具体的文件目录下。</li>\n<li>k8s的Volume与Pod生命周期相关而不是容器是生命周期，即容器挂掉，数据不会丢失但是Pod挂掉，数据则会丢失。</li>\n<li>k8s中的Volume支持多种类型的Volume：Ceph、GlusterFS等分布式系统。</li>\n</ol>\n<h3>9.3. Volume的使用方式</h3>\n<p>先在Pod上声明一个Volume，然后容器引用该Volume并Mount到容器的某个目录。</p>\n<h3>9.4. Volume类型</h3>\n<h4>9.4.1. emptyDir</h4>\n<p>emptyDir Volume是在Pod分配到Node时创建的，初始内容为空，无须指定宿主机上对应的目录文件，由K8S自动分配一个目录，当Pod被删除时，对应的emptyDir数据也会永久删除。</p>\n<p><strong>作用</strong>：</p>\n<ol>\n<li>临时空间，例如程序的临时文件，无须永久保留</li>\n<li>长时间任务的中间过程CheckPoint的临时保存目录</li>\n<li>一个容器需要从另一个容器中获取数据的目录（即多容器共享目录）</li>\n</ol>\n<p><strong>说明</strong>：</p>\n<p>目前用户无法设置emptyVolume的使用介质，如果kubelet的配置使用硬盘则emptyDir将创建在该硬盘上。</p>\n<h4>9.4.2. hostPath</h4>\n<p>hostPath是在Pod上挂载宿主机上的文件或目录。</p>\n<p><strong>作用</strong>：</p>\n<ol>\n<li>容器应用日志需要持久化时，可以使用宿主机的高速文件系统进行存储</li>\n<li>需要访问宿主机上Docker引擎内部数据结构的容器应用时，可以通过定义hostPath为宿主机/var/lib/docker目录，使容器内部应用可以直接访问Docker的文件系统。</li>\n</ol>\n<p><strong>注意点：</strong></p>\n<ol>\n<li>在不同的Node上具有相同配置的Pod可能会因为宿主机上的目录或文件不同导致对Volume上目录或文件的访问结果不一致。</li>\n<li>如果使用了资源配额管理，则kubernetes无法将hostPath在宿主机上使用的资源纳入管理。</li>\n</ol>\n<h4>9.4.3. gcePersistentDisk</h4>\n<p>表示使用谷歌公有云提供的永久磁盘（Persistent Disk ,PD）存放Volume的数据，它与EmptyDir不同，PD上的内容会被永久保存。当Pod被删除时，PD只是被卸载时，但不会被删除。需要先创建一个永久磁盘，才能使用gcePersistentDisk。</p>\n<p>使用gcePersistentDisk的限制条件：</p>\n<ul>\n<li>Node(运行kubelet的节点)需要是GCE虚拟机。</li>\n<li>虚拟机需要与PD存在于相同的GCE项目中和Zone中。</li>\n</ul>\n<h2>10. Persistent Volume</h2>\n<p>Volume定义在Pod上，属于“计算资源”的一部分，而Persistent Volume和Persistent Volume Claim是网络存储，简称PV和PVC，可以理解为k8s集群中某个网络存储中对应的一块存储。</p>\n<ul>\n<li>PV是网络存储，不属于任何Node，但可以在每个Node上访问。</li>\n<li>PV不是定义在Pod上，而是独立于Pod之外定义。</li>\n<li>PV常见类型：GCE Persistent Disks、NFS、RBD等。</li>\n</ul>\n<p>PV是有状态的对象，状态类型如下：</p>\n<ul>\n<li>Available:空闲状态</li>\n<li>Bound:已经绑定到某个PVC上</li>\n<li>Released:对应的PVC已经删除，但资源还没有回收</li>\n<li>Failed:PV自动回收失败</li>\n</ul>\n<h2>11. Namespace</h2>\n<p>Namespace即命名空间，主要用于多租户的资源隔离，通过将资源对象分配到不同的Namespace上，便于不同的分组在共享资源的同时可以被分别管理。</p>\n<p>k8s集群启动后会默认创建一个“default”的Namespace。可以通过kubectl get namespaecs查看。</p>\n<p>可以通过kubectl config use-context <code>namespace</code>配置当前k8s客户端的环境，通过kubectl get pods获取当前namespace的Pod。或者通过kubectl get pods --namespace=<code>NAMESPACE</code>来获取指定namespace的Pod。</p>\n<p><strong>Namespace yaml文件的定义</strong></p>\n<h2>12. Annotation(注解)</h2>\n<p>Annotation与Label类似，也使用key/value的形式进行定义，Label定义元数据（Metadata）,Annotation定义“附加”信息。</p>\n<p>通常Annotation记录信息如下：</p>\n<ul>\n<li>build信息，release信息，Docker镜像信息等。</li>\n<li>日志库、监控库等。</li>\n</ul>\n<p>参考《Kubernetes权威指南》</p>\n"},{"title":"[Kubernetes] Kubernetes常用命令","catalog":true,"date":"2017-08-13T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Kubernetes"],"_content":"\n## 一、kubectl介绍\n\nkubectl controls the Kubernetes cluster manager.\n\nUsage: kubectl [flags] kubectl [command]\n\n```shell\n[root@node5 ~]# kubectl --help\nkubectl controls the Kubernetes cluster manager.\nFind more information at https://github.com/kubernetes/kubernetes.\nUsage:\n  kubectl [flags]\n  kubectl [command]\nAvailable Commands:\n  get            Display one or many resources\n  describe       Show details of a specific resource or group of resources\n  create         Create a resource by filename or stdin\n  replace        Replace a resource by filename or stdin.\n  patch          Update field(s) of a resource by stdin.\n  delete         Delete resources by filenames, stdin, resources and names, or by resources and label selector.\n  edit           Edit a resource on the server\n  apply          Apply a configuration to a resource by filename or stdin\n  namespace      SUPERSEDED: Set and view the current Kubernetes namespace\n  logs           Print the logs for a container in a pod.\n  restart        Restart a container in a pod.\n  rolling-update Perform a rolling update of the given ReplicationController.\n  scale          Set a new size for a Replication Controller.\n  attach         Attach to a running container.\n  exec           Execute a command in a container.\n  port-forward   Forward one or more local ports to a pod.\n  proxy          Run a proxy to the Kubernetes API server\n  run            Run a particular image on the cluster.\n  stop           Deprecated: Gracefully shut down a resource by name or filename.\n  expose         Take a replication controller, service or pod and expose it as a new Kubernetes Service\n  autoscale      Auto-scale a replication controller\n  label          Update the labels on a resource\n  annotate       Update the annotations on a resource\n  config         config modifies kubeconfig files\n  cluster-info   Display cluster info\n  api-versions   Print the supported API versions on the server, in the form of \"group/version\".\n  version        Print the client and server version information.\n  help           Help about any command\nFlags:\n      --alsologtostderr[=false]: log to standard error as well as files\n      --api-version=\"\": The API version to use when talking to the server\n      --certificate-authority=\"\": Path to a cert. file for the certificate authority.\n      --client-certificate=\"\": Path to a client key file for TLS.\n      --client-key=\"\": Path to a client key file for TLS.\n      --cluster=\"\": The name of the kubeconfig cluster to use\n      --context=\"\": The name of the kubeconfig context to use\n      --insecure-skip-tls-verify[=false]: If true, the server's certificate will not be checked for validity. This will make your HTTPS connectionsinsecure.\n      --kubeconfig=\"\": Path to the kubeconfig file to use for CLI requests.\n      --log-backtrace-at=:0: when logging hits line file:N, emit a stack trace\n      --log-dir=\"\": If non-empty, write log files in this directory\n      --log-flush-frequency=5s: Maximum number of seconds between log flushes\n      --logtostderr[=true]: log to standard error instead of files\n      --match-server-version[=false]: Require server version to match client version\n      --namespace=\"\": If present, the namespace scope for this CLI request.\n      --password=\"\": Password for basic authentication to the API server.\n  -s, --server=\"\": The address and port of the Kubernetes API server\n      --stderrthreshold=2: logs at or above this threshold go to stderr\n      --token=\"\": Bearer token for authentication to the API server.\n      --user=\"\": The name of the kubeconfig user to use\n      --username=\"\": Username for basic authentication to the API server.\n      --v=0: log level for V logs\n      --vmodule=: comma-separated list of pattern=N settings for file-filtered logging\n \nUse \"kubectl [command] --help\" for more information about a command.\n```\n\n## 二、操作的资源对象\n\n1. Node\n2. Pods\n3. Replication Controllers\n4. Services\n5. Namespace\n6. ComponentStatus\n\n## 三、kubectl命令分类[command]\n\n### （一）增\n\n1）create:[Create a resource by filename or stdin]\n\n2）run:[ Run a particular image on the cluster]\n\n3）apply:[Apply a configuration to a resource by filename or stdin]\n\n4）proxy:[Run a proxy to the Kubernetes API server ]\n\n### （二）删\n\n1）delete:[Delete resources ]\n\n### （三）改\n\n1）scale:[Set a new size for a Replication Controller]\n\n2）exec:[Execute a command in a container]\n\n3）attach:[Attach to a running container]\n\n4）patch:[Update field(s) of a resource by stdin]\n\n5）edit:[Edit a resource on the server]\n\n6） label:[Update the labels on a resource]\n\n7）annotate:[Auto-scale a replication controller]\n\n8）replace:[Replace a resource by filename or stdin]\n\n9）config:[config modifies kubeconfig files]\n\n### （四）查\n\n1）get:[Display one or many resources]\n\n2）describe:[Show details of a specific resource or group of resources]\n\n3）log:[Print the logs for a container in a pod]\n\n4）cluster-info:[Display cluster info]\n\n5） version:[Print the client and server version information]\n\n6）api-versions:[Print the supported API versions]","source":"_posts/Kubernetes/Kubernetes常用命令.md","raw":"---\ntitle: \"[Kubernetes] Kubernetes常用命令\"\ncatalog: true\ndate: 2017-08-13 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Kubernetes\ncatagories:\n- Kubernetes\n---\n\n## 一、kubectl介绍\n\nkubectl controls the Kubernetes cluster manager.\n\nUsage: kubectl [flags] kubectl [command]\n\n```shell\n[root@node5 ~]# kubectl --help\nkubectl controls the Kubernetes cluster manager.\nFind more information at https://github.com/kubernetes/kubernetes.\nUsage:\n  kubectl [flags]\n  kubectl [command]\nAvailable Commands:\n  get            Display one or many resources\n  describe       Show details of a specific resource or group of resources\n  create         Create a resource by filename or stdin\n  replace        Replace a resource by filename or stdin.\n  patch          Update field(s) of a resource by stdin.\n  delete         Delete resources by filenames, stdin, resources and names, or by resources and label selector.\n  edit           Edit a resource on the server\n  apply          Apply a configuration to a resource by filename or stdin\n  namespace      SUPERSEDED: Set and view the current Kubernetes namespace\n  logs           Print the logs for a container in a pod.\n  restart        Restart a container in a pod.\n  rolling-update Perform a rolling update of the given ReplicationController.\n  scale          Set a new size for a Replication Controller.\n  attach         Attach to a running container.\n  exec           Execute a command in a container.\n  port-forward   Forward one or more local ports to a pod.\n  proxy          Run a proxy to the Kubernetes API server\n  run            Run a particular image on the cluster.\n  stop           Deprecated: Gracefully shut down a resource by name or filename.\n  expose         Take a replication controller, service or pod and expose it as a new Kubernetes Service\n  autoscale      Auto-scale a replication controller\n  label          Update the labels on a resource\n  annotate       Update the annotations on a resource\n  config         config modifies kubeconfig files\n  cluster-info   Display cluster info\n  api-versions   Print the supported API versions on the server, in the form of \"group/version\".\n  version        Print the client and server version information.\n  help           Help about any command\nFlags:\n      --alsologtostderr[=false]: log to standard error as well as files\n      --api-version=\"\": The API version to use when talking to the server\n      --certificate-authority=\"\": Path to a cert. file for the certificate authority.\n      --client-certificate=\"\": Path to a client key file for TLS.\n      --client-key=\"\": Path to a client key file for TLS.\n      --cluster=\"\": The name of the kubeconfig cluster to use\n      --context=\"\": The name of the kubeconfig context to use\n      --insecure-skip-tls-verify[=false]: If true, the server's certificate will not be checked for validity. This will make your HTTPS connectionsinsecure.\n      --kubeconfig=\"\": Path to the kubeconfig file to use for CLI requests.\n      --log-backtrace-at=:0: when logging hits line file:N, emit a stack trace\n      --log-dir=\"\": If non-empty, write log files in this directory\n      --log-flush-frequency=5s: Maximum number of seconds between log flushes\n      --logtostderr[=true]: log to standard error instead of files\n      --match-server-version[=false]: Require server version to match client version\n      --namespace=\"\": If present, the namespace scope for this CLI request.\n      --password=\"\": Password for basic authentication to the API server.\n  -s, --server=\"\": The address and port of the Kubernetes API server\n      --stderrthreshold=2: logs at or above this threshold go to stderr\n      --token=\"\": Bearer token for authentication to the API server.\n      --user=\"\": The name of the kubeconfig user to use\n      --username=\"\": Username for basic authentication to the API server.\n      --v=0: log level for V logs\n      --vmodule=: comma-separated list of pattern=N settings for file-filtered logging\n \nUse \"kubectl [command] --help\" for more information about a command.\n```\n\n## 二、操作的资源对象\n\n1. Node\n2. Pods\n3. Replication Controllers\n4. Services\n5. Namespace\n6. ComponentStatus\n\n## 三、kubectl命令分类[command]\n\n### （一）增\n\n1）create:[Create a resource by filename or stdin]\n\n2）run:[ Run a particular image on the cluster]\n\n3）apply:[Apply a configuration to a resource by filename or stdin]\n\n4）proxy:[Run a proxy to the Kubernetes API server ]\n\n### （二）删\n\n1）delete:[Delete resources ]\n\n### （三）改\n\n1）scale:[Set a new size for a Replication Controller]\n\n2）exec:[Execute a command in a container]\n\n3）attach:[Attach to a running container]\n\n4）patch:[Update field(s) of a resource by stdin]\n\n5）edit:[Edit a resource on the server]\n\n6） label:[Update the labels on a resource]\n\n7）annotate:[Auto-scale a replication controller]\n\n8）replace:[Replace a resource by filename or stdin]\n\n9）config:[config modifies kubeconfig files]\n\n### （四）查\n\n1）get:[Display one or many resources]\n\n2）describe:[Show details of a specific resource or group of resources]\n\n3）log:[Print the logs for a container in a pod]\n\n4）cluster-info:[Display cluster info]\n\n5） version:[Print the client and server version information]\n\n6）api-versions:[Print the supported API versions]","slug":"Kubernetes/Kubernetes常用命令","published":1,"updated":"2017-10-02T11:28:07.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740hf000e30vubo0788j2","content":"<h2><span id=\"一-kubectl介绍\">一、kubectl介绍</span></h2>\n<p>kubectl controls the Kubernetes cluster manager.</p>\n<p>Usage: kubectl [flags] kubectl [command]</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@node5 ~]# kubectl --help</div><div class=\"line\">kubectl controls the Kubernetes cluster manager.</div><div class=\"line\">Find more information at https://github.com/kubernetes/kubernetes.</div><div class=\"line\">Usage:</div><div class=\"line\">  kubectl [flags]</div><div class=\"line\">  kubectl [command]</div><div class=\"line\">Available Commands:</div><div class=\"line\">  get            Display one or many resources</div><div class=\"line\">  describe       Show details of a specific resource or group of resources</div><div class=\"line\">  create         Create a resource by filename or stdin</div><div class=\"line\">  replace        Replace a resource by filename or stdin.</div><div class=\"line\">  patch          Update field(s) of a resource by stdin.</div><div class=\"line\">  delete         Delete resources by filenames, stdin, resources and names, or by resources and label selector.</div><div class=\"line\">  edit           Edit a resource on the server</div><div class=\"line\">  apply          Apply a configuration to a resource by filename or stdin</div><div class=\"line\">  namespace      SUPERSEDED: Set and view the current Kubernetes namespace</div><div class=\"line\">  logs           Print the logs for a container in a pod.</div><div class=\"line\">  restart        Restart a container in a pod.</div><div class=\"line\">  rolling-update Perform a rolling update of the given ReplicationController.</div><div class=\"line\">  scale          Set a new size for a Replication Controller.</div><div class=\"line\">  attach         Attach to a running container.</div><div class=\"line\">  exec           Execute a command in a container.</div><div class=\"line\">  port-forward   Forward one or more local ports to a pod.</div><div class=\"line\">  proxy          Run a proxy to the Kubernetes API server</div><div class=\"line\">  run            Run a particular image on the cluster.</div><div class=\"line\">  stop           Deprecated: Gracefully shut down a resource by name or filename.</div><div class=\"line\">  expose         Take a replication controller, service or pod and expose it as a new Kubernetes Service</div><div class=\"line\">  autoscale      Auto-scale a replication controller</div><div class=\"line\">  label          Update the labels on a resource</div><div class=\"line\">  annotate       Update the annotations on a resource</div><div class=\"line\">  config         config modifies kubeconfig files</div><div class=\"line\">  cluster-info   Display cluster info</div><div class=\"line\">  api-versions   Print the supported API versions on the server, in the form of \"group/version\".</div><div class=\"line\">  version        Print the client and server version information.</div><div class=\"line\">  help           Help about any command</div><div class=\"line\">Flags:</div><div class=\"line\">      --alsologtostderr[=false]: log to standard error as well as files</div><div class=\"line\">      --api-version=\"\": The API version to use when talking to the server</div><div class=\"line\">      --certificate-authority=\"\": Path to a cert. file for the certificate authority.</div><div class=\"line\">      --client-certificate=\"\": Path to a client key file for TLS.</div><div class=\"line\">      --client-key=\"\": Path to a client key file for TLS.</div><div class=\"line\">      --cluster=\"\": The name of the kubeconfig cluster to use</div><div class=\"line\">      --context=\"\": The name of the kubeconfig context to use</div><div class=\"line\">      --insecure-skip-tls-verify[=false]: If true, the server's certificate will not be checked for validity. This will make your HTTPS connectionsinsecure.</div><div class=\"line\">      --kubeconfig=\"\": Path to the kubeconfig file to use for CLI requests.</div><div class=\"line\">      --log-backtrace-at=:0: when logging hits line file:N, emit a stack trace</div><div class=\"line\">      --log-dir=\"\": If non-empty, write log files in this directory</div><div class=\"line\">      --log-flush-frequency=5s: Maximum number of seconds between log flushes</div><div class=\"line\">      --logtostderr[=true]: log to standard error instead of files</div><div class=\"line\">      --match-server-version[=false]: Require server version to match client version</div><div class=\"line\">      --namespace=\"\": If present, the namespace scope for this CLI request.</div><div class=\"line\">      --password=\"\": Password for basic authentication to the API server.</div><div class=\"line\">  -s, --server=\"\": The address and port of the Kubernetes API server</div><div class=\"line\">      --stderrthreshold=2: logs at or above this threshold go to stderr</div><div class=\"line\">      --token=\"\": Bearer token for authentication to the API server.</div><div class=\"line\">      --user=\"\": The name of the kubeconfig user to use</div><div class=\"line\">      --username=\"\": Username for basic authentication to the API server.</div><div class=\"line\">      --v=0: log level for V logs</div><div class=\"line\">      --vmodule=: comma-separated list of pattern=N settings for file-filtered logging</div><div class=\"line\"> </div><div class=\"line\">Use \"kubectl [command] --help\" for more information about a command.</div></pre></td></tr></table></figure>\n<h2><span id=\"二-操作的资源对象\">二、操作的资源对象</span></h2>\n<ol>\n<li>Node</li>\n<li>Pods</li>\n<li>Replication Controllers</li>\n<li>Services</li>\n<li>Namespace</li>\n<li>ComponentStatus</li>\n</ol>\n<h2><span id=\"三-kubectl命令分类command\">三、kubectl命令分类[command]</span></h2>\n<h3><span id=\"一增\">（一）增</span></h3>\n<p>1）create:[Create a resource by filename or stdin]</p>\n<p>2）run:[ Run a particular image on the cluster]</p>\n<p>3）apply:[Apply a configuration to a resource by filename or stdin]</p>\n<p>4）proxy:[Run a proxy to the Kubernetes API server ]</p>\n<h3><span id=\"二删\">（二）删</span></h3>\n<p>1）delete:[Delete resources ]</p>\n<h3><span id=\"三改\">（三）改</span></h3>\n<p>1）scale:[Set a new size for a Replication Controller]</p>\n<p>2）exec:[Execute a command in a container]</p>\n<p>3）attach:[Attach to a running container]</p>\n<p>4）patch:[Update field(s) of a resource by stdin]</p>\n<p>5）edit:[Edit a resource on the server]</p>\n<p>6） label:[Update the labels on a resource]</p>\n<p>7）annotate:[Auto-scale a replication controller]</p>\n<p>8）replace:[Replace a resource by filename or stdin]</p>\n<p>9）config:[config modifies kubeconfig files]</p>\n<h3><span id=\"四查\">（四）查</span></h3>\n<p>1）get:[Display one or many resources]</p>\n<p>2）describe:[Show details of a specific resource or group of resources]</p>\n<p>3）log:[Print the logs for a container in a pod]</p>\n<p>4）cluster-info:[Display cluster info]</p>\n<p>5） version:[Print the client and server version information]</p>\n<p>6）api-versions:[Print the supported API versions]</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>一、kubectl介绍</h2>\n<p>kubectl controls the Kubernetes cluster manager.</p>\n<p>Usage: kubectl [flags] kubectl [command]</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@node5 ~]# kubectl --help</div><div class=\"line\">kubectl controls the Kubernetes cluster manager.</div><div class=\"line\">Find more information at https://github.com/kubernetes/kubernetes.</div><div class=\"line\">Usage:</div><div class=\"line\">  kubectl [flags]</div><div class=\"line\">  kubectl [command]</div><div class=\"line\">Available Commands:</div><div class=\"line\">  get            Display one or many resources</div><div class=\"line\">  describe       Show details of a specific resource or group of resources</div><div class=\"line\">  create         Create a resource by filename or stdin</div><div class=\"line\">  replace        Replace a resource by filename or stdin.</div><div class=\"line\">  patch          Update field(s) of a resource by stdin.</div><div class=\"line\">  delete         Delete resources by filenames, stdin, resources and names, or by resources and label selector.</div><div class=\"line\">  edit           Edit a resource on the server</div><div class=\"line\">  apply          Apply a configuration to a resource by filename or stdin</div><div class=\"line\">  namespace      SUPERSEDED: Set and view the current Kubernetes namespace</div><div class=\"line\">  logs           Print the logs for a container in a pod.</div><div class=\"line\">  restart        Restart a container in a pod.</div><div class=\"line\">  rolling-update Perform a rolling update of the given ReplicationController.</div><div class=\"line\">  scale          Set a new size for a Replication Controller.</div><div class=\"line\">  attach         Attach to a running container.</div><div class=\"line\">  exec           Execute a command in a container.</div><div class=\"line\">  port-forward   Forward one or more local ports to a pod.</div><div class=\"line\">  proxy          Run a proxy to the Kubernetes API server</div><div class=\"line\">  run            Run a particular image on the cluster.</div><div class=\"line\">  stop           Deprecated: Gracefully shut down a resource by name or filename.</div><div class=\"line\">  expose         Take a replication controller, service or pod and expose it as a new Kubernetes Service</div><div class=\"line\">  autoscale      Auto-scale a replication controller</div><div class=\"line\">  label          Update the labels on a resource</div><div class=\"line\">  annotate       Update the annotations on a resource</div><div class=\"line\">  config         config modifies kubeconfig files</div><div class=\"line\">  cluster-info   Display cluster info</div><div class=\"line\">  api-versions   Print the supported API versions on the server, in the form of \"group/version\".</div><div class=\"line\">  version        Print the client and server version information.</div><div class=\"line\">  help           Help about any command</div><div class=\"line\">Flags:</div><div class=\"line\">      --alsologtostderr[=false]: log to standard error as well as files</div><div class=\"line\">      --api-version=\"\": The API version to use when talking to the server</div><div class=\"line\">      --certificate-authority=\"\": Path to a cert. file for the certificate authority.</div><div class=\"line\">      --client-certificate=\"\": Path to a client key file for TLS.</div><div class=\"line\">      --client-key=\"\": Path to a client key file for TLS.</div><div class=\"line\">      --cluster=\"\": The name of the kubeconfig cluster to use</div><div class=\"line\">      --context=\"\": The name of the kubeconfig context to use</div><div class=\"line\">      --insecure-skip-tls-verify[=false]: If true, the server's certificate will not be checked for validity. This will make your HTTPS connectionsinsecure.</div><div class=\"line\">      --kubeconfig=\"\": Path to the kubeconfig file to use for CLI requests.</div><div class=\"line\">      --log-backtrace-at=:0: when logging hits line file:N, emit a stack trace</div><div class=\"line\">      --log-dir=\"\": If non-empty, write log files in this directory</div><div class=\"line\">      --log-flush-frequency=5s: Maximum number of seconds between log flushes</div><div class=\"line\">      --logtostderr[=true]: log to standard error instead of files</div><div class=\"line\">      --match-server-version[=false]: Require server version to match client version</div><div class=\"line\">      --namespace=\"\": If present, the namespace scope for this CLI request.</div><div class=\"line\">      --password=\"\": Password for basic authentication to the API server.</div><div class=\"line\">  -s, --server=\"\": The address and port of the Kubernetes API server</div><div class=\"line\">      --stderrthreshold=2: logs at or above this threshold go to stderr</div><div class=\"line\">      --token=\"\": Bearer token for authentication to the API server.</div><div class=\"line\">      --user=\"\": The name of the kubeconfig user to use</div><div class=\"line\">      --username=\"\": Username for basic authentication to the API server.</div><div class=\"line\">      --v=0: log level for V logs</div><div class=\"line\">      --vmodule=: comma-separated list of pattern=N settings for file-filtered logging</div><div class=\"line\"> </div><div class=\"line\">Use \"kubectl [command] --help\" for more information about a command.</div></pre></td></tr></table></figure>\n<h2>二、操作的资源对象</h2>\n<ol>\n<li>Node</li>\n<li>Pods</li>\n<li>Replication Controllers</li>\n<li>Services</li>\n<li>Namespace</li>\n<li>ComponentStatus</li>\n</ol>\n<h2>三、kubectl命令分类[command]</h2>\n<h3>（一）增</h3>\n<p>1）create:[Create a resource by filename or stdin]</p>\n<p>2）run:[ Run a particular image on the cluster]</p>\n<p>3）apply:[Apply a configuration to a resource by filename or stdin]</p>\n<p>4）proxy:[Run a proxy to the Kubernetes API server ]</p>\n<h3>（二）删</h3>\n<p>1）delete:[Delete resources ]</p>\n<h3>（三）改</h3>\n<p>1）scale:[Set a new size for a Replication Controller]</p>\n<p>2）exec:[Execute a command in a container]</p>\n<p>3）attach:[Attach to a running container]</p>\n<p>4）patch:[Update field(s) of a resource by stdin]</p>\n<p>5）edit:[Edit a resource on the server]</p>\n<p>6） label:[Update the labels on a resource]</p>\n<p>7）annotate:[Auto-scale a replication controller]</p>\n<p>8）replace:[Replace a resource by filename or stdin]</p>\n<p>9）config:[config modifies kubeconfig files]</p>\n<h3>（四）查</h3>\n<p>1）get:[Display one or many resources]</p>\n<p>2）describe:[Show details of a specific resource or group of resources]</p>\n<p>3）log:[Print the logs for a container in a pod]</p>\n<p>4）cluster-info:[Display cluster info]</p>\n<p>5） version:[Print the client and server version information]</p>\n<p>6）api-versions:[Print the supported API versions]</p>\n"},{"title":"[Kubernetes] Kubernetes总架构图","catalog":true,"date":"2017-09-20T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Kubernetes"],"_content":"\n## 一、Kubernetes的总架构图\n\n![k8s架构2](/img/article/kubernetes/k8s总架构/k8s架构2.png)\n\n## 二、Kubernetes各个组件介绍\n\n### （一）kube-master[控制节点]\n\n- #### master的工作流程图\n\n![master](/img/article/kubernetes/k8s总架构/master.png)\n\n1. Kubecfg将特定的请求，比如创建Pod，发送给Kubernetes Client。\n2. Kubernetes Client将请求发送给API server。\n3. API Server根据请求的类型，比如创建Pod时storage类型是pods，然后依此选择何种REST Storage API对请求作出处理。\n4. REST Storage API对的请求作相应的处理。\n5. 将处理的结果存入高可用键值存储系统Etcd中。\n6. 在API Server响应Kubecfg的请求后，Scheduler会根据Kubernetes Client获取集群中运行Pod及Minion/Node信息。\n7. 依据从Kubernetes Client获取的信息，Scheduler将未分发的Pod分发到可用的Minion/Node节点上。\n\n#### 1、API Server[资源操作入口]\n\n1. 提供了资源对象的唯一操作入口，其他所有组件都必须通过它提供的API来操作资源数据，只有API Server与存储通信，其他模块通过API Server访问集群状态。\n   1. 第一，是为了保证集群状态访问的安全。\n   2. 第二，是为了隔离集群状态访问的方式和后端存储实现的方式：API Server是状态访问的方式，不会因为后端存储技术etcd的改变而改变。\n2. 作为kubernetes系统的入口，封装了核心对象的增删改查操作，以RESTFul接口方式提供给外部客户和内部组件调用。对相关的资源数据“全量查询”+“变化监听”，实时完成相关的业务功能。\n\n更多API Server信息请参考：[Kubernetes核心原理（一）之API Server](http://blog.csdn.net/huwh_/article/details/75675706)\n\n#### 2、Controller Manager[内部管理控制中心]\n\n1. 实现集群故障检测和恢复的自动化工作，负责执行各种控制器，主要有：\n   - endpoint-controller：定期关联service和pod(关联信息由endpoint对象维护)，保证service到pod的映射总是最新的。\n   - replication-controller：定期关联replicationController和pod，保证replicationController定义的复制数量与实际运行pod的数量总是一致的。\n\n更多Controller Manager信息请参考：[Kubernetes核心原理（二）之Controller Manager](http://blog.csdn.net/huwh_/article/details/75675761)\n\n#### 3、Scheduler[集群分发调度器]\n\n1. Scheduler收集和分析当前Kubernetes集群中所有Minion节点的资源(内存、CPU)负载情况，然后依此分发新建的Pod到Kubernetes集群中可用的节点。\n2. 实时监测Kubernetes集群中未分发和已分发的所有运行的Pod。\n3. Scheduler也监测Minion节点信息，由于会频繁查找Minion节点，Scheduler会缓存一份最新的信息在本地。\n4. 最后，Scheduler在分发Pod到指定的Minion节点后，会把Pod相关的信息Binding写回API Server。\n\n更多Scheduler信息请参考：[Kubernetes核心原理（三）之Scheduler](http://blog.csdn.net/huwh_/article/details/77017353)\n\n### （二）kube-node[服务节点]\n\n- #### kubelet结构图\n\n![kubelet](/img/article/kubernetes/k8s总架构/kubelet.png)\n\n#### 1、Kubelet[节点上的Pod管家]\n\n1. 负责Node节点上pod的创建、修改、监控、删除等全生命周期的管理\n2. 定时上报本Node的状态信息给API Server。\n3. kubelet是Master API Server和Minion之间的桥梁，接收Master API Server分配给它的commands和work，与持久性键值存储etcd、file、server和http进行交互，读取配置信息。\n4. 具体的工作如下：\n   1. 设置容器的环境变量、给容器绑定Volume、给容器绑定Port、根据指定的Pod运行一个单一容器、给指定的Pod创建network 容器。\n   2. 同步Pod的状态、同步Pod的状态、从cAdvisor获取container info、 pod info、 root info、 machine info。\n   3. 在容器中运行命令、杀死容器、删除Pod的所有容器。\n\n更多Kubelet信息请参考：[Kubernetes核心原理（四）之Kubelet](http://blog.csdn.net/huwh_/article/details/77922293)\n\n#### 2、Proxy[负载均衡、路由转发]\n\n1. Proxy是为了解决外部网络能够访问跨机器集群中容器提供的应用服务而设计的，运行在每个Node上。Proxy提供TCP/UDP sockets的proxy，每创建一种Service，Proxy主要从etcd获取Services和Endpoints的配置信息（也可以从file获取），然后根据配置信息在Minion上启动一个Proxy的进程并监听相应的服务端口，当外部请求发生时，Proxy会根据Load Balancer将请求分发到后端正确的容器处理。\n2. Proxy不但解决了同一主宿机相同服务端口冲突的问题，还提供了Service转发服务端口对外提供服务的能力，Proxy后端使用了随机、轮循负载均衡算法。\n\n#### 3、kubectl（kubelet client）[集群管理命令行工具集]\n\n1. 通过客户端的kubectl命令集操作，API Server响应对应的命令结果，从而达到对kubernetes集群的管理。\n\n参考文章：\n\nhttps://yq.aliyun.com/articles/47308?spm=5176.100240.searchblog.19.jF7FFa","source":"_posts/Kubernetes/Kubernetes总架构图.md","raw":"---\ntitle: \"[Kubernetes] Kubernetes总架构图\"\ncatalog: true\ndate: 2017-09-20 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Kubernetes\ncatagories:\n- Kubernetes\n---\n\n## 一、Kubernetes的总架构图\n\n![k8s架构2](/img/article/kubernetes/k8s总架构/k8s架构2.png)\n\n## 二、Kubernetes各个组件介绍\n\n### （一）kube-master[控制节点]\n\n- #### master的工作流程图\n\n![master](/img/article/kubernetes/k8s总架构/master.png)\n\n1. Kubecfg将特定的请求，比如创建Pod，发送给Kubernetes Client。\n2. Kubernetes Client将请求发送给API server。\n3. API Server根据请求的类型，比如创建Pod时storage类型是pods，然后依此选择何种REST Storage API对请求作出处理。\n4. REST Storage API对的请求作相应的处理。\n5. 将处理的结果存入高可用键值存储系统Etcd中。\n6. 在API Server响应Kubecfg的请求后，Scheduler会根据Kubernetes Client获取集群中运行Pod及Minion/Node信息。\n7. 依据从Kubernetes Client获取的信息，Scheduler将未分发的Pod分发到可用的Minion/Node节点上。\n\n#### 1、API Server[资源操作入口]\n\n1. 提供了资源对象的唯一操作入口，其他所有组件都必须通过它提供的API来操作资源数据，只有API Server与存储通信，其他模块通过API Server访问集群状态。\n   1. 第一，是为了保证集群状态访问的安全。\n   2. 第二，是为了隔离集群状态访问的方式和后端存储实现的方式：API Server是状态访问的方式，不会因为后端存储技术etcd的改变而改变。\n2. 作为kubernetes系统的入口，封装了核心对象的增删改查操作，以RESTFul接口方式提供给外部客户和内部组件调用。对相关的资源数据“全量查询”+“变化监听”，实时完成相关的业务功能。\n\n更多API Server信息请参考：[Kubernetes核心原理（一）之API Server](http://blog.csdn.net/huwh_/article/details/75675706)\n\n#### 2、Controller Manager[内部管理控制中心]\n\n1. 实现集群故障检测和恢复的自动化工作，负责执行各种控制器，主要有：\n   - endpoint-controller：定期关联service和pod(关联信息由endpoint对象维护)，保证service到pod的映射总是最新的。\n   - replication-controller：定期关联replicationController和pod，保证replicationController定义的复制数量与实际运行pod的数量总是一致的。\n\n更多Controller Manager信息请参考：[Kubernetes核心原理（二）之Controller Manager](http://blog.csdn.net/huwh_/article/details/75675761)\n\n#### 3、Scheduler[集群分发调度器]\n\n1. Scheduler收集和分析当前Kubernetes集群中所有Minion节点的资源(内存、CPU)负载情况，然后依此分发新建的Pod到Kubernetes集群中可用的节点。\n2. 实时监测Kubernetes集群中未分发和已分发的所有运行的Pod。\n3. Scheduler也监测Minion节点信息，由于会频繁查找Minion节点，Scheduler会缓存一份最新的信息在本地。\n4. 最后，Scheduler在分发Pod到指定的Minion节点后，会把Pod相关的信息Binding写回API Server。\n\n更多Scheduler信息请参考：[Kubernetes核心原理（三）之Scheduler](http://blog.csdn.net/huwh_/article/details/77017353)\n\n### （二）kube-node[服务节点]\n\n- #### kubelet结构图\n\n![kubelet](/img/article/kubernetes/k8s总架构/kubelet.png)\n\n#### 1、Kubelet[节点上的Pod管家]\n\n1. 负责Node节点上pod的创建、修改、监控、删除等全生命周期的管理\n2. 定时上报本Node的状态信息给API Server。\n3. kubelet是Master API Server和Minion之间的桥梁，接收Master API Server分配给它的commands和work，与持久性键值存储etcd、file、server和http进行交互，读取配置信息。\n4. 具体的工作如下：\n   1. 设置容器的环境变量、给容器绑定Volume、给容器绑定Port、根据指定的Pod运行一个单一容器、给指定的Pod创建network 容器。\n   2. 同步Pod的状态、同步Pod的状态、从cAdvisor获取container info、 pod info、 root info、 machine info。\n   3. 在容器中运行命令、杀死容器、删除Pod的所有容器。\n\n更多Kubelet信息请参考：[Kubernetes核心原理（四）之Kubelet](http://blog.csdn.net/huwh_/article/details/77922293)\n\n#### 2、Proxy[负载均衡、路由转发]\n\n1. Proxy是为了解决外部网络能够访问跨机器集群中容器提供的应用服务而设计的，运行在每个Node上。Proxy提供TCP/UDP sockets的proxy，每创建一种Service，Proxy主要从etcd获取Services和Endpoints的配置信息（也可以从file获取），然后根据配置信息在Minion上启动一个Proxy的进程并监听相应的服务端口，当外部请求发生时，Proxy会根据Load Balancer将请求分发到后端正确的容器处理。\n2. Proxy不但解决了同一主宿机相同服务端口冲突的问题，还提供了Service转发服务端口对外提供服务的能力，Proxy后端使用了随机、轮循负载均衡算法。\n\n#### 3、kubectl（kubelet client）[集群管理命令行工具集]\n\n1. 通过客户端的kubectl命令集操作，API Server响应对应的命令结果，从而达到对kubernetes集群的管理。\n\n参考文章：\n\nhttps://yq.aliyun.com/articles/47308?spm=5176.100240.searchblog.19.jF7FFa","slug":"Kubernetes/Kubernetes总架构图","published":1,"updated":"2017-10-02T13:10:57.596Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740hh000f30vu912yeccc","content":"<h2><span id=\"一-kubernetes的总架构图\">一、Kubernetes的总架构图</span></h2>\n<p><img src=\"/img/article/kubernetes/k8s%E6%80%BB%E6%9E%B6%E6%9E%84/k8s%E6%9E%B6%E6%9E%842.png\" alt=\"k8s架构2\"></p>\n<h2><span id=\"二-kubernetes各个组件介绍\">二、Kubernetes各个组件介绍</span></h2>\n<h3><span id=\"一kube-master控制节点\">（一）kube-master[控制节点]</span></h3>\n<ul>\n<li>\n<h4><span id=\"master的工作流程图\">master的工作流程图</span></h4>\n</li>\n</ul>\n<p><img src=\"/img/article/kubernetes/k8s%E6%80%BB%E6%9E%B6%E6%9E%84/master.png\" alt=\"master\"></p>\n<ol>\n<li>Kubecfg将特定的请求，比如创建Pod，发送给Kubernetes Client。</li>\n<li>Kubernetes Client将请求发送给API server。</li>\n<li>API Server根据请求的类型，比如创建Pod时storage类型是pods，然后依此选择何种REST Storage API对请求作出处理。</li>\n<li>REST Storage API对的请求作相应的处理。</li>\n<li>将处理的结果存入高可用键值存储系统Etcd中。</li>\n<li>在API Server响应Kubecfg的请求后，Scheduler会根据Kubernetes Client获取集群中运行Pod及Minion/Node信息。</li>\n<li>依据从Kubernetes Client获取的信息，Scheduler将未分发的Pod分发到可用的Minion/Node节点上。</li>\n</ol>\n<h4><span id=\"1-api-server资源操作入口\">1、API Server[资源操作入口]</span></h4>\n<ol>\n<li>提供了资源对象的唯一操作入口，其他所有组件都必须通过它提供的API来操作资源数据，只有API Server与存储通信，其他模块通过API Server访问集群状态。\n<ol>\n<li>第一，是为了保证集群状态访问的安全。</li>\n<li>第二，是为了隔离集群状态访问的方式和后端存储实现的方式：API Server是状态访问的方式，不会因为后端存储技术etcd的改变而改变。</li>\n</ol>\n</li>\n<li>作为kubernetes系统的入口，封装了核心对象的增删改查操作，以RESTFul接口方式提供给外部客户和内部组件调用。对相关的资源数据“全量查询”+“变化监听”，实时完成相关的业务功能。</li>\n</ol>\n<p>更多API Server信息请参考：<a href=\"http://blog.csdn.net/huwh_/article/details/75675706\" target=\"_blank\" rel=\"external\">Kubernetes核心原理（一）之API Server</a></p>\n<h4><span id=\"2-controller-manager内部管理控制中心\">2、Controller Manager[内部管理控制中心]</span></h4>\n<ol>\n<li>实现集群故障检测和恢复的自动化工作，负责执行各种控制器，主要有：\n<ul>\n<li>endpoint-controller：定期关联service和pod(关联信息由endpoint对象维护)，保证service到pod的映射总是最新的。</li>\n<li>replication-controller：定期关联replicationController和pod，保证replicationController定义的复制数量与实际运行pod的数量总是一致的。</li>\n</ul>\n</li>\n</ol>\n<p>更多Controller Manager信息请参考：<a href=\"http://blog.csdn.net/huwh_/article/details/75675761\" target=\"_blank\" rel=\"external\">Kubernetes核心原理（二）之Controller Manager</a></p>\n<h4><span id=\"3-scheduler集群分发调度器\">3、Scheduler[集群分发调度器]</span></h4>\n<ol>\n<li>Scheduler收集和分析当前Kubernetes集群中所有Minion节点的资源(内存、CPU)负载情况，然后依此分发新建的Pod到Kubernetes集群中可用的节点。</li>\n<li>实时监测Kubernetes集群中未分发和已分发的所有运行的Pod。</li>\n<li>Scheduler也监测Minion节点信息，由于会频繁查找Minion节点，Scheduler会缓存一份最新的信息在本地。</li>\n<li>最后，Scheduler在分发Pod到指定的Minion节点后，会把Pod相关的信息Binding写回API Server。</li>\n</ol>\n<p>更多Scheduler信息请参考：<a href=\"http://blog.csdn.net/huwh_/article/details/77017353\" target=\"_blank\" rel=\"external\">Kubernetes核心原理（三）之Scheduler</a></p>\n<h3><span id=\"二kube-node服务节点\">（二）kube-node[服务节点]</span></h3>\n<ul>\n<li>\n<h4><span id=\"kubelet结构图\">kubelet结构图</span></h4>\n</li>\n</ul>\n<p><img src=\"/img/article/kubernetes/k8s%E6%80%BB%E6%9E%B6%E6%9E%84/kubelet.png\" alt=\"kubelet\"></p>\n<h4><span id=\"1-kubelet节点上的pod管家\">1、Kubelet[节点上的Pod管家]</span></h4>\n<ol>\n<li>负责Node节点上pod的创建、修改、监控、删除等全生命周期的管理</li>\n<li>定时上报本Node的状态信息给API Server。</li>\n<li>kubelet是Master API Server和Minion之间的桥梁，接收Master API Server分配给它的commands和work，与持久性键值存储etcd、file、server和http进行交互，读取配置信息。</li>\n<li>具体的工作如下：\n<ol>\n<li>设置容器的环境变量、给容器绑定Volume、给容器绑定Port、根据指定的Pod运行一个单一容器、给指定的Pod创建network 容器。</li>\n<li>同步Pod的状态、同步Pod的状态、从cAdvisor获取container info、 pod info、 root info、 machine info。</li>\n<li>在容器中运行命令、杀死容器、删除Pod的所有容器。</li>\n</ol>\n</li>\n</ol>\n<p>更多Kubelet信息请参考：<a href=\"http://blog.csdn.net/huwh_/article/details/77922293\" target=\"_blank\" rel=\"external\">Kubernetes核心原理（四）之Kubelet</a></p>\n<h4><span id=\"2-proxy负载均衡-路由转发\">2、Proxy[负载均衡、路由转发]</span></h4>\n<ol>\n<li>Proxy是为了解决外部网络能够访问跨机器集群中容器提供的应用服务而设计的，运行在每个Node上。Proxy提供TCP/UDP sockets的proxy，每创建一种Service，Proxy主要从etcd获取Services和Endpoints的配置信息（也可以从file获取），然后根据配置信息在Minion上启动一个Proxy的进程并监听相应的服务端口，当外部请求发生时，Proxy会根据Load Balancer将请求分发到后端正确的容器处理。</li>\n<li>Proxy不但解决了同一主宿机相同服务端口冲突的问题，还提供了Service转发服务端口对外提供服务的能力，Proxy后端使用了随机、轮循负载均衡算法。</li>\n</ol>\n<h4><span id=\"3-kubectlkubelet-client集群管理命令行工具集\">3、kubectl（kubelet client）[集群管理命令行工具集]</span></h4>\n<ol>\n<li>通过客户端的kubectl命令集操作，API Server响应对应的命令结果，从而达到对kubernetes集群的管理。</li>\n</ol>\n<p>参考文章：</p>\n<p><a href=\"https://yq.aliyun.com/articles/47308?spm=5176.100240.searchblog.19.jF7FFa\" target=\"_blank\" rel=\"external\">https://yq.aliyun.com/articles/47308?spm=5176.100240.searchblog.19.jF7FFa</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>一、Kubernetes的总架构图</h2>\n<p><img src=\"/img/article/kubernetes/k8s%E6%80%BB%E6%9E%B6%E6%9E%84/k8s%E6%9E%B6%E6%9E%842.png\" alt=\"k8s架构2\"></p>\n<h2>二、Kubernetes各个组件介绍</h2>\n<h3>（一）kube-master[控制节点]</h3>\n<ul>\n<li>\n<h4>master的工作流程图</h4>\n</li>\n</ul>\n<p><img src=\"/img/article/kubernetes/k8s%E6%80%BB%E6%9E%B6%E6%9E%84/master.png\" alt=\"master\"></p>\n<ol>\n<li>Kubecfg将特定的请求，比如创建Pod，发送给Kubernetes Client。</li>\n<li>Kubernetes Client将请求发送给API server。</li>\n<li>API Server根据请求的类型，比如创建Pod时storage类型是pods，然后依此选择何种REST Storage API对请求作出处理。</li>\n<li>REST Storage API对的请求作相应的处理。</li>\n<li>将处理的结果存入高可用键值存储系统Etcd中。</li>\n<li>在API Server响应Kubecfg的请求后，Scheduler会根据Kubernetes Client获取集群中运行Pod及Minion/Node信息。</li>\n<li>依据从Kubernetes Client获取的信息，Scheduler将未分发的Pod分发到可用的Minion/Node节点上。</li>\n</ol>\n<h4>1、API Server[资源操作入口]</h4>\n<ol>\n<li>提供了资源对象的唯一操作入口，其他所有组件都必须通过它提供的API来操作资源数据，只有API Server与存储通信，其他模块通过API Server访问集群状态。\n<ol>\n<li>第一，是为了保证集群状态访问的安全。</li>\n<li>第二，是为了隔离集群状态访问的方式和后端存储实现的方式：API Server是状态访问的方式，不会因为后端存储技术etcd的改变而改变。</li>\n</ol>\n</li>\n<li>作为kubernetes系统的入口，封装了核心对象的增删改查操作，以RESTFul接口方式提供给外部客户和内部组件调用。对相关的资源数据“全量查询”+“变化监听”，实时完成相关的业务功能。</li>\n</ol>\n<p>更多API Server信息请参考：<a href=\"http://blog.csdn.net/huwh_/article/details/75675706\" target=\"_blank\" rel=\"external\">Kubernetes核心原理（一）之API Server</a></p>\n<h4>2、Controller Manager[内部管理控制中心]</h4>\n<ol>\n<li>实现集群故障检测和恢复的自动化工作，负责执行各种控制器，主要有：\n<ul>\n<li>endpoint-controller：定期关联service和pod(关联信息由endpoint对象维护)，保证service到pod的映射总是最新的。</li>\n<li>replication-controller：定期关联replicationController和pod，保证replicationController定义的复制数量与实际运行pod的数量总是一致的。</li>\n</ul>\n</li>\n</ol>\n<p>更多Controller Manager信息请参考：<a href=\"http://blog.csdn.net/huwh_/article/details/75675761\" target=\"_blank\" rel=\"external\">Kubernetes核心原理（二）之Controller Manager</a></p>\n<h4>3、Scheduler[集群分发调度器]</h4>\n<ol>\n<li>Scheduler收集和分析当前Kubernetes集群中所有Minion节点的资源(内存、CPU)负载情况，然后依此分发新建的Pod到Kubernetes集群中可用的节点。</li>\n<li>实时监测Kubernetes集群中未分发和已分发的所有运行的Pod。</li>\n<li>Scheduler也监测Minion节点信息，由于会频繁查找Minion节点，Scheduler会缓存一份最新的信息在本地。</li>\n<li>最后，Scheduler在分发Pod到指定的Minion节点后，会把Pod相关的信息Binding写回API Server。</li>\n</ol>\n<p>更多Scheduler信息请参考：<a href=\"http://blog.csdn.net/huwh_/article/details/77017353\" target=\"_blank\" rel=\"external\">Kubernetes核心原理（三）之Scheduler</a></p>\n<h3>（二）kube-node[服务节点]</h3>\n<ul>\n<li>\n<h4>kubelet结构图</h4>\n</li>\n</ul>\n<p><img src=\"/img/article/kubernetes/k8s%E6%80%BB%E6%9E%B6%E6%9E%84/kubelet.png\" alt=\"kubelet\"></p>\n<h4>1、Kubelet[节点上的Pod管家]</h4>\n<ol>\n<li>负责Node节点上pod的创建、修改、监控、删除等全生命周期的管理</li>\n<li>定时上报本Node的状态信息给API Server。</li>\n<li>kubelet是Master API Server和Minion之间的桥梁，接收Master API Server分配给它的commands和work，与持久性键值存储etcd、file、server和http进行交互，读取配置信息。</li>\n<li>具体的工作如下：\n<ol>\n<li>设置容器的环境变量、给容器绑定Volume、给容器绑定Port、根据指定的Pod运行一个单一容器、给指定的Pod创建network 容器。</li>\n<li>同步Pod的状态、同步Pod的状态、从cAdvisor获取container info、 pod info、 root info、 machine info。</li>\n<li>在容器中运行命令、杀死容器、删除Pod的所有容器。</li>\n</ol>\n</li>\n</ol>\n<p>更多Kubelet信息请参考：<a href=\"http://blog.csdn.net/huwh_/article/details/77922293\" target=\"_blank\" rel=\"external\">Kubernetes核心原理（四）之Kubelet</a></p>\n<h4>2、Proxy[负载均衡、路由转发]</h4>\n<ol>\n<li>Proxy是为了解决外部网络能够访问跨机器集群中容器提供的应用服务而设计的，运行在每个Node上。Proxy提供TCP/UDP sockets的proxy，每创建一种Service，Proxy主要从etcd获取Services和Endpoints的配置信息（也可以从file获取），然后根据配置信息在Minion上启动一个Proxy的进程并监听相应的服务端口，当外部请求发生时，Proxy会根据Load Balancer将请求分发到后端正确的容器处理。</li>\n<li>Proxy不但解决了同一主宿机相同服务端口冲突的问题，还提供了Service转发服务端口对外提供服务的能力，Proxy后端使用了随机、轮循负载均衡算法。</li>\n</ol>\n<h4>3、kubectl（kubelet client）[集群管理命令行工具集]</h4>\n<ol>\n<li>通过客户端的kubectl命令集操作，API Server响应对应的命令结果，从而达到对kubernetes集群的管理。</li>\n</ol>\n<p>参考文章：</p>\n<p><a href=\"https://yq.aliyun.com/articles/47308?spm=5176.100240.searchblog.19.jF7FFa\" target=\"_blank\" rel=\"external\">https://yq.aliyun.com/articles/47308?spm=5176.100240.searchblog.19.jF7FFa</a></p>\n"},{"title":"[Kubernetes] Kubernetes网络原理","catalog":true,"date":"2017-08-13T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Kubernetes"],"_content":"\n## 1. kubernetes网络模型\n\n### 1.1. 基础原则\n\n1. 每个Pod都拥有一个独立的IP地址，而且假定所有Pod都在一个可以直接连通的、扁平的网络空间中，不管是否运行在同一Node上都可以通过Pod的IP来访问。\n2. k8s中Pod的IP是最小粒度IP。同一个Pod内所有的容器共享一个网络堆栈，该模型称为IP-per-Pod模型。\n3. Pod由docker0实际分配的IP，Pod内部看到的IP地址和端口与外部保持一致。同一个Pod内的不同容器共享网络，可以通过localhost来访问对方的端口，类似同一个VM内的不同进程。\n4. IP-per-Pod模型从端口分配、域名解析、服务发现、负载均衡、应用配置等角度看，Pod可以看作是一台独立的VM或物理机。\n\n### 1.2. k8s对集群的网络要求\n\n1. 所有容器都可以不用NAT的方式同别的容器通信。\n2. 所有节点都可以在不同NAT的方式下同所有容器通信，反之亦然。\n3. 容器的地址和别人看到的地址是同一个地址。\n\n以上的集群网络要求可以通过第三方开源方案实现，例如flannel。\n\n### 1.3. 网络架构图\n\n![网络架构图](/img/article/kubernetes/k8s网络/网络架构图.png)\n\n### 1.4. k8s集群IP概念汇总\n\n由集群外部到集群内部：\n\n| IP类型                | 说明                                    |\n| ------------------- | ------------------------------------- |\n| Proxy-IP            | 代理层公网地址IP，外部访问应用的网关服务器。[实际需要关注的IP]    |\n| Service-IP          | Service的固定虚拟IP，Service-IP是内部，外部无法寻址到。 |\n| Node-IP             | 容器宿主机的主机IP。                           |\n| Container-Bridge-IP | 容器网桥（docker0）IP，容器的网络都需要通过容器网桥转发。     |\n| Pod-IP              | Pod的IP，等效于Pod中网络容器的Container-IP。      |\n| Container-IP        | 容器的IP，容器的网络是个隔离的网络空间。                 |\n\n## 2. Docker的网络基础\n\n### 2.1. Network Namespace\n\n不同的网络命名空间中，协议栈是独立的，完全隔离，彼此之间无法通信。同一个网络命名空间有独立的路由表和独立的Iptables/Netfilter来提供包的转发、NAT、IP包过滤等功能。\n\n#### 2.1.1. 网络命名空间的实现\n\n将与网络协议栈相关的全局变量变成一个Net Namespace变量的成员，然后在调用协议栈函数中加入一个Namepace参数。\n\n#### 2.1.2. 网络命名空间的操作\n\n1、创建网络命名空间\n\nip netns add\n\n2、在命名空间内执行命令\n\nip netns exec\n\n3、进入命名空间\n\nip netns exec bash\n\n## 3. Docker的网络实现\n\n### 3.1. 容器网络\n\nDocker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。\n\nDocker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接Container-IP访问到容器。如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即docker run创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器。\n\n![容器网络](/img/article/kubernetes/k8s网络/容器网络.png)\n\n### 3.2. 4类网络模式\n\n| Docker网络模式  | 配置                        | 说明                                       |\n| ----------- | ------------------------- | ---------------------------------------- |\n| host模式      | –net=host                 | 容器和宿主机共享Network namespace。               |\n| container模式 | –net=container:NAME_or_ID | 容器和另外一个容器共享Network namespace。 kubernetes中的pod就是多个容器共享一个Network namespace。 |\n| none模式      | –net=none                 | 容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等。 |\n| bridge模式    | –net=bridge（默认为该模式）       |                                          |\n\n### 3.3. bridge模式\n\nk8s只使用bridge模式。\n\n在bridge模式下，Docker Daemon首次启动时会创建一个虚拟网桥docker0，地址通常为172.x.x.x开头，在私有的网络空间中给这个网络分配一个子网。由Docker创建处理的每个容器，都会创建一个虚拟以太设备（Veth设备对），一端关联到网桥，另一端使用Namespace技术映射到容器内的eth0设备，然后从网桥的地址段内给eth0接口分配一个IP地址。\n\n![image2017-5-4 20-51-53](/img/article/kubernetes/k8s网络/image2017-5-4 20-51-53.png)\n\n一般情况，宿主机IP与docker0 IP、容器IP是不同的IP段，默认情况，外部看不到docker0和容器IP，对于外部来说相当于docker0和容器的IP为内网IP。\n\n## 4. kubernetes的网络实现\n\nk8s网络场景\n\n1. 容器与容器之间的直接通信。\n2. Pod与Pod之间的通信。\n3. Pod到Service之间的通信。\n4. 集群外部与内部组件之间的通信。\n\n### 4.1. Pod网络\n\nPod作为kubernetes的最小调度单元，Pod是容器的集合，是一个逻辑概念，Pod包含的容器都运行在同一个宿主机上，这些容器将拥有同样的网络空间，容器之间能够互相通信，它们能够在本地访问其它容器的端口。 实际上Pod都包含一个网络容器，它不做任何事情，只是用来接管Pod的网络，业务容器通过加入网络容器的网络从而实现网络共享。Pod网络本质上还是容器网络，所以Pod-IP就是网络容器的Container-IP。\n\n一般将容器云平台的网络模型打造成一个扁平化网络平面，在这个网络平面内，Pod作为一个网络单元同Kubernetes Node的网络处于同一层级\n\n### 4.2. 容器之间的通信\n\n同一个Pod之间的不同容器因为共享同一个网络命名空间，所以可以直接通过localhost直接通信。\n\n### 4.3. Pod之间的通信\n\n#### **4.3.1. 同Node的Pod之间的通信**\n\n同一个Node内，不同的Pod都有一个全局IP，可以直接通过Pod的IP进行通信。Pod地址和docker0在同一个网段。\n\n#### **4.3.2. 不同Node的Pod之间的通信**\n\n不同的Node之间，Node的IP相当于外网IP，可以直接访问，而Node内的docker0和Pod的IP则是内网IP，无法直接跨Node访问。需要通过Node的网卡进行转发。\n\n所以不同Node之间的通信需要达到两个条件：\n\n1. 对整个集群中的Pod-IP分配进行规划，不能有冲突（可以通过第三方开源工具来管理，例如flannel）。\n2. 将Node-IP与该Node上的Pod-IP关联起来，通过Node-IP再转发到Pod-IP。\n\n![Pod网络](/img/article/kubernetes/k8s网络/Pod网络.png)\n\n**1. Pod间实现通信**\n\n例如：Pod1和Pod2（同主机），Pod1和Pod3(跨主机)能够通信\n\n实现：因为Pod的Pod-IP是Docker网桥分配的，Pod-IP是同Node下全局唯一的。所以将不同Kubernetes Node的 Docker网桥配置成不同的IP网段即可。\n\n**2. Node与Pod间实现通信**\n\n例如：Node1和Pod1/ Pod2(同主机)，Pod3(跨主机)能够通信\n\n实现：在容器集群中创建一个覆盖网络(Overlay Network)，联通各个节点，目前可以通过第三方网络插件来创建覆盖网络，比如Flannel和Open vSwitch等。\n\n### 4.4. Service网络\n\nService的就是在Pod之间起到服务代理的作用，对外表现为一个单一访问接口，将请求转发给Pod，Service的网络转发是Kubernetes实现服务编排的关键一环。Service都会生成一个虚拟IP，称为Service-IP， Kuberenetes Porxy组件负责实现Service-IP路由和转发，在容器覆盖网络之上又实现了虚拟转发网络。\n\nKubernetes Porxy实现了以下功能：\n\n1. 转发访问Service的Service-IP的请求到Endpoints(即Pod-IP)。\n2. 监控Service和Endpoints的变化，实时刷新转发规则。\n3. 负载均衡能力。\n\n## 5. 开源的网络组件\n\n### 5.1. Flannel\n\n具体参考[Flannel介绍](http://blog.csdn.net/huwh_/article/details/77899108)\n\n参考《Kubernetes权威指南》","source":"_posts/Kubernetes/Kubernetes网络原理.md","raw":"---\ntitle: \"[Kubernetes] Kubernetes网络原理\"\ncatalog: true\ndate: 2017-08-13 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Kubernetes\ncatagories:\n- Kubernetes\n---\n\n## 1. kubernetes网络模型\n\n### 1.1. 基础原则\n\n1. 每个Pod都拥有一个独立的IP地址，而且假定所有Pod都在一个可以直接连通的、扁平的网络空间中，不管是否运行在同一Node上都可以通过Pod的IP来访问。\n2. k8s中Pod的IP是最小粒度IP。同一个Pod内所有的容器共享一个网络堆栈，该模型称为IP-per-Pod模型。\n3. Pod由docker0实际分配的IP，Pod内部看到的IP地址和端口与外部保持一致。同一个Pod内的不同容器共享网络，可以通过localhost来访问对方的端口，类似同一个VM内的不同进程。\n4. IP-per-Pod模型从端口分配、域名解析、服务发现、负载均衡、应用配置等角度看，Pod可以看作是一台独立的VM或物理机。\n\n### 1.2. k8s对集群的网络要求\n\n1. 所有容器都可以不用NAT的方式同别的容器通信。\n2. 所有节点都可以在不同NAT的方式下同所有容器通信，反之亦然。\n3. 容器的地址和别人看到的地址是同一个地址。\n\n以上的集群网络要求可以通过第三方开源方案实现，例如flannel。\n\n### 1.3. 网络架构图\n\n![网络架构图](/img/article/kubernetes/k8s网络/网络架构图.png)\n\n### 1.4. k8s集群IP概念汇总\n\n由集群外部到集群内部：\n\n| IP类型                | 说明                                    |\n| ------------------- | ------------------------------------- |\n| Proxy-IP            | 代理层公网地址IP，外部访问应用的网关服务器。[实际需要关注的IP]    |\n| Service-IP          | Service的固定虚拟IP，Service-IP是内部，外部无法寻址到。 |\n| Node-IP             | 容器宿主机的主机IP。                           |\n| Container-Bridge-IP | 容器网桥（docker0）IP，容器的网络都需要通过容器网桥转发。     |\n| Pod-IP              | Pod的IP，等效于Pod中网络容器的Container-IP。      |\n| Container-IP        | 容器的IP，容器的网络是个隔离的网络空间。                 |\n\n## 2. Docker的网络基础\n\n### 2.1. Network Namespace\n\n不同的网络命名空间中，协议栈是独立的，完全隔离，彼此之间无法通信。同一个网络命名空间有独立的路由表和独立的Iptables/Netfilter来提供包的转发、NAT、IP包过滤等功能。\n\n#### 2.1.1. 网络命名空间的实现\n\n将与网络协议栈相关的全局变量变成一个Net Namespace变量的成员，然后在调用协议栈函数中加入一个Namepace参数。\n\n#### 2.1.2. 网络命名空间的操作\n\n1、创建网络命名空间\n\nip netns add\n\n2、在命名空间内执行命令\n\nip netns exec\n\n3、进入命名空间\n\nip netns exec bash\n\n## 3. Docker的网络实现\n\n### 3.1. 容器网络\n\nDocker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。\n\nDocker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接Container-IP访问到容器。如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即docker run创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器。\n\n![容器网络](/img/article/kubernetes/k8s网络/容器网络.png)\n\n### 3.2. 4类网络模式\n\n| Docker网络模式  | 配置                        | 说明                                       |\n| ----------- | ------------------------- | ---------------------------------------- |\n| host模式      | –net=host                 | 容器和宿主机共享Network namespace。               |\n| container模式 | –net=container:NAME_or_ID | 容器和另外一个容器共享Network namespace。 kubernetes中的pod就是多个容器共享一个Network namespace。 |\n| none模式      | –net=none                 | 容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等。 |\n| bridge模式    | –net=bridge（默认为该模式）       |                                          |\n\n### 3.3. bridge模式\n\nk8s只使用bridge模式。\n\n在bridge模式下，Docker Daemon首次启动时会创建一个虚拟网桥docker0，地址通常为172.x.x.x开头，在私有的网络空间中给这个网络分配一个子网。由Docker创建处理的每个容器，都会创建一个虚拟以太设备（Veth设备对），一端关联到网桥，另一端使用Namespace技术映射到容器内的eth0设备，然后从网桥的地址段内给eth0接口分配一个IP地址。\n\n![image2017-5-4 20-51-53](/img/article/kubernetes/k8s网络/image2017-5-4 20-51-53.png)\n\n一般情况，宿主机IP与docker0 IP、容器IP是不同的IP段，默认情况，外部看不到docker0和容器IP，对于外部来说相当于docker0和容器的IP为内网IP。\n\n## 4. kubernetes的网络实现\n\nk8s网络场景\n\n1. 容器与容器之间的直接通信。\n2. Pod与Pod之间的通信。\n3. Pod到Service之间的通信。\n4. 集群外部与内部组件之间的通信。\n\n### 4.1. Pod网络\n\nPod作为kubernetes的最小调度单元，Pod是容器的集合，是一个逻辑概念，Pod包含的容器都运行在同一个宿主机上，这些容器将拥有同样的网络空间，容器之间能够互相通信，它们能够在本地访问其它容器的端口。 实际上Pod都包含一个网络容器，它不做任何事情，只是用来接管Pod的网络，业务容器通过加入网络容器的网络从而实现网络共享。Pod网络本质上还是容器网络，所以Pod-IP就是网络容器的Container-IP。\n\n一般将容器云平台的网络模型打造成一个扁平化网络平面，在这个网络平面内，Pod作为一个网络单元同Kubernetes Node的网络处于同一层级\n\n### 4.2. 容器之间的通信\n\n同一个Pod之间的不同容器因为共享同一个网络命名空间，所以可以直接通过localhost直接通信。\n\n### 4.3. Pod之间的通信\n\n#### **4.3.1. 同Node的Pod之间的通信**\n\n同一个Node内，不同的Pod都有一个全局IP，可以直接通过Pod的IP进行通信。Pod地址和docker0在同一个网段。\n\n#### **4.3.2. 不同Node的Pod之间的通信**\n\n不同的Node之间，Node的IP相当于外网IP，可以直接访问，而Node内的docker0和Pod的IP则是内网IP，无法直接跨Node访问。需要通过Node的网卡进行转发。\n\n所以不同Node之间的通信需要达到两个条件：\n\n1. 对整个集群中的Pod-IP分配进行规划，不能有冲突（可以通过第三方开源工具来管理，例如flannel）。\n2. 将Node-IP与该Node上的Pod-IP关联起来，通过Node-IP再转发到Pod-IP。\n\n![Pod网络](/img/article/kubernetes/k8s网络/Pod网络.png)\n\n**1. Pod间实现通信**\n\n例如：Pod1和Pod2（同主机），Pod1和Pod3(跨主机)能够通信\n\n实现：因为Pod的Pod-IP是Docker网桥分配的，Pod-IP是同Node下全局唯一的。所以将不同Kubernetes Node的 Docker网桥配置成不同的IP网段即可。\n\n**2. Node与Pod间实现通信**\n\n例如：Node1和Pod1/ Pod2(同主机)，Pod3(跨主机)能够通信\n\n实现：在容器集群中创建一个覆盖网络(Overlay Network)，联通各个节点，目前可以通过第三方网络插件来创建覆盖网络，比如Flannel和Open vSwitch等。\n\n### 4.4. Service网络\n\nService的就是在Pod之间起到服务代理的作用，对外表现为一个单一访问接口，将请求转发给Pod，Service的网络转发是Kubernetes实现服务编排的关键一环。Service都会生成一个虚拟IP，称为Service-IP， Kuberenetes Porxy组件负责实现Service-IP路由和转发，在容器覆盖网络之上又实现了虚拟转发网络。\n\nKubernetes Porxy实现了以下功能：\n\n1. 转发访问Service的Service-IP的请求到Endpoints(即Pod-IP)。\n2. 监控Service和Endpoints的变化，实时刷新转发规则。\n3. 负载均衡能力。\n\n## 5. 开源的网络组件\n\n### 5.1. Flannel\n\n具体参考[Flannel介绍](http://blog.csdn.net/huwh_/article/details/77899108)\n\n参考《Kubernetes权威指南》","slug":"Kubernetes/Kubernetes网络原理","published":1,"updated":"2017-10-02T11:24:06.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740hj000g30vu4qt1jb1u","content":"<h2><span id=\"1-kubernetes网络模型\">1. kubernetes网络模型</span></h2>\n<h3><span id=\"11-基础原则\">1.1. 基础原则</span></h3>\n<ol>\n<li>每个Pod都拥有一个独立的IP地址，而且假定所有Pod都在一个可以直接连通的、扁平的网络空间中，不管是否运行在同一Node上都可以通过Pod的IP来访问。</li>\n<li>k8s中Pod的IP是最小粒度IP。同一个Pod内所有的容器共享一个网络堆栈，该模型称为IP-per-Pod模型。</li>\n<li>Pod由docker0实际分配的IP，Pod内部看到的IP地址和端口与外部保持一致。同一个Pod内的不同容器共享网络，可以通过localhost来访问对方的端口，类似同一个VM内的不同进程。</li>\n<li>IP-per-Pod模型从端口分配、域名解析、服务发现、负载均衡、应用配置等角度看，Pod可以看作是一台独立的VM或物理机。</li>\n</ol>\n<h3><span id=\"12-k8s对集群的网络要求\">1.2. k8s对集群的网络要求</span></h3>\n<ol>\n<li>所有容器都可以不用NAT的方式同别的容器通信。</li>\n<li>所有节点都可以在不同NAT的方式下同所有容器通信，反之亦然。</li>\n<li>容器的地址和别人看到的地址是同一个地址。</li>\n</ol>\n<p>以上的集群网络要求可以通过第三方开源方案实现，例如flannel。</p>\n<h3><span id=\"13-网络架构图\">1.3. 网络架构图</span></h3>\n<p><img src=\"/img/article/kubernetes/k8s%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84%E5%9B%BE.png\" alt=\"网络架构图\"></p>\n<h3><span id=\"14-k8s集群ip概念汇总\">1.4. k8s集群IP概念汇总</span></h3>\n<p>由集群外部到集群内部：</p>\n<table>\n<thead>\n<tr>\n<th>IP类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Proxy-IP</td>\n<td>代理层公网地址IP，外部访问应用的网关服务器。[实际需要关注的IP]</td>\n</tr>\n<tr>\n<td>Service-IP</td>\n<td>Service的固定虚拟IP，Service-IP是内部，外部无法寻址到。</td>\n</tr>\n<tr>\n<td>Node-IP</td>\n<td>容器宿主机的主机IP。</td>\n</tr>\n<tr>\n<td>Container-Bridge-IP</td>\n<td>容器网桥（docker0）IP，容器的网络都需要通过容器网桥转发。</td>\n</tr>\n<tr>\n<td>Pod-IP</td>\n<td>Pod的IP，等效于Pod中网络容器的Container-IP。</td>\n</tr>\n<tr>\n<td>Container-IP</td>\n<td>容器的IP，容器的网络是个隔离的网络空间。</td>\n</tr>\n</tbody>\n</table>\n<h2><span id=\"2-docker的网络基础\">2. Docker的网络基础</span></h2>\n<h3><span id=\"21-network-namespace\">2.1. Network Namespace</span></h3>\n<p>不同的网络命名空间中，协议栈是独立的，完全隔离，彼此之间无法通信。同一个网络命名空间有独立的路由表和独立的Iptables/Netfilter来提供包的转发、NAT、IP包过滤等功能。</p>\n<h4><span id=\"211-网络命名空间的实现\">2.1.1. 网络命名空间的实现</span></h4>\n<p>将与网络协议栈相关的全局变量变成一个Net Namespace变量的成员，然后在调用协议栈函数中加入一个Namepace参数。</p>\n<h4><span id=\"212-网络命名空间的操作\">2.1.2. 网络命名空间的操作</span></h4>\n<p>1、创建网络命名空间</p>\n<p>ip netns add</p>\n<p>2、在命名空间内执行命令</p>\n<p>ip netns exec</p>\n<p>3、进入命名空间</p>\n<p>ip netns exec bash</p>\n<h2><span id=\"3-docker的网络实现\">3. Docker的网络实现</span></h2>\n<h3><span id=\"31-容器网络\">3.1. 容器网络</span></h3>\n<p>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</p>\n<p>Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接Container-IP访问到容器。如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即docker run创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器。</p>\n<p><img src=\"/img/article/kubernetes/k8s%E7%BD%91%E7%BB%9C/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C.png\" alt=\"容器网络\"></p>\n<h3><span id=\"32-4类网络模式\">3.2. 4类网络模式</span></h3>\n<table>\n<thead>\n<tr>\n<th>Docker网络模式</th>\n<th>配置</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>host模式</td>\n<td>–net=host</td>\n<td>容器和宿主机共享Network namespace。</td>\n</tr>\n<tr>\n<td>container模式</td>\n<td>–net=container:NAME_or_ID</td>\n<td>容器和另外一个容器共享Network namespace。 kubernetes中的pod就是多个容器共享一个Network namespace。</td>\n</tr>\n<tr>\n<td>none模式</td>\n<td>–net=none</td>\n<td>容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等。</td>\n</tr>\n<tr>\n<td>bridge模式</td>\n<td>–net=bridge（默认为该模式）</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3><span id=\"33-bridge模式\">3.3. bridge模式</span></h3>\n<p>k8s只使用bridge模式。</p>\n<p>在bridge模式下，Docker Daemon首次启动时会创建一个虚拟网桥docker0，地址通常为172.x.x.x开头，在私有的网络空间中给这个网络分配一个子网。由Docker创建处理的每个容器，都会创建一个虚拟以太设备（Veth设备对），一端关联到网桥，另一端使用Namespace技术映射到容器内的eth0设备，然后从网桥的地址段内给eth0接口分配一个IP地址。</p>\n<p>![image2017-5-4 20-51-53](/img/article/kubernetes/k8s网络/image2017-5-4 20-51-53.png)</p>\n<p>一般情况，宿主机IP与docker0 IP、容器IP是不同的IP段，默认情况，外部看不到docker0和容器IP，对于外部来说相当于docker0和容器的IP为内网IP。</p>\n<h2><span id=\"4-kubernetes的网络实现\">4. kubernetes的网络实现</span></h2>\n<p>k8s网络场景</p>\n<ol>\n<li>容器与容器之间的直接通信。</li>\n<li>Pod与Pod之间的通信。</li>\n<li>Pod到Service之间的通信。</li>\n<li>集群外部与内部组件之间的通信。</li>\n</ol>\n<h3><span id=\"41-pod网络\">4.1. Pod网络</span></h3>\n<p>Pod作为kubernetes的最小调度单元，Pod是容器的集合，是一个逻辑概念，Pod包含的容器都运行在同一个宿主机上，这些容器将拥有同样的网络空间，容器之间能够互相通信，它们能够在本地访问其它容器的端口。 实际上Pod都包含一个网络容器，它不做任何事情，只是用来接管Pod的网络，业务容器通过加入网络容器的网络从而实现网络共享。Pod网络本质上还是容器网络，所以Pod-IP就是网络容器的Container-IP。</p>\n<p>一般将容器云平台的网络模型打造成一个扁平化网络平面，在这个网络平面内，Pod作为一个网络单元同Kubernetes Node的网络处于同一层级</p>\n<h3><span id=\"42-容器之间的通信\">4.2. 容器之间的通信</span></h3>\n<p>同一个Pod之间的不同容器因为共享同一个网络命名空间，所以可以直接通过localhost直接通信。</p>\n<h3><span id=\"43-pod之间的通信\">4.3. Pod之间的通信</span></h3>\n<h4><span id=\"431-同node的pod之间的通信\"><strong>4.3.1. 同Node的Pod之间的通信</strong></span></h4>\n<p>同一个Node内，不同的Pod都有一个全局IP，可以直接通过Pod的IP进行通信。Pod地址和docker0在同一个网段。</p>\n<h4><span id=\"432-不同node的pod之间的通信\"><strong>4.3.2. 不同Node的Pod之间的通信</strong></span></h4>\n<p>不同的Node之间，Node的IP相当于外网IP，可以直接访问，而Node内的docker0和Pod的IP则是内网IP，无法直接跨Node访问。需要通过Node的网卡进行转发。</p>\n<p>所以不同Node之间的通信需要达到两个条件：</p>\n<ol>\n<li>对整个集群中的Pod-IP分配进行规划，不能有冲突（可以通过第三方开源工具来管理，例如flannel）。</li>\n<li>将Node-IP与该Node上的Pod-IP关联起来，通过Node-IP再转发到Pod-IP。</li>\n</ol>\n<p><img src=\"/img/article/kubernetes/k8s%E7%BD%91%E7%BB%9C/Pod%E7%BD%91%E7%BB%9C.png\" alt=\"Pod网络\"></p>\n<p><strong>1. Pod间实现通信</strong></p>\n<p>例如：Pod1和Pod2（同主机），Pod1和Pod3(跨主机)能够通信</p>\n<p>实现：因为Pod的Pod-IP是Docker网桥分配的，Pod-IP是同Node下全局唯一的。所以将不同Kubernetes Node的 Docker网桥配置成不同的IP网段即可。</p>\n<p><strong>2. Node与Pod间实现通信</strong></p>\n<p>例如：Node1和Pod1/ Pod2(同主机)，Pod3(跨主机)能够通信</p>\n<p>实现：在容器集群中创建一个覆盖网络(Overlay Network)，联通各个节点，目前可以通过第三方网络插件来创建覆盖网络，比如Flannel和Open vSwitch等。</p>\n<h3><span id=\"44-service网络\">4.4. Service网络</span></h3>\n<p>Service的就是在Pod之间起到服务代理的作用，对外表现为一个单一访问接口，将请求转发给Pod，Service的网络转发是Kubernetes实现服务编排的关键一环。Service都会生成一个虚拟IP，称为Service-IP， Kuberenetes Porxy组件负责实现Service-IP路由和转发，在容器覆盖网络之上又实现了虚拟转发网络。</p>\n<p>Kubernetes Porxy实现了以下功能：</p>\n<ol>\n<li>转发访问Service的Service-IP的请求到Endpoints(即Pod-IP)。</li>\n<li>监控Service和Endpoints的变化，实时刷新转发规则。</li>\n<li>负载均衡能力。</li>\n</ol>\n<h2><span id=\"5-开源的网络组件\">5. 开源的网络组件</span></h2>\n<h3><span id=\"51-flannel\">5.1. Flannel</span></h3>\n<p>具体参考<a href=\"http://blog.csdn.net/huwh_/article/details/77899108\" target=\"_blank\" rel=\"external\">Flannel介绍</a></p>\n<p>参考《Kubernetes权威指南》</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. kubernetes网络模型</h2>\n<h3>1.1. 基础原则</h3>\n<ol>\n<li>每个Pod都拥有一个独立的IP地址，而且假定所有Pod都在一个可以直接连通的、扁平的网络空间中，不管是否运行在同一Node上都可以通过Pod的IP来访问。</li>\n<li>k8s中Pod的IP是最小粒度IP。同一个Pod内所有的容器共享一个网络堆栈，该模型称为IP-per-Pod模型。</li>\n<li>Pod由docker0实际分配的IP，Pod内部看到的IP地址和端口与外部保持一致。同一个Pod内的不同容器共享网络，可以通过localhost来访问对方的端口，类似同一个VM内的不同进程。</li>\n<li>IP-per-Pod模型从端口分配、域名解析、服务发现、负载均衡、应用配置等角度看，Pod可以看作是一台独立的VM或物理机。</li>\n</ol>\n<h3>1.2. k8s对集群的网络要求</h3>\n<ol>\n<li>所有容器都可以不用NAT的方式同别的容器通信。</li>\n<li>所有节点都可以在不同NAT的方式下同所有容器通信，反之亦然。</li>\n<li>容器的地址和别人看到的地址是同一个地址。</li>\n</ol>\n<p>以上的集群网络要求可以通过第三方开源方案实现，例如flannel。</p>\n<h3>1.3. 网络架构图</h3>\n<p><img src=\"/img/article/kubernetes/k8s%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84%E5%9B%BE.png\" alt=\"网络架构图\"></p>\n<h3>1.4. k8s集群IP概念汇总</h3>\n<p>由集群外部到集群内部：</p>\n<table>\n<thead>\n<tr>\n<th>IP类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Proxy-IP</td>\n<td>代理层公网地址IP，外部访问应用的网关服务器。[实际需要关注的IP]</td>\n</tr>\n<tr>\n<td>Service-IP</td>\n<td>Service的固定虚拟IP，Service-IP是内部，外部无法寻址到。</td>\n</tr>\n<tr>\n<td>Node-IP</td>\n<td>容器宿主机的主机IP。</td>\n</tr>\n<tr>\n<td>Container-Bridge-IP</td>\n<td>容器网桥（docker0）IP，容器的网络都需要通过容器网桥转发。</td>\n</tr>\n<tr>\n<td>Pod-IP</td>\n<td>Pod的IP，等效于Pod中网络容器的Container-IP。</td>\n</tr>\n<tr>\n<td>Container-IP</td>\n<td>容器的IP，容器的网络是个隔离的网络空间。</td>\n</tr>\n</tbody>\n</table>\n<h2>2. Docker的网络基础</h2>\n<h3>2.1. Network Namespace</h3>\n<p>不同的网络命名空间中，协议栈是独立的，完全隔离，彼此之间无法通信。同一个网络命名空间有独立的路由表和独立的Iptables/Netfilter来提供包的转发、NAT、IP包过滤等功能。</p>\n<h4>2.1.1. 网络命名空间的实现</h4>\n<p>将与网络协议栈相关的全局变量变成一个Net Namespace变量的成员，然后在调用协议栈函数中加入一个Namepace参数。</p>\n<h4>2.1.2. 网络命名空间的操作</h4>\n<p>1、创建网络命名空间</p>\n<p>ip netns add</p>\n<p>2、在命名空间内执行命令</p>\n<p>ip netns exec</p>\n<p>3、进入命名空间</p>\n<p>ip netns exec bash</p>\n<h2>3. Docker的网络实现</h2>\n<h3>3.1. 容器网络</h3>\n<p>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</p>\n<p>Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接Container-IP访问到容器。如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即docker run创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器。</p>\n<p><img src=\"/img/article/kubernetes/k8s%E7%BD%91%E7%BB%9C/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C.png\" alt=\"容器网络\"></p>\n<h3>3.2. 4类网络模式</h3>\n<table>\n<thead>\n<tr>\n<th>Docker网络模式</th>\n<th>配置</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>host模式</td>\n<td>–net=host</td>\n<td>容器和宿主机共享Network namespace。</td>\n</tr>\n<tr>\n<td>container模式</td>\n<td>–net=container:NAME_or_ID</td>\n<td>容器和另外一个容器共享Network namespace。 kubernetes中的pod就是多个容器共享一个Network namespace。</td>\n</tr>\n<tr>\n<td>none模式</td>\n<td>–net=none</td>\n<td>容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等。</td>\n</tr>\n<tr>\n<td>bridge模式</td>\n<td>–net=bridge（默认为该模式）</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3>3.3. bridge模式</h3>\n<p>k8s只使用bridge模式。</p>\n<p>在bridge模式下，Docker Daemon首次启动时会创建一个虚拟网桥docker0，地址通常为172.x.x.x开头，在私有的网络空间中给这个网络分配一个子网。由Docker创建处理的每个容器，都会创建一个虚拟以太设备（Veth设备对），一端关联到网桥，另一端使用Namespace技术映射到容器内的eth0设备，然后从网桥的地址段内给eth0接口分配一个IP地址。</p>\n<p>![image2017-5-4 20-51-53](/img/article/kubernetes/k8s网络/image2017-5-4 20-51-53.png)</p>\n<p>一般情况，宿主机IP与docker0 IP、容器IP是不同的IP段，默认情况，外部看不到docker0和容器IP，对于外部来说相当于docker0和容器的IP为内网IP。</p>\n<h2>4. kubernetes的网络实现</h2>\n<p>k8s网络场景</p>\n<ol>\n<li>容器与容器之间的直接通信。</li>\n<li>Pod与Pod之间的通信。</li>\n<li>Pod到Service之间的通信。</li>\n<li>集群外部与内部组件之间的通信。</li>\n</ol>\n<h3>4.1. Pod网络</h3>\n<p>Pod作为kubernetes的最小调度单元，Pod是容器的集合，是一个逻辑概念，Pod包含的容器都运行在同一个宿主机上，这些容器将拥有同样的网络空间，容器之间能够互相通信，它们能够在本地访问其它容器的端口。 实际上Pod都包含一个网络容器，它不做任何事情，只是用来接管Pod的网络，业务容器通过加入网络容器的网络从而实现网络共享。Pod网络本质上还是容器网络，所以Pod-IP就是网络容器的Container-IP。</p>\n<p>一般将容器云平台的网络模型打造成一个扁平化网络平面，在这个网络平面内，Pod作为一个网络单元同Kubernetes Node的网络处于同一层级</p>\n<h3>4.2. 容器之间的通信</h3>\n<p>同一个Pod之间的不同容器因为共享同一个网络命名空间，所以可以直接通过localhost直接通信。</p>\n<h3>4.3. Pod之间的通信</h3>\n<h4><strong>4.3.1. 同Node的Pod之间的通信</strong></h4>\n<p>同一个Node内，不同的Pod都有一个全局IP，可以直接通过Pod的IP进行通信。Pod地址和docker0在同一个网段。</p>\n<h4><strong>4.3.2. 不同Node的Pod之间的通信</strong></h4>\n<p>不同的Node之间，Node的IP相当于外网IP，可以直接访问，而Node内的docker0和Pod的IP则是内网IP，无法直接跨Node访问。需要通过Node的网卡进行转发。</p>\n<p>所以不同Node之间的通信需要达到两个条件：</p>\n<ol>\n<li>对整个集群中的Pod-IP分配进行规划，不能有冲突（可以通过第三方开源工具来管理，例如flannel）。</li>\n<li>将Node-IP与该Node上的Pod-IP关联起来，通过Node-IP再转发到Pod-IP。</li>\n</ol>\n<p><img src=\"/img/article/kubernetes/k8s%E7%BD%91%E7%BB%9C/Pod%E7%BD%91%E7%BB%9C.png\" alt=\"Pod网络\"></p>\n<p><strong>1. Pod间实现通信</strong></p>\n<p>例如：Pod1和Pod2（同主机），Pod1和Pod3(跨主机)能够通信</p>\n<p>实现：因为Pod的Pod-IP是Docker网桥分配的，Pod-IP是同Node下全局唯一的。所以将不同Kubernetes Node的 Docker网桥配置成不同的IP网段即可。</p>\n<p><strong>2. Node与Pod间实现通信</strong></p>\n<p>例如：Node1和Pod1/ Pod2(同主机)，Pod3(跨主机)能够通信</p>\n<p>实现：在容器集群中创建一个覆盖网络(Overlay Network)，联通各个节点，目前可以通过第三方网络插件来创建覆盖网络，比如Flannel和Open vSwitch等。</p>\n<h3>4.4. Service网络</h3>\n<p>Service的就是在Pod之间起到服务代理的作用，对外表现为一个单一访问接口，将请求转发给Pod，Service的网络转发是Kubernetes实现服务编排的关键一环。Service都会生成一个虚拟IP，称为Service-IP， Kuberenetes Porxy组件负责实现Service-IP路由和转发，在容器覆盖网络之上又实现了虚拟转发网络。</p>\n<p>Kubernetes Porxy实现了以下功能：</p>\n<ol>\n<li>转发访问Service的Service-IP的请求到Endpoints(即Pod-IP)。</li>\n<li>监控Service和Endpoints的变化，实时刷新转发规则。</li>\n<li>负载均衡能力。</li>\n</ol>\n<h2>5. 开源的网络组件</h2>\n<h3>5.1. Flannel</h3>\n<p>具体参考<a href=\"http://blog.csdn.net/huwh_/article/details/77899108\" target=\"_blank\" rel=\"external\">Flannel介绍</a></p>\n<p>参考《Kubernetes权威指南》</p>\n"},{"title":"[Kubernetes] Kubernetes集群问题排查","catalog":true,"date":"2017-09-20T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Kubernetes"],"_content":"\n## 1. 查看系统Event事件\n\n ```\nkubectl describe pod <PodName> --namespace=<NAMESPACE> \n ```\n\n该命令可以显示Pod创建时的配置定义、状态等信息和最近的Event事件，事件信息可用于排错。例如当Pod状态为Pending，可通过查看Event事件确认原因，一般原因有几种：\n\n- 没有可用的Node可调度\n- 开启了资源配额管理并且当前Pod的目标节点上恰好没有可用的资源\n- 正在下载镜像（镜像拉取耗时太久）或镜像下载失败。\n\nkubectl describe还可以查看其它k8s对象：NODE,RC,Service,Namespace,Secrets。\n\n### 1.1. Pod\n\n```\nkubectl describe pod <PodName> --namespace=<NAMESPACE>\n```\n\n以下是容器的启动命令非阻塞式导致容器挂掉，被k8s频繁重启所产生的事件。\n\n```shell\nkubectl describe pod <PodName> --namespace=<NAMESPACE>  \n\nEvents:\n  FirstSeen LastSeen    Count   From            SubobjectPath       Reason      Message\n  ───────── ────────    ─────   ────            ─────────────       ──────      ───────\n  7m        7m      1   {scheduler }                    Scheduled   Successfully assigned yangsc-1-0-0-index0 to 10.8.216.19\n  7m        7m      1   {kubelet 10.8.216.19}   containers{infra}   Pulled      Container image \"registry.wae.haplat.net/kube-system/pause:0.8.0\" already present on machine\n  7m        7m      1   {kubelet 10.8.216.19}   containers{infra}   Created     Created with docker id 84f133c324d0\n  7m        7m      1   {kubelet 10.8.216.19}   containers{infra}   Started     Started with docker id 84f133c324d0\n  7m        7m      1   {kubelet 10.8.216.19}   containers{yangsc0} Started     Started with docker id 3f9f82abb145\n  7m        7m      1   {kubelet 10.8.216.19}   containers{yangsc0} Created     Created with docker id 3f9f82abb145\n  7m        7m      1   {kubelet 10.8.216.19}   containers{yangsc0} Created     Created with docker id fb112e4002f4\n  7m        7m      1   {kubelet 10.8.216.19}   containers{yangsc0} Started     Started with docker id fb112e4002f4\n  6m        6m      1   {kubelet 10.8.216.19}   containers{yangsc0} Created     Created with docker id 613b119d4474\n  6m        6m      1   {kubelet 10.8.216.19}   containers{yangsc0} Started     Started with docker id 613b119d4474\n  6m        6m      1   {kubelet 10.8.216.19}   containers{yangsc0} Created     Created with docker id 25cb68d1fd3d\n  6m        6m      1   {kubelet 10.8.216.19}   containers{yangsc0} Started     Started with docker id 25cb68d1fd3d\n  5m        5m      1   {kubelet 10.8.216.19}   containers{yangsc0} Started     Started with docker id 7d9ee8610b28\n  5m        5m      1   {kubelet 10.8.216.19}   containers{yangsc0} Created     Created with docker id 7d9ee8610b28\n  3m        3m      1   {kubelet 10.8.216.19}   containers{yangsc0} Started     Started with docker id 88b9e8d582dd\n  3m        3m      1   {kubelet 10.8.216.19}   containers{yangsc0} Created     Created with docker id 88b9e8d582dd\n  7m        1m      7   {kubelet 10.8.216.19}   containers{yangsc0} Pulling     Pulling image \"registry.ts.wae.haplat.net/test/tcp-hello:1.0.0\"\n  1m        1m      1   {kubelet 10.8.216.19}   containers{yangsc0} Started     Started with docker id 089abff050e7\n  1m        1m      1   {kubelet 10.8.216.19}   containers{yangsc0} Created     Created with docker id 089abff050e7\n  7m        1m      7   {kubelet 10.8.216.19}   containers{yangsc0} Pulled      Successfully pulled image \"registry.ts.wae.haplat.net/test/tcp-hello:1.0.0\"\n  6m        7s      34  {kubelet 10.8.216.19}   containers{yangsc0} Backoff     Back-off restarting failed docker container\n```\n\n### 1.2. NODE\n\n```\nkubectl describe node 10.8.216.20\n```\n\n```shell\n[root@FC-43745A-10 ~]# kubectl describe node 10.8.216.20  \nName:           10.8.216.20  \nLabels:         kubernetes.io/hostname=10.8.216.20,namespace/bcs-cc=true,namespace/myview=true  \nCreationTimestamp:  Mon, 17 Apr 2017 11:32:52 +0800  \nPhase:            \nConditions:  \n  Type      Status  LastHeartbeatTime           LastTransitionTime          Reason              Message  \n  ────      ──────  ─────────────────           ──────────────────          ──────              ───────  \n  Ready     True    Fri, 18 Aug 2017 09:38:33 +0800     Tue, 02 May 2017 17:40:58 +0800     KubeletReady            kubelet is posting ready status  \n  OutOfDisk     False   Fri, 18 Aug 2017 09:38:33 +0800     Mon, 17 Apr 2017 11:31:27 +0800     KubeletHasSufficientDisk    kubelet has sufficient disk space available  \nAddresses:  10.8.216.20,10.8.216.20  \nCapacity:  \n cpu:       32  \n memory:    67323039744  \n pods:      40  \nSystem Info:  \n Machine ID:            723bafc7f6764022972b3eae1ce6b198  \n System UUID:           4C4C4544-0042-4210-8044-C3C04F595631  \n Boot ID:           da01f2e3-987a-425a-9ca7-1caaec35d1e5  \n Kernel Version:        3.10.0-327.28.3.el7.x86_64  \n OS Image:          CentOS Linux 7 (Core)  \n Container Runtime Version: docker://1.13.1  \n Kubelet Version:       v1.1.1-wae2-13.1+79c90c68bfb72f-dirty  \n Kube-Proxy Version:        v1.1.1-wae2-13.1+79c90c68bfb72f-dirty  \nExternalID:         10.8.216.20  \nNon-terminated Pods:        (6 in total)  \n  Namespace         Name                    CPU Requests    CPU Limits  Memory Requests Memory Limits  \n  ─────────         ────                    ────────────    ──────────  ─────────────── ─────────────  \n  bcs-cc            bcs-cc-api-0-0-1364-index0      1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  \n  bcs-cc            bcs-cc-api-0-0-1444-index0      1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  \n  fw                fw-demo2-0-0-1519-index0        1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  \n  myview            myview-api-0-0-1362-index0      1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  \n  myview            myview-api-0-0-1442-index0      1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  \n  qa-ts-dna         ts-dna-console3-0-0-1434-index0     1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  \nAllocated resources:  \n  (Total limits may be over 100%, i.e., overcommitted. More info: http://releases.k8s.io/HEAD/docs/user-guide/compute-resources.md)  \n  CPU Requests  CPU Limits  Memory Requests     Memory Limits  \n  ────────────  ──────────  ───────────────     ─────────────  \n  6 (18%)   6 (18%)     25769803776 (38%)   25769803776 (38%)  \nNo events.  \n```\n\n### 1.3. RC\n\n```\nkubectl describe rc mytest-1-0-0 --namespace=test\n```\n\n```shell\n[root@FC-43745A-10 ~]# kubectl describe rc mytest-1-0-0 --namespace=test  \nName:       mytest-1-0-0  \nNamespace:  test  \nImage(s):   registry.ts.wae.haplat.net/test/mywebcalculator:1.0.1  \nSelector:   app=mytest,appVersion=1.0.0  \nLabels:     app=mytest,appVersion=1.0.0,env=ts,zone=inner  \nReplicas:   1 current / 1 desired  \nPods Status:    1 Running / 0 Waiting / 0 Succeeded / 0 Failed  \nNo volumes.  \nEvents:  \n  FirstSeen LastSeen    Count   From                SubobjectPath   Reason          Message  \n  ───────── ────────    ─────   ────                ─────────────   ──────          ───────  \n  20h       19h     9   {replication-controller }           FailedCreate        Error creating: Pod \"mytest-1-0-0-index0\" is forbidden: limited to 10 pods  \n  20h       17h     7   {replication-controller }           FailedCreate        Error creating: pods \"mytest-1-0-0-index0\" already exists  \n  20h       17h     4   {replication-controller }           SuccessfulCreate    Created pod: mytest-1-0-0-index0  \n```\n\n### 1.4. NAMESPACE\n\n```\nkubectl describe namespace test\n```\n\n```shell\n[root@FC-43745A-10 ~]# kubectl describe namespace test  \nName:   test  \nLabels: <none>  \nStatus: Active  \n  \nResource Quotas  \n Resource       Used        Hard  \n ---            ---     ---  \n cpu            5       20  \n memory         1342177280  53687091200  \n persistentvolumeclaims 0       10  \n pods           4       10  \n replicationcontrollers 8       20  \n resourcequotas     1       1  \n secrets        3       10  \n services       8       20  \n  \nNo resource limits.  \n```\n\n### 1.5. Service\n\n```\nkubectl describe service wae-containers-1-1-0 --namespace=test\n```\n\n```shell\n[root@FC-43745A-10 ~]# kubectl describe service wae-containers-1-1-0 --namespace=test  \nName:           wae-containers-1-1-0  \nNamespace:      test  \nLabels:         app=wae-containers,appVersion=1.1.0,env=ts,zone=inner  \nSelector:       app=wae-containers,appVersion=1.1.0  \nType:           ClusterIP  \nIP:         10.254.46.42  \nPort:           port-dna-tcp-35913  35913/TCP  \nEndpoints:      10.0.92.17:35913  \nPort:           port-l7-tcp-8080    8080/TCP  \nEndpoints:      10.0.92.17:8080  \nSession Affinity:   None  \nNo events.  \n```\n\n## 2. 查看容器日志\n\n1、查看指定pod的日志\n\n```shell\nkubectl logs <pod_name>\n\nkubectl logs -f <pod_name> #类似tail -f的方式查看\n```\n\n2、查看上一个pod的日志\n\n```\nkubectl logs -p <pod_name>\n```\n\n3、查看指定pod中指定容器的日志\n\n```\nkubectl logs <pod_name> -c <container_name>\n```\n\n4、kubectl logs --help\n\n```shell\n[root@node5 ~]# kubectl logs --help  \nPrint the logs for a container in a pod. If the pod has only one container, the container name is optional.  \nUsage:  \n  kubectl logs [-f] [-p] POD [-c CONTAINER] [flags]  \nAliases:  \n  logs, log  \n   \nExamples:  \n# Return snapshot logs from pod nginx with only one container  \n$ kubectl logs nginx  \n# Return snapshot of previous terminated ruby container logs from pod web-1  \n$ kubectl logs -p -c ruby web-1  \n# Begin streaming the logs of the ruby container in pod web-1  \n$ kubectl logs -f -c ruby web-1  \n# Display only the most recent 20 lines of output in pod nginx  \n$ kubectl logs --tail=20 nginx  \n# Show all logs from pod nginx written in the last hour  \n$ kubectl logs --since=1h nginx  \n```\n\n## 3. 查看k8s服务日志\n\n### 3.1. journalctl\n\n在Linux系统上systemd系统来管理kubernetes服务，并且journal系统会接管服务程序的输出日志，可以通过**systemctl status <xxx>或journalctl -u <xxx> -f**来查看kubernetes服务的日志。\n\n其中kubernetes组件包括：\n\n| k8s组件                   | 涉及日志内容           | 备注   |\n| ----------------------- | ---------------- | ---- |\n| kube-apiserver          |                  |      |\n| kube-controller-manager | Pod扩容相关或RC相关     |      |\n| kube-scheduler          | Pod扩容相关或RC相关     |      |\n| kubelet                 | Pod生命周期相关：创建、停止等 |      |\n| etcd                    |                  |      |\n\n### 3.2. 日志文件\n\n也可以通过指定日志存放目录来保存和查看日志\n\n- --logtostderr=false：不输出到stderr\n- --log-dir=/var/log/kubernetes:日志的存放目录\n- --alsologtostderr=false:设置为true表示日志输出到文件也输出到stderr\n- --v=0:glog的日志级别\n- --vmodule=gfs*=2,test*=4：glog基于模块的详细日志级别\n\n## 4. 常见问题\n\n### 4.1. Pod状态一直为Pending\n\n```\nkubectl describe <pod_name> --namespace=<NAMESPACE>\n```\n\n查看该POD的事件。\n\n- 正在下载镜像但拉取不下来（镜像拉取耗时太久）[一般都是该原因]\n- 没有可用的Node可调度\n- 开启了资源配额管理并且当前Pod的目标节点上恰好没有可用的资源\n\n解决方法：\n\n1. 查看该POD所在宿主机与镜像仓库之间的网络是否有问题，可以手动拉取镜像\n2. 删除POD实例，让POD调度到别的宿主机上\n\n### 4.2. Pod创建后不断重启\n\nkubectl get pods中Pod状态一会running，一会不是，且RESTARTS次数不断增加。\n\n一般原因为容器启动命令不是阻塞式命令，导致容器运行后马上退出。\n\n非阻塞式命令：\n\n- 本身CMD指定的命令就是非阻塞式命令\n- 将服务启动方式设置为后台运行\n\n解决方法：\n\n1、将命令改为阻塞式命令（前台运行），例如：**zkServer.sh start-foreground**\n\n2、java运行程序的启动脚本将 nohup xxx &的nobup和&去掉，例如：\n\n```shell\nnohup JAVA_HOME/bin/java JAVA_OPTS -cp $CLASSPATH com.cnc.open.processor.Main &\n```\n\n改为：\n\n```shell\nJAVA_HOME/bin/java JAVA_OPTS -cp $CLASSPATH com.cnc.open.processor.Main\n```\n\n \n\n文章参考《Kubernetes权威指南》","source":"_posts/Kubernetes/Kubernetes集群问题排查.md","raw":"---\ntitle: \"[Kubernetes] Kubernetes集群问题排查\"\ncatalog: true\ndate: 2017-09-20 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Kubernetes\ncatagories:\n- Kubernetes\n---\n\n## 1. 查看系统Event事件\n\n ```\nkubectl describe pod <PodName> --namespace=<NAMESPACE> \n ```\n\n该命令可以显示Pod创建时的配置定义、状态等信息和最近的Event事件，事件信息可用于排错。例如当Pod状态为Pending，可通过查看Event事件确认原因，一般原因有几种：\n\n- 没有可用的Node可调度\n- 开启了资源配额管理并且当前Pod的目标节点上恰好没有可用的资源\n- 正在下载镜像（镜像拉取耗时太久）或镜像下载失败。\n\nkubectl describe还可以查看其它k8s对象：NODE,RC,Service,Namespace,Secrets。\n\n### 1.1. Pod\n\n```\nkubectl describe pod <PodName> --namespace=<NAMESPACE>\n```\n\n以下是容器的启动命令非阻塞式导致容器挂掉，被k8s频繁重启所产生的事件。\n\n```shell\nkubectl describe pod <PodName> --namespace=<NAMESPACE>  \n\nEvents:\n  FirstSeen LastSeen    Count   From            SubobjectPath       Reason      Message\n  ───────── ────────    ─────   ────            ─────────────       ──────      ───────\n  7m        7m      1   {scheduler }                    Scheduled   Successfully assigned yangsc-1-0-0-index0 to 10.8.216.19\n  7m        7m      1   {kubelet 10.8.216.19}   containers{infra}   Pulled      Container image \"registry.wae.haplat.net/kube-system/pause:0.8.0\" already present on machine\n  7m        7m      1   {kubelet 10.8.216.19}   containers{infra}   Created     Created with docker id 84f133c324d0\n  7m        7m      1   {kubelet 10.8.216.19}   containers{infra}   Started     Started with docker id 84f133c324d0\n  7m        7m      1   {kubelet 10.8.216.19}   containers{yangsc0} Started     Started with docker id 3f9f82abb145\n  7m        7m      1   {kubelet 10.8.216.19}   containers{yangsc0} Created     Created with docker id 3f9f82abb145\n  7m        7m      1   {kubelet 10.8.216.19}   containers{yangsc0} Created     Created with docker id fb112e4002f4\n  7m        7m      1   {kubelet 10.8.216.19}   containers{yangsc0} Started     Started with docker id fb112e4002f4\n  6m        6m      1   {kubelet 10.8.216.19}   containers{yangsc0} Created     Created with docker id 613b119d4474\n  6m        6m      1   {kubelet 10.8.216.19}   containers{yangsc0} Started     Started with docker id 613b119d4474\n  6m        6m      1   {kubelet 10.8.216.19}   containers{yangsc0} Created     Created with docker id 25cb68d1fd3d\n  6m        6m      1   {kubelet 10.8.216.19}   containers{yangsc0} Started     Started with docker id 25cb68d1fd3d\n  5m        5m      1   {kubelet 10.8.216.19}   containers{yangsc0} Started     Started with docker id 7d9ee8610b28\n  5m        5m      1   {kubelet 10.8.216.19}   containers{yangsc0} Created     Created with docker id 7d9ee8610b28\n  3m        3m      1   {kubelet 10.8.216.19}   containers{yangsc0} Started     Started with docker id 88b9e8d582dd\n  3m        3m      1   {kubelet 10.8.216.19}   containers{yangsc0} Created     Created with docker id 88b9e8d582dd\n  7m        1m      7   {kubelet 10.8.216.19}   containers{yangsc0} Pulling     Pulling image \"registry.ts.wae.haplat.net/test/tcp-hello:1.0.0\"\n  1m        1m      1   {kubelet 10.8.216.19}   containers{yangsc0} Started     Started with docker id 089abff050e7\n  1m        1m      1   {kubelet 10.8.216.19}   containers{yangsc0} Created     Created with docker id 089abff050e7\n  7m        1m      7   {kubelet 10.8.216.19}   containers{yangsc0} Pulled      Successfully pulled image \"registry.ts.wae.haplat.net/test/tcp-hello:1.0.0\"\n  6m        7s      34  {kubelet 10.8.216.19}   containers{yangsc0} Backoff     Back-off restarting failed docker container\n```\n\n### 1.2. NODE\n\n```\nkubectl describe node 10.8.216.20\n```\n\n```shell\n[root@FC-43745A-10 ~]# kubectl describe node 10.8.216.20  \nName:           10.8.216.20  \nLabels:         kubernetes.io/hostname=10.8.216.20,namespace/bcs-cc=true,namespace/myview=true  \nCreationTimestamp:  Mon, 17 Apr 2017 11:32:52 +0800  \nPhase:            \nConditions:  \n  Type      Status  LastHeartbeatTime           LastTransitionTime          Reason              Message  \n  ────      ──────  ─────────────────           ──────────────────          ──────              ───────  \n  Ready     True    Fri, 18 Aug 2017 09:38:33 +0800     Tue, 02 May 2017 17:40:58 +0800     KubeletReady            kubelet is posting ready status  \n  OutOfDisk     False   Fri, 18 Aug 2017 09:38:33 +0800     Mon, 17 Apr 2017 11:31:27 +0800     KubeletHasSufficientDisk    kubelet has sufficient disk space available  \nAddresses:  10.8.216.20,10.8.216.20  \nCapacity:  \n cpu:       32  \n memory:    67323039744  \n pods:      40  \nSystem Info:  \n Machine ID:            723bafc7f6764022972b3eae1ce6b198  \n System UUID:           4C4C4544-0042-4210-8044-C3C04F595631  \n Boot ID:           da01f2e3-987a-425a-9ca7-1caaec35d1e5  \n Kernel Version:        3.10.0-327.28.3.el7.x86_64  \n OS Image:          CentOS Linux 7 (Core)  \n Container Runtime Version: docker://1.13.1  \n Kubelet Version:       v1.1.1-wae2-13.1+79c90c68bfb72f-dirty  \n Kube-Proxy Version:        v1.1.1-wae2-13.1+79c90c68bfb72f-dirty  \nExternalID:         10.8.216.20  \nNon-terminated Pods:        (6 in total)  \n  Namespace         Name                    CPU Requests    CPU Limits  Memory Requests Memory Limits  \n  ─────────         ────                    ────────────    ──────────  ─────────────── ─────────────  \n  bcs-cc            bcs-cc-api-0-0-1364-index0      1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  \n  bcs-cc            bcs-cc-api-0-0-1444-index0      1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  \n  fw                fw-demo2-0-0-1519-index0        1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  \n  myview            myview-api-0-0-1362-index0      1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  \n  myview            myview-api-0-0-1442-index0      1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  \n  qa-ts-dna         ts-dna-console3-0-0-1434-index0     1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  \nAllocated resources:  \n  (Total limits may be over 100%, i.e., overcommitted. More info: http://releases.k8s.io/HEAD/docs/user-guide/compute-resources.md)  \n  CPU Requests  CPU Limits  Memory Requests     Memory Limits  \n  ────────────  ──────────  ───────────────     ─────────────  \n  6 (18%)   6 (18%)     25769803776 (38%)   25769803776 (38%)  \nNo events.  \n```\n\n### 1.3. RC\n\n```\nkubectl describe rc mytest-1-0-0 --namespace=test\n```\n\n```shell\n[root@FC-43745A-10 ~]# kubectl describe rc mytest-1-0-0 --namespace=test  \nName:       mytest-1-0-0  \nNamespace:  test  \nImage(s):   registry.ts.wae.haplat.net/test/mywebcalculator:1.0.1  \nSelector:   app=mytest,appVersion=1.0.0  \nLabels:     app=mytest,appVersion=1.0.0,env=ts,zone=inner  \nReplicas:   1 current / 1 desired  \nPods Status:    1 Running / 0 Waiting / 0 Succeeded / 0 Failed  \nNo volumes.  \nEvents:  \n  FirstSeen LastSeen    Count   From                SubobjectPath   Reason          Message  \n  ───────── ────────    ─────   ────                ─────────────   ──────          ───────  \n  20h       19h     9   {replication-controller }           FailedCreate        Error creating: Pod \"mytest-1-0-0-index0\" is forbidden: limited to 10 pods  \n  20h       17h     7   {replication-controller }           FailedCreate        Error creating: pods \"mytest-1-0-0-index0\" already exists  \n  20h       17h     4   {replication-controller }           SuccessfulCreate    Created pod: mytest-1-0-0-index0  \n```\n\n### 1.4. NAMESPACE\n\n```\nkubectl describe namespace test\n```\n\n```shell\n[root@FC-43745A-10 ~]# kubectl describe namespace test  \nName:   test  \nLabels: <none>  \nStatus: Active  \n  \nResource Quotas  \n Resource       Used        Hard  \n ---            ---     ---  \n cpu            5       20  \n memory         1342177280  53687091200  \n persistentvolumeclaims 0       10  \n pods           4       10  \n replicationcontrollers 8       20  \n resourcequotas     1       1  \n secrets        3       10  \n services       8       20  \n  \nNo resource limits.  \n```\n\n### 1.5. Service\n\n```\nkubectl describe service wae-containers-1-1-0 --namespace=test\n```\n\n```shell\n[root@FC-43745A-10 ~]# kubectl describe service wae-containers-1-1-0 --namespace=test  \nName:           wae-containers-1-1-0  \nNamespace:      test  \nLabels:         app=wae-containers,appVersion=1.1.0,env=ts,zone=inner  \nSelector:       app=wae-containers,appVersion=1.1.0  \nType:           ClusterIP  \nIP:         10.254.46.42  \nPort:           port-dna-tcp-35913  35913/TCP  \nEndpoints:      10.0.92.17:35913  \nPort:           port-l7-tcp-8080    8080/TCP  \nEndpoints:      10.0.92.17:8080  \nSession Affinity:   None  \nNo events.  \n```\n\n## 2. 查看容器日志\n\n1、查看指定pod的日志\n\n```shell\nkubectl logs <pod_name>\n\nkubectl logs -f <pod_name> #类似tail -f的方式查看\n```\n\n2、查看上一个pod的日志\n\n```\nkubectl logs -p <pod_name>\n```\n\n3、查看指定pod中指定容器的日志\n\n```\nkubectl logs <pod_name> -c <container_name>\n```\n\n4、kubectl logs --help\n\n```shell\n[root@node5 ~]# kubectl logs --help  \nPrint the logs for a container in a pod. If the pod has only one container, the container name is optional.  \nUsage:  \n  kubectl logs [-f] [-p] POD [-c CONTAINER] [flags]  \nAliases:  \n  logs, log  \n   \nExamples:  \n# Return snapshot logs from pod nginx with only one container  \n$ kubectl logs nginx  \n# Return snapshot of previous terminated ruby container logs from pod web-1  \n$ kubectl logs -p -c ruby web-1  \n# Begin streaming the logs of the ruby container in pod web-1  \n$ kubectl logs -f -c ruby web-1  \n# Display only the most recent 20 lines of output in pod nginx  \n$ kubectl logs --tail=20 nginx  \n# Show all logs from pod nginx written in the last hour  \n$ kubectl logs --since=1h nginx  \n```\n\n## 3. 查看k8s服务日志\n\n### 3.1. journalctl\n\n在Linux系统上systemd系统来管理kubernetes服务，并且journal系统会接管服务程序的输出日志，可以通过**systemctl status <xxx>或journalctl -u <xxx> -f**来查看kubernetes服务的日志。\n\n其中kubernetes组件包括：\n\n| k8s组件                   | 涉及日志内容           | 备注   |\n| ----------------------- | ---------------- | ---- |\n| kube-apiserver          |                  |      |\n| kube-controller-manager | Pod扩容相关或RC相关     |      |\n| kube-scheduler          | Pod扩容相关或RC相关     |      |\n| kubelet                 | Pod生命周期相关：创建、停止等 |      |\n| etcd                    |                  |      |\n\n### 3.2. 日志文件\n\n也可以通过指定日志存放目录来保存和查看日志\n\n- --logtostderr=false：不输出到stderr\n- --log-dir=/var/log/kubernetes:日志的存放目录\n- --alsologtostderr=false:设置为true表示日志输出到文件也输出到stderr\n- --v=0:glog的日志级别\n- --vmodule=gfs*=2,test*=4：glog基于模块的详细日志级别\n\n## 4. 常见问题\n\n### 4.1. Pod状态一直为Pending\n\n```\nkubectl describe <pod_name> --namespace=<NAMESPACE>\n```\n\n查看该POD的事件。\n\n- 正在下载镜像但拉取不下来（镜像拉取耗时太久）[一般都是该原因]\n- 没有可用的Node可调度\n- 开启了资源配额管理并且当前Pod的目标节点上恰好没有可用的资源\n\n解决方法：\n\n1. 查看该POD所在宿主机与镜像仓库之间的网络是否有问题，可以手动拉取镜像\n2. 删除POD实例，让POD调度到别的宿主机上\n\n### 4.2. Pod创建后不断重启\n\nkubectl get pods中Pod状态一会running，一会不是，且RESTARTS次数不断增加。\n\n一般原因为容器启动命令不是阻塞式命令，导致容器运行后马上退出。\n\n非阻塞式命令：\n\n- 本身CMD指定的命令就是非阻塞式命令\n- 将服务启动方式设置为后台运行\n\n解决方法：\n\n1、将命令改为阻塞式命令（前台运行），例如：**zkServer.sh start-foreground**\n\n2、java运行程序的启动脚本将 nohup xxx &的nobup和&去掉，例如：\n\n```shell\nnohup JAVA_HOME/bin/java JAVA_OPTS -cp $CLASSPATH com.cnc.open.processor.Main &\n```\n\n改为：\n\n```shell\nJAVA_HOME/bin/java JAVA_OPTS -cp $CLASSPATH com.cnc.open.processor.Main\n```\n\n \n\n文章参考《Kubernetes权威指南》","slug":"Kubernetes/Kubernetes集群问题排查","published":1,"updated":"2017-10-02T13:11:53.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740i9000h30vuhw8l4h8s","content":"<h2><span id=\"1-查看系统event事件\">1. 查看系统Event事件</span></h2>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl describe pod <span class=\"tag\">&lt;<span class=\"name\">PodName</span>&gt;</span> --namespace=<span class=\"tag\">&lt;<span class=\"name\">NAMESPACE</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>该命令可以显示Pod创建时的配置定义、状态等信息和最近的Event事件，事件信息可用于排错。例如当Pod状态为Pending，可通过查看Event事件确认原因，一般原因有几种：</p>\n<ul>\n<li>没有可用的Node可调度</li>\n<li>开启了资源配额管理并且当前Pod的目标节点上恰好没有可用的资源</li>\n<li>正在下载镜像（镜像拉取耗时太久）或镜像下载失败。</li>\n</ul>\n<p>kubectl describe还可以查看其它k8s对象：NODE,RC,Service,Namespace,Secrets。</p>\n<h3><span id=\"11-pod\">1.1. Pod</span></h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl describe pod <span class=\"tag\">&lt;<span class=\"name\">PodName</span>&gt;</span> --namespace=<span class=\"tag\">&lt;<span class=\"name\">NAMESPACE</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>以下是容器的启动命令非阻塞式导致容器挂掉，被k8s频繁重启所产生的事件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl describe pod &lt;PodName&gt; --namespace=&lt;NAMESPACE&gt;  </div><div class=\"line\"></div><div class=\"line\">Events:</div><div class=\"line\">  FirstSeen LastSeen    Count   From            SubobjectPath       Reason      Message</div><div class=\"line\">  ───────── ────────    ─────   ────            ─────────────       ──────      ───────</div><div class=\"line\">  7m        7m      1   &#123;scheduler &#125;                    Scheduled   Successfully assigned yangsc-1-0-0-index0 to 10.8.216.19</div><div class=\"line\">  7m        7m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;infra&#125;   Pulled      Container image \"registry.wae.haplat.net/kube-system/pause:0.8.0\" already present on machine</div><div class=\"line\">  7m        7m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;infra&#125;   Created     Created with docker id 84f133c324d0</div><div class=\"line\">  7m        7m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;infra&#125;   Started     Started with docker id 84f133c324d0</div><div class=\"line\">  7m        7m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Started     Started with docker id 3f9f82abb145</div><div class=\"line\">  7m        7m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Created     Created with docker id 3f9f82abb145</div><div class=\"line\">  7m        7m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Created     Created with docker id fb112e4002f4</div><div class=\"line\">  7m        7m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Started     Started with docker id fb112e4002f4</div><div class=\"line\">  6m        6m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Created     Created with docker id 613b119d4474</div><div class=\"line\">  6m        6m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Started     Started with docker id 613b119d4474</div><div class=\"line\">  6m        6m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Created     Created with docker id 25cb68d1fd3d</div><div class=\"line\">  6m        6m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Started     Started with docker id 25cb68d1fd3d</div><div class=\"line\">  5m        5m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Started     Started with docker id 7d9ee8610b28</div><div class=\"line\">  5m        5m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Created     Created with docker id 7d9ee8610b28</div><div class=\"line\">  3m        3m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Started     Started with docker id 88b9e8d582dd</div><div class=\"line\">  3m        3m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Created     Created with docker id 88b9e8d582dd</div><div class=\"line\">  7m        1m      7   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Pulling     Pulling image \"registry.ts.wae.haplat.net/test/tcp-hello:1.0.0\"</div><div class=\"line\">  1m        1m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Started     Started with docker id 089abff050e7</div><div class=\"line\">  1m        1m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Created     Created with docker id 089abff050e7</div><div class=\"line\">  7m        1m      7   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Pulled      Successfully pulled image \"registry.ts.wae.haplat.net/test/tcp-hello:1.0.0\"</div><div class=\"line\">  6m        7s      34  &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Backoff     Back-off restarting failed docker container</div></pre></td></tr></table></figure>\n<h3><span id=\"12-node\">1.2. NODE</span></h3>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl describe <span class=\"keyword\">node</span> <span class=\"title\">10</span>.<span class=\"number\">8.216</span>.<span class=\"number\">20</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@FC-43745A-10 ~]# kubectl describe node 10.8.216.20  </div><div class=\"line\">Name:           10.8.216.20  </div><div class=\"line\">Labels:         kubernetes.io/hostname=10.8.216.20,namespace/bcs-cc=true,namespace/myview=true  </div><div class=\"line\">CreationTimestamp:  Mon, 17 Apr 2017 11:32:52 +0800  </div><div class=\"line\">Phase:            </div><div class=\"line\">Conditions:  </div><div class=\"line\">  Type      Status  LastHeartbeatTime           LastTransitionTime          Reason              Message  </div><div class=\"line\">  ────      ──────  ─────────────────           ──────────────────          ──────              ───────  </div><div class=\"line\">  Ready     True    Fri, 18 Aug 2017 09:38:33 +0800     Tue, 02 May 2017 17:40:58 +0800     KubeletReady            kubelet is posting ready status  </div><div class=\"line\">  OutOfDisk     False   Fri, 18 Aug 2017 09:38:33 +0800     Mon, 17 Apr 2017 11:31:27 +0800     KubeletHasSufficientDisk    kubelet has sufficient disk space available  </div><div class=\"line\">Addresses:  10.8.216.20,10.8.216.20  </div><div class=\"line\">Capacity:  </div><div class=\"line\"> cpu:       32  </div><div class=\"line\"> memory:    67323039744  </div><div class=\"line\"> pods:      40  </div><div class=\"line\">System Info:  </div><div class=\"line\"> Machine ID:            723bafc7f6764022972b3eae1ce6b198  </div><div class=\"line\"> System UUID:           4C4C4544-0042-4210-8044-C3C04F595631  </div><div class=\"line\"> Boot ID:           da01f2e3-987a-425a-9ca7-1caaec35d1e5  </div><div class=\"line\"> Kernel Version:        3.10.0-327.28.3.el7.x86_64  </div><div class=\"line\"> OS Image:          CentOS Linux 7 (Core)  </div><div class=\"line\"> Container Runtime Version: docker://1.13.1  </div><div class=\"line\"> Kubelet Version:       v1.1.1-wae2-13.1+79c90c68bfb72f-dirty  </div><div class=\"line\"> Kube-Proxy Version:        v1.1.1-wae2-13.1+79c90c68bfb72f-dirty  </div><div class=\"line\">ExternalID:         10.8.216.20  </div><div class=\"line\">Non-terminated Pods:        (6 in total)  </div><div class=\"line\">  Namespace         Name                    CPU Requests    CPU Limits  Memory Requests Memory Limits  </div><div class=\"line\">  ─────────         ────                    ────────────    ──────────  ─────────────── ─────────────  </div><div class=\"line\">  bcs-cc            bcs-cc-api-0-0-1364-index0      1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  </div><div class=\"line\">  bcs-cc            bcs-cc-api-0-0-1444-index0      1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  </div><div class=\"line\">  fw                fw-demo2-0-0-1519-index0        1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  </div><div class=\"line\">  myview            myview-api-0-0-1362-index0      1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  </div><div class=\"line\">  myview            myview-api-0-0-1442-index0      1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  </div><div class=\"line\">  qa-ts-dna         ts-dna-console3-0-0-1434-index0     1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  </div><div class=\"line\">Allocated resources:  </div><div class=\"line\">  (Total limits may be over 100%, i.e., overcommitted. More info: http://releases.k8s.io/HEAD/docs/user-guide/compute-resources.md)  </div><div class=\"line\">  CPU Requests  CPU Limits  Memory Requests     Memory Limits  </div><div class=\"line\">  ────────────  ──────────  ───────────────     ─────────────  </div><div class=\"line\">  6 (18%)   6 (18%)     25769803776 (38%)   25769803776 (38%)  </div><div class=\"line\">No events.</div></pre></td></tr></table></figure>\n<h3><span id=\"13-rc\">1.3. RC</span></h3>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl describe rc mytest<span class=\"number\">-1</span><span class=\"number\">-0</span><span class=\"number\">-0</span> --namespace=test</div></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@FC-43745A-10 ~]# kubectl describe rc mytest-1-0-0 --namespace=test  </div><div class=\"line\">Name:       mytest-1-0-0  </div><div class=\"line\">Namespace:  test  </div><div class=\"line\">Image(s):   registry.ts.wae.haplat.net/test/mywebcalculator:1.0.1  </div><div class=\"line\">Selector:   app=mytest,appVersion=1.0.0  </div><div class=\"line\">Labels:     app=mytest,appVersion=1.0.0,env=ts,zone=inner  </div><div class=\"line\">Replicas:   1 current / 1 desired  </div><div class=\"line\">Pods Status:    1 Running / 0 Waiting / 0 Succeeded / 0 Failed  </div><div class=\"line\">No volumes.  </div><div class=\"line\">Events:  </div><div class=\"line\">  FirstSeen LastSeen    Count   From                SubobjectPath   Reason          Message  </div><div class=\"line\">  ───────── ────────    ─────   ────                ─────────────   ──────          ───────  </div><div class=\"line\">  20h       19h     9   &#123;replication-controller &#125;           FailedCreate        Error creating: Pod \"mytest-1-0-0-index0\" is forbidden: limited to 10 pods  </div><div class=\"line\">  20h       17h     7   &#123;replication-controller &#125;           FailedCreate        Error creating: pods \"mytest-1-0-0-index0\" already exists  </div><div class=\"line\">  20h       17h     4   &#123;replication-controller &#125;           SuccessfulCreate    Created pod: mytest-1-0-0-index0</div></pre></td></tr></table></figure>\n<h3><span id=\"14-namespace\">1.4. NAMESPACE</span></h3>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl <span class=\"keyword\">describe</span> namespace <span class=\"keyword\">test</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@FC-43745A-10 ~]# kubectl describe namespace test  </div><div class=\"line\">Name:   test  </div><div class=\"line\">Labels: &lt;none&gt;  </div><div class=\"line\">Status: Active  </div><div class=\"line\">  </div><div class=\"line\">Resource Quotas  </div><div class=\"line\"> Resource       Used        Hard  </div><div class=\"line\"> ---            ---     ---  </div><div class=\"line\"> cpu            5       20  </div><div class=\"line\"> memory         1342177280  53687091200  </div><div class=\"line\"> persistentvolumeclaims 0       10  </div><div class=\"line\"> pods           4       10  </div><div class=\"line\"> replicationcontrollers 8       20  </div><div class=\"line\"> resourcequotas     1       1  </div><div class=\"line\"> secrets        3       10  </div><div class=\"line\"> services       8       20  </div><div class=\"line\">  </div><div class=\"line\">No resource limits.</div></pre></td></tr></table></figure>\n<h3><span id=\"15-service\">1.5. Service</span></h3>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl describe<span class=\"built_in\"> service </span>wae-containers-1-1-0 <span class=\"attribute\">--namespace</span>=test</div></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@FC-43745A-10 ~]# kubectl describe service wae-containers-1-1-0 --namespace=test  </div><div class=\"line\">Name:           wae-containers-1-1-0  </div><div class=\"line\">Namespace:      test  </div><div class=\"line\">Labels:         app=wae-containers,appVersion=1.1.0,env=ts,zone=inner  </div><div class=\"line\">Selector:       app=wae-containers,appVersion=1.1.0  </div><div class=\"line\">Type:           ClusterIP  </div><div class=\"line\">IP:         10.254.46.42  </div><div class=\"line\">Port:           port-dna-tcp-35913  35913/TCP  </div><div class=\"line\">Endpoints:      10.0.92.17:35913  </div><div class=\"line\">Port:           port-l7-tcp-8080    8080/TCP  </div><div class=\"line\">Endpoints:      10.0.92.17:8080  </div><div class=\"line\">Session Affinity:   None  </div><div class=\"line\">No events.</div></pre></td></tr></table></figure>\n<h2><span id=\"2-查看容器日志\">2. 查看容器日志</span></h2>\n<p>1、查看指定pod的日志</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl logs &lt;pod_name&gt;</div><div class=\"line\"></div><div class=\"line\">kubectl logs -f &lt;pod_name&gt; #类似tail -f的方式查看</div></pre></td></tr></table></figure>\n<p>2、查看上一个pod的日志</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl logs -<span class=\"selector-tag\">p</span> &lt;pod_name&gt;</div></pre></td></tr></table></figure>\n<p>3、查看指定pod中指定容器的日志</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl logs <span class=\"tag\">&lt;<span class=\"name\">pod_name</span>&gt;</span> -c <span class=\"tag\">&lt;<span class=\"name\">container_name</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>4、kubectl logs --help</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@node5 ~]# kubectl logs --help  </div><div class=\"line\">Print the logs for a container in a pod. If the pod has only one container, the container name is optional.  </div><div class=\"line\">Usage:  </div><div class=\"line\">  kubectl logs [-f] [-p] POD [-c CONTAINER] [flags]  </div><div class=\"line\">Aliases:  </div><div class=\"line\">  logs, log  </div><div class=\"line\">   </div><div class=\"line\">Examples:  </div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Return snapshot logs from pod nginx with only one container  </span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> kubectl logs nginx  </span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Return snapshot of previous terminated ruby container logs from pod web-1  </span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> kubectl logs -p -c ruby web-1  </span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Begin streaming the logs of the ruby container <span class=\"keyword\">in</span> pod web-1  </span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> kubectl logs -f -c ruby web-1  </span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Display only the most recent 20 lines of output <span class=\"keyword\">in</span> pod nginx  </span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> kubectl logs --tail=20 nginx  </span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Show all logs from pod nginx written <span class=\"keyword\">in</span> the last hour  </span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> kubectl logs --since=1h nginx</span></div></pre></td></tr></table></figure>\n<h2><span id=\"3-查看k8s服务日志\">3. 查看k8s服务日志</span></h2>\n<h3><span id=\"31-journalctl\">3.1. journalctl</span></h3>\n<p>在Linux系统上systemd系统来管理kubernetes服务，并且journal系统会接管服务程序的输出日志，可以通过<strong>systemctl status <xxx>或journalctl -u <xxx> -f</xxx></xxx></strong>来查看kubernetes服务的日志。</p>\n<p>其中kubernetes组件包括：</p>\n<table>\n<thead>\n<tr>\n<th>k8s组件</th>\n<th>涉及日志内容</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>kube-apiserver</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>kube-controller-manager</td>\n<td>Pod扩容相关或RC相关</td>\n<td></td>\n</tr>\n<tr>\n<td>kube-scheduler</td>\n<td>Pod扩容相关或RC相关</td>\n<td></td>\n</tr>\n<tr>\n<td>kubelet</td>\n<td>Pod生命周期相关：创建、停止等</td>\n<td></td>\n</tr>\n<tr>\n<td>etcd</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3><span id=\"32-日志文件\">3.2. 日志文件</span></h3>\n<p>也可以通过指定日志存放目录来保存和查看日志</p>\n<ul>\n<li>–logtostderr=false：不输出到stderr</li>\n<li>–log-dir=/var/log/kubernetes:日志的存放目录</li>\n<li>–alsologtostderr=false:设置为true表示日志输出到文件也输出到stderr</li>\n<li>–v=0:glog的日志级别</li>\n<li>–vmodule=gfs*=2,test*=4：glog基于模块的详细日志级别</li>\n</ul>\n<h2><span id=\"4-常见问题\">4. 常见问题</span></h2>\n<h3><span id=\"41-pod状态一直为pending\">4.1. Pod状态一直为Pending</span></h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl describe <span class=\"tag\">&lt;<span class=\"name\">pod_name</span>&gt;</span> --namespace=<span class=\"tag\">&lt;<span class=\"name\">NAMESPACE</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>查看该POD的事件。</p>\n<ul>\n<li>正在下载镜像但拉取不下来（镜像拉取耗时太久）[一般都是该原因]</li>\n<li>没有可用的Node可调度</li>\n<li>开启了资源配额管理并且当前Pod的目标节点上恰好没有可用的资源</li>\n</ul>\n<p>解决方法：</p>\n<ol>\n<li>查看该POD所在宿主机与镜像仓库之间的网络是否有问题，可以手动拉取镜像</li>\n<li>删除POD实例，让POD调度到别的宿主机上</li>\n</ol>\n<h3><span id=\"42-pod创建后不断重启\">4.2. Pod创建后不断重启</span></h3>\n<p>kubectl get pods中Pod状态一会running，一会不是，且RESTARTS次数不断增加。</p>\n<p>一般原因为容器启动命令不是阻塞式命令，导致容器运行后马上退出。</p>\n<p>非阻塞式命令：</p>\n<ul>\n<li>本身CMD指定的命令就是非阻塞式命令</li>\n<li>将服务启动方式设置为后台运行</li>\n</ul>\n<p>解决方法：</p>\n<p>1、将命令改为阻塞式命令（前台运行），例如：<strong><a href=\"http://zkServer.sh\" target=\"_blank\" rel=\"external\">zkServer.sh</a> start-foreground</strong></p>\n<p>2、java运行程序的启动脚本将 nohup xxx &amp;的nobup和&amp;去掉，例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nohup JAVA_HOME/bin/java JAVA_OPTS -cp $CLASSPATH com.cnc.open.processor.Main &amp;</div></pre></td></tr></table></figure>\n<p>改为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">JAVA_HOME/bin/java JAVA_OPTS -cp $CLASSPATH com.cnc.open.processor.Main</div></pre></td></tr></table></figure>\n<p>文章参考《Kubernetes权威指南》</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 查看系统Event事件</h2>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl describe pod <span class=\"tag\">&lt;<span class=\"name\">PodName</span>&gt;</span> --namespace=<span class=\"tag\">&lt;<span class=\"name\">NAMESPACE</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>该命令可以显示Pod创建时的配置定义、状态等信息和最近的Event事件，事件信息可用于排错。例如当Pod状态为Pending，可通过查看Event事件确认原因，一般原因有几种：</p>\n<ul>\n<li>没有可用的Node可调度</li>\n<li>开启了资源配额管理并且当前Pod的目标节点上恰好没有可用的资源</li>\n<li>正在下载镜像（镜像拉取耗时太久）或镜像下载失败。</li>\n</ul>\n<p>kubectl describe还可以查看其它k8s对象：NODE,RC,Service,Namespace,Secrets。</p>\n<h3>1.1. Pod</h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl describe pod <span class=\"tag\">&lt;<span class=\"name\">PodName</span>&gt;</span> --namespace=<span class=\"tag\">&lt;<span class=\"name\">NAMESPACE</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>以下是容器的启动命令非阻塞式导致容器挂掉，被k8s频繁重启所产生的事件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl describe pod &lt;PodName&gt; --namespace=&lt;NAMESPACE&gt;  </div><div class=\"line\"></div><div class=\"line\">Events:</div><div class=\"line\">  FirstSeen LastSeen    Count   From            SubobjectPath       Reason      Message</div><div class=\"line\">  ───────── ────────    ─────   ────            ─────────────       ──────      ───────</div><div class=\"line\">  7m        7m      1   &#123;scheduler &#125;                    Scheduled   Successfully assigned yangsc-1-0-0-index0 to 10.8.216.19</div><div class=\"line\">  7m        7m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;infra&#125;   Pulled      Container image \"registry.wae.haplat.net/kube-system/pause:0.8.0\" already present on machine</div><div class=\"line\">  7m        7m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;infra&#125;   Created     Created with docker id 84f133c324d0</div><div class=\"line\">  7m        7m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;infra&#125;   Started     Started with docker id 84f133c324d0</div><div class=\"line\">  7m        7m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Started     Started with docker id 3f9f82abb145</div><div class=\"line\">  7m        7m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Created     Created with docker id 3f9f82abb145</div><div class=\"line\">  7m        7m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Created     Created with docker id fb112e4002f4</div><div class=\"line\">  7m        7m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Started     Started with docker id fb112e4002f4</div><div class=\"line\">  6m        6m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Created     Created with docker id 613b119d4474</div><div class=\"line\">  6m        6m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Started     Started with docker id 613b119d4474</div><div class=\"line\">  6m        6m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Created     Created with docker id 25cb68d1fd3d</div><div class=\"line\">  6m        6m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Started     Started with docker id 25cb68d1fd3d</div><div class=\"line\">  5m        5m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Started     Started with docker id 7d9ee8610b28</div><div class=\"line\">  5m        5m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Created     Created with docker id 7d9ee8610b28</div><div class=\"line\">  3m        3m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Started     Started with docker id 88b9e8d582dd</div><div class=\"line\">  3m        3m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Created     Created with docker id 88b9e8d582dd</div><div class=\"line\">  7m        1m      7   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Pulling     Pulling image \"registry.ts.wae.haplat.net/test/tcp-hello:1.0.0\"</div><div class=\"line\">  1m        1m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Started     Started with docker id 089abff050e7</div><div class=\"line\">  1m        1m      1   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Created     Created with docker id 089abff050e7</div><div class=\"line\">  7m        1m      7   &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Pulled      Successfully pulled image \"registry.ts.wae.haplat.net/test/tcp-hello:1.0.0\"</div><div class=\"line\">  6m        7s      34  &#123;kubelet 10.8.216.19&#125;   containers&#123;yangsc0&#125; Backoff     Back-off restarting failed docker container</div></pre></td></tr></table></figure>\n<h3>1.2. NODE</h3>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl describe <span class=\"keyword\">node</span> <span class=\"title\">10</span>.<span class=\"number\">8.216</span>.<span class=\"number\">20</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@FC-43745A-10 ~]# kubectl describe node 10.8.216.20  </div><div class=\"line\">Name:           10.8.216.20  </div><div class=\"line\">Labels:         kubernetes.io/hostname=10.8.216.20,namespace/bcs-cc=true,namespace/myview=true  </div><div class=\"line\">CreationTimestamp:  Mon, 17 Apr 2017 11:32:52 +0800  </div><div class=\"line\">Phase:            </div><div class=\"line\">Conditions:  </div><div class=\"line\">  Type      Status  LastHeartbeatTime           LastTransitionTime          Reason              Message  </div><div class=\"line\">  ────      ──────  ─────────────────           ──────────────────          ──────              ───────  </div><div class=\"line\">  Ready     True    Fri, 18 Aug 2017 09:38:33 +0800     Tue, 02 May 2017 17:40:58 +0800     KubeletReady            kubelet is posting ready status  </div><div class=\"line\">  OutOfDisk     False   Fri, 18 Aug 2017 09:38:33 +0800     Mon, 17 Apr 2017 11:31:27 +0800     KubeletHasSufficientDisk    kubelet has sufficient disk space available  </div><div class=\"line\">Addresses:  10.8.216.20,10.8.216.20  </div><div class=\"line\">Capacity:  </div><div class=\"line\"> cpu:       32  </div><div class=\"line\"> memory:    67323039744  </div><div class=\"line\"> pods:      40  </div><div class=\"line\">System Info:  </div><div class=\"line\"> Machine ID:            723bafc7f6764022972b3eae1ce6b198  </div><div class=\"line\"> System UUID:           4C4C4544-0042-4210-8044-C3C04F595631  </div><div class=\"line\"> Boot ID:           da01f2e3-987a-425a-9ca7-1caaec35d1e5  </div><div class=\"line\"> Kernel Version:        3.10.0-327.28.3.el7.x86_64  </div><div class=\"line\"> OS Image:          CentOS Linux 7 (Core)  </div><div class=\"line\"> Container Runtime Version: docker://1.13.1  </div><div class=\"line\"> Kubelet Version:       v1.1.1-wae2-13.1+79c90c68bfb72f-dirty  </div><div class=\"line\"> Kube-Proxy Version:        v1.1.1-wae2-13.1+79c90c68bfb72f-dirty  </div><div class=\"line\">ExternalID:         10.8.216.20  </div><div class=\"line\">Non-terminated Pods:        (6 in total)  </div><div class=\"line\">  Namespace         Name                    CPU Requests    CPU Limits  Memory Requests Memory Limits  </div><div class=\"line\">  ─────────         ────                    ────────────    ──────────  ─────────────── ─────────────  </div><div class=\"line\">  bcs-cc            bcs-cc-api-0-0-1364-index0      1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  </div><div class=\"line\">  bcs-cc            bcs-cc-api-0-0-1444-index0      1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  </div><div class=\"line\">  fw                fw-demo2-0-0-1519-index0        1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  </div><div class=\"line\">  myview            myview-api-0-0-1362-index0      1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  </div><div class=\"line\">  myview            myview-api-0-0-1442-index0      1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  </div><div class=\"line\">  qa-ts-dna         ts-dna-console3-0-0-1434-index0     1 (3%)      1 (3%)      4294967296 (6%) 4294967296 (6%)  </div><div class=\"line\">Allocated resources:  </div><div class=\"line\">  (Total limits may be over 100%, i.e., overcommitted. More info: http://releases.k8s.io/HEAD/docs/user-guide/compute-resources.md)  </div><div class=\"line\">  CPU Requests  CPU Limits  Memory Requests     Memory Limits  </div><div class=\"line\">  ────────────  ──────────  ───────────────     ─────────────  </div><div class=\"line\">  6 (18%)   6 (18%)     25769803776 (38%)   25769803776 (38%)  </div><div class=\"line\">No events.</div></pre></td></tr></table></figure>\n<h3>1.3. RC</h3>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl describe rc mytest<span class=\"number\">-1</span><span class=\"number\">-0</span><span class=\"number\">-0</span> --namespace=test</div></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@FC-43745A-10 ~]# kubectl describe rc mytest-1-0-0 --namespace=test  </div><div class=\"line\">Name:       mytest-1-0-0  </div><div class=\"line\">Namespace:  test  </div><div class=\"line\">Image(s):   registry.ts.wae.haplat.net/test/mywebcalculator:1.0.1  </div><div class=\"line\">Selector:   app=mytest,appVersion=1.0.0  </div><div class=\"line\">Labels:     app=mytest,appVersion=1.0.0,env=ts,zone=inner  </div><div class=\"line\">Replicas:   1 current / 1 desired  </div><div class=\"line\">Pods Status:    1 Running / 0 Waiting / 0 Succeeded / 0 Failed  </div><div class=\"line\">No volumes.  </div><div class=\"line\">Events:  </div><div class=\"line\">  FirstSeen LastSeen    Count   From                SubobjectPath   Reason          Message  </div><div class=\"line\">  ───────── ────────    ─────   ────                ─────────────   ──────          ───────  </div><div class=\"line\">  20h       19h     9   &#123;replication-controller &#125;           FailedCreate        Error creating: Pod \"mytest-1-0-0-index0\" is forbidden: limited to 10 pods  </div><div class=\"line\">  20h       17h     7   &#123;replication-controller &#125;           FailedCreate        Error creating: pods \"mytest-1-0-0-index0\" already exists  </div><div class=\"line\">  20h       17h     4   &#123;replication-controller &#125;           SuccessfulCreate    Created pod: mytest-1-0-0-index0</div></pre></td></tr></table></figure>\n<h3>1.4. NAMESPACE</h3>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl <span class=\"keyword\">describe</span> namespace <span class=\"keyword\">test</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@FC-43745A-10 ~]# kubectl describe namespace test  </div><div class=\"line\">Name:   test  </div><div class=\"line\">Labels: &lt;none&gt;  </div><div class=\"line\">Status: Active  </div><div class=\"line\">  </div><div class=\"line\">Resource Quotas  </div><div class=\"line\"> Resource       Used        Hard  </div><div class=\"line\"> ---            ---     ---  </div><div class=\"line\"> cpu            5       20  </div><div class=\"line\"> memory         1342177280  53687091200  </div><div class=\"line\"> persistentvolumeclaims 0       10  </div><div class=\"line\"> pods           4       10  </div><div class=\"line\"> replicationcontrollers 8       20  </div><div class=\"line\"> resourcequotas     1       1  </div><div class=\"line\"> secrets        3       10  </div><div class=\"line\"> services       8       20  </div><div class=\"line\">  </div><div class=\"line\">No resource limits.</div></pre></td></tr></table></figure>\n<h3>1.5. Service</h3>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl describe<span class=\"built_in\"> service </span>wae-containers-1-1-0 <span class=\"attribute\">--namespace</span>=test</div></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@FC-43745A-10 ~]# kubectl describe service wae-containers-1-1-0 --namespace=test  </div><div class=\"line\">Name:           wae-containers-1-1-0  </div><div class=\"line\">Namespace:      test  </div><div class=\"line\">Labels:         app=wae-containers,appVersion=1.1.0,env=ts,zone=inner  </div><div class=\"line\">Selector:       app=wae-containers,appVersion=1.1.0  </div><div class=\"line\">Type:           ClusterIP  </div><div class=\"line\">IP:         10.254.46.42  </div><div class=\"line\">Port:           port-dna-tcp-35913  35913/TCP  </div><div class=\"line\">Endpoints:      10.0.92.17:35913  </div><div class=\"line\">Port:           port-l7-tcp-8080    8080/TCP  </div><div class=\"line\">Endpoints:      10.0.92.17:8080  </div><div class=\"line\">Session Affinity:   None  </div><div class=\"line\">No events.</div></pre></td></tr></table></figure>\n<h2>2. 查看容器日志</h2>\n<p>1、查看指定pod的日志</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl logs &lt;pod_name&gt;</div><div class=\"line\"></div><div class=\"line\">kubectl logs -f &lt;pod_name&gt; #类似tail -f的方式查看</div></pre></td></tr></table></figure>\n<p>2、查看上一个pod的日志</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl logs -<span class=\"selector-tag\">p</span> &lt;pod_name&gt;</div></pre></td></tr></table></figure>\n<p>3、查看指定pod中指定容器的日志</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl logs <span class=\"tag\">&lt;<span class=\"name\">pod_name</span>&gt;</span> -c <span class=\"tag\">&lt;<span class=\"name\">container_name</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>4、kubectl logs --help</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@node5 ~]# kubectl logs --help  </div><div class=\"line\">Print the logs for a container in a pod. If the pod has only one container, the container name is optional.  </div><div class=\"line\">Usage:  </div><div class=\"line\">  kubectl logs [-f] [-p] POD [-c CONTAINER] [flags]  </div><div class=\"line\">Aliases:  </div><div class=\"line\">  logs, log  </div><div class=\"line\">   </div><div class=\"line\">Examples:  </div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Return snapshot logs from pod nginx with only one container  </span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> kubectl logs nginx  </span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Return snapshot of previous terminated ruby container logs from pod web-1  </span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> kubectl logs -p -c ruby web-1  </span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Begin streaming the logs of the ruby container <span class=\"keyword\">in</span> pod web-1  </span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> kubectl logs -f -c ruby web-1  </span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Display only the most recent 20 lines of output <span class=\"keyword\">in</span> pod nginx  </span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> kubectl logs --tail=20 nginx  </span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Show all logs from pod nginx written <span class=\"keyword\">in</span> the last hour  </span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> kubectl logs --since=1h nginx</span></div></pre></td></tr></table></figure>\n<h2>3. 查看k8s服务日志</h2>\n<h3>3.1. journalctl</h3>\n<p>在Linux系统上systemd系统来管理kubernetes服务，并且journal系统会接管服务程序的输出日志，可以通过<strong>systemctl status <xxx>或journalctl -u <xxx> -f</xxx></xxx></strong>来查看kubernetes服务的日志。</p>\n<p>其中kubernetes组件包括：</p>\n<table>\n<thead>\n<tr>\n<th>k8s组件</th>\n<th>涉及日志内容</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>kube-apiserver</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>kube-controller-manager</td>\n<td>Pod扩容相关或RC相关</td>\n<td></td>\n</tr>\n<tr>\n<td>kube-scheduler</td>\n<td>Pod扩容相关或RC相关</td>\n<td></td>\n</tr>\n<tr>\n<td>kubelet</td>\n<td>Pod生命周期相关：创建、停止等</td>\n<td></td>\n</tr>\n<tr>\n<td>etcd</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3>3.2. 日志文件</h3>\n<p>也可以通过指定日志存放目录来保存和查看日志</p>\n<ul>\n<li>–logtostderr=false：不输出到stderr</li>\n<li>–log-dir=/var/log/kubernetes:日志的存放目录</li>\n<li>–alsologtostderr=false:设置为true表示日志输出到文件也输出到stderr</li>\n<li>–v=0:glog的日志级别</li>\n<li>–vmodule=gfs*=2,test*=4：glog基于模块的详细日志级别</li>\n</ul>\n<h2>4. 常见问题</h2>\n<h3>4.1. Pod状态一直为Pending</h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl describe <span class=\"tag\">&lt;<span class=\"name\">pod_name</span>&gt;</span> --namespace=<span class=\"tag\">&lt;<span class=\"name\">NAMESPACE</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>查看该POD的事件。</p>\n<ul>\n<li>正在下载镜像但拉取不下来（镜像拉取耗时太久）[一般都是该原因]</li>\n<li>没有可用的Node可调度</li>\n<li>开启了资源配额管理并且当前Pod的目标节点上恰好没有可用的资源</li>\n</ul>\n<p>解决方法：</p>\n<ol>\n<li>查看该POD所在宿主机与镜像仓库之间的网络是否有问题，可以手动拉取镜像</li>\n<li>删除POD实例，让POD调度到别的宿主机上</li>\n</ol>\n<h3>4.2. Pod创建后不断重启</h3>\n<p>kubectl get pods中Pod状态一会running，一会不是，且RESTARTS次数不断增加。</p>\n<p>一般原因为容器启动命令不是阻塞式命令，导致容器运行后马上退出。</p>\n<p>非阻塞式命令：</p>\n<ul>\n<li>本身CMD指定的命令就是非阻塞式命令</li>\n<li>将服务启动方式设置为后台运行</li>\n</ul>\n<p>解决方法：</p>\n<p>1、将命令改为阻塞式命令（前台运行），例如：<strong><a href=\"http://zkServer.sh\" target=\"_blank\" rel=\"external\">zkServer.sh</a> start-foreground</strong></p>\n<p>2、java运行程序的启动脚本将 nohup xxx &amp;的nobup和&amp;去掉，例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nohup JAVA_HOME/bin/java JAVA_OPTS -cp $CLASSPATH com.cnc.open.processor.Main &amp;</div></pre></td></tr></table></figure>\n<p>改为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">JAVA_HOME/bin/java JAVA_OPTS -cp $CLASSPATH com.cnc.open.processor.Main</div></pre></td></tr></table></figure>\n<p>文章参考《Kubernetes权威指南》</p>\n"},{"title":"[Nginx] Nginx的部署与配置","catalog":true,"date":"2017-09-13T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Nginx"],"_content":"\n## 1. 部署\n\n### 1.1. 使用安装包的方式\n\nrpm -ivh nginx-xxx.rpm\n\n### 1.2. 使用源代码安装\n\n#### 1.2.1. 下载源码包\n\n```shell\nwget http://blob.wae.haplat.net/nginx/nginx-1.9.13.tar.gz\n```\n\n### 1.2.2. 创建临时目录并解压源码包\n\n```shell\nmkdir $HOME/build\ncd $HOME/build && tar zxvf nginx-`version-number`.tar.gz\n```\n\n#### 1.2.3. 编译并安装\n\n```shell\n cd $HOME/build/nginx-`version-number`\n \n./configure \\\n--prefix=/etc/nginx \\\n--sbin-path=/usr/sbin/nginx \\\n--conf-path=/etc/nginx/nginx.conf \\\n...\n#`更多配置项见以下说明`\n \nmake && make install\n```\n\n#### 1.2.4. 配置项\n\n##### 1.2.4.1. 通用配置项\n\n| 配置选项                    | 说明                                       |\n| ----------------------- | ---------------------------------------- |\n| --prefix=`path`         | nginx安装的根路径，所有其他的路径都要依赖与该选项              |\n| --sbin-path=`path`      | nginx二进制文件的路径，如果没有指定则会依赖于--prefix        |\n| --conf-path=`path`      | 如果在命令行中没有指定配置文件，则通过该配置项去查找配置文件           |\n| --error-log-path=`path` | 指定错误文件的路径                                |\n| --pid-path=`path`       | 指定的文件将会写入nginx master进程的pid，通常在/var/run下 |\n| --lock-path=`path`      | 共享存储器互斥锁文件的路径                            |\n| --user=`user`           | worker进程运行的用户                            |\n| --group=`group`         | worker进程运行的组                             |\n| --with-file-aio         | 启动异步I/O                                  |\n| --with-debug            | 启用调试日志，生产环境不推荐配置                         |\n\n##### 1.2.4.2. 优化配置项\n\n| 配置选项                    | 说明                    |\n| ----------------------- | --------------------- |\n| --with-cc=`path`        | 如果想设置一个不在默认PATH下的C编译器 |\n| --with-cpp=`path`       | 设置C预处理器的相应路径          |\n| --with-cc-opt=`options` | 指定必要的include文件路径      |\n| --with-ld-opt=`options` | 包含连接器库的路径和运行路径        |\n| --with-cpu-opt=`cpu`    | 通过该选项为特定的CPU构建nginx   |\n\n##### 1.2.4.3. http模块的配置项\n\n| 配置选项                                | 说明                                       |\n| ----------------------------------- | ---------------------------------------- |\n| --without-http-cache                | 在使用upstream模块时，nginx能够配置本地缓存内容，该选项可以禁用缓存 |\n| --with-http_perl_module             | nginx配置能够扩展使用perl代码。该项启用这个模块，但会降低性能      |\n| --with-perl_modules_path=`path`     | 对于额外嵌入的perl模块，该选项指定该perl解析器的路径           |\n| --with-perl=`path`                  | 如果在默认的路径中找不到perl则指定perl（5.6版本以上）的路径      |\n| --http-log-path=`path`              | http访问日志的默认路径                            |\n| --http-client-body-temp-path=`path` | 从客户端收到请求后，该项用于作为请求体临时存放的目录               |\n| --http-proxy-temp-path=`path`       | 在使用代理后，通过该项设置存放临时文件路径                    |\n| --http-fastcgi-temp-path=`path`     | 设置FastCGI临时文件的目录                         |\n| --http-uwsgi-temp-path=`path`       | 设置uWSGI临时文件的目录                           |\n| --http-scgi-temp-path=`path`        | 设置SCGI临时文件的目录                            |\n\n##### 1.2.4.4. 其他模块额外配置项\n\n默认没有安装这些模块，可以通过--with-`module-name`_module来启用相应的模块功能。\n\n| 配置选项                            | 说明                                       |\n| ------------------------------- | ---------------------------------------- |\n| --with-http_ssl_module          | 如果需要对流量进行加密，可以使用该选项，再URLs中开始部分将会是https(需要OpenSSL库) |\n| --with-http_realip_module       | 如果nginx在七层负载均衡器或者其他设备之后，它们将Http头中的客户端IP地址传递，则需要启用该模块，再多个客户处于一个IP地址的情况下使用 |\n| --with-http_addition_module     | 该模块作为输出过滤器，使能够在请求经过一个location前或后时在该location本身添加内容 |\n| --with-http_xslt_module         | 该模块用于处理XML响应转换，基于一个或多个XSLT格式             |\n| --with-http_image_filter_module | 该模块被作为图像过滤器使用，在将图像投递到客户之前进行处理（需要libgd库）  |\n| --with-http_geoip_module        | 使用该模块，能够设置各种变量以便在配置文件中的区段使用，基于地理位置查找客户端IP地址 |\n| --with-http_sub_module          | 该模块实现替代过滤，在响应中用一个字符串替代另一个字符串             |\n| --with-heep_dav_module          | 启用这个模块将激活使用WebDAV的配置指令。                  |\n| --with-http_flv_module          | 如果需要提供Flash流媒体视频文件，那么该模块将会提供伪流媒体         |\n| --with-http_mp4_module          | 这个模块支持H.264/AAC文件伪流媒体                    |\n| --with-http_gzip_static_module  | 当被调用的资源没有.gz结尾格式的文件时，如果想支持发送预压缩版本的静态文件，那么使用该模块 |\n| --with-http_gunzip_module       | 对于不支持gzip编码的客户，该模块用于为客户解压缩预压缩内容          |\n| --with-http_random_index_module | 如果你想提供从一个目录中随机选择文件的索引文件，那么该模块需要激活        |\n| --with-http_secure_link_module  | 该模块提供一种机制，它会将一个哈希值链接到一个URL中，因此只有那些使用正确密码能够计算链接 |\n| --with-http_stub_status_module  | 启用这个模块后会收集Nginx自身的状态信息。输出的状态信息可以使用RRDtool或类似的东西绘制成图 |\n\n## 2. 配置\n\n配置文件一般为/etc/nginx/nginx.conf或/usr/local/nginx/conf/nginx.conf。\n\n### 2.1. 基本配置格式\n\n```shell\n`section`{\n    `directive` `parameters`;\n}\n```\n\n每一个指令行由分号结束，大括号{}表示一个新的上下文。\n\n### 2.2. Nginx全局配置参数\n\n全局配置指令\n\n| 模块                 | 配置项                                      | 说明                                       |\n| ------------------ | ---------------------------------------- | ---------------------------------------- |\n| main模块             | user                                     | 配置worker进程的用户和组，如果忽略group，则group等于指定的用户的所属组 |\n| worker_processes   | 指定worker进程的启动数量，可将其设置为可用的CPU内核数，若为auto为自动检测 |                                          |\n| error_log          | 所有错误的写入文件，第二个参数指定错误的级别（debug，info，notice，warn，error，crit，alert，emerg） |                                          |\n| pid                | 设置主进程IP的文件                               |                                          |\n| events模块           | use                                      | 用于设置使用什么样的连接方法                           |\n| worker_connections | 用于配置一个工作进程能够接受的并发连接最大数。包括客户连接和向上游服务器的连接。 |                                          |\n\n### 2.3. 使用include文件\n\ninclude文件可以在任何地方以增强配置文件的可读性，使用include文件要确保被包含文件自身正确的nginx语法，即配置指令和块，然后指定这些文件的路径。\n\ninclude /etc/nginx/mime.types;\n\n若使用通配符则表示通配的多个文件，若没有给定全路径则依据主配置文件路径进行搜索。\n\ninclude /etc/nginx/conf.d/*.conf\n\n测试配置文件(包括include的配置文件)语法：\n\nnginx -t -c path-to-nginx.conf\n\n### 2.4. 配置说明\n\n#### 2.4.1. main模块\n\n```shell\n#main模块类似main函数包含其他子模块，非模块配置项(包括模块内)分号结尾，子模块配置花括号结尾\nuser nobady;   #一般按默认设置\npid /var/run/nginx.pid;   #进程标识符存放路径，一般按默认设置\nworker_processes auto;   #nginx对外提供web服务时的worder进程数，可将其设置为可用的CPU内核数，auto为自动检测\nworker_rlimit_nofile 100000;  # 更改worker进程的最大打开文件数限制\nerror_log logs/error.log  info;   #错误日志存放路径\nkeepalive_timeout 60;  #keepalive_timeout 60;\nevents{\n  #见events模块\n}\nhttp{  #见http模块\n  server{ \n    ...\n    location /{\n     \n    }\n  }\n}\nmail{\n  #见mail模块\n}\n```\n\n#### 2.4.2. events模块\n\n```shell\nevents {\n  worker_connections 2048;    #设置可由一个worker进程同时打开的最大连接数\n  multi_accept on;   #告诉nginx收到一个新连接通知后接受尽可能多的连接\n  use epoll; #设置用于复用客户端线程的轮询方法。Linux 2.6+：使用epoll；*BSD：使用kqueue。\n}\n```\n\n#### 2.4.3. http模块\n\n```shell\nhttp {  #http模块\n    server {  #server模块，http服务上的虚拟主机， server 当做对应一个域名进行的配置\n        listen          80;  #配置监听端口\n        server_name     www.linuxidc.com; #配置访问域名\n        access_log      logs/linuxidc.access.log main;  #指定日志文件的存放路径\n        index index.html;    #默认访问页面\n        root  /var/www/androidj.com/htdocs;  # root 是指将本地的一个文件夹作为所有 url 请求的根路径\n        upstream backend {   #反向代理的后端机器，实现负载均衡\n            ip_hash;    #指明了我们均衡的方式是按照用户的 ip 地址进行分配\n            server backend1.example.com;\n            server backend2.example.com;\n            server backend3.example.com;\n            server backend4.example.com;\n        }\n        location / {  #location 是在一个域名下对更精细的路径进行配置\n            proxy_pass http://backend;  #反向代理到后端机器\n        }\n    }\n \n    server {\n        listen          80;\n        server_name     www.Androidj.com;\n        access_log      logs/androidj.access.log main;\n        location / {\n            index index.html;\n            root  /var/www/androidj.com/htdocs;\n        }\n    }\n}\n```\n\n#### 2.4.4. mail模块\n\n```shell\nmail {\n    auth_http  127.0.0.1:80/auth.php;\n    pop3_capabilities  \"TOP\"  \"USER\";\n    imap_capabilities  \"IMAP4rev1\"  \"UIDPLUS\";\n \n    server {\n        listen     110;\n        protocol   pop3;\n        proxy      on;\n    }\n    server {\n        listen      25;\n        protocol    smtp;\n        proxy       on;\n        smtp_auth   login plain;\n        xclient     off;\n    }\n}\n```","source":"_posts/Nginx/Nginx的部署与配置.md","raw":"---\ntitle: \"[Nginx] Nginx的部署与配置\"\ncatalog: true\ndate: 2017-09-13 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Nginx\ncatagories:\n- Nginx\n---\n\n## 1. 部署\n\n### 1.1. 使用安装包的方式\n\nrpm -ivh nginx-xxx.rpm\n\n### 1.2. 使用源代码安装\n\n#### 1.2.1. 下载源码包\n\n```shell\nwget http://blob.wae.haplat.net/nginx/nginx-1.9.13.tar.gz\n```\n\n### 1.2.2. 创建临时目录并解压源码包\n\n```shell\nmkdir $HOME/build\ncd $HOME/build && tar zxvf nginx-`version-number`.tar.gz\n```\n\n#### 1.2.3. 编译并安装\n\n```shell\n cd $HOME/build/nginx-`version-number`\n \n./configure \\\n--prefix=/etc/nginx \\\n--sbin-path=/usr/sbin/nginx \\\n--conf-path=/etc/nginx/nginx.conf \\\n...\n#`更多配置项见以下说明`\n \nmake && make install\n```\n\n#### 1.2.4. 配置项\n\n##### 1.2.4.1. 通用配置项\n\n| 配置选项                    | 说明                                       |\n| ----------------------- | ---------------------------------------- |\n| --prefix=`path`         | nginx安装的根路径，所有其他的路径都要依赖与该选项              |\n| --sbin-path=`path`      | nginx二进制文件的路径，如果没有指定则会依赖于--prefix        |\n| --conf-path=`path`      | 如果在命令行中没有指定配置文件，则通过该配置项去查找配置文件           |\n| --error-log-path=`path` | 指定错误文件的路径                                |\n| --pid-path=`path`       | 指定的文件将会写入nginx master进程的pid，通常在/var/run下 |\n| --lock-path=`path`      | 共享存储器互斥锁文件的路径                            |\n| --user=`user`           | worker进程运行的用户                            |\n| --group=`group`         | worker进程运行的组                             |\n| --with-file-aio         | 启动异步I/O                                  |\n| --with-debug            | 启用调试日志，生产环境不推荐配置                         |\n\n##### 1.2.4.2. 优化配置项\n\n| 配置选项                    | 说明                    |\n| ----------------------- | --------------------- |\n| --with-cc=`path`        | 如果想设置一个不在默认PATH下的C编译器 |\n| --with-cpp=`path`       | 设置C预处理器的相应路径          |\n| --with-cc-opt=`options` | 指定必要的include文件路径      |\n| --with-ld-opt=`options` | 包含连接器库的路径和运行路径        |\n| --with-cpu-opt=`cpu`    | 通过该选项为特定的CPU构建nginx   |\n\n##### 1.2.4.3. http模块的配置项\n\n| 配置选项                                | 说明                                       |\n| ----------------------------------- | ---------------------------------------- |\n| --without-http-cache                | 在使用upstream模块时，nginx能够配置本地缓存内容，该选项可以禁用缓存 |\n| --with-http_perl_module             | nginx配置能够扩展使用perl代码。该项启用这个模块，但会降低性能      |\n| --with-perl_modules_path=`path`     | 对于额外嵌入的perl模块，该选项指定该perl解析器的路径           |\n| --with-perl=`path`                  | 如果在默认的路径中找不到perl则指定perl（5.6版本以上）的路径      |\n| --http-log-path=`path`              | http访问日志的默认路径                            |\n| --http-client-body-temp-path=`path` | 从客户端收到请求后，该项用于作为请求体临时存放的目录               |\n| --http-proxy-temp-path=`path`       | 在使用代理后，通过该项设置存放临时文件路径                    |\n| --http-fastcgi-temp-path=`path`     | 设置FastCGI临时文件的目录                         |\n| --http-uwsgi-temp-path=`path`       | 设置uWSGI临时文件的目录                           |\n| --http-scgi-temp-path=`path`        | 设置SCGI临时文件的目录                            |\n\n##### 1.2.4.4. 其他模块额外配置项\n\n默认没有安装这些模块，可以通过--with-`module-name`_module来启用相应的模块功能。\n\n| 配置选项                            | 说明                                       |\n| ------------------------------- | ---------------------------------------- |\n| --with-http_ssl_module          | 如果需要对流量进行加密，可以使用该选项，再URLs中开始部分将会是https(需要OpenSSL库) |\n| --with-http_realip_module       | 如果nginx在七层负载均衡器或者其他设备之后，它们将Http头中的客户端IP地址传递，则需要启用该模块，再多个客户处于一个IP地址的情况下使用 |\n| --with-http_addition_module     | 该模块作为输出过滤器，使能够在请求经过一个location前或后时在该location本身添加内容 |\n| --with-http_xslt_module         | 该模块用于处理XML响应转换，基于一个或多个XSLT格式             |\n| --with-http_image_filter_module | 该模块被作为图像过滤器使用，在将图像投递到客户之前进行处理（需要libgd库）  |\n| --with-http_geoip_module        | 使用该模块，能够设置各种变量以便在配置文件中的区段使用，基于地理位置查找客户端IP地址 |\n| --with-http_sub_module          | 该模块实现替代过滤，在响应中用一个字符串替代另一个字符串             |\n| --with-heep_dav_module          | 启用这个模块将激活使用WebDAV的配置指令。                  |\n| --with-http_flv_module          | 如果需要提供Flash流媒体视频文件，那么该模块将会提供伪流媒体         |\n| --with-http_mp4_module          | 这个模块支持H.264/AAC文件伪流媒体                    |\n| --with-http_gzip_static_module  | 当被调用的资源没有.gz结尾格式的文件时，如果想支持发送预压缩版本的静态文件，那么使用该模块 |\n| --with-http_gunzip_module       | 对于不支持gzip编码的客户，该模块用于为客户解压缩预压缩内容          |\n| --with-http_random_index_module | 如果你想提供从一个目录中随机选择文件的索引文件，那么该模块需要激活        |\n| --with-http_secure_link_module  | 该模块提供一种机制，它会将一个哈希值链接到一个URL中，因此只有那些使用正确密码能够计算链接 |\n| --with-http_stub_status_module  | 启用这个模块后会收集Nginx自身的状态信息。输出的状态信息可以使用RRDtool或类似的东西绘制成图 |\n\n## 2. 配置\n\n配置文件一般为/etc/nginx/nginx.conf或/usr/local/nginx/conf/nginx.conf。\n\n### 2.1. 基本配置格式\n\n```shell\n`section`{\n    `directive` `parameters`;\n}\n```\n\n每一个指令行由分号结束，大括号{}表示一个新的上下文。\n\n### 2.2. Nginx全局配置参数\n\n全局配置指令\n\n| 模块                 | 配置项                                      | 说明                                       |\n| ------------------ | ---------------------------------------- | ---------------------------------------- |\n| main模块             | user                                     | 配置worker进程的用户和组，如果忽略group，则group等于指定的用户的所属组 |\n| worker_processes   | 指定worker进程的启动数量，可将其设置为可用的CPU内核数，若为auto为自动检测 |                                          |\n| error_log          | 所有错误的写入文件，第二个参数指定错误的级别（debug，info，notice，warn，error，crit，alert，emerg） |                                          |\n| pid                | 设置主进程IP的文件                               |                                          |\n| events模块           | use                                      | 用于设置使用什么样的连接方法                           |\n| worker_connections | 用于配置一个工作进程能够接受的并发连接最大数。包括客户连接和向上游服务器的连接。 |                                          |\n\n### 2.3. 使用include文件\n\ninclude文件可以在任何地方以增强配置文件的可读性，使用include文件要确保被包含文件自身正确的nginx语法，即配置指令和块，然后指定这些文件的路径。\n\ninclude /etc/nginx/mime.types;\n\n若使用通配符则表示通配的多个文件，若没有给定全路径则依据主配置文件路径进行搜索。\n\ninclude /etc/nginx/conf.d/*.conf\n\n测试配置文件(包括include的配置文件)语法：\n\nnginx -t -c path-to-nginx.conf\n\n### 2.4. 配置说明\n\n#### 2.4.1. main模块\n\n```shell\n#main模块类似main函数包含其他子模块，非模块配置项(包括模块内)分号结尾，子模块配置花括号结尾\nuser nobady;   #一般按默认设置\npid /var/run/nginx.pid;   #进程标识符存放路径，一般按默认设置\nworker_processes auto;   #nginx对外提供web服务时的worder进程数，可将其设置为可用的CPU内核数，auto为自动检测\nworker_rlimit_nofile 100000;  # 更改worker进程的最大打开文件数限制\nerror_log logs/error.log  info;   #错误日志存放路径\nkeepalive_timeout 60;  #keepalive_timeout 60;\nevents{\n  #见events模块\n}\nhttp{  #见http模块\n  server{ \n    ...\n    location /{\n     \n    }\n  }\n}\nmail{\n  #见mail模块\n}\n```\n\n#### 2.4.2. events模块\n\n```shell\nevents {\n  worker_connections 2048;    #设置可由一个worker进程同时打开的最大连接数\n  multi_accept on;   #告诉nginx收到一个新连接通知后接受尽可能多的连接\n  use epoll; #设置用于复用客户端线程的轮询方法。Linux 2.6+：使用epoll；*BSD：使用kqueue。\n}\n```\n\n#### 2.4.3. http模块\n\n```shell\nhttp {  #http模块\n    server {  #server模块，http服务上的虚拟主机， server 当做对应一个域名进行的配置\n        listen          80;  #配置监听端口\n        server_name     www.linuxidc.com; #配置访问域名\n        access_log      logs/linuxidc.access.log main;  #指定日志文件的存放路径\n        index index.html;    #默认访问页面\n        root  /var/www/androidj.com/htdocs;  # root 是指将本地的一个文件夹作为所有 url 请求的根路径\n        upstream backend {   #反向代理的后端机器，实现负载均衡\n            ip_hash;    #指明了我们均衡的方式是按照用户的 ip 地址进行分配\n            server backend1.example.com;\n            server backend2.example.com;\n            server backend3.example.com;\n            server backend4.example.com;\n        }\n        location / {  #location 是在一个域名下对更精细的路径进行配置\n            proxy_pass http://backend;  #反向代理到后端机器\n        }\n    }\n \n    server {\n        listen          80;\n        server_name     www.Androidj.com;\n        access_log      logs/androidj.access.log main;\n        location / {\n            index index.html;\n            root  /var/www/androidj.com/htdocs;\n        }\n    }\n}\n```\n\n#### 2.4.4. mail模块\n\n```shell\nmail {\n    auth_http  127.0.0.1:80/auth.php;\n    pop3_capabilities  \"TOP\"  \"USER\";\n    imap_capabilities  \"IMAP4rev1\"  \"UIDPLUS\";\n \n    server {\n        listen     110;\n        protocol   pop3;\n        proxy      on;\n    }\n    server {\n        listen      25;\n        protocol    smtp;\n        proxy       on;\n        smtp_auth   login plain;\n        xclient     off;\n    }\n}\n```","slug":"Nginx/Nginx的部署与配置","published":1,"updated":"2017-10-02T12:39:33.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740io000j30vuk7srhi38","content":"<h2><span id=\"1-部署\">1. 部署</span></h2>\n<h3><span id=\"11-使用安装包的方式\">1.1. 使用安装包的方式</span></h3>\n<p>rpm -ivh nginx-xxx.rpm</p>\n<h3><span id=\"12-使用源代码安装\">1.2. 使用源代码安装</span></h3>\n<h4><span id=\"121-下载源码包\">1.2.1. 下载源码包</span></h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://blob.wae.haplat.net/nginx/nginx-1.9.13.tar.gz</div></pre></td></tr></table></figure>\n<h3><span id=\"122-创建临时目录并解压源码包\">1.2.2. 创建临时目录并解压源码包</span></h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir $HOME/build</div><div class=\"line\">cd $HOME/build &amp;&amp; tar zxvf nginx-`version-number`.tar.gz</div></pre></td></tr></table></figure>\n<h4><span id=\"123-编译并安装\">1.2.3. 编译并安装</span></h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> cd $HOME/build/nginx-`version-number`</div><div class=\"line\"> </div><div class=\"line\">./configure \\</div><div class=\"line\">--prefix=/etc/nginx \\</div><div class=\"line\">--sbin-path=/usr/sbin/nginx \\</div><div class=\"line\">--conf-path=/etc/nginx/nginx.conf \\</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">`更多配置项见以下说明`</span></div><div class=\"line\"> </div><div class=\"line\">make &amp;&amp; make install</div></pre></td></tr></table></figure>\n<h4><span id=\"124-配置项\">1.2.4. 配置项</span></h4>\n<h5><span id=\"1241-通用配置项\">1.2.4.1. 通用配置项</span></h5>\n<table>\n<thead>\n<tr>\n<th>配置选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–prefix=<code>path</code></td>\n<td>nginx安装的根路径，所有其他的路径都要依赖与该选项</td>\n</tr>\n<tr>\n<td>–sbin-path=<code>path</code></td>\n<td>nginx二进制文件的路径，如果没有指定则会依赖于–prefix</td>\n</tr>\n<tr>\n<td>–conf-path=<code>path</code></td>\n<td>如果在命令行中没有指定配置文件，则通过该配置项去查找配置文件</td>\n</tr>\n<tr>\n<td>–error-log-path=<code>path</code></td>\n<td>指定错误文件的路径</td>\n</tr>\n<tr>\n<td>–pid-path=<code>path</code></td>\n<td>指定的文件将会写入nginx master进程的pid，通常在/var/run下</td>\n</tr>\n<tr>\n<td>–lock-path=<code>path</code></td>\n<td>共享存储器互斥锁文件的路径</td>\n</tr>\n<tr>\n<td>–user=<code>user</code></td>\n<td>worker进程运行的用户</td>\n</tr>\n<tr>\n<td>–group=<code>group</code></td>\n<td>worker进程运行的组</td>\n</tr>\n<tr>\n<td>–with-file-aio</td>\n<td>启动异步I/O</td>\n</tr>\n<tr>\n<td>–with-debug</td>\n<td>启用调试日志，生产环境不推荐配置</td>\n</tr>\n</tbody>\n</table>\n<h5><span id=\"1242-优化配置项\">1.2.4.2. 优化配置项</span></h5>\n<table>\n<thead>\n<tr>\n<th>配置选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–with-cc=<code>path</code></td>\n<td>如果想设置一个不在默认PATH下的C编译器</td>\n</tr>\n<tr>\n<td>–with-cpp=<code>path</code></td>\n<td>设置C预处理器的相应路径</td>\n</tr>\n<tr>\n<td>–with-cc-opt=<code>options</code></td>\n<td>指定必要的include文件路径</td>\n</tr>\n<tr>\n<td>–with-ld-opt=<code>options</code></td>\n<td>包含连接器库的路径和运行路径</td>\n</tr>\n<tr>\n<td>–with-cpu-opt=<code>cpu</code></td>\n<td>通过该选项为特定的CPU构建nginx</td>\n</tr>\n</tbody>\n</table>\n<h5><span id=\"1243-http模块的配置项\">1.2.4.3. http模块的配置项</span></h5>\n<table>\n<thead>\n<tr>\n<th>配置选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–without-http-cache</td>\n<td>在使用upstream模块时，nginx能够配置本地缓存内容，该选项可以禁用缓存</td>\n</tr>\n<tr>\n<td>–with-http_perl_module</td>\n<td>nginx配置能够扩展使用perl代码。该项启用这个模块，但会降低性能</td>\n</tr>\n<tr>\n<td>–with-perl_modules_path=<code>path</code></td>\n<td>对于额外嵌入的perl模块，该选项指定该perl解析器的路径</td>\n</tr>\n<tr>\n<td>–with-perl=<code>path</code></td>\n<td>如果在默认的路径中找不到perl则指定perl（5.6版本以上）的路径</td>\n</tr>\n<tr>\n<td>–http-log-path=<code>path</code></td>\n<td>http访问日志的默认路径</td>\n</tr>\n<tr>\n<td>–http-client-body-temp-path=<code>path</code></td>\n<td>从客户端收到请求后，该项用于作为请求体临时存放的目录</td>\n</tr>\n<tr>\n<td>–http-proxy-temp-path=<code>path</code></td>\n<td>在使用代理后，通过该项设置存放临时文件路径</td>\n</tr>\n<tr>\n<td>–http-fastcgi-temp-path=<code>path</code></td>\n<td>设置FastCGI临时文件的目录</td>\n</tr>\n<tr>\n<td>–http-uwsgi-temp-path=<code>path</code></td>\n<td>设置uWSGI临时文件的目录</td>\n</tr>\n<tr>\n<td>–http-scgi-temp-path=<code>path</code></td>\n<td>设置SCGI临时文件的目录</td>\n</tr>\n</tbody>\n</table>\n<h5><span id=\"1244-其他模块额外配置项\">1.2.4.4. 其他模块额外配置项</span></h5>\n<p>默认没有安装这些模块，可以通过–with-<code>module-name</code>_module来启用相应的模块功能。</p>\n<table>\n<thead>\n<tr>\n<th>配置选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–with-http_ssl_module</td>\n<td>如果需要对流量进行加密，可以使用该选项，再URLs中开始部分将会是https(需要OpenSSL库)</td>\n</tr>\n<tr>\n<td>–with-http_realip_module</td>\n<td>如果nginx在七层负载均衡器或者其他设备之后，它们将Http头中的客户端IP地址传递，则需要启用该模块，再多个客户处于一个IP地址的情况下使用</td>\n</tr>\n<tr>\n<td>–with-http_addition_module</td>\n<td>该模块作为输出过滤器，使能够在请求经过一个location前或后时在该location本身添加内容</td>\n</tr>\n<tr>\n<td>–with-http_xslt_module</td>\n<td>该模块用于处理XML响应转换，基于一个或多个XSLT格式</td>\n</tr>\n<tr>\n<td>–with-http_image_filter_module</td>\n<td>该模块被作为图像过滤器使用，在将图像投递到客户之前进行处理（需要libgd库）</td>\n</tr>\n<tr>\n<td>–with-http_geoip_module</td>\n<td>使用该模块，能够设置各种变量以便在配置文件中的区段使用，基于地理位置查找客户端IP地址</td>\n</tr>\n<tr>\n<td>–with-http_sub_module</td>\n<td>该模块实现替代过滤，在响应中用一个字符串替代另一个字符串</td>\n</tr>\n<tr>\n<td>–with-heep_dav_module</td>\n<td>启用这个模块将激活使用WebDAV的配置指令。</td>\n</tr>\n<tr>\n<td>–with-http_flv_module</td>\n<td>如果需要提供Flash流媒体视频文件，那么该模块将会提供伪流媒体</td>\n</tr>\n<tr>\n<td>–with-http_mp4_module</td>\n<td>这个模块支持H.264/AAC文件伪流媒体</td>\n</tr>\n<tr>\n<td>–with-http_gzip_static_module</td>\n<td>当被调用的资源没有.gz结尾格式的文件时，如果想支持发送预压缩版本的静态文件，那么使用该模块</td>\n</tr>\n<tr>\n<td>–with-http_gunzip_module</td>\n<td>对于不支持gzip编码的客户，该模块用于为客户解压缩预压缩内容</td>\n</tr>\n<tr>\n<td>–with-http_random_index_module</td>\n<td>如果你想提供从一个目录中随机选择文件的索引文件，那么该模块需要激活</td>\n</tr>\n<tr>\n<td>–with-http_secure_link_module</td>\n<td>该模块提供一种机制，它会将一个哈希值链接到一个URL中，因此只有那些使用正确密码能够计算链接</td>\n</tr>\n<tr>\n<td>–with-http_stub_status_module</td>\n<td>启用这个模块后会收集Nginx自身的状态信息。输出的状态信息可以使用RRDtool或类似的东西绘制成图</td>\n</tr>\n</tbody>\n</table>\n<h2><span id=\"2-配置\">2. 配置</span></h2>\n<p>配置文件一般为/etc/nginx/nginx.conf或/usr/local/nginx/conf/nginx.conf。</p>\n<h3><span id=\"21-基本配置格式\">2.1. 基本配置格式</span></h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">`section`&#123;</div><div class=\"line\">    `directive` `parameters`;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>每一个指令行由分号结束，大括号{}表示一个新的上下文。</p>\n<h3><span id=\"22-nginx全局配置参数\">2.2. Nginx全局配置参数</span></h3>\n<p>全局配置指令</p>\n<table>\n<thead>\n<tr>\n<th>模块</th>\n<th>配置项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>main模块</td>\n<td>user</td>\n<td>配置worker进程的用户和组，如果忽略group，则group等于指定的用户的所属组</td>\n</tr>\n<tr>\n<td>worker_processes</td>\n<td>指定worker进程的启动数量，可将其设置为可用的CPU内核数，若为auto为自动检测</td>\n<td></td>\n</tr>\n<tr>\n<td>error_log</td>\n<td>所有错误的写入文件，第二个参数指定错误的级别（debug，info，notice，warn，error，crit，alert，emerg）</td>\n<td></td>\n</tr>\n<tr>\n<td>pid</td>\n<td>设置主进程IP的文件</td>\n<td></td>\n</tr>\n<tr>\n<td>events模块</td>\n<td>use</td>\n<td>用于设置使用什么样的连接方法</td>\n</tr>\n<tr>\n<td>worker_connections</td>\n<td>用于配置一个工作进程能够接受的并发连接最大数。包括客户连接和向上游服务器的连接。</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3><span id=\"23-使用include文件\">2.3. 使用include文件</span></h3>\n<p>include文件可以在任何地方以增强配置文件的可读性，使用include文件要确保被包含文件自身正确的nginx语法，即配置指令和块，然后指定这些文件的路径。</p>\n<p>include /etc/nginx/mime.types;</p>\n<p>若使用通配符则表示通配的多个文件，若没有给定全路径则依据主配置文件路径进行搜索。</p>\n<p>include /etc/nginx/conf.d/*.conf</p>\n<p>测试配置文件(包括include的配置文件)语法：</p>\n<p>nginx -t -c path-to-nginx.conf</p>\n<h3><span id=\"24-配置说明\">2.4. 配置说明</span></h3>\n<h4><span id=\"241-main模块\">2.4.1. main模块</span></h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">main模块类似main函数包含其他子模块，非模块配置项(包括模块内)分号结尾，子模块配置花括号结尾</span></div><div class=\"line\">user nobady;   #一般按默认设置</div><div class=\"line\">pid /var/run/nginx.pid;   #进程标识符存放路径，一般按默认设置</div><div class=\"line\">worker_processes auto;   #nginx对外提供web服务时的worder进程数，可将其设置为可用的CPU内核数，auto为自动检测</div><div class=\"line\">worker_rlimit_nofile 100000;  # 更改worker进程的最大打开文件数限制</div><div class=\"line\">error_log logs/error.log  info;   #错误日志存放路径</div><div class=\"line\">keepalive_timeout 60;  #keepalive_timeout 60;</div><div class=\"line\">events&#123;</div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\">见events模块</span></div><div class=\"line\">&#125;</div><div class=\"line\">http&#123;  #见http模块</div><div class=\"line\">  server&#123; </div><div class=\"line\">    ...</div><div class=\"line\">    location /&#123;</div><div class=\"line\">     </div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">mail&#123;</div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\">见mail模块</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4><span id=\"242-events模块\">2.4.2. events模块</span></h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">events &#123;</div><div class=\"line\">  worker_connections 2048;    #设置可由一个worker进程同时打开的最大连接数</div><div class=\"line\">  multi_accept on;   #告诉nginx收到一个新连接通知后接受尽可能多的连接</div><div class=\"line\">  use epoll; #设置用于复用客户端线程的轮询方法。Linux 2.6+：使用epoll；*BSD：使用kqueue。</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4><span id=\"243-http模块\">2.4.3. http模块</span></h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">http &#123;  #http模块</div><div class=\"line\">    server &#123;  #server模块，http服务上的虚拟主机， server 当做对应一个域名进行的配置</div><div class=\"line\">        listen          80;  #配置监听端口</div><div class=\"line\">        server_name     www.linuxidc.com; #配置访问域名</div><div class=\"line\">        access_log      logs/linuxidc.access.log main;  #指定日志文件的存放路径</div><div class=\"line\">        index index.html;    #默认访问页面</div><div class=\"line\">        root  /var/www/androidj.com/htdocs;  # root 是指将本地的一个文件夹作为所有 url 请求的根路径</div><div class=\"line\">        upstream backend &#123;   #反向代理的后端机器，实现负载均衡</div><div class=\"line\">            ip_hash;    #指明了我们均衡的方式是按照用户的 ip 地址进行分配</div><div class=\"line\">            server backend1.example.com;</div><div class=\"line\">            server backend2.example.com;</div><div class=\"line\">            server backend3.example.com;</div><div class=\"line\">            server backend4.example.com;</div><div class=\"line\">        &#125;</div><div class=\"line\">        location / &#123;  #location 是在一个域名下对更精细的路径进行配置</div><div class=\"line\">            proxy_pass http://backend;  #反向代理到后端机器</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    server &#123;</div><div class=\"line\">        listen          80;</div><div class=\"line\">        server_name     www.Androidj.com;</div><div class=\"line\">        access_log      logs/androidj.access.log main;</div><div class=\"line\">        location / &#123;</div><div class=\"line\">            index index.html;</div><div class=\"line\">            root  /var/www/androidj.com/htdocs;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4><span id=\"244-mail模块\">2.4.4. mail模块</span></h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">mail &#123;</div><div class=\"line\">    auth_http  127.0.0.1:80/auth.php;</div><div class=\"line\">    pop3_capabilities  \"TOP\"  \"USER\";</div><div class=\"line\">    imap_capabilities  \"IMAP4rev1\"  \"UIDPLUS\";</div><div class=\"line\"> </div><div class=\"line\">    server &#123;</div><div class=\"line\">        listen     110;</div><div class=\"line\">        protocol   pop3;</div><div class=\"line\">        proxy      on;</div><div class=\"line\">    &#125;</div><div class=\"line\">    server &#123;</div><div class=\"line\">        listen      25;</div><div class=\"line\">        protocol    smtp;</div><div class=\"line\">        proxy       on;</div><div class=\"line\">        smtp_auth   login plain;</div><div class=\"line\">        xclient     off;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2>1. 部署</h2>\n<h3>1.1. 使用安装包的方式</h3>\n<p>rpm -ivh nginx-xxx.rpm</p>\n<h3>1.2. 使用源代码安装</h3>\n<h4>1.2.1. 下载源码包</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://blob.wae.haplat.net/nginx/nginx-1.9.13.tar.gz</div></pre></td></tr></table></figure>\n<h3>1.2.2. 创建临时目录并解压源码包</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir $HOME/build</div><div class=\"line\">cd $HOME/build &amp;&amp; tar zxvf nginx-`version-number`.tar.gz</div></pre></td></tr></table></figure>\n<h4>1.2.3. 编译并安装</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> cd $HOME/build/nginx-`version-number`</div><div class=\"line\"> </div><div class=\"line\">./configure \\</div><div class=\"line\">--prefix=/etc/nginx \\</div><div class=\"line\">--sbin-path=/usr/sbin/nginx \\</div><div class=\"line\">--conf-path=/etc/nginx/nginx.conf \\</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">`更多配置项见以下说明`</span></div><div class=\"line\"> </div><div class=\"line\">make &amp;&amp; make install</div></pre></td></tr></table></figure>\n<h4>1.2.4. 配置项</h4>\n<h5>1.2.4.1. 通用配置项</h5>\n<table>\n<thead>\n<tr>\n<th>配置选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–prefix=<code>path</code></td>\n<td>nginx安装的根路径，所有其他的路径都要依赖与该选项</td>\n</tr>\n<tr>\n<td>–sbin-path=<code>path</code></td>\n<td>nginx二进制文件的路径，如果没有指定则会依赖于–prefix</td>\n</tr>\n<tr>\n<td>–conf-path=<code>path</code></td>\n<td>如果在命令行中没有指定配置文件，则通过该配置项去查找配置文件</td>\n</tr>\n<tr>\n<td>–error-log-path=<code>path</code></td>\n<td>指定错误文件的路径</td>\n</tr>\n<tr>\n<td>–pid-path=<code>path</code></td>\n<td>指定的文件将会写入nginx master进程的pid，通常在/var/run下</td>\n</tr>\n<tr>\n<td>–lock-path=<code>path</code></td>\n<td>共享存储器互斥锁文件的路径</td>\n</tr>\n<tr>\n<td>–user=<code>user</code></td>\n<td>worker进程运行的用户</td>\n</tr>\n<tr>\n<td>–group=<code>group</code></td>\n<td>worker进程运行的组</td>\n</tr>\n<tr>\n<td>–with-file-aio</td>\n<td>启动异步I/O</td>\n</tr>\n<tr>\n<td>–with-debug</td>\n<td>启用调试日志，生产环境不推荐配置</td>\n</tr>\n</tbody>\n</table>\n<h5>1.2.4.2. 优化配置项</h5>\n<table>\n<thead>\n<tr>\n<th>配置选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–with-cc=<code>path</code></td>\n<td>如果想设置一个不在默认PATH下的C编译器</td>\n</tr>\n<tr>\n<td>–with-cpp=<code>path</code></td>\n<td>设置C预处理器的相应路径</td>\n</tr>\n<tr>\n<td>–with-cc-opt=<code>options</code></td>\n<td>指定必要的include文件路径</td>\n</tr>\n<tr>\n<td>–with-ld-opt=<code>options</code></td>\n<td>包含连接器库的路径和运行路径</td>\n</tr>\n<tr>\n<td>–with-cpu-opt=<code>cpu</code></td>\n<td>通过该选项为特定的CPU构建nginx</td>\n</tr>\n</tbody>\n</table>\n<h5>1.2.4.3. http模块的配置项</h5>\n<table>\n<thead>\n<tr>\n<th>配置选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–without-http-cache</td>\n<td>在使用upstream模块时，nginx能够配置本地缓存内容，该选项可以禁用缓存</td>\n</tr>\n<tr>\n<td>–with-http_perl_module</td>\n<td>nginx配置能够扩展使用perl代码。该项启用这个模块，但会降低性能</td>\n</tr>\n<tr>\n<td>–with-perl_modules_path=<code>path</code></td>\n<td>对于额外嵌入的perl模块，该选项指定该perl解析器的路径</td>\n</tr>\n<tr>\n<td>–with-perl=<code>path</code></td>\n<td>如果在默认的路径中找不到perl则指定perl（5.6版本以上）的路径</td>\n</tr>\n<tr>\n<td>–http-log-path=<code>path</code></td>\n<td>http访问日志的默认路径</td>\n</tr>\n<tr>\n<td>–http-client-body-temp-path=<code>path</code></td>\n<td>从客户端收到请求后，该项用于作为请求体临时存放的目录</td>\n</tr>\n<tr>\n<td>–http-proxy-temp-path=<code>path</code></td>\n<td>在使用代理后，通过该项设置存放临时文件路径</td>\n</tr>\n<tr>\n<td>–http-fastcgi-temp-path=<code>path</code></td>\n<td>设置FastCGI临时文件的目录</td>\n</tr>\n<tr>\n<td>–http-uwsgi-temp-path=<code>path</code></td>\n<td>设置uWSGI临时文件的目录</td>\n</tr>\n<tr>\n<td>–http-scgi-temp-path=<code>path</code></td>\n<td>设置SCGI临时文件的目录</td>\n</tr>\n</tbody>\n</table>\n<h5>1.2.4.4. 其他模块额外配置项</h5>\n<p>默认没有安装这些模块，可以通过–with-<code>module-name</code>_module来启用相应的模块功能。</p>\n<table>\n<thead>\n<tr>\n<th>配置选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–with-http_ssl_module</td>\n<td>如果需要对流量进行加密，可以使用该选项，再URLs中开始部分将会是https(需要OpenSSL库)</td>\n</tr>\n<tr>\n<td>–with-http_realip_module</td>\n<td>如果nginx在七层负载均衡器或者其他设备之后，它们将Http头中的客户端IP地址传递，则需要启用该模块，再多个客户处于一个IP地址的情况下使用</td>\n</tr>\n<tr>\n<td>–with-http_addition_module</td>\n<td>该模块作为输出过滤器，使能够在请求经过一个location前或后时在该location本身添加内容</td>\n</tr>\n<tr>\n<td>–with-http_xslt_module</td>\n<td>该模块用于处理XML响应转换，基于一个或多个XSLT格式</td>\n</tr>\n<tr>\n<td>–with-http_image_filter_module</td>\n<td>该模块被作为图像过滤器使用，在将图像投递到客户之前进行处理（需要libgd库）</td>\n</tr>\n<tr>\n<td>–with-http_geoip_module</td>\n<td>使用该模块，能够设置各种变量以便在配置文件中的区段使用，基于地理位置查找客户端IP地址</td>\n</tr>\n<tr>\n<td>–with-http_sub_module</td>\n<td>该模块实现替代过滤，在响应中用一个字符串替代另一个字符串</td>\n</tr>\n<tr>\n<td>–with-heep_dav_module</td>\n<td>启用这个模块将激活使用WebDAV的配置指令。</td>\n</tr>\n<tr>\n<td>–with-http_flv_module</td>\n<td>如果需要提供Flash流媒体视频文件，那么该模块将会提供伪流媒体</td>\n</tr>\n<tr>\n<td>–with-http_mp4_module</td>\n<td>这个模块支持H.264/AAC文件伪流媒体</td>\n</tr>\n<tr>\n<td>–with-http_gzip_static_module</td>\n<td>当被调用的资源没有.gz结尾格式的文件时，如果想支持发送预压缩版本的静态文件，那么使用该模块</td>\n</tr>\n<tr>\n<td>–with-http_gunzip_module</td>\n<td>对于不支持gzip编码的客户，该模块用于为客户解压缩预压缩内容</td>\n</tr>\n<tr>\n<td>–with-http_random_index_module</td>\n<td>如果你想提供从一个目录中随机选择文件的索引文件，那么该模块需要激活</td>\n</tr>\n<tr>\n<td>–with-http_secure_link_module</td>\n<td>该模块提供一种机制，它会将一个哈希值链接到一个URL中，因此只有那些使用正确密码能够计算链接</td>\n</tr>\n<tr>\n<td>–with-http_stub_status_module</td>\n<td>启用这个模块后会收集Nginx自身的状态信息。输出的状态信息可以使用RRDtool或类似的东西绘制成图</td>\n</tr>\n</tbody>\n</table>\n<h2>2. 配置</h2>\n<p>配置文件一般为/etc/nginx/nginx.conf或/usr/local/nginx/conf/nginx.conf。</p>\n<h3>2.1. 基本配置格式</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">`section`&#123;</div><div class=\"line\">    `directive` `parameters`;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>每一个指令行由分号结束，大括号{}表示一个新的上下文。</p>\n<h3>2.2. Nginx全局配置参数</h3>\n<p>全局配置指令</p>\n<table>\n<thead>\n<tr>\n<th>模块</th>\n<th>配置项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>main模块</td>\n<td>user</td>\n<td>配置worker进程的用户和组，如果忽略group，则group等于指定的用户的所属组</td>\n</tr>\n<tr>\n<td>worker_processes</td>\n<td>指定worker进程的启动数量，可将其设置为可用的CPU内核数，若为auto为自动检测</td>\n<td></td>\n</tr>\n<tr>\n<td>error_log</td>\n<td>所有错误的写入文件，第二个参数指定错误的级别（debug，info，notice，warn，error，crit，alert，emerg）</td>\n<td></td>\n</tr>\n<tr>\n<td>pid</td>\n<td>设置主进程IP的文件</td>\n<td></td>\n</tr>\n<tr>\n<td>events模块</td>\n<td>use</td>\n<td>用于设置使用什么样的连接方法</td>\n</tr>\n<tr>\n<td>worker_connections</td>\n<td>用于配置一个工作进程能够接受的并发连接最大数。包括客户连接和向上游服务器的连接。</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3>2.3. 使用include文件</h3>\n<p>include文件可以在任何地方以增强配置文件的可读性，使用include文件要确保被包含文件自身正确的nginx语法，即配置指令和块，然后指定这些文件的路径。</p>\n<p>include /etc/nginx/mime.types;</p>\n<p>若使用通配符则表示通配的多个文件，若没有给定全路径则依据主配置文件路径进行搜索。</p>\n<p>include /etc/nginx/conf.d/*.conf</p>\n<p>测试配置文件(包括include的配置文件)语法：</p>\n<p>nginx -t -c path-to-nginx.conf</p>\n<h3>2.4. 配置说明</h3>\n<h4>2.4.1. main模块</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">main模块类似main函数包含其他子模块，非模块配置项(包括模块内)分号结尾，子模块配置花括号结尾</span></div><div class=\"line\">user nobady;   #一般按默认设置</div><div class=\"line\">pid /var/run/nginx.pid;   #进程标识符存放路径，一般按默认设置</div><div class=\"line\">worker_processes auto;   #nginx对外提供web服务时的worder进程数，可将其设置为可用的CPU内核数，auto为自动检测</div><div class=\"line\">worker_rlimit_nofile 100000;  # 更改worker进程的最大打开文件数限制</div><div class=\"line\">error_log logs/error.log  info;   #错误日志存放路径</div><div class=\"line\">keepalive_timeout 60;  #keepalive_timeout 60;</div><div class=\"line\">events&#123;</div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\">见events模块</span></div><div class=\"line\">&#125;</div><div class=\"line\">http&#123;  #见http模块</div><div class=\"line\">  server&#123; </div><div class=\"line\">    ...</div><div class=\"line\">    location /&#123;</div><div class=\"line\">     </div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">mail&#123;</div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\">见mail模块</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4>2.4.2. events模块</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">events &#123;</div><div class=\"line\">  worker_connections 2048;    #设置可由一个worker进程同时打开的最大连接数</div><div class=\"line\">  multi_accept on;   #告诉nginx收到一个新连接通知后接受尽可能多的连接</div><div class=\"line\">  use epoll; #设置用于复用客户端线程的轮询方法。Linux 2.6+：使用epoll；*BSD：使用kqueue。</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4>2.4.3. http模块</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">http &#123;  #http模块</div><div class=\"line\">    server &#123;  #server模块，http服务上的虚拟主机， server 当做对应一个域名进行的配置</div><div class=\"line\">        listen          80;  #配置监听端口</div><div class=\"line\">        server_name     www.linuxidc.com; #配置访问域名</div><div class=\"line\">        access_log      logs/linuxidc.access.log main;  #指定日志文件的存放路径</div><div class=\"line\">        index index.html;    #默认访问页面</div><div class=\"line\">        root  /var/www/androidj.com/htdocs;  # root 是指将本地的一个文件夹作为所有 url 请求的根路径</div><div class=\"line\">        upstream backend &#123;   #反向代理的后端机器，实现负载均衡</div><div class=\"line\">            ip_hash;    #指明了我们均衡的方式是按照用户的 ip 地址进行分配</div><div class=\"line\">            server backend1.example.com;</div><div class=\"line\">            server backend2.example.com;</div><div class=\"line\">            server backend3.example.com;</div><div class=\"line\">            server backend4.example.com;</div><div class=\"line\">        &#125;</div><div class=\"line\">        location / &#123;  #location 是在一个域名下对更精细的路径进行配置</div><div class=\"line\">            proxy_pass http://backend;  #反向代理到后端机器</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    server &#123;</div><div class=\"line\">        listen          80;</div><div class=\"line\">        server_name     www.Androidj.com;</div><div class=\"line\">        access_log      logs/androidj.access.log main;</div><div class=\"line\">        location / &#123;</div><div class=\"line\">            index index.html;</div><div class=\"line\">            root  /var/www/androidj.com/htdocs;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4>2.4.4. mail模块</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">mail &#123;</div><div class=\"line\">    auth_http  127.0.0.1:80/auth.php;</div><div class=\"line\">    pop3_capabilities  \"TOP\"  \"USER\";</div><div class=\"line\">    imap_capabilities  \"IMAP4rev1\"  \"UIDPLUS\";</div><div class=\"line\"> </div><div class=\"line\">    server &#123;</div><div class=\"line\">        listen     110;</div><div class=\"line\">        protocol   pop3;</div><div class=\"line\">        proxy      on;</div><div class=\"line\">    &#125;</div><div class=\"line\">    server &#123;</div><div class=\"line\">        listen      25;</div><div class=\"line\">        protocol    smtp;</div><div class=\"line\">        proxy       on;</div><div class=\"line\">        smtp_auth   login plain;</div><div class=\"line\">        xclient     off;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"[Kubernetes] 基于Docker及Kubernetes技术构建容器云（PaaS）平台","catalog":true,"date":"2017-09-19T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Kubernetes"],"_content":"\n[编者的话]\n\n目前很多的容器云平台通过Docker及Kubernetes等技术提供应用运行平台，从而实现运维自动化，快速部署应用、弹性伸缩和动态调整应用环境资源，提高研发运营效率。\n\n从宏观到微观（从抽象到具体）的思路来理解：云计算→PaaS→ App Engine→XAE[XXX App Engine] （XAE泛指一类应用运行平台，例如GAE、SAE、BAE等）。\n\n本文简要介绍了与容器云相关的几个重要概念：PaaS、App Engine、Dokcer、Kubernetes。\n\n## 1. PaaS概述\n\n### 1.1. PaaS概念\n\n1. PaaS(Platform as a service)，平台即服务，指将软件研发的平台（或业务基础平台）作为一种服务，以SaaS的模式提交给用户。\n2. PaaS是云计算服务的其中一种模式，云计算是一种按使用量付费的模式的服务，类似一种租赁服务，服务可以是基础设施计算资源（IaaS），平台（PaaS），软件（SaaS）。租用IT资源的方式来实现业务需要，如同水力、电力资源一样，计算、存储、网络将成为企业IT运行的一种被使用的资源，无需自己建设，可按需获得。\n3. PaaS的实质是将互联网的资源服务化为可编程接口，为第三方开发者提供有商业价值的资源和服务平台。简而言之，IaaS就是卖硬件及计算资源，PaaS就是卖开发、运行环境，SaaS就是卖软件。\n\n### 1.2. IaaS/PaaS/SaaS说明\n\n ![云计算三个层次](/img/article/CaaS/云计算三个层次.jpg)\n\n| 类型                                       | 说明                     | 比喻          | 例子                   |\n| ---------------------------------------- | ---------------------- | ----------- | -------------------- |\n| IaaS:Infrastructure-as-a-Service(基础设施即服务) | 提供的服务是计算基础设施           | 地皮，需要自己盖房子  | Amazon EC2（亚马逊弹性云计算） |\n| PaaS: Platform-as-a-Service(平台即服务)       | 提供的服务是软件研发的平台或业务基础平台   | 商品房，需要自己装修  | GAE（谷歌开发者平台）         |\n| SaaS: Software-as-a-Service(软件即服务)       | 提供的服务是运行在云计算基础设施上的应用程序 | 酒店套房，可以直接入住 | 谷歌的Gmail邮箱           |\n\n![PaaS](/img/article/CaaS/PaaS.jpg)\n\n### 1.3. PaaS的特点（三种层次）\n\n| 特点    | 说明                                  |\n| ----- | ----------------------------------- |\n| 平台即服务 | PaaS提供的服务就是个基础平台，一个环境，而不是具体的应用      |\n| 平台及服务 | 不仅提供平台，还提供对该平台的技术支持、优化等服务           |\n| 平台级服务 | “平台级服务”即强大稳定的平台和专业的技术支持团队，保障应用的稳定使用 |\n\n## 2. App Engine概述\n\n### 2.1. App Engine概念\n\nApp Engine是PaaS模式的一种实现方式，App Engine将应用运行所需的 IT 资源和基础设施以服务的方式提供给用户，包括了中间件服务、资源管理服务、弹性调度服务、消息服务等多种服务形式。App Engine的目标是对应用提供完整生命周期（包括设计、开发、测试和部署等阶段）的支持，从而减少了用户在购置和管理应用生命周期内所必须的软硬件以及部署应用和IT 基础设施的成本，同时简化了以上工作的复杂度。常见的App Engine有：GAE(Google App Engine)，SAE(Sina App Engine)，BAE(Baidu App Engine)。\n\nApp Engine利用虚拟化与自动化技术实现快速搭建部署应用运行环境和动态调整应用运行时环境资源这两个目标。一方面实现即时部署以及快速回收，降低了环境搭建时间，避免了手工配置错误，快速重复搭建环境，及时回收资源， 减少了低利用率硬件资源的空置。另一方面，根据应用运行时的需求对应用环境进行动态调整，实现了应用平台的弹性扩展和自优化，减少了非高峰时硬件资源的空置。\n\n简而言之，App Engine主要目标是：Easy to maintain(维护), Easy to scale(扩容), Easy to build(构建)。\n\n### 2.2. 架构设计\n\n ![App Engine](/img/article/CaaS/AppEngine.jpg)\n\n### 2.3. 组成模块说明\n\n| 组成模块                    | 模块说明                                    |\n| ----------------------- | --------------------------------------- |\n| App Router[流量接入层]       | 接收用户请求，并转发到不同的App Runtime。              |\n| App Runtime[应用运行层]      | 应用运行环境，为各个应用提供基本的运行引擎，从而让app能够运行起来。     |\n| Services[基础服务层]         | 各个通用基础服务，主要是对主流的服务提供通用的接入，例如数据库等。       |\n| Platform Control[平台控制层] | 整个平台的控制中心，实现业务调度，弹性扩容、资源审计、集群管理等相关工作。   |\n| Manage System[管理界面层]    | 提供友好可用的管理操作界面方便平台管理员来控制管理整个平台。          |\n| Platform Support[平台支持层] | 为应用提供相关的支持，比如应用监控、问题定位、分布式日志重建、统计分析等。   |\n| Log Center[日志中心]        | 实时收集相关应用及系统的日志（日志收集），提供实时计算和分析平台（日志处理）。 |\n| Code Center[代码中心]       | 完成代码存储、部署上线相关的工作。                       |\n\n## 3. 容器云平台技术栈\n\n| 功能组成部分 | 使用工具                                  |\n| ------ | ------------------------------------- |\n| 应用载体   | Docker                                |\n| 编排工具   | Kubernetes                            |\n| 配置管理   | Etcd                                  |\n| 网络管理   | Flannel                               |\n| 存储管理   | Ceph                                  |\n| 底层实现   | Linux内核的Namespace[资源隔离]和CGroups[资源控制] |\n\n- **Namespace[资源隔离]**\n  Namespaces机制提供一种资源隔离方案。PID,IPC,Network等系统资源不再是全局性的，而是属于某个特定的Namespace。每个namespace下的资源对于其他namespace下的资源都是透明，不可见的。\n- **CGroups[资源控制]**\n  CGroup（control group）是将任意进程进行分组化管理的Linux内核功能。CGroup本身是提供将进程进行分组化管理的功能和接口的基础结构，I/O或内存的分配控制等具体的资源管理功能是通过这个功能来实现的。CGroups可以限制、记录、隔离进程组所使用的物理资源（包括：CPU、memory、IO等），为容器实现虚拟化提供了基本保证。CGroups本质是内核附加在程序上的一系列钩子（hooks），通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的。\n\n## 4. Docker概述\n\n更多详情请参考：[Docker整体架构图](http://wiki.haplat.net/pages/viewpage.action?pageId=11176501)\n\n### 4.1. Docker介绍\n\n1. Docker - Build, Ship, and Run Any App, Anywhere\n2. Docker是一种Linux容器工具集，它是为“构建（Build）、交付（Ship）和运行（Run）”分布式应用而设计的。\n3. Docker相当于把应用以及应用所依赖的环境完完整整地打成了一个包，这个包拿到哪里都能原生运行。因此可以在开发、测试、运维中保证环境的一致性。\n4. Docker的本质：Docker=LXC(Namespace+CGroups)+Docker Images，即在Linux内核的Namespace[资源隔离]和CGroups[资源控制]技术的基础上通过镜像管理机制来实现轻量化设计。\n\n### 4.2. Docker的基本概念\n\n![image2016-3-15 15-48-30](/img/article/CaaS/docker.png)\n\n#### 4.2.1. 镜像\n\nDocker 镜像就是一个只读的模板，可以把镜像理解成一个模子（模具），由模子（镜像）制作的成品（容器）都是一样的（除非在生成时加额外参数），修改成品（容器）本身并不会对模子（镜像）产生影响（除非将成品提交成一个模子），容器重启时，即由模子（镜像）重新制作成一个成品（容器），与其他由该模子制作成的成品并无区别。\n\n例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。镜像可以用来创建 Docker 容器。Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户可以直接从其他人那里下载一个已经做好的镜像来直接使用。\n\n#### 4.2.2. 容器\n\nDocker 利用容器来运行应用。容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。\n\n#### 4.2.3. 仓库\n\n仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。\n\n### 4.3. Docker的优势\n\n ![Container VS VMs](/img/article/CaaS/ContainerVSVMs.jpg)\n\n1. 容器的快速轻量\n\n   容器的启动，停止和销毁都是以秒或毫秒为单位的，并且相比传统的虚拟化技术，使用容器在CPU、内存，网络IO等资源上的性能损耗都有同样水平甚至更优的表现。\n\n2. 一次构建，到处运行\n\n   当将容器固化成镜像后，就可以非常快速地加载到任何环境中部署运行。而构建出来的镜像打包了应用运行所需的程序、依赖和运行环境， 这是一个完整可用的应用集装箱，在任何环境下都能保证环境一致性。\n\n3. 完整的生态链\n\n   容器技术并不是Docker首创，但是以往的容器实现只关注于如何运行，而Docker站在巨人的肩膀上进行整合和创新，特别是Docker镜像的设计，完美地解决了容器从构建、交付到运行，提供了完整的生态链支持。\n\n## 5. Kubernetes概述\n\n更多详情请参考：[Kubernetes总架构图](http://wiki.haplat.net/pages/viewpage.action?pageId=11896198)\n\n### 5.1. Kubernetes介绍\n\nKubernetes是Google开源的容器集群管理系统。它构建Docker技术之上，为容器化的应用提供资源调度、部署运行、服务发现、扩容缩容等整一套功能，本质上可看作是基于容器技术的Micro-PaaS平台，即第三代PaaS的代表性项目。\n\n### 5.2. Kubernetes的基本概念\n\n#### 5.2.1. Pod\n\nPod是若干个相关容器的组合，是一个逻辑概念，Pod包含的容器运行在同一个宿主机上，这些容器使用相同的网络命名空间、IP地址和端口，相互之间能通过localhost来发现和通信，共享一块存储卷空间。在Kubernetes中创建、调度和管理的最小单位是Pod。一个Pod一般只放一个业务容器和一个用于统一网络管理的网络容器。\n\n#### 5.2.2. Replication Controller\n\nReplication Controller是用来控制管理Pod副本(Replica，或者称实例)，Replication Controller确保任何时候Kubernetes集群中有指定数量的Pod副本在运行，如果少于指定数量的Pod副本，Replication Controller会启动新的Pod副本，反之会杀死多余的以保证数量不变。另外Replication Controller是弹性伸缩、滚动升级的实现核心。\n\n#### 5.2.3. Service\n\nService是真实应用服务的抽象，定义了Pod的逻辑集合和访问这个Pod集合的策略，Service将代理Pod对外表现为一个单一访问接口，外部不需要了解后端Pod如何运行，这给扩展或维护带来很大的好处，提供了一套简化的服务代理和发现机制。\n\n#### 5.2.4. Label\n\nLabel是用于区分Pod、Service、Replication Controller的Key/Value键值对，实际上Kubernetes中的任意API对象都可以通过Label进行标识。每个API对象可以有多个Label，但是每个Label的Key只能对应一个Value。Label是Service和Replication Controller运行的基础，它们都通过Label来关联Pod，相比于强绑定模型，这是一种非常好的松耦合关系。\n\n#### 5.2.5. Node\n\nKubernets属于主从的分布式集群架构，Kubernets Node（简称为Node，早期版本叫做Minion）运行并管理容器。Node作为Kubernetes的操作单元，将用来分配给Pod（或者说容器）进行绑定，Pod最终运行在Node上，Node可以认为是Pod的宿主机。\n\n### 5.3. Kubernetes架构\n\n![k8s架构](/img/article/CaaS/k8s架构.png)\n\n ","source":"_posts/Kubernetes/基于Docker及Kubernetes技术构建容器云（PaaS）平台.md","raw":"---\ntitle: \"[Kubernetes] 基于Docker及Kubernetes技术构建容器云（PaaS）平台\"\ncatalog: true\ndate: 2017-09-19 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Kubernetes\ncatagories:\n- Kubernetes\n---\n\n[编者的话]\n\n目前很多的容器云平台通过Docker及Kubernetes等技术提供应用运行平台，从而实现运维自动化，快速部署应用、弹性伸缩和动态调整应用环境资源，提高研发运营效率。\n\n从宏观到微观（从抽象到具体）的思路来理解：云计算→PaaS→ App Engine→XAE[XXX App Engine] （XAE泛指一类应用运行平台，例如GAE、SAE、BAE等）。\n\n本文简要介绍了与容器云相关的几个重要概念：PaaS、App Engine、Dokcer、Kubernetes。\n\n## 1. PaaS概述\n\n### 1.1. PaaS概念\n\n1. PaaS(Platform as a service)，平台即服务，指将软件研发的平台（或业务基础平台）作为一种服务，以SaaS的模式提交给用户。\n2. PaaS是云计算服务的其中一种模式，云计算是一种按使用量付费的模式的服务，类似一种租赁服务，服务可以是基础设施计算资源（IaaS），平台（PaaS），软件（SaaS）。租用IT资源的方式来实现业务需要，如同水力、电力资源一样，计算、存储、网络将成为企业IT运行的一种被使用的资源，无需自己建设，可按需获得。\n3. PaaS的实质是将互联网的资源服务化为可编程接口，为第三方开发者提供有商业价值的资源和服务平台。简而言之，IaaS就是卖硬件及计算资源，PaaS就是卖开发、运行环境，SaaS就是卖软件。\n\n### 1.2. IaaS/PaaS/SaaS说明\n\n ![云计算三个层次](/img/article/CaaS/云计算三个层次.jpg)\n\n| 类型                                       | 说明                     | 比喻          | 例子                   |\n| ---------------------------------------- | ---------------------- | ----------- | -------------------- |\n| IaaS:Infrastructure-as-a-Service(基础设施即服务) | 提供的服务是计算基础设施           | 地皮，需要自己盖房子  | Amazon EC2（亚马逊弹性云计算） |\n| PaaS: Platform-as-a-Service(平台即服务)       | 提供的服务是软件研发的平台或业务基础平台   | 商品房，需要自己装修  | GAE（谷歌开发者平台）         |\n| SaaS: Software-as-a-Service(软件即服务)       | 提供的服务是运行在云计算基础设施上的应用程序 | 酒店套房，可以直接入住 | 谷歌的Gmail邮箱           |\n\n![PaaS](/img/article/CaaS/PaaS.jpg)\n\n### 1.3. PaaS的特点（三种层次）\n\n| 特点    | 说明                                  |\n| ----- | ----------------------------------- |\n| 平台即服务 | PaaS提供的服务就是个基础平台，一个环境，而不是具体的应用      |\n| 平台及服务 | 不仅提供平台，还提供对该平台的技术支持、优化等服务           |\n| 平台级服务 | “平台级服务”即强大稳定的平台和专业的技术支持团队，保障应用的稳定使用 |\n\n## 2. App Engine概述\n\n### 2.1. App Engine概念\n\nApp Engine是PaaS模式的一种实现方式，App Engine将应用运行所需的 IT 资源和基础设施以服务的方式提供给用户，包括了中间件服务、资源管理服务、弹性调度服务、消息服务等多种服务形式。App Engine的目标是对应用提供完整生命周期（包括设计、开发、测试和部署等阶段）的支持，从而减少了用户在购置和管理应用生命周期内所必须的软硬件以及部署应用和IT 基础设施的成本，同时简化了以上工作的复杂度。常见的App Engine有：GAE(Google App Engine)，SAE(Sina App Engine)，BAE(Baidu App Engine)。\n\nApp Engine利用虚拟化与自动化技术实现快速搭建部署应用运行环境和动态调整应用运行时环境资源这两个目标。一方面实现即时部署以及快速回收，降低了环境搭建时间，避免了手工配置错误，快速重复搭建环境，及时回收资源， 减少了低利用率硬件资源的空置。另一方面，根据应用运行时的需求对应用环境进行动态调整，实现了应用平台的弹性扩展和自优化，减少了非高峰时硬件资源的空置。\n\n简而言之，App Engine主要目标是：Easy to maintain(维护), Easy to scale(扩容), Easy to build(构建)。\n\n### 2.2. 架构设计\n\n ![App Engine](/img/article/CaaS/AppEngine.jpg)\n\n### 2.3. 组成模块说明\n\n| 组成模块                    | 模块说明                                    |\n| ----------------------- | --------------------------------------- |\n| App Router[流量接入层]       | 接收用户请求，并转发到不同的App Runtime。              |\n| App Runtime[应用运行层]      | 应用运行环境，为各个应用提供基本的运行引擎，从而让app能够运行起来。     |\n| Services[基础服务层]         | 各个通用基础服务，主要是对主流的服务提供通用的接入，例如数据库等。       |\n| Platform Control[平台控制层] | 整个平台的控制中心，实现业务调度，弹性扩容、资源审计、集群管理等相关工作。   |\n| Manage System[管理界面层]    | 提供友好可用的管理操作界面方便平台管理员来控制管理整个平台。          |\n| Platform Support[平台支持层] | 为应用提供相关的支持，比如应用监控、问题定位、分布式日志重建、统计分析等。   |\n| Log Center[日志中心]        | 实时收集相关应用及系统的日志（日志收集），提供实时计算和分析平台（日志处理）。 |\n| Code Center[代码中心]       | 完成代码存储、部署上线相关的工作。                       |\n\n## 3. 容器云平台技术栈\n\n| 功能组成部分 | 使用工具                                  |\n| ------ | ------------------------------------- |\n| 应用载体   | Docker                                |\n| 编排工具   | Kubernetes                            |\n| 配置管理   | Etcd                                  |\n| 网络管理   | Flannel                               |\n| 存储管理   | Ceph                                  |\n| 底层实现   | Linux内核的Namespace[资源隔离]和CGroups[资源控制] |\n\n- **Namespace[资源隔离]**\n  Namespaces机制提供一种资源隔离方案。PID,IPC,Network等系统资源不再是全局性的，而是属于某个特定的Namespace。每个namespace下的资源对于其他namespace下的资源都是透明，不可见的。\n- **CGroups[资源控制]**\n  CGroup（control group）是将任意进程进行分组化管理的Linux内核功能。CGroup本身是提供将进程进行分组化管理的功能和接口的基础结构，I/O或内存的分配控制等具体的资源管理功能是通过这个功能来实现的。CGroups可以限制、记录、隔离进程组所使用的物理资源（包括：CPU、memory、IO等），为容器实现虚拟化提供了基本保证。CGroups本质是内核附加在程序上的一系列钩子（hooks），通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的。\n\n## 4. Docker概述\n\n更多详情请参考：[Docker整体架构图](http://wiki.haplat.net/pages/viewpage.action?pageId=11176501)\n\n### 4.1. Docker介绍\n\n1. Docker - Build, Ship, and Run Any App, Anywhere\n2. Docker是一种Linux容器工具集，它是为“构建（Build）、交付（Ship）和运行（Run）”分布式应用而设计的。\n3. Docker相当于把应用以及应用所依赖的环境完完整整地打成了一个包，这个包拿到哪里都能原生运行。因此可以在开发、测试、运维中保证环境的一致性。\n4. Docker的本质：Docker=LXC(Namespace+CGroups)+Docker Images，即在Linux内核的Namespace[资源隔离]和CGroups[资源控制]技术的基础上通过镜像管理机制来实现轻量化设计。\n\n### 4.2. Docker的基本概念\n\n![image2016-3-15 15-48-30](/img/article/CaaS/docker.png)\n\n#### 4.2.1. 镜像\n\nDocker 镜像就是一个只读的模板，可以把镜像理解成一个模子（模具），由模子（镜像）制作的成品（容器）都是一样的（除非在生成时加额外参数），修改成品（容器）本身并不会对模子（镜像）产生影响（除非将成品提交成一个模子），容器重启时，即由模子（镜像）重新制作成一个成品（容器），与其他由该模子制作成的成品并无区别。\n\n例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。镜像可以用来创建 Docker 容器。Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户可以直接从其他人那里下载一个已经做好的镜像来直接使用。\n\n#### 4.2.2. 容器\n\nDocker 利用容器来运行应用。容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。\n\n#### 4.2.3. 仓库\n\n仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。\n\n### 4.3. Docker的优势\n\n ![Container VS VMs](/img/article/CaaS/ContainerVSVMs.jpg)\n\n1. 容器的快速轻量\n\n   容器的启动，停止和销毁都是以秒或毫秒为单位的，并且相比传统的虚拟化技术，使用容器在CPU、内存，网络IO等资源上的性能损耗都有同样水平甚至更优的表现。\n\n2. 一次构建，到处运行\n\n   当将容器固化成镜像后，就可以非常快速地加载到任何环境中部署运行。而构建出来的镜像打包了应用运行所需的程序、依赖和运行环境， 这是一个完整可用的应用集装箱，在任何环境下都能保证环境一致性。\n\n3. 完整的生态链\n\n   容器技术并不是Docker首创，但是以往的容器实现只关注于如何运行，而Docker站在巨人的肩膀上进行整合和创新，特别是Docker镜像的设计，完美地解决了容器从构建、交付到运行，提供了完整的生态链支持。\n\n## 5. Kubernetes概述\n\n更多详情请参考：[Kubernetes总架构图](http://wiki.haplat.net/pages/viewpage.action?pageId=11896198)\n\n### 5.1. Kubernetes介绍\n\nKubernetes是Google开源的容器集群管理系统。它构建Docker技术之上，为容器化的应用提供资源调度、部署运行、服务发现、扩容缩容等整一套功能，本质上可看作是基于容器技术的Micro-PaaS平台，即第三代PaaS的代表性项目。\n\n### 5.2. Kubernetes的基本概念\n\n#### 5.2.1. Pod\n\nPod是若干个相关容器的组合，是一个逻辑概念，Pod包含的容器运行在同一个宿主机上，这些容器使用相同的网络命名空间、IP地址和端口，相互之间能通过localhost来发现和通信，共享一块存储卷空间。在Kubernetes中创建、调度和管理的最小单位是Pod。一个Pod一般只放一个业务容器和一个用于统一网络管理的网络容器。\n\n#### 5.2.2. Replication Controller\n\nReplication Controller是用来控制管理Pod副本(Replica，或者称实例)，Replication Controller确保任何时候Kubernetes集群中有指定数量的Pod副本在运行，如果少于指定数量的Pod副本，Replication Controller会启动新的Pod副本，反之会杀死多余的以保证数量不变。另外Replication Controller是弹性伸缩、滚动升级的实现核心。\n\n#### 5.2.3. Service\n\nService是真实应用服务的抽象，定义了Pod的逻辑集合和访问这个Pod集合的策略，Service将代理Pod对外表现为一个单一访问接口，外部不需要了解后端Pod如何运行，这给扩展或维护带来很大的好处，提供了一套简化的服务代理和发现机制。\n\n#### 5.2.4. Label\n\nLabel是用于区分Pod、Service、Replication Controller的Key/Value键值对，实际上Kubernetes中的任意API对象都可以通过Label进行标识。每个API对象可以有多个Label，但是每个Label的Key只能对应一个Value。Label是Service和Replication Controller运行的基础，它们都通过Label来关联Pod，相比于强绑定模型，这是一种非常好的松耦合关系。\n\n#### 5.2.5. Node\n\nKubernets属于主从的分布式集群架构，Kubernets Node（简称为Node，早期版本叫做Minion）运行并管理容器。Node作为Kubernetes的操作单元，将用来分配给Pod（或者说容器）进行绑定，Pod最终运行在Node上，Node可以认为是Pod的宿主机。\n\n### 5.3. Kubernetes架构\n\n![k8s架构](/img/article/CaaS/k8s架构.png)\n\n ","slug":"Kubernetes/基于Docker及Kubernetes技术构建容器云（PaaS）平台","published":1,"updated":"2017-10-02T13:11:13.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740iq000k30vuewf4boq0","content":"<p>[编者的话]</p>\n<p>目前很多的容器云平台通过Docker及Kubernetes等技术提供应用运行平台，从而实现运维自动化，快速部署应用、弹性伸缩和动态调整应用环境资源，提高研发运营效率。</p>\n<p>从宏观到微观（从抽象到具体）的思路来理解：云计算→PaaS→ App Engine→XAE[XXX App Engine] （XAE泛指一类应用运行平台，例如GAE、SAE、BAE等）。</p>\n<p>本文简要介绍了与容器云相关的几个重要概念：PaaS、App Engine、Dokcer、Kubernetes。</p>\n<h2><span id=\"1-paas概述\">1. PaaS概述</span></h2>\n<h3><span id=\"11-paas概念\">1.1. PaaS概念</span></h3>\n<ol>\n<li>PaaS(Platform as a service)，平台即服务，指将软件研发的平台（或业务基础平台）作为一种服务，以SaaS的模式提交给用户。</li>\n<li>PaaS是云计算服务的其中一种模式，云计算是一种按使用量付费的模式的服务，类似一种租赁服务，服务可以是基础设施计算资源（IaaS），平台（PaaS），软件（SaaS）。租用IT资源的方式来实现业务需要，如同水力、电力资源一样，计算、存储、网络将成为企业IT运行的一种被使用的资源，无需自己建设，可按需获得。</li>\n<li>PaaS的实质是将互联网的资源服务化为可编程接口，为第三方开发者提供有商业价值的资源和服务平台。简而言之，IaaS就是卖硬件及计算资源，PaaS就是卖开发、运行环境，SaaS就是卖软件。</li>\n</ol>\n<h3><span id=\"12-iaaspaassaas说明\">1.2. IaaS/PaaS/SaaS说明</span></h3>\n<p><img src=\"/img/article/CaaS/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1.jpg\" alt=\"云计算三个层次\"></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>说明</th>\n<th>比喻</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IaaS:Infrastructure-as-a-Service(基础设施即服务)</td>\n<td>提供的服务是计算基础设施</td>\n<td>地皮，需要自己盖房子</td>\n<td>Amazon EC2（亚马逊弹性云计算）</td>\n</tr>\n<tr>\n<td>PaaS: Platform-as-a-Service(平台即服务)</td>\n<td>提供的服务是软件研发的平台或业务基础平台</td>\n<td>商品房，需要自己装修</td>\n<td>GAE（谷歌开发者平台）</td>\n</tr>\n<tr>\n<td>SaaS: Software-as-a-Service(软件即服务)</td>\n<td>提供的服务是运行在云计算基础设施上的应用程序</td>\n<td>酒店套房，可以直接入住</td>\n<td>谷歌的Gmail邮箱</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/img/article/CaaS/PaaS.jpg\" alt=\"PaaS\"></p>\n<h3><span id=\"13-paas的特点三种层次\">1.3. PaaS的特点（三种层次）</span></h3>\n<table>\n<thead>\n<tr>\n<th>特点</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>平台即服务</td>\n<td>PaaS提供的服务就是个基础平台，一个环境，而不是具体的应用</td>\n</tr>\n<tr>\n<td>平台及服务</td>\n<td>不仅提供平台，还提供对该平台的技术支持、优化等服务</td>\n</tr>\n<tr>\n<td>平台级服务</td>\n<td>“平台级服务”即强大稳定的平台和专业的技术支持团队，保障应用的稳定使用</td>\n</tr>\n</tbody>\n</table>\n<h2><span id=\"2-app-engine概述\">2. App Engine概述</span></h2>\n<h3><span id=\"21-app-engine概念\">2.1. App Engine概念</span></h3>\n<p>App Engine是PaaS模式的一种实现方式，App Engine将应用运行所需的 IT 资源和基础设施以服务的方式提供给用户，包括了中间件服务、资源管理服务、弹性调度服务、消息服务等多种服务形式。App Engine的目标是对应用提供完整生命周期（包括设计、开发、测试和部署等阶段）的支持，从而减少了用户在购置和管理应用生命周期内所必须的软硬件以及部署应用和IT 基础设施的成本，同时简化了以上工作的复杂度。常见的App Engine有：GAE(Google App Engine)，SAE(Sina App Engine)，BAE(Baidu App Engine)。</p>\n<p>App Engine利用虚拟化与自动化技术实现快速搭建部署应用运行环境和动态调整应用运行时环境资源这两个目标。一方面实现即时部署以及快速回收，降低了环境搭建时间，避免了手工配置错误，快速重复搭建环境，及时回收资源， 减少了低利用率硬件资源的空置。另一方面，根据应用运行时的需求对应用环境进行动态调整，实现了应用平台的弹性扩展和自优化，减少了非高峰时硬件资源的空置。</p>\n<p>简而言之，App Engine主要目标是：Easy to maintain(维护), Easy to scale(扩容), Easy to build(构建)。</p>\n<h3><span id=\"22-架构设计\">2.2. 架构设计</span></h3>\n<p><img src=\"/img/article/CaaS/AppEngine.jpg\" alt=\"App Engine\"></p>\n<h3><span id=\"23-组成模块说明\">2.3. 组成模块说明</span></h3>\n<table>\n<thead>\n<tr>\n<th>组成模块</th>\n<th>模块说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>App Router[流量接入层]</td>\n<td>接收用户请求，并转发到不同的App Runtime。</td>\n</tr>\n<tr>\n<td>App Runtime[应用运行层]</td>\n<td>应用运行环境，为各个应用提供基本的运行引擎，从而让app能够运行起来。</td>\n</tr>\n<tr>\n<td>Services[基础服务层]</td>\n<td>各个通用基础服务，主要是对主流的服务提供通用的接入，例如数据库等。</td>\n</tr>\n<tr>\n<td>Platform Control[平台控制层]</td>\n<td>整个平台的控制中心，实现业务调度，弹性扩容、资源审计、集群管理等相关工作。</td>\n</tr>\n<tr>\n<td>Manage System[管理界面层]</td>\n<td>提供友好可用的管理操作界面方便平台管理员来控制管理整个平台。</td>\n</tr>\n<tr>\n<td>Platform Support[平台支持层]</td>\n<td>为应用提供相关的支持，比如应用监控、问题定位、分布式日志重建、统计分析等。</td>\n</tr>\n<tr>\n<td>Log Center[日志中心]</td>\n<td>实时收集相关应用及系统的日志（日志收集），提供实时计算和分析平台（日志处理）。</td>\n</tr>\n<tr>\n<td>Code Center[代码中心]</td>\n<td>完成代码存储、部署上线相关的工作。</td>\n</tr>\n</tbody>\n</table>\n<h2><span id=\"3-容器云平台技术栈\">3. 容器云平台技术栈</span></h2>\n<table>\n<thead>\n<tr>\n<th>功能组成部分</th>\n<th>使用工具</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用载体</td>\n<td>Docker</td>\n</tr>\n<tr>\n<td>编排工具</td>\n<td>Kubernetes</td>\n</tr>\n<tr>\n<td>配置管理</td>\n<td>Etcd</td>\n</tr>\n<tr>\n<td>网络管理</td>\n<td>Flannel</td>\n</tr>\n<tr>\n<td>存储管理</td>\n<td>Ceph</td>\n</tr>\n<tr>\n<td>底层实现</td>\n<td>Linux内核的Namespace[资源隔离]和CGroups[资源控制]</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>Namespace[资源隔离]</strong><br>\nNamespaces机制提供一种资源隔离方案。PID,IPC,Network等系统资源不再是全局性的，而是属于某个特定的Namespace。每个namespace下的资源对于其他namespace下的资源都是透明，不可见的。</li>\n<li><strong>CGroups[资源控制]</strong><br>\nCGroup（control group）是将任意进程进行分组化管理的Linux内核功能。CGroup本身是提供将进程进行分组化管理的功能和接口的基础结构，I/O或内存的分配控制等具体的资源管理功能是通过这个功能来实现的。CGroups可以限制、记录、隔离进程组所使用的物理资源（包括：CPU、memory、IO等），为容器实现虚拟化提供了基本保证。CGroups本质是内核附加在程序上的一系列钩子（hooks），通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的。</li>\n</ul>\n<h2><span id=\"4-docker概述\">4. Docker概述</span></h2>\n<p>更多详情请参考：<a href=\"http://wiki.haplat.net/pages/viewpage.action?pageId=11176501\" target=\"_blank\" rel=\"external\">Docker整体架构图</a></p>\n<h3><span id=\"41-docker介绍\">4.1. Docker介绍</span></h3>\n<ol>\n<li>Docker - Build, Ship, and Run Any App, Anywhere</li>\n<li>Docker是一种Linux容器工具集，它是为“构建（Build）、交付（Ship）和运行（Run）”分布式应用而设计的。</li>\n<li>Docker相当于把应用以及应用所依赖的环境完完整整地打成了一个包，这个包拿到哪里都能原生运行。因此可以在开发、测试、运维中保证环境的一致性。</li>\n<li>Docker的本质：Docker=LXC(Namespace+CGroups)+Docker Images，即在Linux内核的Namespace[资源隔离]和CGroups[资源控制]技术的基础上通过镜像管理机制来实现轻量化设计。</li>\n</ol>\n<h3><span id=\"42-docker的基本概念\">4.2. Docker的基本概念</span></h3>\n<p><img src=\"/img/article/CaaS/docker.png\" alt=\"image2016-3-15 15-48-30\"></p>\n<h4><span id=\"421-镜像\">4.2.1. 镜像</span></h4>\n<p>Docker 镜像就是一个只读的模板，可以把镜像理解成一个模子（模具），由模子（镜像）制作的成品（容器）都是一样的（除非在生成时加额外参数），修改成品（容器）本身并不会对模子（镜像）产生影响（除非将成品提交成一个模子），容器重启时，即由模子（镜像）重新制作成一个成品（容器），与其他由该模子制作成的成品并无区别。</p>\n<p>例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。镜像可以用来创建 Docker 容器。Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户可以直接从其他人那里下载一个已经做好的镜像来直接使用。</p>\n<h4><span id=\"422-容器\">4.2.2. 容器</span></h4>\n<p>Docker 利用容器来运行应用。容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p>\n<h4><span id=\"423-仓库\">4.2.3. 仓库</span></h4>\n<p>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p>\n<h3><span id=\"43-docker的优势\">4.3. Docker的优势</span></h3>\n<p><img src=\"/img/article/CaaS/ContainerVSVMs.jpg\" alt=\"Container VS VMs\"></p>\n<ol>\n<li>\n<p>容器的快速轻量</p>\n<p>容器的启动，停止和销毁都是以秒或毫秒为单位的，并且相比传统的虚拟化技术，使用容器在CPU、内存，网络IO等资源上的性能损耗都有同样水平甚至更优的表现。</p>\n</li>\n<li>\n<p>一次构建，到处运行</p>\n<p>当将容器固化成镜像后，就可以非常快速地加载到任何环境中部署运行。而构建出来的镜像打包了应用运行所需的程序、依赖和运行环境， 这是一个完整可用的应用集装箱，在任何环境下都能保证环境一致性。</p>\n</li>\n<li>\n<p>完整的生态链</p>\n<p>容器技术并不是Docker首创，但是以往的容器实现只关注于如何运行，而Docker站在巨人的肩膀上进行整合和创新，特别是Docker镜像的设计，完美地解决了容器从构建、交付到运行，提供了完整的生态链支持。</p>\n</li>\n</ol>\n<h2><span id=\"5-kubernetes概述\">5. Kubernetes概述</span></h2>\n<p>更多详情请参考：<a href=\"http://wiki.haplat.net/pages/viewpage.action?pageId=11896198\" target=\"_blank\" rel=\"external\">Kubernetes总架构图</a></p>\n<h3><span id=\"51-kubernetes介绍\">5.1. Kubernetes介绍</span></h3>\n<p>Kubernetes是Google开源的容器集群管理系统。它构建Docker技术之上，为容器化的应用提供资源调度、部署运行、服务发现、扩容缩容等整一套功能，本质上可看作是基于容器技术的Micro-PaaS平台，即第三代PaaS的代表性项目。</p>\n<h3><span id=\"52-kubernetes的基本概念\">5.2. Kubernetes的基本概念</span></h3>\n<h4><span id=\"521-pod\">5.2.1. Pod</span></h4>\n<p>Pod是若干个相关容器的组合，是一个逻辑概念，Pod包含的容器运行在同一个宿主机上，这些容器使用相同的网络命名空间、IP地址和端口，相互之间能通过localhost来发现和通信，共享一块存储卷空间。在Kubernetes中创建、调度和管理的最小单位是Pod。一个Pod一般只放一个业务容器和一个用于统一网络管理的网络容器。</p>\n<h4><span id=\"522-replication-controller\">5.2.2. Replication Controller</span></h4>\n<p>Replication Controller是用来控制管理Pod副本(Replica，或者称实例)，Replication Controller确保任何时候Kubernetes集群中有指定数量的Pod副本在运行，如果少于指定数量的Pod副本，Replication Controller会启动新的Pod副本，反之会杀死多余的以保证数量不变。另外Replication Controller是弹性伸缩、滚动升级的实现核心。</p>\n<h4><span id=\"523-service\">5.2.3. Service</span></h4>\n<p>Service是真实应用服务的抽象，定义了Pod的逻辑集合和访问这个Pod集合的策略，Service将代理Pod对外表现为一个单一访问接口，外部不需要了解后端Pod如何运行，这给扩展或维护带来很大的好处，提供了一套简化的服务代理和发现机制。</p>\n<h4><span id=\"524-label\">5.2.4. Label</span></h4>\n<p>Label是用于区分Pod、Service、Replication Controller的Key/Value键值对，实际上Kubernetes中的任意API对象都可以通过Label进行标识。每个API对象可以有多个Label，但是每个Label的Key只能对应一个Value。Label是Service和Replication Controller运行的基础，它们都通过Label来关联Pod，相比于强绑定模型，这是一种非常好的松耦合关系。</p>\n<h4><span id=\"525-node\">5.2.5. Node</span></h4>\n<p>Kubernets属于主从的分布式集群架构，Kubernets Node（简称为Node，早期版本叫做Minion）运行并管理容器。Node作为Kubernetes的操作单元，将用来分配给Pod（或者说容器）进行绑定，Pod最终运行在Node上，Node可以认为是Pod的宿主机。</p>\n<h3><span id=\"53-kubernetes架构\">5.3. Kubernetes架构</span></h3>\n<p><img src=\"/img/article/CaaS/k8s%E6%9E%B6%E6%9E%84.png\" alt=\"k8s架构\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[编者的话]</p>\n<p>目前很多的容器云平台通过Docker及Kubernetes等技术提供应用运行平台，从而实现运维自动化，快速部署应用、弹性伸缩和动态调整应用环境资源，提高研发运营效率。</p>\n<p>从宏观到微观（从抽象到具体）的思路来理解：云计算→PaaS→ App Engine→XAE[XXX App Engine] （XAE泛指一类应用运行平台，例如GAE、SAE、BAE等）。</p>\n<p>本文简要介绍了与容器云相关的几个重要概念：PaaS、App Engine、Dokcer、Kubernetes。</p>\n<h2>1. PaaS概述</h2>\n<h3>1.1. PaaS概念</h3>\n<ol>\n<li>PaaS(Platform as a service)，平台即服务，指将软件研发的平台（或业务基础平台）作为一种服务，以SaaS的模式提交给用户。</li>\n<li>PaaS是云计算服务的其中一种模式，云计算是一种按使用量付费的模式的服务，类似一种租赁服务，服务可以是基础设施计算资源（IaaS），平台（PaaS），软件（SaaS）。租用IT资源的方式来实现业务需要，如同水力、电力资源一样，计算、存储、网络将成为企业IT运行的一种被使用的资源，无需自己建设，可按需获得。</li>\n<li>PaaS的实质是将互联网的资源服务化为可编程接口，为第三方开发者提供有商业价值的资源和服务平台。简而言之，IaaS就是卖硬件及计算资源，PaaS就是卖开发、运行环境，SaaS就是卖软件。</li>\n</ol>\n<h3>1.2. IaaS/PaaS/SaaS说明</h3>\n<p><img src=\"/img/article/CaaS/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1.jpg\" alt=\"云计算三个层次\"></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>说明</th>\n<th>比喻</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IaaS:Infrastructure-as-a-Service(基础设施即服务)</td>\n<td>提供的服务是计算基础设施</td>\n<td>地皮，需要自己盖房子</td>\n<td>Amazon EC2（亚马逊弹性云计算）</td>\n</tr>\n<tr>\n<td>PaaS: Platform-as-a-Service(平台即服务)</td>\n<td>提供的服务是软件研发的平台或业务基础平台</td>\n<td>商品房，需要自己装修</td>\n<td>GAE（谷歌开发者平台）</td>\n</tr>\n<tr>\n<td>SaaS: Software-as-a-Service(软件即服务)</td>\n<td>提供的服务是运行在云计算基础设施上的应用程序</td>\n<td>酒店套房，可以直接入住</td>\n<td>谷歌的Gmail邮箱</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/img/article/CaaS/PaaS.jpg\" alt=\"PaaS\"></p>\n<h3>1.3. PaaS的特点（三种层次）</h3>\n<table>\n<thead>\n<tr>\n<th>特点</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>平台即服务</td>\n<td>PaaS提供的服务就是个基础平台，一个环境，而不是具体的应用</td>\n</tr>\n<tr>\n<td>平台及服务</td>\n<td>不仅提供平台，还提供对该平台的技术支持、优化等服务</td>\n</tr>\n<tr>\n<td>平台级服务</td>\n<td>“平台级服务”即强大稳定的平台和专业的技术支持团队，保障应用的稳定使用</td>\n</tr>\n</tbody>\n</table>\n<h2>2. App Engine概述</h2>\n<h3>2.1. App Engine概念</h3>\n<p>App Engine是PaaS模式的一种实现方式，App Engine将应用运行所需的 IT 资源和基础设施以服务的方式提供给用户，包括了中间件服务、资源管理服务、弹性调度服务、消息服务等多种服务形式。App Engine的目标是对应用提供完整生命周期（包括设计、开发、测试和部署等阶段）的支持，从而减少了用户在购置和管理应用生命周期内所必须的软硬件以及部署应用和IT 基础设施的成本，同时简化了以上工作的复杂度。常见的App Engine有：GAE(Google App Engine)，SAE(Sina App Engine)，BAE(Baidu App Engine)。</p>\n<p>App Engine利用虚拟化与自动化技术实现快速搭建部署应用运行环境和动态调整应用运行时环境资源这两个目标。一方面实现即时部署以及快速回收，降低了环境搭建时间，避免了手工配置错误，快速重复搭建环境，及时回收资源， 减少了低利用率硬件资源的空置。另一方面，根据应用运行时的需求对应用环境进行动态调整，实现了应用平台的弹性扩展和自优化，减少了非高峰时硬件资源的空置。</p>\n<p>简而言之，App Engine主要目标是：Easy to maintain(维护), Easy to scale(扩容), Easy to build(构建)。</p>\n<h3>2.2. 架构设计</h3>\n<p><img src=\"/img/article/CaaS/AppEngine.jpg\" alt=\"App Engine\"></p>\n<h3>2.3. 组成模块说明</h3>\n<table>\n<thead>\n<tr>\n<th>组成模块</th>\n<th>模块说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>App Router[流量接入层]</td>\n<td>接收用户请求，并转发到不同的App Runtime。</td>\n</tr>\n<tr>\n<td>App Runtime[应用运行层]</td>\n<td>应用运行环境，为各个应用提供基本的运行引擎，从而让app能够运行起来。</td>\n</tr>\n<tr>\n<td>Services[基础服务层]</td>\n<td>各个通用基础服务，主要是对主流的服务提供通用的接入，例如数据库等。</td>\n</tr>\n<tr>\n<td>Platform Control[平台控制层]</td>\n<td>整个平台的控制中心，实现业务调度，弹性扩容、资源审计、集群管理等相关工作。</td>\n</tr>\n<tr>\n<td>Manage System[管理界面层]</td>\n<td>提供友好可用的管理操作界面方便平台管理员来控制管理整个平台。</td>\n</tr>\n<tr>\n<td>Platform Support[平台支持层]</td>\n<td>为应用提供相关的支持，比如应用监控、问题定位、分布式日志重建、统计分析等。</td>\n</tr>\n<tr>\n<td>Log Center[日志中心]</td>\n<td>实时收集相关应用及系统的日志（日志收集），提供实时计算和分析平台（日志处理）。</td>\n</tr>\n<tr>\n<td>Code Center[代码中心]</td>\n<td>完成代码存储、部署上线相关的工作。</td>\n</tr>\n</tbody>\n</table>\n<h2>3. 容器云平台技术栈</h2>\n<table>\n<thead>\n<tr>\n<th>功能组成部分</th>\n<th>使用工具</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用载体</td>\n<td>Docker</td>\n</tr>\n<tr>\n<td>编排工具</td>\n<td>Kubernetes</td>\n</tr>\n<tr>\n<td>配置管理</td>\n<td>Etcd</td>\n</tr>\n<tr>\n<td>网络管理</td>\n<td>Flannel</td>\n</tr>\n<tr>\n<td>存储管理</td>\n<td>Ceph</td>\n</tr>\n<tr>\n<td>底层实现</td>\n<td>Linux内核的Namespace[资源隔离]和CGroups[资源控制]</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>Namespace[资源隔离]</strong><br>\nNamespaces机制提供一种资源隔离方案。PID,IPC,Network等系统资源不再是全局性的，而是属于某个特定的Namespace。每个namespace下的资源对于其他namespace下的资源都是透明，不可见的。</li>\n<li><strong>CGroups[资源控制]</strong><br>\nCGroup（control group）是将任意进程进行分组化管理的Linux内核功能。CGroup本身是提供将进程进行分组化管理的功能和接口的基础结构，I/O或内存的分配控制等具体的资源管理功能是通过这个功能来实现的。CGroups可以限制、记录、隔离进程组所使用的物理资源（包括：CPU、memory、IO等），为容器实现虚拟化提供了基本保证。CGroups本质是内核附加在程序上的一系列钩子（hooks），通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的。</li>\n</ul>\n<h2>4. Docker概述</h2>\n<p>更多详情请参考：<a href=\"http://wiki.haplat.net/pages/viewpage.action?pageId=11176501\" target=\"_blank\" rel=\"external\">Docker整体架构图</a></p>\n<h3>4.1. Docker介绍</h3>\n<ol>\n<li>Docker - Build, Ship, and Run Any App, Anywhere</li>\n<li>Docker是一种Linux容器工具集，它是为“构建（Build）、交付（Ship）和运行（Run）”分布式应用而设计的。</li>\n<li>Docker相当于把应用以及应用所依赖的环境完完整整地打成了一个包，这个包拿到哪里都能原生运行。因此可以在开发、测试、运维中保证环境的一致性。</li>\n<li>Docker的本质：Docker=LXC(Namespace+CGroups)+Docker Images，即在Linux内核的Namespace[资源隔离]和CGroups[资源控制]技术的基础上通过镜像管理机制来实现轻量化设计。</li>\n</ol>\n<h3>4.2. Docker的基本概念</h3>\n<p><img src=\"/img/article/CaaS/docker.png\" alt=\"image2016-3-15 15-48-30\"></p>\n<h4>4.2.1. 镜像</h4>\n<p>Docker 镜像就是一个只读的模板，可以把镜像理解成一个模子（模具），由模子（镜像）制作的成品（容器）都是一样的（除非在生成时加额外参数），修改成品（容器）本身并不会对模子（镜像）产生影响（除非将成品提交成一个模子），容器重启时，即由模子（镜像）重新制作成一个成品（容器），与其他由该模子制作成的成品并无区别。</p>\n<p>例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。镜像可以用来创建 Docker 容器。Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户可以直接从其他人那里下载一个已经做好的镜像来直接使用。</p>\n<h4>4.2.2. 容器</h4>\n<p>Docker 利用容器来运行应用。容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p>\n<h4>4.2.3. 仓库</h4>\n<p>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p>\n<h3>4.3. Docker的优势</h3>\n<p><img src=\"/img/article/CaaS/ContainerVSVMs.jpg\" alt=\"Container VS VMs\"></p>\n<ol>\n<li>\n<p>容器的快速轻量</p>\n<p>容器的启动，停止和销毁都是以秒或毫秒为单位的，并且相比传统的虚拟化技术，使用容器在CPU、内存，网络IO等资源上的性能损耗都有同样水平甚至更优的表现。</p>\n</li>\n<li>\n<p>一次构建，到处运行</p>\n<p>当将容器固化成镜像后，就可以非常快速地加载到任何环境中部署运行。而构建出来的镜像打包了应用运行所需的程序、依赖和运行环境， 这是一个完整可用的应用集装箱，在任何环境下都能保证环境一致性。</p>\n</li>\n<li>\n<p>完整的生态链</p>\n<p>容器技术并不是Docker首创，但是以往的容器实现只关注于如何运行，而Docker站在巨人的肩膀上进行整合和创新，特别是Docker镜像的设计，完美地解决了容器从构建、交付到运行，提供了完整的生态链支持。</p>\n</li>\n</ol>\n<h2>5. Kubernetes概述</h2>\n<p>更多详情请参考：<a href=\"http://wiki.haplat.net/pages/viewpage.action?pageId=11896198\" target=\"_blank\" rel=\"external\">Kubernetes总架构图</a></p>\n<h3>5.1. Kubernetes介绍</h3>\n<p>Kubernetes是Google开源的容器集群管理系统。它构建Docker技术之上，为容器化的应用提供资源调度、部署运行、服务发现、扩容缩容等整一套功能，本质上可看作是基于容器技术的Micro-PaaS平台，即第三代PaaS的代表性项目。</p>\n<h3>5.2. Kubernetes的基本概念</h3>\n<h4>5.2.1. Pod</h4>\n<p>Pod是若干个相关容器的组合，是一个逻辑概念，Pod包含的容器运行在同一个宿主机上，这些容器使用相同的网络命名空间、IP地址和端口，相互之间能通过localhost来发现和通信，共享一块存储卷空间。在Kubernetes中创建、调度和管理的最小单位是Pod。一个Pod一般只放一个业务容器和一个用于统一网络管理的网络容器。</p>\n<h4>5.2.2. Replication Controller</h4>\n<p>Replication Controller是用来控制管理Pod副本(Replica，或者称实例)，Replication Controller确保任何时候Kubernetes集群中有指定数量的Pod副本在运行，如果少于指定数量的Pod副本，Replication Controller会启动新的Pod副本，反之会杀死多余的以保证数量不变。另外Replication Controller是弹性伸缩、滚动升级的实现核心。</p>\n<h4>5.2.3. Service</h4>\n<p>Service是真实应用服务的抽象，定义了Pod的逻辑集合和访问这个Pod集合的策略，Service将代理Pod对外表现为一个单一访问接口，外部不需要了解后端Pod如何运行，这给扩展或维护带来很大的好处，提供了一套简化的服务代理和发现机制。</p>\n<h4>5.2.4. Label</h4>\n<p>Label是用于区分Pod、Service、Replication Controller的Key/Value键值对，实际上Kubernetes中的任意API对象都可以通过Label进行标识。每个API对象可以有多个Label，但是每个Label的Key只能对应一个Value。Label是Service和Replication Controller运行的基础，它们都通过Label来关联Pod，相比于强绑定模型，这是一种非常好的松耦合关系。</p>\n<h4>5.2.5. Node</h4>\n<p>Kubernets属于主从的分布式集群架构，Kubernets Node（简称为Node，早期版本叫做Minion）运行并管理容器。Node作为Kubernetes的操作单元，将用来分配给Pod（或者说容器）进行绑定，Pod最终运行在Node上，Node可以认为是Pod的宿主机。</p>\n<h3>5.3. Kubernetes架构</h3>\n<p><img src=\"/img/article/CaaS/k8s%E6%9E%B6%E6%9E%84.png\" alt=\"k8s架构\"></p>\n"},{"title":"[Docker] Docker源码分析（二）之Docker Daemon","catalog":true,"date":"2017-07-09T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Docker"],"_content":"\n## 一、Docker Daemon架构示意图\n\n![Daemon架构图](/img/article/docker/docker源码之Docker-Daemon/Daemon架构图.jpg)\n\nDocker Daemon是Docker架构中运行在后台的守护进程，大致可以分为Docker Server、Engine和Job三部分。\n\nDocker Daemon可以认为是通过Docker Server模块接受Docker Client的请求，并在Engine中处理请求，然后根据请求类型，创建出指定的Job并运行。\n\n运行过程的作用有以下几种可能：\n\n- 向Docker Registry获取镜像，\n- 通过graphdriver执行容器镜像的本地化操作，\n- 通过networkdriver执行容器网络环境的配置，\n- 通过execdriver执行容器内部运行的执行工作等。\n\n说明：本文分析的代码为Docker 1.2.0版本。\n\n## 二、Docker Daemon启动流程图\n\n![Daemon启动流程](/img/article/docker/docker源码之Docker-Daemon/Daemon启动流程.jpg)\n\n启动Docker Daemon时，一般可以使用以下命令：docker --daemon=true; docker –d; docker –d=true等。接着由docker的main()函数来解析以上命令的相应flag参数，并最终完成Docker Daemon的启动。\n\n**/docker/docker.go**\n\n```go\nfunc main() {\n    ...\n    if *flDaemon {\n        mainDaemon()\n        return\n    }\n    ...\n}\n```\n\n## 三、mainDaemon的具体实现\n\n宏观来讲，mainDaemon()完成创建一个daemon进程，并使其正常运行。\n\n从功能的角度来说，mainDaemon()实现了两部分内容：\n\n- 第一，创建Docker运行环境；\n- 第二，服务于Docker Client，接收并处理相应请求。\n\n### （一）配置初始化\n\n**/docker/daemon.go**\n\n```go\nvar (\n    daemonCfg = &daemon.Config{}\n)\nfunc init() {\n    daemonCfg.InstallFlags()\n}\n```\n\n在mainDaemon()运行之前，关于Docker Daemon所需要的config配置信息均已经初始化完毕。\n\n声明一个为daemon包中Config类型的变量，名为daemonCfg。而Config对象，定义了Docker Daemon所需的配置信息。在Docker Daemon在启动时，daemonCfg变量被传递至Docker Daemon并被使用。\n\n**/daemon/config.go**\n\n```go\ntype Config struct {\n    Pidfile                  string   //Docker Daemon所属进程的PID文件\n    Root                   string   //Docker运行时所使用的root路径\n    AutoRestart             bool    //已被启用，转而支持docker run时的重启\n    Dns                   []string  //Docker使用的DNS Server地址\n    DnsSearch              []string  //Docker使用的指定的DNS查找域名\n    Mirrors                 []string  //指定的优先Docker Registry镜像\n    EnableIptables           bool    //启用Docker的iptables功能\n    EnableIpForward         bool    //启用net.ipv4.ip_forward功能\n    EnableIpMasq            bool      //启用IP伪装技术\n    DefaultIp                net.IP     //绑定容器端口时使用的默认IP\n    BridgeIface              string      //添加容器网络至已有的网桥\n    BridgeIP                 string     //创建网桥的IP地址\n    FixedCIDR               string     //指定IP的IPv4子网，必须被网桥子网包含\n    InterContainerCommunication   bool  //是否允许相同host上容器间的通信\n    GraphDriver             string      //Docker运行时使用的特定存储驱动\n    GraphOptions            []string   //可设置的存储驱动选项\n    ExecDriver               string    // Docker运行时使用的特定exec驱动\n    Mtu                    int      //设置容器网络的MTU\n    DisableNetwork          bool     //有定义，之后未初始化\n    EnableSelinuxSupport      bool     //启用SELinux功能的支持\n    Context                 map[string][]string   //有定义，之后未初始化\n}\n```\n\ninit()函数实现了daemonCfg变量中各属性的赋值，具体的实现为：daemonCfg.InstallFlags()\n\n**/daemon/config.go**\n\n```go\n// InstallFlags adds command-line options to the top-level flag parser for\n// the current process.\n// Subsequent calls to `flag.Parse` will populate config with values parsed\n// from the command-line.\nfunc (config *Config) InstallFlags() {\n    flag.StringVar(&config.Pidfile, []string{\"p\", \"-pidfile\"}, \"/var/run/docker.pid\", \"Path to use for daemon PID file\")\n    flag.StringVar(&config.Root, []string{\"g\", \"-graph\"}, \"/var/lib/docker\", \"Path to use as the root of the Docker runtime\")\n    flag.BoolVar(&config.AutoRestart, []string{\"#r\", \"#-restart\"}, true, \"--restart on the daemon has been deprecated infavor of --restart policies on docker run\")\n    flag.BoolVar(&config.EnableIptables, []string{\"#iptables\", \"-iptables\"}, true, \"Enable Docker's addition of iptables rules\")\n    flag.BoolVar(&config.EnableIpForward, []string{\"#ip-forward\", \"-ip-forward\"}, true, \"Enable net.ipv4.ip_forward\")\n    flag.StringVar(&config.BridgeIP, []string{\"#bip\", \"-bip\"}, \"\", \"Use this CIDR notation address for the network bridge's IP, not compatible with -b\")\n    flag.StringVar(&config.BridgeIface, []string{\"b\", \"-bridge\"}, \"\", \"Attach containers to a pre-existing network bridge/nuse 'none' to disable container networking\")\n    flag.BoolVar(&config.InterContainerCommunication, []string{\"#icc\", \"-icc\"}, true, \"Enable inter-container communication\")\n    flag.StringVar(&config.GraphDriver, []string{\"s\", \"-storage-driver\"}, \"\", \"Force the Docker runtime to use a specific storage driver\")\n    flag.StringVar(&config.ExecDriver, []string{\"e\", \"-exec-driver\"}, \"native\", \"Force the Docker runtime to use a specific exec driver\")\n    flag.BoolVar(&config.EnableSelinuxSupport, []string{\"-selinux-enabled\"}, false, \"Enable selinux support. SELinux does not presently support the BTRFS storage driver\")\n    flag.IntVar(&config.Mtu, []string{\"#mtu\", \"-mtu\"}, 0, \"Set the containers network MTU/nif no value is provided: default to the default route MTU or 1500 if no default route is available\")\n    opts.IPVar(&config.DefaultIp, []string{\"#ip\", \"-ip\"}, \"0.0.0.0\", \"Default IP address to use when binding container ports\")\n    opts.ListVar(&config.GraphOptions, []string{\"-storage-opt\"}, \"Set storage driver options\")\n    // FIXME: why the inconsistency between \"hosts\" and \"sockets\"?\n    opts.IPListVar(&config.Dns, []string{\"#dns\", \"-dns\"}, \"Force Docker to use specific DNS servers\")\n    opts.DnsSearchListVar(&config.DnsSearch, []string{\"-dns-search\"}, \"Force Docker to use specific DNS search domains\")\n}\n```\n\n在InstallFlags()函数的实现过程中，主要是定义某种类型的flag参数，并将该参数的值绑定在config变量的指定属性上，如：\n\nflag.StringVar(&config.Pidfile, []string{\"p\", \"-pidfile\"}, \" /var/run/docker.pid\", \"Path to use for daemon PID file\")\n\n以上语句的含义为：\n\n- 定义一个为String类型的flag参数；\n- 该flag的名称为”p”或者”-pidfile”;\n- 该flag的值为” /var/run/docker.pid”,并将该值绑定在变量config.Pidfile上；\n- 该flag的描述信息为\"Path to use for daemon PID file\"。\n\n### （二）flag参数检查\n\n**/docker/daemon.go**\n\n```go\nif flag.NArg() != 0 {\n    flag.Usage()\n    return\n}\n```\n\n- 参数个数不为0，则说明在启动Docker Daemon的时候，传入了多余的参数，此时会输出错误提示，并退出运行程序。\n- 若为0，则说明Docker Daemon的启动命令无误，正常运行。\n\n### （三）创建engine对象\n\n**/docker/daemon.go**\n\n```go\neng := engine.New()\n```\n\nEngine是Docker架构中的运行引擎，同时也是Docker运行的核心模块。Engine扮演着Docker container存储仓库的角色，并且通过job的形式来管理这些容器。\n\n**/engine/engine.go**\n\n```go\ntype Engine struct {\n    handlers   map[string]Handler\n    catchall   Handler\n    hack       Hack // data for temporary hackery (see hack.go)\n    id         string\n    Stdout     io.Writer\n    Stderr     io.Writer\n    Stdin      io.Reader\n    Logging    bool\n    tasks      sync.WaitGroup\n    l          sync.RWMutex // lock for shutdown\n    shutdown   bool\n    onShutdown []func() // shutdown handlers\n}\n```\n\nEngine结构体中最为重要的即为handlers属性。该handlers属性为map类型，key为string类型，value为Handler类型。Handler为一个定义的函数。该函数传入的参数为Job指针，返回为Status状态。\n\n**/engine/engine.go**\n\n```go\ntype Handler func(*Job) Status\n```\n\nNew()函数的实现:\n\n**/engine/engine.go**\n\n```go\n// New initializes a new engine.\nfunc New() *Engine {\n    eng := &Engine{\n        handlers: make(map[string]Handler),\n        id:       utils.RandomString(),\n        Stdout:   os.Stdout,\n        Stderr:   os.Stderr,\n        Stdin:    os.Stdin,\n        Logging:  true,\n    }\n    eng.Register(\"commands\", func(job *Job) Status {\n        for _, name := range eng.commands() {\n            job.Printf(\"%s/n\", name)\n        }\n        return StatusOK\n    })\n    // Copy existing global handlers\n    for k, v := range globalHandlers {\n        eng.handlers[k] = v\n    }\n    return eng\n}\n```\n\n1. 创建一个Engine结构体实例eng\n2. 向eng对象注册名为commands的Handler，其中Handler为临时定义的函数func(job *Job) Status{ } , 该函数的作用是通过job来打印所有已经注册完毕的command名称，最终返回状态StatusOK。\n3. 将已定义的变量globalHandlers中的所有的Handler，都复制到eng对象的handlers属性中。最后成功返回eng对象。\n\n### （四）设置engine的信号捕获\n\n**/daemon/daemon.go**\n\n```go\nsignal.Trap(eng.Shutdown)\n```\n\n在Docker Daemon的运行中，设置Trap特定信号的处理方法，特定信号有SIGINT，SIGTERM以及SIGQUIT；当程序捕获到SIGINT或者SIGTERM信号时，执行相应的善后操作，最后保证Docker Daemon程序退出。\n\n**/pkg/signal/trap.go**\n\n```go\n//Trap sets up a simplified signal \"trap\", appropriate for common\n// behavior expected from a vanilla unix command-line tool in general\n// (and the Docker engine in particular).\n//\n// * If SIGINT or SIGTERM are received, `cleanup` is called, then the process is terminated.\n// * If SIGINT or SIGTERM are repeated 3 times before cleanup is complete, then cleanup is\n// skipped and the process terminated directly.\n// * If \"DEBUG\" is set in the environment, SIGQUIT causes an exit without cleanup.\n//\nfunc Trap(cleanup func()) {\n    c := make(chan os.Signal, 1)\n    signals := []os.Signal{os.Interrupt, syscall.SIGTERM}\n    if os.Getenv(\"DEBUG\") == \"\" {\n        signals = append(signals, syscall.SIGQUIT)\n    }\n    gosignal.Notify(c, signals...)\n    go func() {\n        interruptCount := uint32(0)\n        for sig := range c {\n            go func(sig os.Signal) {\n                log.Printf(\"Received signal '%v', starting shutdown of docker.../n\", sig)\n                switch sig {\n                case os.Interrupt, syscall.SIGTERM:\n                    // If the user really wants to interrupt, let him do so.\n                    if atomic.LoadUint32(&interruptCount) < 3 {\n                        atomic.AddUint32(&interruptCount, 1)\n                        // Initiate the cleanup only once\n                        if atomic.LoadUint32(&interruptCount) == 1 {\n                            // Call cleanup handler\n                            cleanup()\n                            os.Exit(0)\n                        } else {\n                            return\n                        }\n                    } else {\n                        log.Printf(\"Force shutdown of docker, interrupting cleanup/n\")\n                    }\n                case syscall.SIGQUIT:\n                }\n                os.Exit(128 + int(sig.(syscall.Signal)))\n            }(sig)\n        }\n    }()\n} \n```\n\n- 创建并设置一个channel，用于发送信号通知；\n- 定义signals数组变量，初始值为os.SIGINT, os.SIGTERM;若环境变量DEBUG为空的话，则添加os.SIGQUIT至signals数组；\n- 通过gosignal.Notify(c, signals...)中Notify函数来实现将接收到的signal信号传递给c。需要注意的是只有signals中被罗列出的信号才会被传递给c，其余信号会被直接忽略；\n- 创建一个goroutine来处理具体的signal信号，当信号类型为os.Interrupt或者syscall.SIGTERM时，执行传入Trap函数的具体执行方法，形参为cleanup(),实参为eng.Shutdown。\n\nShutdown()函数的定义位于[./docker/engine/engine.go](https://github.com/docker/docker/blob/v1.2.0/engine/engine.go#L153)，主要做的工作是为Docker Daemon的关闭做一些善后工作。\n\n**/engine/engine.go**\n\n```go\n// Shutdown permanently shuts down eng as follows:\n// - It refuses all new jobs, permanently.\n// - It waits for all active jobs to complete (with no timeout)\n// - It calls all shutdown handlers concurrently (if any)\n// - It returns when all handlers complete, or after 15 seconds,\n//    whichever happens first.\nfunc (eng *Engine) Shutdown() {\n    eng.l.Lock()\n    if eng.shutdown {\n        eng.l.Unlock()\n        return\n    }\n    eng.shutdown = true\n    eng.l.Unlock()\n    // We don't need to protect the rest with a lock, to allow\n    // for other calls to immediately fail with \"shutdown\" instead\n    // of hanging for 15 seconds.\n    // This requires all concurrent calls to check for shutdown, otherwise\n    // it might cause a race.\n    // Wait for all jobs to complete.\n    // Timeout after 5 seconds.\n    tasksDone := make(chan struct{})\n    go func() {\n        eng.tasks.Wait()\n        close(tasksDone)\n    }()\n    select {\n    case <-time.After(time.Second * 5):\n    case <-tasksDone:\n    }\n    // Call shutdown handlers, if any.\n    // Timeout after 10 seconds.\n    var wg sync.WaitGroup\n    for _, h := range eng.onShutdown {\n        wg.Add(1)\n        go func(h func()) {\n            defer wg.Done()\n            h()\n        }(h)\n    }\n    done := make(chan struct{})\n    go func() {\n        wg.Wait()\n        close(done)\n    }()\n    select {\n    case <-time.After(time.Second * 10):\n    case <-done:\n    }\n    return\n}\n```\n\n- Docker Daemon不再接收任何新的Job；\n- Docker Daemon等待所有存活的Job执行完毕；\n- Docker Daemon调用所有shutdown的处理方法；\n- 当所有的handler执行完毕，或者15秒之后，Shutdown()函数返回。\n\n由于在signal.Trap( eng.Shutdown )函数的具体实现中执行eng.Shutdown，在执行完eng.Shutdown之后，随即执行[os.Exit(0)](https://github.com/docker/docker/blob/v1.2.0/pkg/signal/trap.go#L41)，完成当前程序的立即退出。\n\n### （五）加载builtins\n\n**/docker/daemon.go**\n\n```go\nif err := builtins.Register(eng); err != nil {\n    log.Fatal(err)\n}\n```\n\n为engine注册多个Handler，以便后续在执行相应任务时，运行指定的Handler。\n\n这些Handler包括：\n\n- 网络初始化、\n- web API服务、\n- 事件查询、\n- 版本查看、\n- Docker Registry验证与搜索。\n\n**/builtins/builtins.go**\n\n```go\nfunc Register(eng *engine.Engine) error {\n    if err := daemon(eng); err != nil {\n        return err\n    }\n    if err := remote(eng); err != nil {\n        return err\n    }\n    if err := events.New().Install(eng); err != nil {\n        return err\n    }\n    if err := eng.Register(\"version\", dockerVersion); err != nil {\n        return err\n    }\n    return registry.NewService().Install(eng)\n}\n```\n\n#### 1、注册初始化网络驱动的Handler\n\ndaemon(eng)的实现过程，主要为eng对象注册了一个key为”init_networkdriver”的Handler，该Handler的值为bridge.InitDriver函数，代码如下：\n\n**/builtins/builtins.go**\n\n```go\nfunc daemon(eng *engine.Engine) error {\n    return eng.Register(\"init_networkdriver\", bridge.InitDriver)\n}\n```\n\n需要注意的是，向eng对象注册Handler，并不代表Handler的值函数会被直接运行，如bridge.InitDriver，并不会直接运行，而是将bridge.InitDriver的函数入口，写入eng的handlers属性中。\n\n**/daemon/networkdriver/bridge/driver.go**\n\n```go\nfunc InitDriver(job *engine.Job) engine.Status {\n    var (\n        network        *net.IPNet\n        enableIPTables = job.GetenvBool(\"EnableIptables\")\n        icc            = job.GetenvBool(\"InterContainerCommunication\")\n        ipForward      = job.GetenvBool(\"EnableIpForward\")\n        bridgeIP       = job.Getenv(\"BridgeIP\")\n    )\n \n    if defaultIP := job.Getenv(\"DefaultBindingIP\"); defaultIP != \"\" {\n        defaultBindingIP = net.ParseIP(defaultIP)\n    }\n \n    bridgeIface = job.Getenv(\"BridgeIface\")\n    usingDefaultBridge := false\n    if bridgeIface == \"\" {\n        usingDefaultBridge = true\n        bridgeIface = DefaultNetworkBridge\n    }\n \n    addr, err := networkdriver.GetIfaceAddr(bridgeIface)\n    if err != nil {\n        // If we're not using the default bridge, fail without trying to create it\n        if !usingDefaultBridge {\n            job.Logf(\"bridge not found: %s\", bridgeIface)\n            return job.Error(err)\n        }\n        // If the iface is not found, try to create it\n        job.Logf(\"creating new bridge for %s\", bridgeIface)\n        if err := createBridge(bridgeIP); err != nil {\n            return job.Error(err)\n        }\n \n        job.Logf(\"getting iface addr\")\n        addr, err = networkdriver.GetIfaceAddr(bridgeIface)\n        if err != nil {\n            return job.Error(err)\n        }\n        network = addr.(*net.IPNet)\n    } else {\n        network = addr.(*net.IPNet)\n        // validate that the bridge ip matches the ip specified by BridgeIP\n        if bridgeIP != \"\" {\n            bip, _, err := net.ParseCIDR(bridgeIP)\n            if err != nil {\n                return job.Error(err)\n            }\n            if !network.IP.Equal(bip) {\n                return job.Errorf(\"bridge ip (%s) does not match existing bridge configuration %s\", network.IP, bip)\n            }\n        }\n    }\n \n    // Configure iptables for link support\n    if enableIPTables {\n        if err := setupIPTables(addr, icc); err != nil {\n            return job.Error(err)\n        }\n    }\n \n    if ipForward {\n        // Enable IPv4 forwarding\n        if err := ioutil.WriteFile(\"/proc/sys/net/ipv4/ip_forward\", []byte{'1', '/n'}, 0644); err != nil {\n            job.Logf(\"WARNING: unable to enable IPv4 forwarding: %s/n\", err)\n        }\n    }\n \n    // We can always try removing the iptables\n    if err := iptables.RemoveExistingChain(\"DOCKER\"); err != nil {\n        return job.Error(err)\n    }\n \n    if enableIPTables {\n        chain, err := iptables.NewChain(\"DOCKER\", bridgeIface)\n        if err != nil {\n            return job.Error(err)\n        }\n        portmapper.SetIptablesChain(chain)\n    }\n \n    bridgeNetwork = network\n \n    // https://github.com/docker/docker/issues/2768\n    job.Eng.Hack_SetGlobalVar(\"httpapi.bridgeIP\", bridgeNetwork.IP)\n \n    for name, f := range map[string]engine.Handler{\n        \"allocate_interface\": Allocate,\n        \"release_interface\":  Release,\n        \"allocate_port\":      AllocatePort,\n        \"link\":               LinkContainers,\n    } {\n        if err := job.Eng.Register(name, f); err != nil {\n            return job.Error(err)\n        }\n    }\n    return engine.StatusOK\n}\n```\n\nBridge.InitDriver的作用：\n\n- 获取为Docker服务的网络设备的地址；\n- 创建指定IP地址的网桥；\n- 配置网络iptables规则；\n- 另外还为eng对象注册了多个Handler,如 ”allocate_interface”， ”release_interface”， ”allocate_port”，”link”。\n\n#### 2、注册API服务的Handler\n\nremote(eng)的实现过程，主要为eng对象注册了两个Handler，分别为”serveapi”与”acceptconnections”。代码实现如下：\n\n**/builtins/builtins.go**\n\n```go\nfunc remote(eng *engine.Engine) error {\n    if err := eng.Register(\"serveapi\", apiserver.ServeApi); err != nil {\n        return err\n    }\n    return eng.Register(\"acceptconnections\", apiserver.AcceptConnections)\n}\n```\n\n注册的两个Handler名称分别为”serveapi”与”acceptconnections”\n\n- ServeApi执行时，通过循环多种协议，创建出goroutine来配置指定的http.Server，最终为不同的协议请求服务；\n- AcceptConnections的实现主要是为了通知init守护进程，Docker Daemon已经启动完毕，可以让Docker Daemon进程接受请求。(守护进程)\n\n#### 3、注册events事件的Handler\n\nevents.New().Install(eng)的实现过程，为Docker注册了多个event事件，功能是给Docker用户提供API，使得用户可以通过这些API查看Docker内部的events信息，log信息以及subscribers_count信息。\n\n**/events/events.go**\n\n```go\ntype Events struct {\n    mu          sync.RWMutex\n    events      []*utils.JSONMessage\n    subscribers []listener\n}\nfunc New() *Events {\n    return &Events{\n        events: make([]*utils.JSONMessage, 0, eventsLimit),\n    }\n}\n// Install installs events public api in docker engine\nfunc (e *Events) Install(eng *engine.Engine) error {\n    // Here you should describe public interface\n    jobs := map[string]engine.Handler{\n        \"events\":            e.Get,\n        \"log\":               e.Log,\n        \"subscribers_count\": e.SubscribersCount,\n    }\n    for name, job := range jobs {\n        if err := eng.Register(name, job); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n```\n\n#### 4、注册版本的Handler\n\neng.Register(“version”,dockerVersion)的实现过程，向eng对象注册key为”version”，value为”dockerVersion”执行方法的Handler，dockerVersion的执行过程中，会向名为version的job的标准输出中写入Docker的版本，Docker API的版本，git版本，Go语言运行时版本以及操作系统等版本信息。\n\n**/builtins/builtins.go**\n\n```go\n// builtins jobs independent of any subsystem\nfunc dockerVersion(job *engine.Job) engine.Status {\n    v := &engine.Env{}\n    v.SetJson(\"Version\", dockerversion.VERSION)\n    v.SetJson(\"ApiVersion\", api.APIVERSION)\n    v.Set(\"GitCommit\", dockerversion.GITCOMMIT)\n    v.Set(\"GoVersion\", runtime.Version())\n    v.Set(\"Os\", runtime.GOOS)\n    v.Set(\"Arch\", runtime.GOARCH)\n    if kernelVersion, err := kernel.GetKernelVersion(); err == nil {\n        v.Set(\"KernelVersion\", kernelVersion.String())\n    }\n    if _, err := v.WriteTo(job.Stdout); err != nil {\n        return job.Error(err)\n    }\n    return engine.StatusOK\n}\n```\n\n#### 5、注册registry的Handler\n\nregistry.NewService().Install(eng)的实现过程位于[./docker/registry/service.go](https://github.com/docker/docker/blob/v1.2.0/registry/service.go#L25)，在eng对象对外暴露的API信息中添加docker registry的信息。当registry.NewService()成功被Install安装完毕的话，则有两个调用能够被eng使用：”auth”，向公有registry进行认证；”search”，在公有registry上搜索指定的镜像。\n\n**/registry/service.go**\n\n```go\n// NewService returns a new instance of Service ready to be\n// installed no an engine.\nfunc NewService() *Service {\n    return &Service{}\n}\n// Install installs registry capabilities to eng.\nfunc (s *Service) Install(eng *engine.Engine) error {\n    eng.Register(\"auth\", s.Auth)\n    eng.Register(\"search\", s.Search)\n    return nil\n}\n```\n\n### （六）使用goroutine加载daemon对象\n\n执行完builtins的加载，回到mainDaemon()的执行，通过一个goroutine来加载daemon对象并开始运行。这一环节的执行，主要包含三个步骤：\n\n- 通过init函数中初始化的daemonCfg与eng对象来创建一个daemon对象d；(守护进程)\n- 通过daemon对象的Install函数，向eng对象中注册众多的Handler；\n- 在Docker Daemon启动完毕之后，运行名为”acceptconnections”的job，主要工作为向init守护进程发送”READY=1”信号，以便开始正常接受请求。\n\n**/docker/daemon.go**\n\n```go\n// load the daemon in the background so we can immediately start\n// the http api so that connections don't fail while the daemon\n// is booting\ngo func() {\n    d, err := daemon.NewDaemon(daemonCfg, eng)\n    if err != nil {\n        log.Fatal(err)\n    }\n    if err := d.Install(eng); err != nil {\n        log.Fatal(err)\n    }\n    // after the daemon is done setting up we can tell the api to start\n    // accepting connections\n    if err := eng.Job(\"acceptconnections\").Run(); err != nil {\n        log.Fatal(err)\n    }\n}()\n```\n\n#### 1、创建daemon对象\n\n**/docker/daemon.go**\n\n```go\nd, err := daemon.NewDaemon(daemonCfg, eng)\nif err != nil {\n    log.Fatal(err)\n}\n```\n\ndaemon.NewDaemon(daemonCfg, eng)是创建daemon对象d的核心部分。主要作用为初始化Docker Daemon的基本环境，如处理config参数，验证系统支持度，配置Docker工作目录，设置与加载多种driver，创建graph环境等，验证DNS配置等。具体参考[NewDaemon](http://wiki.haplat.net/display/~huwh/NewDaemon) 。\n\n#### 2、通过daemon对象为engine注册Handler\n\n当创建完daemon对象，goroutine执行d.Install(eng)\n\n**/daemon/daemon.go**\n\n```go\ntype Daemon struct {\n    repository     string\n    sysInitPath    string\n    containers     *contStore\n    graph          *graph.Graph\n    repositories   *graph.TagStore\n    idIndex        *truncindex.TruncIndex\n    sysInfo        *sysinfo.SysInfo\n    volumes        *graph.Graph\n    eng            *engine.Engine\n    config         *Config\n    containerGraph *graphdb.Database\n    driver         graphdriver.Driver\n    execDriver     execdriver.Driver\n}\n// Install installs daemon capabilities to eng.\nfunc (daemon *Daemon) Install(eng *engine.Engine) error {\n    // FIXME: rename \"delete\" to \"rm\" for consistency with the CLI command\n    // FIXME: rename ContainerDestroy to ContainerRm for consistency with the CLI command\n    // FIXME: remove ImageDelete's dependency on Daemon, then move to graph/\n    for name, method := range map[string]engine.Handler{\n        \"attach\":            daemon.ContainerAttach,\n        \"build\":             daemon.CmdBuild,\n        \"commit\":            daemon.ContainerCommit,\n        \"container_changes\": daemon.ContainerChanges,\n        \"container_copy\":    daemon.ContainerCopy,\n        \"container_inspect\": daemon.ContainerInspect,\n        \"containers\":        daemon.Containers,\n        \"create\":            daemon.ContainerCreate,\n        \"delete\":            daemon.ContainerDestroy,\n        \"export\":            daemon.ContainerExport,\n        \"info\":              daemon.CmdInfo,\n        \"kill\":              daemon.ContainerKill,\n        \"logs\":              daemon.ContainerLogs,\n        \"pause\":             daemon.ContainerPause,\n        \"resize\":            daemon.ContainerResize,\n        \"restart\":           daemon.ContainerRestart,\n        \"start\":             daemon.ContainerStart,\n        \"stop\":              daemon.ContainerStop,\n        \"top\":               daemon.ContainerTop,\n        \"unpause\":           daemon.ContainerUnpause,\n        \"wait\":              daemon.ContainerWait,\n        \"image_delete\":      daemon.ImageDelete, // FIXME: see above\n    } {\n        if err := eng.Register(name, method); err != nil {\n            return err\n        }\n    }\n    if err := daemon.Repositories().Install(eng); err != nil {\n        return err\n    }\n    // FIXME: this hack is necessary for legacy integration tests to access\n    // the daemon object.\n    eng.Hack_SetGlobalVar(\"httpapi.daemon\", daemon)\n    return nil\n}\n```\n\n以上代码的实现分为三部分：\n\n- 向eng对象中注册众多的Handler对象；\n- daemon.Repositories().Install(eng)实现了向eng对象注册多个与image相关的Handler，Install的实现位于[./docker/graph/service.go](https://github.com/docker/docker/blob/v1.2.0/graph/service.go#L12)；\n- eng.Hack_SetGlobalVar(\"httpapi.daemon\", daemon)实现向eng对象中map类型的hack对象中添加一条记录，key为”httpapi.daemon”，value为daemon。\n\n#### 3、运行acceptconnections的job\n\n**/docker/daemon.go**\n\n```go\nif err := eng.Job(\"acceptconnections\").Run(); err != nil {\n    log.Fatal(err)\n}\n```\n\n在goroutine内部最后运行名为”acceptconnections”的job，主要作用是通知init守护进程，Docker Daemon可以开始接受请求了。\n\n首先执行eng.Job(\"acceptconnections\")，返回一个Job，随后再执行eng.Job(\"acceptconnections\").Run()，也就是该执行Job的run函数。\n\n**/engine/engine.go**\n\n```go\n// Job creates a new job which can later be executed.\n// This function mimics `Command` from the standard os/exec package.\nfunc (eng *Engine) Job(name string, args ...string) *Job {\n    job := &Job{\n        Eng:    eng,\n        Name:   name,\n        Args:   args,\n        Stdin:  NewInput(),\n        Stdout: NewOutput(),\n        Stderr: NewOutput(),\n        env:    &Env{},\n    }\n    if eng.Logging {\n        job.Stderr.Add(utils.NopWriteCloser(eng.Stderr))\n    }\n    // Catchall is shadowed by specific Register.\n    if handler, exists := eng.handlers[name]; exists {\n        job.handler = handler\n    } else if eng.catchall != nil && name != \"\" {\n        // empty job names are illegal, catchall or not.\n        job.handler = eng.catchall\n    }\n    return job\n} \n```\n\n1. 首先创建一个类型为Job的job对象，该对象中Eng属性为函数的调用者eng，Name属性为”acceptconnections”，没有参数传入。\n2. 另外在eng对象所有的handlers属性中寻找键为”acceptconnections”记录的值，由于在加载builtins操作中的remote(eng)中已经向eng注册过这样的一条记录，key为”acceptconnections”，value为apiserver.AcceptConnections。\n3. 因此job对象的handler为apiserver.AcceptConnections。\n4. 最后返回已经初始化完毕的对象job。\n\n创建完job对象之后，随即执行该job对象的run()函数。\n\n**/engine/job.go**\n\n```go\n// A job is the fundamental unit of work in the docker engine.\n// Everything docker can do should eventually be exposed as a job.\n// For example: execute a process in a container, create a new container,\n// download an archive from the internet, serve the http api, etc.\n//\n// The job API is designed after unix processes: a job has a name, arguments,\n// environment variables, standard streams for input, output and error, and\n// an exit status which can indicate success (0) or error (anything else).\n//\n// One slight variation is that jobs report their status as a string. The\n// string \"0\" indicates success, and any other strings indicates an error.\n// This allows for richer error reporting.\n//\ntype Job struct {\n    Eng     *Engine\n    Name    string\n    Args    []string\n    env     *Env\n    Stdout  *Output\n    Stderr  *Output\n    Stdin   *Input\n    handler Handler\n    status  Status\n    end     time.Time\n}\ntype Status int\nconst (\n    StatusOK       Status = 0\n    StatusErr      Status = 1\n    StatusNotFound Status = 127\n)\n// Run executes the job and blocks until the job completes.\n// If the job returns a failure status, an error is returned\n// which includes the status.\nfunc (job *Job) Run() error {\n    if job.Eng.IsShutdown() {\n        return fmt.Errorf(\"engine is shutdown\")\n    }\n    // FIXME: this is a temporary workaround to avoid Engine.Shutdown\n    // waiting 5 seconds for server/api.ServeApi to complete (which it never will)\n    // everytime the daemon is cleanly restarted.\n    // The permanent fix is to implement Job.Stop and Job.OnStop so that\n    // ServeApi can cooperate and terminate cleanly.\n    if job.Name != \"serveapi\" {\n        job.Eng.l.Lock()\n        job.Eng.tasks.Add(1)\n        job.Eng.l.Unlock()\n        defer job.Eng.tasks.Done()\n    }\n    // FIXME: make this thread-safe\n    // FIXME: implement wait\n    if !job.end.IsZero() {\n        return fmt.Errorf(\"%s: job has already completed\", job.Name)\n    }\n    // Log beginning and end of the job\n    job.Eng.Logf(\"+job %s\", job.CallString())\n    defer func() {\n        job.Eng.Logf(\"-job %s%s\", job.CallString(), job.StatusString())\n    }()\n    var errorMessage = bytes.NewBuffer(nil)\n    job.Stderr.Add(errorMessage)\n    if job.handler == nil {\n        job.Errorf(\"%s: command not found\", job.Name)\n        job.status = 127\n    } else {\n        job.status = job.handler(job)\n        job.end = time.Now()\n    }\n    // Wait for all background tasks to complete\n    if err := job.Stdout.Close(); err != nil {\n        return err\n    }\n    if err := job.Stderr.Close(); err != nil {\n        return err\n    }\n    if err := job.Stdin.Close(); err != nil {\n        return err\n    }\n    if job.status != 0 {\n        return fmt.Errorf(\"%s\", Tail(errorMessage, 1))\n    }\n    return nil\n}\n```\n\nRun()函数的实现位于[./docker/engine/job.go](https://github.com/docker/docker/blob/v1.2.0/engine/job.go#L48)，该函数执行指定的job，并在job执行完成前一直阻塞。对于名为”acceptconnections”的job对象，运行代码为[job.status = job.handler(job)](https://github.com/docker/docker/blob/v1.2.0/engine/job.go#L79)，由于job.handler值为apiserver.AcceptConnections，故真正执行的是job.status = apiserver.AcceptConnections(job)。\n\n进入AcceptConnections的具体实现，位于[./docker/api/server/server.go](https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1370),如下：\n\n**/api/server/server.go**\n\n```go\nfunc AcceptConnections(job *engine.Job) engine.Status {\n    // Tell the init daemon we are accepting requests\n    go  systemd.SdNotify(\"READY=1\")\n    if activationLock != nil {\n        close(activationLock)\n    }\n    return engine.StatusOK\n}\n```\n\n重点为go systemd.SdNotify(\"READY=1\")的实现，位于[./docker/pkg/system/sd_notify.go](https://github.com/docker/docker/blob/v1.2.0/pkg/systemd/sd_notify.go#L12)，主要作用是通知init守护进程Docker Daemon的启动已经全部完成，潜在的功能是使得Docker Daemon开始接受Docker Client发送来的API请求。\n\n至此，已经完成通过goroutine来加载daemon对象并运行。\n\n### （七）打印Docker版本及驱动信息\n\n显示docker的版本信息，以及ExecDriver和GraphDriver这两个驱动的具体信息\n\n**/docker/daemon.go**\n\n```go\n// TODO actually have a resolved graphdriver to show?\nlog.Printf(\"docker daemon: %s %s; execdriver: %s; graphdriver: %s\",\n    dockerversion.VERSION,\n    dockerversion.GITCOMMIT,\n    daemonCfg.ExecDriver,\n    daemonCfg.GraphDriver,\n)\n```\n\n### （八）serveapi的创建与运行\n\n打印部分Docker具体信息之后，Docker Daemon立即创建并运行名为”serveapi”的job，主要作用为让Docker Daemon提供API访问服务。\n\n**/docker/daemon.go**\n\n```go\n// Serve api\njob := eng.Job(\"serveapi\", flHosts...)\njob.SetenvBool(\"Logging\", true)\njob.SetenvBool(\"EnableCors\", *flEnableCors)\njob.Setenv(\"Version\", dockerversion.VERSION)\njob.Setenv(\"SocketGroup\", *flSocketGroup)\njob.SetenvBool(\"Tls\", *flTls)\njob.SetenvBool(\"TlsVerify\", *flTlsVerify)\njob.Setenv(\"TlsCa\", *flCa)\njob.Setenv(\"TlsCert\", *flCert)\njob.Setenv(\"TlsKey\", *flKey)\njob.SetenvBool(\"BufferRequests\", true)\nif err := job.Run(); err != nil {\n    log.Fatal(err)\n}\n```\n\n1. 创建一个名为”serveapi”的job，并将flHosts的值赋给job.Args。flHost的作用主要是为Docker Daemon提供使用的协议与监听的地址。\n2. Docker Daemon为该job设置了众多的环境变量，如安全传输层协议的环境变量等。最后通过job.Run()运行该serveapi的job。\n\n由于在eng中key为”serveapi”的handler，value为apiserver.ServeApi，故该job运行时，执行apiserver.ServeApi函数，位于[./docker/api/server/server.go](https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1339)。ServeApi函数的作用主要是对于用户定义的所有支持协议，Docker Daemon均创建一个goroutine来启动相应的http.Server，分别为不同的协议服务。具体参考[Docker Server](http://wiki.haplat.net/display/~huwh/Docker+Server)。\n\n ","source":"_posts/Docker/Docker源码/Docker源码分析（二）之Docker Daemon.md","raw":"---\ntitle: \"[Docker] Docker源码分析（二）之Docker Daemon\"\ncatalog: true\ndate: 2017-07-09 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Docker\ncatagories:\n- Docker\n---\n\n## 一、Docker Daemon架构示意图\n\n![Daemon架构图](/img/article/docker/docker源码之Docker-Daemon/Daemon架构图.jpg)\n\nDocker Daemon是Docker架构中运行在后台的守护进程，大致可以分为Docker Server、Engine和Job三部分。\n\nDocker Daemon可以认为是通过Docker Server模块接受Docker Client的请求，并在Engine中处理请求，然后根据请求类型，创建出指定的Job并运行。\n\n运行过程的作用有以下几种可能：\n\n- 向Docker Registry获取镜像，\n- 通过graphdriver执行容器镜像的本地化操作，\n- 通过networkdriver执行容器网络环境的配置，\n- 通过execdriver执行容器内部运行的执行工作等。\n\n说明：本文分析的代码为Docker 1.2.0版本。\n\n## 二、Docker Daemon启动流程图\n\n![Daemon启动流程](/img/article/docker/docker源码之Docker-Daemon/Daemon启动流程.jpg)\n\n启动Docker Daemon时，一般可以使用以下命令：docker --daemon=true; docker –d; docker –d=true等。接着由docker的main()函数来解析以上命令的相应flag参数，并最终完成Docker Daemon的启动。\n\n**/docker/docker.go**\n\n```go\nfunc main() {\n    ...\n    if *flDaemon {\n        mainDaemon()\n        return\n    }\n    ...\n}\n```\n\n## 三、mainDaemon的具体实现\n\n宏观来讲，mainDaemon()完成创建一个daemon进程，并使其正常运行。\n\n从功能的角度来说，mainDaemon()实现了两部分内容：\n\n- 第一，创建Docker运行环境；\n- 第二，服务于Docker Client，接收并处理相应请求。\n\n### （一）配置初始化\n\n**/docker/daemon.go**\n\n```go\nvar (\n    daemonCfg = &daemon.Config{}\n)\nfunc init() {\n    daemonCfg.InstallFlags()\n}\n```\n\n在mainDaemon()运行之前，关于Docker Daemon所需要的config配置信息均已经初始化完毕。\n\n声明一个为daemon包中Config类型的变量，名为daemonCfg。而Config对象，定义了Docker Daemon所需的配置信息。在Docker Daemon在启动时，daemonCfg变量被传递至Docker Daemon并被使用。\n\n**/daemon/config.go**\n\n```go\ntype Config struct {\n    Pidfile                  string   //Docker Daemon所属进程的PID文件\n    Root                   string   //Docker运行时所使用的root路径\n    AutoRestart             bool    //已被启用，转而支持docker run时的重启\n    Dns                   []string  //Docker使用的DNS Server地址\n    DnsSearch              []string  //Docker使用的指定的DNS查找域名\n    Mirrors                 []string  //指定的优先Docker Registry镜像\n    EnableIptables           bool    //启用Docker的iptables功能\n    EnableIpForward         bool    //启用net.ipv4.ip_forward功能\n    EnableIpMasq            bool      //启用IP伪装技术\n    DefaultIp                net.IP     //绑定容器端口时使用的默认IP\n    BridgeIface              string      //添加容器网络至已有的网桥\n    BridgeIP                 string     //创建网桥的IP地址\n    FixedCIDR               string     //指定IP的IPv4子网，必须被网桥子网包含\n    InterContainerCommunication   bool  //是否允许相同host上容器间的通信\n    GraphDriver             string      //Docker运行时使用的特定存储驱动\n    GraphOptions            []string   //可设置的存储驱动选项\n    ExecDriver               string    // Docker运行时使用的特定exec驱动\n    Mtu                    int      //设置容器网络的MTU\n    DisableNetwork          bool     //有定义，之后未初始化\n    EnableSelinuxSupport      bool     //启用SELinux功能的支持\n    Context                 map[string][]string   //有定义，之后未初始化\n}\n```\n\ninit()函数实现了daemonCfg变量中各属性的赋值，具体的实现为：daemonCfg.InstallFlags()\n\n**/daemon/config.go**\n\n```go\n// InstallFlags adds command-line options to the top-level flag parser for\n// the current process.\n// Subsequent calls to `flag.Parse` will populate config with values parsed\n// from the command-line.\nfunc (config *Config) InstallFlags() {\n    flag.StringVar(&config.Pidfile, []string{\"p\", \"-pidfile\"}, \"/var/run/docker.pid\", \"Path to use for daemon PID file\")\n    flag.StringVar(&config.Root, []string{\"g\", \"-graph\"}, \"/var/lib/docker\", \"Path to use as the root of the Docker runtime\")\n    flag.BoolVar(&config.AutoRestart, []string{\"#r\", \"#-restart\"}, true, \"--restart on the daemon has been deprecated infavor of --restart policies on docker run\")\n    flag.BoolVar(&config.EnableIptables, []string{\"#iptables\", \"-iptables\"}, true, \"Enable Docker's addition of iptables rules\")\n    flag.BoolVar(&config.EnableIpForward, []string{\"#ip-forward\", \"-ip-forward\"}, true, \"Enable net.ipv4.ip_forward\")\n    flag.StringVar(&config.BridgeIP, []string{\"#bip\", \"-bip\"}, \"\", \"Use this CIDR notation address for the network bridge's IP, not compatible with -b\")\n    flag.StringVar(&config.BridgeIface, []string{\"b\", \"-bridge\"}, \"\", \"Attach containers to a pre-existing network bridge/nuse 'none' to disable container networking\")\n    flag.BoolVar(&config.InterContainerCommunication, []string{\"#icc\", \"-icc\"}, true, \"Enable inter-container communication\")\n    flag.StringVar(&config.GraphDriver, []string{\"s\", \"-storage-driver\"}, \"\", \"Force the Docker runtime to use a specific storage driver\")\n    flag.StringVar(&config.ExecDriver, []string{\"e\", \"-exec-driver\"}, \"native\", \"Force the Docker runtime to use a specific exec driver\")\n    flag.BoolVar(&config.EnableSelinuxSupport, []string{\"-selinux-enabled\"}, false, \"Enable selinux support. SELinux does not presently support the BTRFS storage driver\")\n    flag.IntVar(&config.Mtu, []string{\"#mtu\", \"-mtu\"}, 0, \"Set the containers network MTU/nif no value is provided: default to the default route MTU or 1500 if no default route is available\")\n    opts.IPVar(&config.DefaultIp, []string{\"#ip\", \"-ip\"}, \"0.0.0.0\", \"Default IP address to use when binding container ports\")\n    opts.ListVar(&config.GraphOptions, []string{\"-storage-opt\"}, \"Set storage driver options\")\n    // FIXME: why the inconsistency between \"hosts\" and \"sockets\"?\n    opts.IPListVar(&config.Dns, []string{\"#dns\", \"-dns\"}, \"Force Docker to use specific DNS servers\")\n    opts.DnsSearchListVar(&config.DnsSearch, []string{\"-dns-search\"}, \"Force Docker to use specific DNS search domains\")\n}\n```\n\n在InstallFlags()函数的实现过程中，主要是定义某种类型的flag参数，并将该参数的值绑定在config变量的指定属性上，如：\n\nflag.StringVar(&config.Pidfile, []string{\"p\", \"-pidfile\"}, \" /var/run/docker.pid\", \"Path to use for daemon PID file\")\n\n以上语句的含义为：\n\n- 定义一个为String类型的flag参数；\n- 该flag的名称为”p”或者”-pidfile”;\n- 该flag的值为” /var/run/docker.pid”,并将该值绑定在变量config.Pidfile上；\n- 该flag的描述信息为\"Path to use for daemon PID file\"。\n\n### （二）flag参数检查\n\n**/docker/daemon.go**\n\n```go\nif flag.NArg() != 0 {\n    flag.Usage()\n    return\n}\n```\n\n- 参数个数不为0，则说明在启动Docker Daemon的时候，传入了多余的参数，此时会输出错误提示，并退出运行程序。\n- 若为0，则说明Docker Daemon的启动命令无误，正常运行。\n\n### （三）创建engine对象\n\n**/docker/daemon.go**\n\n```go\neng := engine.New()\n```\n\nEngine是Docker架构中的运行引擎，同时也是Docker运行的核心模块。Engine扮演着Docker container存储仓库的角色，并且通过job的形式来管理这些容器。\n\n**/engine/engine.go**\n\n```go\ntype Engine struct {\n    handlers   map[string]Handler\n    catchall   Handler\n    hack       Hack // data for temporary hackery (see hack.go)\n    id         string\n    Stdout     io.Writer\n    Stderr     io.Writer\n    Stdin      io.Reader\n    Logging    bool\n    tasks      sync.WaitGroup\n    l          sync.RWMutex // lock for shutdown\n    shutdown   bool\n    onShutdown []func() // shutdown handlers\n}\n```\n\nEngine结构体中最为重要的即为handlers属性。该handlers属性为map类型，key为string类型，value为Handler类型。Handler为一个定义的函数。该函数传入的参数为Job指针，返回为Status状态。\n\n**/engine/engine.go**\n\n```go\ntype Handler func(*Job) Status\n```\n\nNew()函数的实现:\n\n**/engine/engine.go**\n\n```go\n// New initializes a new engine.\nfunc New() *Engine {\n    eng := &Engine{\n        handlers: make(map[string]Handler),\n        id:       utils.RandomString(),\n        Stdout:   os.Stdout,\n        Stderr:   os.Stderr,\n        Stdin:    os.Stdin,\n        Logging:  true,\n    }\n    eng.Register(\"commands\", func(job *Job) Status {\n        for _, name := range eng.commands() {\n            job.Printf(\"%s/n\", name)\n        }\n        return StatusOK\n    })\n    // Copy existing global handlers\n    for k, v := range globalHandlers {\n        eng.handlers[k] = v\n    }\n    return eng\n}\n```\n\n1. 创建一个Engine结构体实例eng\n2. 向eng对象注册名为commands的Handler，其中Handler为临时定义的函数func(job *Job) Status{ } , 该函数的作用是通过job来打印所有已经注册完毕的command名称，最终返回状态StatusOK。\n3. 将已定义的变量globalHandlers中的所有的Handler，都复制到eng对象的handlers属性中。最后成功返回eng对象。\n\n### （四）设置engine的信号捕获\n\n**/daemon/daemon.go**\n\n```go\nsignal.Trap(eng.Shutdown)\n```\n\n在Docker Daemon的运行中，设置Trap特定信号的处理方法，特定信号有SIGINT，SIGTERM以及SIGQUIT；当程序捕获到SIGINT或者SIGTERM信号时，执行相应的善后操作，最后保证Docker Daemon程序退出。\n\n**/pkg/signal/trap.go**\n\n```go\n//Trap sets up a simplified signal \"trap\", appropriate for common\n// behavior expected from a vanilla unix command-line tool in general\n// (and the Docker engine in particular).\n//\n// * If SIGINT or SIGTERM are received, `cleanup` is called, then the process is terminated.\n// * If SIGINT or SIGTERM are repeated 3 times before cleanup is complete, then cleanup is\n// skipped and the process terminated directly.\n// * If \"DEBUG\" is set in the environment, SIGQUIT causes an exit without cleanup.\n//\nfunc Trap(cleanup func()) {\n    c := make(chan os.Signal, 1)\n    signals := []os.Signal{os.Interrupt, syscall.SIGTERM}\n    if os.Getenv(\"DEBUG\") == \"\" {\n        signals = append(signals, syscall.SIGQUIT)\n    }\n    gosignal.Notify(c, signals...)\n    go func() {\n        interruptCount := uint32(0)\n        for sig := range c {\n            go func(sig os.Signal) {\n                log.Printf(\"Received signal '%v', starting shutdown of docker.../n\", sig)\n                switch sig {\n                case os.Interrupt, syscall.SIGTERM:\n                    // If the user really wants to interrupt, let him do so.\n                    if atomic.LoadUint32(&interruptCount) < 3 {\n                        atomic.AddUint32(&interruptCount, 1)\n                        // Initiate the cleanup only once\n                        if atomic.LoadUint32(&interruptCount) == 1 {\n                            // Call cleanup handler\n                            cleanup()\n                            os.Exit(0)\n                        } else {\n                            return\n                        }\n                    } else {\n                        log.Printf(\"Force shutdown of docker, interrupting cleanup/n\")\n                    }\n                case syscall.SIGQUIT:\n                }\n                os.Exit(128 + int(sig.(syscall.Signal)))\n            }(sig)\n        }\n    }()\n} \n```\n\n- 创建并设置一个channel，用于发送信号通知；\n- 定义signals数组变量，初始值为os.SIGINT, os.SIGTERM;若环境变量DEBUG为空的话，则添加os.SIGQUIT至signals数组；\n- 通过gosignal.Notify(c, signals...)中Notify函数来实现将接收到的signal信号传递给c。需要注意的是只有signals中被罗列出的信号才会被传递给c，其余信号会被直接忽略；\n- 创建一个goroutine来处理具体的signal信号，当信号类型为os.Interrupt或者syscall.SIGTERM时，执行传入Trap函数的具体执行方法，形参为cleanup(),实参为eng.Shutdown。\n\nShutdown()函数的定义位于[./docker/engine/engine.go](https://github.com/docker/docker/blob/v1.2.0/engine/engine.go#L153)，主要做的工作是为Docker Daemon的关闭做一些善后工作。\n\n**/engine/engine.go**\n\n```go\n// Shutdown permanently shuts down eng as follows:\n// - It refuses all new jobs, permanently.\n// - It waits for all active jobs to complete (with no timeout)\n// - It calls all shutdown handlers concurrently (if any)\n// - It returns when all handlers complete, or after 15 seconds,\n//    whichever happens first.\nfunc (eng *Engine) Shutdown() {\n    eng.l.Lock()\n    if eng.shutdown {\n        eng.l.Unlock()\n        return\n    }\n    eng.shutdown = true\n    eng.l.Unlock()\n    // We don't need to protect the rest with a lock, to allow\n    // for other calls to immediately fail with \"shutdown\" instead\n    // of hanging for 15 seconds.\n    // This requires all concurrent calls to check for shutdown, otherwise\n    // it might cause a race.\n    // Wait for all jobs to complete.\n    // Timeout after 5 seconds.\n    tasksDone := make(chan struct{})\n    go func() {\n        eng.tasks.Wait()\n        close(tasksDone)\n    }()\n    select {\n    case <-time.After(time.Second * 5):\n    case <-tasksDone:\n    }\n    // Call shutdown handlers, if any.\n    // Timeout after 10 seconds.\n    var wg sync.WaitGroup\n    for _, h := range eng.onShutdown {\n        wg.Add(1)\n        go func(h func()) {\n            defer wg.Done()\n            h()\n        }(h)\n    }\n    done := make(chan struct{})\n    go func() {\n        wg.Wait()\n        close(done)\n    }()\n    select {\n    case <-time.After(time.Second * 10):\n    case <-done:\n    }\n    return\n}\n```\n\n- Docker Daemon不再接收任何新的Job；\n- Docker Daemon等待所有存活的Job执行完毕；\n- Docker Daemon调用所有shutdown的处理方法；\n- 当所有的handler执行完毕，或者15秒之后，Shutdown()函数返回。\n\n由于在signal.Trap( eng.Shutdown )函数的具体实现中执行eng.Shutdown，在执行完eng.Shutdown之后，随即执行[os.Exit(0)](https://github.com/docker/docker/blob/v1.2.0/pkg/signal/trap.go#L41)，完成当前程序的立即退出。\n\n### （五）加载builtins\n\n**/docker/daemon.go**\n\n```go\nif err := builtins.Register(eng); err != nil {\n    log.Fatal(err)\n}\n```\n\n为engine注册多个Handler，以便后续在执行相应任务时，运行指定的Handler。\n\n这些Handler包括：\n\n- 网络初始化、\n- web API服务、\n- 事件查询、\n- 版本查看、\n- Docker Registry验证与搜索。\n\n**/builtins/builtins.go**\n\n```go\nfunc Register(eng *engine.Engine) error {\n    if err := daemon(eng); err != nil {\n        return err\n    }\n    if err := remote(eng); err != nil {\n        return err\n    }\n    if err := events.New().Install(eng); err != nil {\n        return err\n    }\n    if err := eng.Register(\"version\", dockerVersion); err != nil {\n        return err\n    }\n    return registry.NewService().Install(eng)\n}\n```\n\n#### 1、注册初始化网络驱动的Handler\n\ndaemon(eng)的实现过程，主要为eng对象注册了一个key为”init_networkdriver”的Handler，该Handler的值为bridge.InitDriver函数，代码如下：\n\n**/builtins/builtins.go**\n\n```go\nfunc daemon(eng *engine.Engine) error {\n    return eng.Register(\"init_networkdriver\", bridge.InitDriver)\n}\n```\n\n需要注意的是，向eng对象注册Handler，并不代表Handler的值函数会被直接运行，如bridge.InitDriver，并不会直接运行，而是将bridge.InitDriver的函数入口，写入eng的handlers属性中。\n\n**/daemon/networkdriver/bridge/driver.go**\n\n```go\nfunc InitDriver(job *engine.Job) engine.Status {\n    var (\n        network        *net.IPNet\n        enableIPTables = job.GetenvBool(\"EnableIptables\")\n        icc            = job.GetenvBool(\"InterContainerCommunication\")\n        ipForward      = job.GetenvBool(\"EnableIpForward\")\n        bridgeIP       = job.Getenv(\"BridgeIP\")\n    )\n \n    if defaultIP := job.Getenv(\"DefaultBindingIP\"); defaultIP != \"\" {\n        defaultBindingIP = net.ParseIP(defaultIP)\n    }\n \n    bridgeIface = job.Getenv(\"BridgeIface\")\n    usingDefaultBridge := false\n    if bridgeIface == \"\" {\n        usingDefaultBridge = true\n        bridgeIface = DefaultNetworkBridge\n    }\n \n    addr, err := networkdriver.GetIfaceAddr(bridgeIface)\n    if err != nil {\n        // If we're not using the default bridge, fail without trying to create it\n        if !usingDefaultBridge {\n            job.Logf(\"bridge not found: %s\", bridgeIface)\n            return job.Error(err)\n        }\n        // If the iface is not found, try to create it\n        job.Logf(\"creating new bridge for %s\", bridgeIface)\n        if err := createBridge(bridgeIP); err != nil {\n            return job.Error(err)\n        }\n \n        job.Logf(\"getting iface addr\")\n        addr, err = networkdriver.GetIfaceAddr(bridgeIface)\n        if err != nil {\n            return job.Error(err)\n        }\n        network = addr.(*net.IPNet)\n    } else {\n        network = addr.(*net.IPNet)\n        // validate that the bridge ip matches the ip specified by BridgeIP\n        if bridgeIP != \"\" {\n            bip, _, err := net.ParseCIDR(bridgeIP)\n            if err != nil {\n                return job.Error(err)\n            }\n            if !network.IP.Equal(bip) {\n                return job.Errorf(\"bridge ip (%s) does not match existing bridge configuration %s\", network.IP, bip)\n            }\n        }\n    }\n \n    // Configure iptables for link support\n    if enableIPTables {\n        if err := setupIPTables(addr, icc); err != nil {\n            return job.Error(err)\n        }\n    }\n \n    if ipForward {\n        // Enable IPv4 forwarding\n        if err := ioutil.WriteFile(\"/proc/sys/net/ipv4/ip_forward\", []byte{'1', '/n'}, 0644); err != nil {\n            job.Logf(\"WARNING: unable to enable IPv4 forwarding: %s/n\", err)\n        }\n    }\n \n    // We can always try removing the iptables\n    if err := iptables.RemoveExistingChain(\"DOCKER\"); err != nil {\n        return job.Error(err)\n    }\n \n    if enableIPTables {\n        chain, err := iptables.NewChain(\"DOCKER\", bridgeIface)\n        if err != nil {\n            return job.Error(err)\n        }\n        portmapper.SetIptablesChain(chain)\n    }\n \n    bridgeNetwork = network\n \n    // https://github.com/docker/docker/issues/2768\n    job.Eng.Hack_SetGlobalVar(\"httpapi.bridgeIP\", bridgeNetwork.IP)\n \n    for name, f := range map[string]engine.Handler{\n        \"allocate_interface\": Allocate,\n        \"release_interface\":  Release,\n        \"allocate_port\":      AllocatePort,\n        \"link\":               LinkContainers,\n    } {\n        if err := job.Eng.Register(name, f); err != nil {\n            return job.Error(err)\n        }\n    }\n    return engine.StatusOK\n}\n```\n\nBridge.InitDriver的作用：\n\n- 获取为Docker服务的网络设备的地址；\n- 创建指定IP地址的网桥；\n- 配置网络iptables规则；\n- 另外还为eng对象注册了多个Handler,如 ”allocate_interface”， ”release_interface”， ”allocate_port”，”link”。\n\n#### 2、注册API服务的Handler\n\nremote(eng)的实现过程，主要为eng对象注册了两个Handler，分别为”serveapi”与”acceptconnections”。代码实现如下：\n\n**/builtins/builtins.go**\n\n```go\nfunc remote(eng *engine.Engine) error {\n    if err := eng.Register(\"serveapi\", apiserver.ServeApi); err != nil {\n        return err\n    }\n    return eng.Register(\"acceptconnections\", apiserver.AcceptConnections)\n}\n```\n\n注册的两个Handler名称分别为”serveapi”与”acceptconnections”\n\n- ServeApi执行时，通过循环多种协议，创建出goroutine来配置指定的http.Server，最终为不同的协议请求服务；\n- AcceptConnections的实现主要是为了通知init守护进程，Docker Daemon已经启动完毕，可以让Docker Daemon进程接受请求。(守护进程)\n\n#### 3、注册events事件的Handler\n\nevents.New().Install(eng)的实现过程，为Docker注册了多个event事件，功能是给Docker用户提供API，使得用户可以通过这些API查看Docker内部的events信息，log信息以及subscribers_count信息。\n\n**/events/events.go**\n\n```go\ntype Events struct {\n    mu          sync.RWMutex\n    events      []*utils.JSONMessage\n    subscribers []listener\n}\nfunc New() *Events {\n    return &Events{\n        events: make([]*utils.JSONMessage, 0, eventsLimit),\n    }\n}\n// Install installs events public api in docker engine\nfunc (e *Events) Install(eng *engine.Engine) error {\n    // Here you should describe public interface\n    jobs := map[string]engine.Handler{\n        \"events\":            e.Get,\n        \"log\":               e.Log,\n        \"subscribers_count\": e.SubscribersCount,\n    }\n    for name, job := range jobs {\n        if err := eng.Register(name, job); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n```\n\n#### 4、注册版本的Handler\n\neng.Register(“version”,dockerVersion)的实现过程，向eng对象注册key为”version”，value为”dockerVersion”执行方法的Handler，dockerVersion的执行过程中，会向名为version的job的标准输出中写入Docker的版本，Docker API的版本，git版本，Go语言运行时版本以及操作系统等版本信息。\n\n**/builtins/builtins.go**\n\n```go\n// builtins jobs independent of any subsystem\nfunc dockerVersion(job *engine.Job) engine.Status {\n    v := &engine.Env{}\n    v.SetJson(\"Version\", dockerversion.VERSION)\n    v.SetJson(\"ApiVersion\", api.APIVERSION)\n    v.Set(\"GitCommit\", dockerversion.GITCOMMIT)\n    v.Set(\"GoVersion\", runtime.Version())\n    v.Set(\"Os\", runtime.GOOS)\n    v.Set(\"Arch\", runtime.GOARCH)\n    if kernelVersion, err := kernel.GetKernelVersion(); err == nil {\n        v.Set(\"KernelVersion\", kernelVersion.String())\n    }\n    if _, err := v.WriteTo(job.Stdout); err != nil {\n        return job.Error(err)\n    }\n    return engine.StatusOK\n}\n```\n\n#### 5、注册registry的Handler\n\nregistry.NewService().Install(eng)的实现过程位于[./docker/registry/service.go](https://github.com/docker/docker/blob/v1.2.0/registry/service.go#L25)，在eng对象对外暴露的API信息中添加docker registry的信息。当registry.NewService()成功被Install安装完毕的话，则有两个调用能够被eng使用：”auth”，向公有registry进行认证；”search”，在公有registry上搜索指定的镜像。\n\n**/registry/service.go**\n\n```go\n// NewService returns a new instance of Service ready to be\n// installed no an engine.\nfunc NewService() *Service {\n    return &Service{}\n}\n// Install installs registry capabilities to eng.\nfunc (s *Service) Install(eng *engine.Engine) error {\n    eng.Register(\"auth\", s.Auth)\n    eng.Register(\"search\", s.Search)\n    return nil\n}\n```\n\n### （六）使用goroutine加载daemon对象\n\n执行完builtins的加载，回到mainDaemon()的执行，通过一个goroutine来加载daemon对象并开始运行。这一环节的执行，主要包含三个步骤：\n\n- 通过init函数中初始化的daemonCfg与eng对象来创建一个daemon对象d；(守护进程)\n- 通过daemon对象的Install函数，向eng对象中注册众多的Handler；\n- 在Docker Daemon启动完毕之后，运行名为”acceptconnections”的job，主要工作为向init守护进程发送”READY=1”信号，以便开始正常接受请求。\n\n**/docker/daemon.go**\n\n```go\n// load the daemon in the background so we can immediately start\n// the http api so that connections don't fail while the daemon\n// is booting\ngo func() {\n    d, err := daemon.NewDaemon(daemonCfg, eng)\n    if err != nil {\n        log.Fatal(err)\n    }\n    if err := d.Install(eng); err != nil {\n        log.Fatal(err)\n    }\n    // after the daemon is done setting up we can tell the api to start\n    // accepting connections\n    if err := eng.Job(\"acceptconnections\").Run(); err != nil {\n        log.Fatal(err)\n    }\n}()\n```\n\n#### 1、创建daemon对象\n\n**/docker/daemon.go**\n\n```go\nd, err := daemon.NewDaemon(daemonCfg, eng)\nif err != nil {\n    log.Fatal(err)\n}\n```\n\ndaemon.NewDaemon(daemonCfg, eng)是创建daemon对象d的核心部分。主要作用为初始化Docker Daemon的基本环境，如处理config参数，验证系统支持度，配置Docker工作目录，设置与加载多种driver，创建graph环境等，验证DNS配置等。具体参考[NewDaemon](http://wiki.haplat.net/display/~huwh/NewDaemon) 。\n\n#### 2、通过daemon对象为engine注册Handler\n\n当创建完daemon对象，goroutine执行d.Install(eng)\n\n**/daemon/daemon.go**\n\n```go\ntype Daemon struct {\n    repository     string\n    sysInitPath    string\n    containers     *contStore\n    graph          *graph.Graph\n    repositories   *graph.TagStore\n    idIndex        *truncindex.TruncIndex\n    sysInfo        *sysinfo.SysInfo\n    volumes        *graph.Graph\n    eng            *engine.Engine\n    config         *Config\n    containerGraph *graphdb.Database\n    driver         graphdriver.Driver\n    execDriver     execdriver.Driver\n}\n// Install installs daemon capabilities to eng.\nfunc (daemon *Daemon) Install(eng *engine.Engine) error {\n    // FIXME: rename \"delete\" to \"rm\" for consistency with the CLI command\n    // FIXME: rename ContainerDestroy to ContainerRm for consistency with the CLI command\n    // FIXME: remove ImageDelete's dependency on Daemon, then move to graph/\n    for name, method := range map[string]engine.Handler{\n        \"attach\":            daemon.ContainerAttach,\n        \"build\":             daemon.CmdBuild,\n        \"commit\":            daemon.ContainerCommit,\n        \"container_changes\": daemon.ContainerChanges,\n        \"container_copy\":    daemon.ContainerCopy,\n        \"container_inspect\": daemon.ContainerInspect,\n        \"containers\":        daemon.Containers,\n        \"create\":            daemon.ContainerCreate,\n        \"delete\":            daemon.ContainerDestroy,\n        \"export\":            daemon.ContainerExport,\n        \"info\":              daemon.CmdInfo,\n        \"kill\":              daemon.ContainerKill,\n        \"logs\":              daemon.ContainerLogs,\n        \"pause\":             daemon.ContainerPause,\n        \"resize\":            daemon.ContainerResize,\n        \"restart\":           daemon.ContainerRestart,\n        \"start\":             daemon.ContainerStart,\n        \"stop\":              daemon.ContainerStop,\n        \"top\":               daemon.ContainerTop,\n        \"unpause\":           daemon.ContainerUnpause,\n        \"wait\":              daemon.ContainerWait,\n        \"image_delete\":      daemon.ImageDelete, // FIXME: see above\n    } {\n        if err := eng.Register(name, method); err != nil {\n            return err\n        }\n    }\n    if err := daemon.Repositories().Install(eng); err != nil {\n        return err\n    }\n    // FIXME: this hack is necessary for legacy integration tests to access\n    // the daemon object.\n    eng.Hack_SetGlobalVar(\"httpapi.daemon\", daemon)\n    return nil\n}\n```\n\n以上代码的实现分为三部分：\n\n- 向eng对象中注册众多的Handler对象；\n- daemon.Repositories().Install(eng)实现了向eng对象注册多个与image相关的Handler，Install的实现位于[./docker/graph/service.go](https://github.com/docker/docker/blob/v1.2.0/graph/service.go#L12)；\n- eng.Hack_SetGlobalVar(\"httpapi.daemon\", daemon)实现向eng对象中map类型的hack对象中添加一条记录，key为”httpapi.daemon”，value为daemon。\n\n#### 3、运行acceptconnections的job\n\n**/docker/daemon.go**\n\n```go\nif err := eng.Job(\"acceptconnections\").Run(); err != nil {\n    log.Fatal(err)\n}\n```\n\n在goroutine内部最后运行名为”acceptconnections”的job，主要作用是通知init守护进程，Docker Daemon可以开始接受请求了。\n\n首先执行eng.Job(\"acceptconnections\")，返回一个Job，随后再执行eng.Job(\"acceptconnections\").Run()，也就是该执行Job的run函数。\n\n**/engine/engine.go**\n\n```go\n// Job creates a new job which can later be executed.\n// This function mimics `Command` from the standard os/exec package.\nfunc (eng *Engine) Job(name string, args ...string) *Job {\n    job := &Job{\n        Eng:    eng,\n        Name:   name,\n        Args:   args,\n        Stdin:  NewInput(),\n        Stdout: NewOutput(),\n        Stderr: NewOutput(),\n        env:    &Env{},\n    }\n    if eng.Logging {\n        job.Stderr.Add(utils.NopWriteCloser(eng.Stderr))\n    }\n    // Catchall is shadowed by specific Register.\n    if handler, exists := eng.handlers[name]; exists {\n        job.handler = handler\n    } else if eng.catchall != nil && name != \"\" {\n        // empty job names are illegal, catchall or not.\n        job.handler = eng.catchall\n    }\n    return job\n} \n```\n\n1. 首先创建一个类型为Job的job对象，该对象中Eng属性为函数的调用者eng，Name属性为”acceptconnections”，没有参数传入。\n2. 另外在eng对象所有的handlers属性中寻找键为”acceptconnections”记录的值，由于在加载builtins操作中的remote(eng)中已经向eng注册过这样的一条记录，key为”acceptconnections”，value为apiserver.AcceptConnections。\n3. 因此job对象的handler为apiserver.AcceptConnections。\n4. 最后返回已经初始化完毕的对象job。\n\n创建完job对象之后，随即执行该job对象的run()函数。\n\n**/engine/job.go**\n\n```go\n// A job is the fundamental unit of work in the docker engine.\n// Everything docker can do should eventually be exposed as a job.\n// For example: execute a process in a container, create a new container,\n// download an archive from the internet, serve the http api, etc.\n//\n// The job API is designed after unix processes: a job has a name, arguments,\n// environment variables, standard streams for input, output and error, and\n// an exit status which can indicate success (0) or error (anything else).\n//\n// One slight variation is that jobs report their status as a string. The\n// string \"0\" indicates success, and any other strings indicates an error.\n// This allows for richer error reporting.\n//\ntype Job struct {\n    Eng     *Engine\n    Name    string\n    Args    []string\n    env     *Env\n    Stdout  *Output\n    Stderr  *Output\n    Stdin   *Input\n    handler Handler\n    status  Status\n    end     time.Time\n}\ntype Status int\nconst (\n    StatusOK       Status = 0\n    StatusErr      Status = 1\n    StatusNotFound Status = 127\n)\n// Run executes the job and blocks until the job completes.\n// If the job returns a failure status, an error is returned\n// which includes the status.\nfunc (job *Job) Run() error {\n    if job.Eng.IsShutdown() {\n        return fmt.Errorf(\"engine is shutdown\")\n    }\n    // FIXME: this is a temporary workaround to avoid Engine.Shutdown\n    // waiting 5 seconds for server/api.ServeApi to complete (which it never will)\n    // everytime the daemon is cleanly restarted.\n    // The permanent fix is to implement Job.Stop and Job.OnStop so that\n    // ServeApi can cooperate and terminate cleanly.\n    if job.Name != \"serveapi\" {\n        job.Eng.l.Lock()\n        job.Eng.tasks.Add(1)\n        job.Eng.l.Unlock()\n        defer job.Eng.tasks.Done()\n    }\n    // FIXME: make this thread-safe\n    // FIXME: implement wait\n    if !job.end.IsZero() {\n        return fmt.Errorf(\"%s: job has already completed\", job.Name)\n    }\n    // Log beginning and end of the job\n    job.Eng.Logf(\"+job %s\", job.CallString())\n    defer func() {\n        job.Eng.Logf(\"-job %s%s\", job.CallString(), job.StatusString())\n    }()\n    var errorMessage = bytes.NewBuffer(nil)\n    job.Stderr.Add(errorMessage)\n    if job.handler == nil {\n        job.Errorf(\"%s: command not found\", job.Name)\n        job.status = 127\n    } else {\n        job.status = job.handler(job)\n        job.end = time.Now()\n    }\n    // Wait for all background tasks to complete\n    if err := job.Stdout.Close(); err != nil {\n        return err\n    }\n    if err := job.Stderr.Close(); err != nil {\n        return err\n    }\n    if err := job.Stdin.Close(); err != nil {\n        return err\n    }\n    if job.status != 0 {\n        return fmt.Errorf(\"%s\", Tail(errorMessage, 1))\n    }\n    return nil\n}\n```\n\nRun()函数的实现位于[./docker/engine/job.go](https://github.com/docker/docker/blob/v1.2.0/engine/job.go#L48)，该函数执行指定的job，并在job执行完成前一直阻塞。对于名为”acceptconnections”的job对象，运行代码为[job.status = job.handler(job)](https://github.com/docker/docker/blob/v1.2.0/engine/job.go#L79)，由于job.handler值为apiserver.AcceptConnections，故真正执行的是job.status = apiserver.AcceptConnections(job)。\n\n进入AcceptConnections的具体实现，位于[./docker/api/server/server.go](https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1370),如下：\n\n**/api/server/server.go**\n\n```go\nfunc AcceptConnections(job *engine.Job) engine.Status {\n    // Tell the init daemon we are accepting requests\n    go  systemd.SdNotify(\"READY=1\")\n    if activationLock != nil {\n        close(activationLock)\n    }\n    return engine.StatusOK\n}\n```\n\n重点为go systemd.SdNotify(\"READY=1\")的实现，位于[./docker/pkg/system/sd_notify.go](https://github.com/docker/docker/blob/v1.2.0/pkg/systemd/sd_notify.go#L12)，主要作用是通知init守护进程Docker Daemon的启动已经全部完成，潜在的功能是使得Docker Daemon开始接受Docker Client发送来的API请求。\n\n至此，已经完成通过goroutine来加载daemon对象并运行。\n\n### （七）打印Docker版本及驱动信息\n\n显示docker的版本信息，以及ExecDriver和GraphDriver这两个驱动的具体信息\n\n**/docker/daemon.go**\n\n```go\n// TODO actually have a resolved graphdriver to show?\nlog.Printf(\"docker daemon: %s %s; execdriver: %s; graphdriver: %s\",\n    dockerversion.VERSION,\n    dockerversion.GITCOMMIT,\n    daemonCfg.ExecDriver,\n    daemonCfg.GraphDriver,\n)\n```\n\n### （八）serveapi的创建与运行\n\n打印部分Docker具体信息之后，Docker Daemon立即创建并运行名为”serveapi”的job，主要作用为让Docker Daemon提供API访问服务。\n\n**/docker/daemon.go**\n\n```go\n// Serve api\njob := eng.Job(\"serveapi\", flHosts...)\njob.SetenvBool(\"Logging\", true)\njob.SetenvBool(\"EnableCors\", *flEnableCors)\njob.Setenv(\"Version\", dockerversion.VERSION)\njob.Setenv(\"SocketGroup\", *flSocketGroup)\njob.SetenvBool(\"Tls\", *flTls)\njob.SetenvBool(\"TlsVerify\", *flTlsVerify)\njob.Setenv(\"TlsCa\", *flCa)\njob.Setenv(\"TlsCert\", *flCert)\njob.Setenv(\"TlsKey\", *flKey)\njob.SetenvBool(\"BufferRequests\", true)\nif err := job.Run(); err != nil {\n    log.Fatal(err)\n}\n```\n\n1. 创建一个名为”serveapi”的job，并将flHosts的值赋给job.Args。flHost的作用主要是为Docker Daemon提供使用的协议与监听的地址。\n2. Docker Daemon为该job设置了众多的环境变量，如安全传输层协议的环境变量等。最后通过job.Run()运行该serveapi的job。\n\n由于在eng中key为”serveapi”的handler，value为apiserver.ServeApi，故该job运行时，执行apiserver.ServeApi函数，位于[./docker/api/server/server.go](https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1339)。ServeApi函数的作用主要是对于用户定义的所有支持协议，Docker Daemon均创建一个goroutine来启动相应的http.Server，分别为不同的协议服务。具体参考[Docker Server](http://wiki.haplat.net/display/~huwh/Docker+Server)。\n\n ","slug":"Docker/Docker源码/Docker源码分析（二）之Docker Daemon","published":1,"updated":"2017-10-02T08:42:41.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740jv000x30vu4qospztx","content":"<h2><span id=\"一-docker-daemon架构示意图\">一、Docker Daemon架构示意图</span></h2>\n<p><img src=\"/img/article/docker/docker%E6%BA%90%E7%A0%81%E4%B9%8BDocker-Daemon/Daemon%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg\" alt=\"Daemon架构图\"></p>\n<p>Docker Daemon是Docker架构中运行在后台的守护进程，大致可以分为Docker Server、Engine和Job三部分。</p>\n<p>Docker Daemon可以认为是通过Docker Server模块接受Docker Client的请求，并在Engine中处理请求，然后根据请求类型，创建出指定的Job并运行。</p>\n<p>运行过程的作用有以下几种可能：</p>\n<ul>\n<li>向Docker Registry获取镜像，</li>\n<li>通过graphdriver执行容器镜像的本地化操作，</li>\n<li>通过networkdriver执行容器网络环境的配置，</li>\n<li>通过execdriver执行容器内部运行的执行工作等。</li>\n</ul>\n<p>说明：本文分析的代码为Docker 1.2.0版本。</p>\n<h2><span id=\"二-docker-daemon启动流程图\">二、Docker Daemon启动流程图</span></h2>\n<p><img src=\"/img/article/docker/docker%E6%BA%90%E7%A0%81%E4%B9%8BDocker-Daemon/Daemon%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.jpg\" alt=\"Daemon启动流程\"></p>\n<p>启动Docker Daemon时，一般可以使用以下命令：docker --daemon=true; docker –d; docker –d=true等。接着由docker的main()函数来解析以上命令的相应flag参数，并最终完成Docker Daemon的启动。</p>\n<p><strong>/docker/docker.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">if</span> *flDaemon &#123;</div><div class=\"line\">        mainDaemon()</div><div class=\"line\">        <span class=\"keyword\">return</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2><span id=\"三-maindaemon的具体实现\">三、mainDaemon的具体实现</span></h2>\n<p>宏观来讲，mainDaemon()完成创建一个daemon进程，并使其正常运行。</p>\n<p>从功能的角度来说，mainDaemon()实现了两部分内容：</p>\n<ul>\n<li>第一，创建Docker运行环境；</li>\n<li>第二，服务于Docker Client，接收并处理相应请求。</li>\n</ul>\n<h3><span id=\"一配置初始化\">（一）配置初始化</span></h3>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> (</div><div class=\"line\">    daemonCfg = &amp;daemon.Config&#123;&#125;</div><div class=\"line\">)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    daemonCfg.InstallFlags()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在mainDaemon()运行之前，关于Docker Daemon所需要的config配置信息均已经初始化完毕。</p>\n<p>声明一个为daemon包中Config类型的变量，名为daemonCfg。而Config对象，定义了Docker Daemon所需的配置信息。在Docker Daemon在启动时，daemonCfg变量被传递至Docker Daemon并被使用。</p>\n<p><strong>/daemon/config.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Config <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    Pidfile                  <span class=\"keyword\">string</span>   <span class=\"comment\">//Docker Daemon所属进程的PID文件</span></div><div class=\"line\">    Root                   <span class=\"keyword\">string</span>   <span class=\"comment\">//Docker运行时所使用的root路径</span></div><div class=\"line\">    AutoRestart             <span class=\"keyword\">bool</span>    <span class=\"comment\">//已被启用，转而支持docker run时的重启</span></div><div class=\"line\">    Dns                   []<span class=\"keyword\">string</span>  <span class=\"comment\">//Docker使用的DNS Server地址</span></div><div class=\"line\">    DnsSearch              []<span class=\"keyword\">string</span>  <span class=\"comment\">//Docker使用的指定的DNS查找域名</span></div><div class=\"line\">    Mirrors                 []<span class=\"keyword\">string</span>  <span class=\"comment\">//指定的优先Docker Registry镜像</span></div><div class=\"line\">    EnableIptables           <span class=\"keyword\">bool</span>    <span class=\"comment\">//启用Docker的iptables功能</span></div><div class=\"line\">    EnableIpForward         <span class=\"keyword\">bool</span>    <span class=\"comment\">//启用net.ipv4.ip_forward功能</span></div><div class=\"line\">    EnableIpMasq            <span class=\"keyword\">bool</span>      <span class=\"comment\">//启用IP伪装技术</span></div><div class=\"line\">    DefaultIp                net.IP     <span class=\"comment\">//绑定容器端口时使用的默认IP</span></div><div class=\"line\">    BridgeIface              <span class=\"keyword\">string</span>      <span class=\"comment\">//添加容器网络至已有的网桥</span></div><div class=\"line\">    BridgeIP                 <span class=\"keyword\">string</span>     <span class=\"comment\">//创建网桥的IP地址</span></div><div class=\"line\">    FixedCIDR               <span class=\"keyword\">string</span>     <span class=\"comment\">//指定IP的IPv4子网，必须被网桥子网包含</span></div><div class=\"line\">    InterContainerCommunication   <span class=\"keyword\">bool</span>  <span class=\"comment\">//是否允许相同host上容器间的通信</span></div><div class=\"line\">    GraphDriver             <span class=\"keyword\">string</span>      <span class=\"comment\">//Docker运行时使用的特定存储驱动</span></div><div class=\"line\">    GraphOptions            []<span class=\"keyword\">string</span>   <span class=\"comment\">//可设置的存储驱动选项</span></div><div class=\"line\">    ExecDriver               <span class=\"keyword\">string</span>    <span class=\"comment\">// Docker运行时使用的特定exec驱动</span></div><div class=\"line\">    Mtu                    <span class=\"keyword\">int</span>      <span class=\"comment\">//设置容器网络的MTU</span></div><div class=\"line\">    DisableNetwork          <span class=\"keyword\">bool</span>     <span class=\"comment\">//有定义，之后未初始化</span></div><div class=\"line\">    EnableSelinuxSupport      <span class=\"keyword\">bool</span>     <span class=\"comment\">//启用SELinux功能的支持</span></div><div class=\"line\">    Context                 <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>][]<span class=\"keyword\">string</span>   <span class=\"comment\">//有定义，之后未初始化</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>init()函数实现了daemonCfg变量中各属性的赋值，具体的实现为：daemonCfg.InstallFlags()</p>\n<p><strong>/daemon/config.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// InstallFlags adds command-line options to the top-level flag parser for</span></div><div class=\"line\"><span class=\"comment\">// the current process.</span></div><div class=\"line\"><span class=\"comment\">// Subsequent calls to `flag.Parse` will populate config with values parsed</span></div><div class=\"line\"><span class=\"comment\">// from the command-line.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(config *Config)</span> <span class=\"title\">InstallFlags</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    flag.StringVar(&amp;config.Pidfile, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"p\"</span>, <span class=\"string\">\"-pidfile\"</span>&#125;, <span class=\"string\">\"/var/run/docker.pid\"</span>, <span class=\"string\">\"Path to use for daemon PID file\"</span>)</div><div class=\"line\">    flag.StringVar(&amp;config.Root, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"g\"</span>, <span class=\"string\">\"-graph\"</span>&#125;, <span class=\"string\">\"/var/lib/docker\"</span>, <span class=\"string\">\"Path to use as the root of the Docker runtime\"</span>)</div><div class=\"line\">    flag.BoolVar(&amp;config.AutoRestart, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#r\"</span>, <span class=\"string\">\"#-restart\"</span>&#125;, <span class=\"literal\">true</span>, <span class=\"string\">\"--restart on the daemon has been deprecated infavor of --restart policies on docker run\"</span>)</div><div class=\"line\">    flag.BoolVar(&amp;config.EnableIptables, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#iptables\"</span>, <span class=\"string\">\"-iptables\"</span>&#125;, <span class=\"literal\">true</span>, <span class=\"string\">\"Enable Docker's addition of iptables rules\"</span>)</div><div class=\"line\">    flag.BoolVar(&amp;config.EnableIpForward, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#ip-forward\"</span>, <span class=\"string\">\"-ip-forward\"</span>&#125;, <span class=\"literal\">true</span>, <span class=\"string\">\"Enable net.ipv4.ip_forward\"</span>)</div><div class=\"line\">    flag.StringVar(&amp;config.BridgeIP, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#bip\"</span>, <span class=\"string\">\"-bip\"</span>&#125;, <span class=\"string\">\"\"</span>, <span class=\"string\">\"Use this CIDR notation address for the network bridge's IP, not compatible with -b\"</span>)</div><div class=\"line\">    flag.StringVar(&amp;config.BridgeIface, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"b\"</span>, <span class=\"string\">\"-bridge\"</span>&#125;, <span class=\"string\">\"\"</span>, <span class=\"string\">\"Attach containers to a pre-existing network bridge/nuse 'none' to disable container networking\"</span>)</div><div class=\"line\">    flag.BoolVar(&amp;config.InterContainerCommunication, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#icc\"</span>, <span class=\"string\">\"-icc\"</span>&#125;, <span class=\"literal\">true</span>, <span class=\"string\">\"Enable inter-container communication\"</span>)</div><div class=\"line\">    flag.StringVar(&amp;config.GraphDriver, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"s\"</span>, <span class=\"string\">\"-storage-driver\"</span>&#125;, <span class=\"string\">\"\"</span>, <span class=\"string\">\"Force the Docker runtime to use a specific storage driver\"</span>)</div><div class=\"line\">    flag.StringVar(&amp;config.ExecDriver, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"e\"</span>, <span class=\"string\">\"-exec-driver\"</span>&#125;, <span class=\"string\">\"native\"</span>, <span class=\"string\">\"Force the Docker runtime to use a specific exec driver\"</span>)</div><div class=\"line\">    flag.BoolVar(&amp;config.EnableSelinuxSupport, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-selinux-enabled\"</span>&#125;, <span class=\"literal\">false</span>, <span class=\"string\">\"Enable selinux support. SELinux does not presently support the BTRFS storage driver\"</span>)</div><div class=\"line\">    flag.IntVar(&amp;config.Mtu, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#mtu\"</span>, <span class=\"string\">\"-mtu\"</span>&#125;, <span class=\"number\">0</span>, <span class=\"string\">\"Set the containers network MTU/nif no value is provided: default to the default route MTU or 1500 if no default route is available\"</span>)</div><div class=\"line\">    opts.IPVar(&amp;config.DefaultIp, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#ip\"</span>, <span class=\"string\">\"-ip\"</span>&#125;, <span class=\"string\">\"0.0.0.0\"</span>, <span class=\"string\">\"Default IP address to use when binding container ports\"</span>)</div><div class=\"line\">    opts.ListVar(&amp;config.GraphOptions, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-storage-opt\"</span>&#125;, <span class=\"string\">\"Set storage driver options\"</span>)</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> why the inconsistency between \"hosts\" and \"sockets\"?</span></div><div class=\"line\">    opts.IPListVar(&amp;config.Dns, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#dns\"</span>, <span class=\"string\">\"-dns\"</span>&#125;, <span class=\"string\">\"Force Docker to use specific DNS servers\"</span>)</div><div class=\"line\">    opts.DnsSearchListVar(&amp;config.DnsSearch, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-dns-search\"</span>&#125;, <span class=\"string\">\"Force Docker to use specific DNS search domains\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在InstallFlags()函数的实现过程中，主要是定义某种类型的flag参数，并将该参数的值绑定在config变量的指定属性上，如：</p>\n<p>flag.StringVar(&amp;config.Pidfile, []string{“p”, “-pidfile”}, &quot; /var/run/docker.pid&quot;, “Path to use for daemon PID file”)</p>\n<p>以上语句的含义为：</p>\n<ul>\n<li>定义一个为String类型的flag参数；</li>\n<li>该flag的名称为”p”或者”-pidfile”;</li>\n<li>该flag的值为” /var/run/docker.pid”,并将该值绑定在变量config.Pidfile上；</li>\n<li>该flag的描述信息为&quot;Path to use for daemon PID file&quot;。</li>\n</ul>\n<h3><span id=\"二flag参数检查\">（二）flag参数检查</span></h3>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> flag.NArg() != <span class=\"number\">0</span> &#123;</div><div class=\"line\">    flag.Usage()</div><div class=\"line\">    <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>参数个数不为0，则说明在启动Docker Daemon的时候，传入了多余的参数，此时会输出错误提示，并退出运行程序。</li>\n<li>若为0，则说明Docker Daemon的启动命令无误，正常运行。</li>\n</ul>\n<h3><span id=\"三创建engine对象\">（三）创建engine对象</span></h3>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">eng := engine.New()</div></pre></td></tr></table></figure>\n<p>Engine是Docker架构中的运行引擎，同时也是Docker运行的核心模块。Engine扮演着Docker container存储仓库的角色，并且通过job的形式来管理这些容器。</p>\n<p><strong>/engine/engine.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Engine <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    handlers   <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Handler</div><div class=\"line\">    catchall   Handler</div><div class=\"line\">    hack       Hack <span class=\"comment\">// data for temporary hackery (see hack.go)</span></div><div class=\"line\">    id         <span class=\"keyword\">string</span></div><div class=\"line\">    Stdout     io.Writer</div><div class=\"line\">    Stderr     io.Writer</div><div class=\"line\">    Stdin      io.Reader</div><div class=\"line\">    Logging    <span class=\"keyword\">bool</span></div><div class=\"line\">    tasks      sync.WaitGroup</div><div class=\"line\">    l          sync.RWMutex <span class=\"comment\">// lock for shutdown</span></div><div class=\"line\">    shutdown   <span class=\"keyword\">bool</span></div><div class=\"line\">    onShutdown []<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> // <span class=\"title\">shutdown</span> <span class=\"title\">handlers</span></span></div><div class=\"line\"><span class=\"function\">&#125;</span></div></pre></td></tr></table></figure>\n<p>Engine结构体中最为重要的即为handlers属性。该handlers属性为map类型，key为string类型，value为Handler类型。Handler为一个定义的函数。该函数传入的参数为Job指针，返回为Status状态。</p>\n<p><strong>/engine/engine.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Handler <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*Job)</span> <span class=\"title\">Status</span></span></div></pre></td></tr></table></figure>\n<p>New()函数的实现:</p>\n<p><strong>/engine/engine.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// New initializes a new engine.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span> *<span class=\"title\">Engine</span></span> &#123;</div><div class=\"line\">    eng := &amp;Engine&#123;</div><div class=\"line\">        handlers: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Handler),</div><div class=\"line\">        id:       utils.RandomString(),</div><div class=\"line\">        Stdout:   os.Stdout,</div><div class=\"line\">        Stderr:   os.Stderr,</div><div class=\"line\">        Stdin:    os.Stdin,</div><div class=\"line\">        Logging:  <span class=\"literal\">true</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\">    eng.Register(<span class=\"string\">\"commands\"</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(job *Job)</span> <span class=\"title\">Status</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> _, name := <span class=\"keyword\">range</span> eng.commands() &#123;</div><div class=\"line\">            job.Printf(<span class=\"string\">\"%s/n\"</span>, name)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> StatusOK</div><div class=\"line\">    &#125;)</div><div class=\"line\">    <span class=\"comment\">// Copy existing global handlers</span></div><div class=\"line\">    <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> globalHandlers &#123;</div><div class=\"line\">        eng.handlers[k] = v</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> eng</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>创建一个Engine结构体实例eng</li>\n<li>向eng对象注册名为commands的Handler，其中Handler为临时定义的函数func(job *Job) Status{ } , 该函数的作用是通过job来打印所有已经注册完毕的command名称，最终返回状态StatusOK。</li>\n<li>将已定义的变量globalHandlers中的所有的Handler，都复制到eng对象的handlers属性中。最后成功返回eng对象。</li>\n</ol>\n<h3><span id=\"四设置engine的信号捕获\">（四）设置engine的信号捕获</span></h3>\n<p><strong>/daemon/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">signal.Trap(eng.Shutdown)</div></pre></td></tr></table></figure>\n<p>在Docker Daemon的运行中，设置Trap特定信号的处理方法，特定信号有SIGINT，SIGTERM以及SIGQUIT；当程序捕获到SIGINT或者SIGTERM信号时，执行相应的善后操作，最后保证Docker Daemon程序退出。</p>\n<p><strong>/pkg/signal/trap.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Trap sets up a simplified signal \"trap\", appropriate for common</span></div><div class=\"line\"><span class=\"comment\">// behavior expected from a vanilla unix command-line tool in general</span></div><div class=\"line\"><span class=\"comment\">// (and the Docker engine in particular).</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"comment\">// * If SIGINT or SIGTERM are received, `cleanup` is called, then the process is terminated.</span></div><div class=\"line\"><span class=\"comment\">// * If SIGINT or SIGTERM are repeated 3 times before cleanup is complete, then cleanup is</span></div><div class=\"line\"><span class=\"comment\">// skipped and the process terminated directly.</span></div><div class=\"line\"><span class=\"comment\">// * If \"DEBUG\" is set in the environment, SIGQUIT causes an exit without cleanup.</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Trap</span><span class=\"params\">(cleanup <span class=\"keyword\">func</span>()</span>)</span> &#123;</div><div class=\"line\">    c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> os.Signal, <span class=\"number\">1</span>)</div><div class=\"line\">    signals := []os.Signal&#123;os.Interrupt, syscall.SIGTERM&#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> os.Getenv(<span class=\"string\">\"DEBUG\"</span>) == <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        signals = <span class=\"built_in\">append</span>(signals, syscall.SIGQUIT)</div><div class=\"line\">    &#125;</div><div class=\"line\">    gosignal.Notify(c, signals...)</div><div class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        interruptCount := <span class=\"keyword\">uint32</span>(<span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">for</span> sig := <span class=\"keyword\">range</span> c &#123;</div><div class=\"line\">            <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(sig os.Signal)</span></span> &#123;</div><div class=\"line\">                log.Printf(<span class=\"string\">\"Received signal '%v', starting shutdown of docker.../n\"</span>, sig)</div><div class=\"line\">                <span class=\"keyword\">switch</span> sig &#123;</div><div class=\"line\">                <span class=\"keyword\">case</span> os.Interrupt, syscall.SIGTERM:</div><div class=\"line\">                    <span class=\"comment\">// If the user really wants to interrupt, let him do so.</span></div><div class=\"line\">                    <span class=\"keyword\">if</span> atomic.LoadUint32(&amp;interruptCount) &lt; <span class=\"number\">3</span> &#123;</div><div class=\"line\">                        atomic.AddUint32(&amp;interruptCount, <span class=\"number\">1</span>)</div><div class=\"line\">                        <span class=\"comment\">// Initiate the cleanup only once</span></div><div class=\"line\">                        <span class=\"keyword\">if</span> atomic.LoadUint32(&amp;interruptCount) == <span class=\"number\">1</span> &#123;</div><div class=\"line\">                            <span class=\"comment\">// Call cleanup handler</span></div><div class=\"line\">                            cleanup()</div><div class=\"line\">                            os.Exit(<span class=\"number\">0</span>)</div><div class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                            <span class=\"keyword\">return</span></div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                        log.Printf(<span class=\"string\">\"Force shutdown of docker, interrupting cleanup/n\"</span>)</div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">case</span> syscall.SIGQUIT:</div><div class=\"line\">                &#125;</div><div class=\"line\">                os.Exit(<span class=\"number\">128</span> + <span class=\"keyword\">int</span>(sig.(syscall.Signal)))</div><div class=\"line\">            &#125;(sig)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>创建并设置一个channel，用于发送信号通知；</li>\n<li>定义signals数组变量，初始值为os.SIGINT, os.SIGTERM;若环境变量DEBUG为空的话，则添加os.SIGQUIT至signals数组；</li>\n<li>通过gosignal.Notify(c, signals…)中Notify函数来实现将接收到的signal信号传递给c。需要注意的是只有signals中被罗列出的信号才会被传递给c，其余信号会被直接忽略；</li>\n<li>创建一个goroutine来处理具体的signal信号，当信号类型为os.Interrupt或者syscall.SIGTERM时，执行传入Trap函数的具体执行方法，形参为cleanup(),实参为eng.Shutdown。</li>\n</ul>\n<p>Shutdown()函数的定义位于<a href=\"https://github.com/docker/docker/blob/v1.2.0/engine/engine.go#L153\" target=\"_blank\" rel=\"external\">./docker/engine/engine.go</a>，主要做的工作是为Docker Daemon的关闭做一些善后工作。</p>\n<p><strong>/engine/engine.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Shutdown permanently shuts down eng as follows:</span></div><div class=\"line\"><span class=\"comment\">// - It refuses all new jobs, permanently.</span></div><div class=\"line\"><span class=\"comment\">// - It waits for all active jobs to complete (with no timeout)</span></div><div class=\"line\"><span class=\"comment\">// - It calls all shutdown handlers concurrently (if any)</span></div><div class=\"line\"><span class=\"comment\">// - It returns when all handlers complete, or after 15 seconds,</span></div><div class=\"line\"><span class=\"comment\">//    whichever happens first.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(eng *Engine)</span> <span class=\"title\">Shutdown</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    eng.l.Lock()</div><div class=\"line\">    <span class=\"keyword\">if</span> eng.shutdown &#123;</div><div class=\"line\">        eng.l.Unlock()</div><div class=\"line\">        <span class=\"keyword\">return</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    eng.shutdown = <span class=\"literal\">true</span></div><div class=\"line\">    eng.l.Unlock()</div><div class=\"line\">    <span class=\"comment\">// We don't need to protect the rest with a lock, to allow</span></div><div class=\"line\">    <span class=\"comment\">// for other calls to immediately fail with \"shutdown\" instead</span></div><div class=\"line\">    <span class=\"comment\">// of hanging for 15 seconds.</span></div><div class=\"line\">    <span class=\"comment\">// This requires all concurrent calls to check for shutdown, otherwise</span></div><div class=\"line\">    <span class=\"comment\">// it might cause a race.</span></div><div class=\"line\">    <span class=\"comment\">// Wait for all jobs to complete.</span></div><div class=\"line\">    <span class=\"comment\">// Timeout after 5 seconds.</span></div><div class=\"line\">    tasksDone := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</div><div class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        eng.tasks.Wait()</div><div class=\"line\">        <span class=\"built_in\">close</span>(tasksDone)</div><div class=\"line\">    &#125;()</div><div class=\"line\">    <span class=\"keyword\">select</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> &lt;-time.After(time.Second * <span class=\"number\">5</span>):</div><div class=\"line\">    <span class=\"keyword\">case</span> &lt;-tasksDone:</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Call shutdown handlers, if any.</span></div><div class=\"line\">    <span class=\"comment\">// Timeout after 10 seconds.</span></div><div class=\"line\">    <span class=\"keyword\">var</span> wg sync.WaitGroup</div><div class=\"line\">    <span class=\"keyword\">for</span> _, h := <span class=\"keyword\">range</span> eng.onShutdown &#123;</div><div class=\"line\">        wg.Add(<span class=\"number\">1</span>)</div><div class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(h <span class=\"keyword\">func</span>()</span>)</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">defer</span> wg.Done()</div><div class=\"line\">            h()</div><div class=\"line\">        &#125;(h)</div><div class=\"line\">    &#125;</div><div class=\"line\">    done := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</div><div class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        wg.Wait()</div><div class=\"line\">        <span class=\"built_in\">close</span>(done)</div><div class=\"line\">    &#125;()</div><div class=\"line\">    <span class=\"keyword\">select</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> &lt;-time.After(time.Second * <span class=\"number\">10</span>):</div><div class=\"line\">    <span class=\"keyword\">case</span> &lt;-done:</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>Docker Daemon不再接收任何新的Job；</li>\n<li>Docker Daemon等待所有存活的Job执行完毕；</li>\n<li>Docker Daemon调用所有shutdown的处理方法；</li>\n<li>当所有的handler执行完毕，或者15秒之后，Shutdown()函数返回。</li>\n</ul>\n<p>由于在signal.Trap( eng.Shutdown )函数的具体实现中执行eng.Shutdown，在执行完eng.Shutdown之后，随即执行<a href=\"https://github.com/docker/docker/blob/v1.2.0/pkg/signal/trap.go#L41\" target=\"_blank\" rel=\"external\">os.Exit(0)</a>，完成当前程序的立即退出。</p>\n<h3><span id=\"五加载builtins\">（五）加载builtins</span></h3>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> err := builtins.Register(eng); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    log.Fatal(err)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为engine注册多个Handler，以便后续在执行相应任务时，运行指定的Handler。</p>\n<p>这些Handler包括：</p>\n<ul>\n<li>网络初始化、</li>\n<li>web API服务、</li>\n<li>事件查询、</li>\n<li>版本查看、</li>\n<li>Docker Registry验证与搜索。</li>\n</ul>\n<p><strong>/builtins/builtins.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Register</span><span class=\"params\">(eng *engine.Engine)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> err := daemon(eng); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> err := remote(eng); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> err := events.New().Install(eng); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> err := eng.Register(<span class=\"string\">\"version\"</span>, dockerVersion); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> registry.NewService().Install(eng)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4><span id=\"1-注册初始化网络驱动的handler\">1、注册初始化网络驱动的Handler</span></h4>\n<p>daemon(eng)的实现过程，主要为eng对象注册了一个key为”init_networkdriver”的Handler，该Handler的值为bridge.InitDriver函数，代码如下：</p>\n<p><strong>/builtins/builtins.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">daemon</span><span class=\"params\">(eng *engine.Engine)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> eng.Register(<span class=\"string\">\"init_networkdriver\"</span>, bridge.InitDriver)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要注意的是，向eng对象注册Handler，并不代表Handler的值函数会被直接运行，如bridge.InitDriver，并不会直接运行，而是将bridge.InitDriver的函数入口，写入eng的handlers属性中。</p>\n<p><strong>/daemon/networkdriver/bridge/driver.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">InitDriver</span><span class=\"params\">(job *engine.Job)</span> <span class=\"title\">engine</span>.<span class=\"title\">Status</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> (</div><div class=\"line\">        network        *net.IPNet</div><div class=\"line\">        enableIPTables = job.GetenvBool(<span class=\"string\">\"EnableIptables\"</span>)</div><div class=\"line\">        icc            = job.GetenvBool(<span class=\"string\">\"InterContainerCommunication\"</span>)</div><div class=\"line\">        ipForward      = job.GetenvBool(<span class=\"string\">\"EnableIpForward\"</span>)</div><div class=\"line\">        bridgeIP       = job.Getenv(<span class=\"string\">\"BridgeIP\"</span>)</div><div class=\"line\">    )</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> defaultIP := job.Getenv(<span class=\"string\">\"DefaultBindingIP\"</span>); defaultIP != <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        defaultBindingIP = net.ParseIP(defaultIP)</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    bridgeIface = job.Getenv(<span class=\"string\">\"BridgeIface\"</span>)</div><div class=\"line\">    usingDefaultBridge := <span class=\"literal\">false</span></div><div class=\"line\">    <span class=\"keyword\">if</span> bridgeIface == <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        usingDefaultBridge = <span class=\"literal\">true</span></div><div class=\"line\">        bridgeIface = DefaultNetworkBridge</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    addr, err := networkdriver.GetIfaceAddr(bridgeIface)</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// If we're not using the default bridge, fail without trying to create it</span></div><div class=\"line\">        <span class=\"keyword\">if</span> !usingDefaultBridge &#123;</div><div class=\"line\">            job.Logf(<span class=\"string\">\"bridge not found: %s\"</span>, bridgeIface)</div><div class=\"line\">            <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// If the iface is not found, try to create it</span></div><div class=\"line\">        job.Logf(<span class=\"string\">\"creating new bridge for %s\"</span>, bridgeIface)</div><div class=\"line\">        <span class=\"keyword\">if</span> err := createBridge(bridgeIP); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        job.Logf(<span class=\"string\">\"getting iface addr\"</span>)</div><div class=\"line\">        addr, err = networkdriver.GetIfaceAddr(bridgeIface)</div><div class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">        &#125;</div><div class=\"line\">        network = addr.(*net.IPNet)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        network = addr.(*net.IPNet)</div><div class=\"line\">        <span class=\"comment\">// validate that the bridge ip matches the ip specified by BridgeIP</span></div><div class=\"line\">        <span class=\"keyword\">if</span> bridgeIP != <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">            bip, _, err := net.ParseCIDR(bridgeIP)</div><div class=\"line\">            <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> !network.IP.Equal(bip) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> job.Errorf(<span class=\"string\">\"bridge ip (%s) does not match existing bridge configuration %s\"</span>, network.IP, bip)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">// Configure iptables for link support</span></div><div class=\"line\">    <span class=\"keyword\">if</span> enableIPTables &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> err := setupIPTables(addr, icc); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> ipForward &#123;</div><div class=\"line\">        <span class=\"comment\">// Enable IPv4 forwarding</span></div><div class=\"line\">        <span class=\"keyword\">if</span> err := ioutil.WriteFile(<span class=\"string\">\"/proc/sys/net/ipv4/ip_forward\"</span>, []<span class=\"keyword\">byte</span>&#123;<span class=\"string\">'1'</span>, <span class=\"string\">'/n'</span>&#125;, <span class=\"number\">0644</span>); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            job.Logf(<span class=\"string\">\"WARNING: unable to enable IPv4 forwarding: %s/n\"</span>, err)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">// We can always try removing the iptables</span></div><div class=\"line\">    <span class=\"keyword\">if</span> err := iptables.RemoveExistingChain(<span class=\"string\">\"DOCKER\"</span>); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> enableIPTables &#123;</div><div class=\"line\">        chain, err := iptables.NewChain(<span class=\"string\">\"DOCKER\"</span>, bridgeIface)</div><div class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">        &#125;</div><div class=\"line\">        portmapper.SetIptablesChain(chain)</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    bridgeNetwork = network</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">// https://github.com/docker/docker/issues/2768</span></div><div class=\"line\">    job.Eng.Hack_SetGlobalVar(<span class=\"string\">\"httpapi.bridgeIP\"</span>, bridgeNetwork.IP)</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">for</span> name, f := <span class=\"keyword\">range</span> <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]engine.Handler&#123;</div><div class=\"line\">        <span class=\"string\">\"allocate_interface\"</span>: Allocate,</div><div class=\"line\">        <span class=\"string\">\"release_interface\"</span>:  Release,</div><div class=\"line\">        <span class=\"string\">\"allocate_port\"</span>:      AllocatePort,</div><div class=\"line\">        <span class=\"string\">\"link\"</span>:               LinkContainers,</div><div class=\"line\">    &#125; &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> err := job.Eng.Register(name, f); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> engine.StatusOK</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Bridge.InitDriver的作用：</p>\n<ul>\n<li>获取为Docker服务的网络设备的地址；</li>\n<li>创建指定IP地址的网桥；</li>\n<li>配置网络iptables规则；</li>\n<li>另外还为eng对象注册了多个Handler,如 ”allocate_interface”， ”release_interface”， ”allocate_port”，”link”。</li>\n</ul>\n<h4><span id=\"2-注册api服务的handler\">2、注册API服务的Handler</span></h4>\n<p>remote(eng)的实现过程，主要为eng对象注册了两个Handler，分别为”serveapi”与”acceptconnections”。代码实现如下：</p>\n<p><strong>/builtins/builtins.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">remote</span><span class=\"params\">(eng *engine.Engine)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> err := eng.Register(<span class=\"string\">\"serveapi\"</span>, apiserver.ServeApi); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> eng.Register(<span class=\"string\">\"acceptconnections\"</span>, apiserver.AcceptConnections)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注册的两个Handler名称分别为”serveapi”与”acceptconnections”</p>\n<ul>\n<li>ServeApi执行时，通过循环多种协议，创建出goroutine来配置指定的http.Server，最终为不同的协议请求服务；</li>\n<li>AcceptConnections的实现主要是为了通知init守护进程，Docker Daemon已经启动完毕，可以让Docker Daemon进程接受请求。(守护进程)</li>\n</ul>\n<h4><span id=\"3-注册events事件的handler\">3、注册events事件的Handler</span></h4>\n<p>events.New().Install(eng)的实现过程，为Docker注册了多个event事件，功能是给Docker用户提供API，使得用户可以通过这些API查看Docker内部的events信息，log信息以及subscribers_count信息。</p>\n<p><strong>/events/events.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Events <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    mu          sync.RWMutex</div><div class=\"line\">    events      []*utils.JSONMessage</div><div class=\"line\">    subscribers []listener</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span> *<span class=\"title\">Events</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &amp;Events&#123;</div><div class=\"line\">        events: <span class=\"built_in\">make</span>([]*utils.JSONMessage, <span class=\"number\">0</span>, eventsLimit),</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Install installs events public api in docker engine</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Events)</span> <span class=\"title\">Install</span><span class=\"params\">(eng *engine.Engine)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Here you should describe public interface</span></div><div class=\"line\">    jobs := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]engine.Handler&#123;</div><div class=\"line\">        <span class=\"string\">\"events\"</span>:            e.Get,</div><div class=\"line\">        <span class=\"string\">\"log\"</span>:               e.Log,</div><div class=\"line\">        <span class=\"string\">\"subscribers_count\"</span>: e.SubscribersCount,</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> name, job := <span class=\"keyword\">range</span> jobs &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> err := eng.Register(name, job); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> err</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4><span id=\"4-注册版本的handler\">4、注册版本的Handler</span></h4>\n<p>eng.Register(“version”,dockerVersion)的实现过程，向eng对象注册key为”version”，value为”dockerVersion”执行方法的Handler，dockerVersion的执行过程中，会向名为version的job的标准输出中写入Docker的版本，Docker API的版本，git版本，Go语言运行时版本以及操作系统等版本信息。</p>\n<p><strong>/builtins/builtins.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// builtins jobs independent of any subsystem</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dockerVersion</span><span class=\"params\">(job *engine.Job)</span> <span class=\"title\">engine</span>.<span class=\"title\">Status</span></span> &#123;</div><div class=\"line\">    v := &amp;engine.Env&#123;&#125;</div><div class=\"line\">    v.SetJson(<span class=\"string\">\"Version\"</span>, dockerversion.VERSION)</div><div class=\"line\">    v.SetJson(<span class=\"string\">\"ApiVersion\"</span>, api.APIVERSION)</div><div class=\"line\">    v.Set(<span class=\"string\">\"GitCommit\"</span>, dockerversion.GITCOMMIT)</div><div class=\"line\">    v.Set(<span class=\"string\">\"GoVersion\"</span>, runtime.Version())</div><div class=\"line\">    v.Set(<span class=\"string\">\"Os\"</span>, runtime.GOOS)</div><div class=\"line\">    v.Set(<span class=\"string\">\"Arch\"</span>, runtime.GOARCH)</div><div class=\"line\">    <span class=\"keyword\">if</span> kernelVersion, err := kernel.GetKernelVersion(); err == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        v.Set(<span class=\"string\">\"KernelVersion\"</span>, kernelVersion.String())</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> _, err := v.WriteTo(job.Stdout); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> engine.StatusOK</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4><span id=\"5-注册registry的handler\">5、注册registry的Handler</span></h4>\n<p>registry.NewService().Install(eng)的实现过程位于<a href=\"https://github.com/docker/docker/blob/v1.2.0/registry/service.go#L25\" target=\"_blank\" rel=\"external\">./docker/registry/service.go</a>，在eng对象对外暴露的API信息中添加docker registry的信息。当registry.NewService()成功被Install安装完毕的话，则有两个调用能够被eng使用：”auth”，向公有registry进行认证；”search”，在公有registry上搜索指定的镜像。</p>\n<p><strong>/registry/service.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// NewService returns a new instance of Service ready to be</span></div><div class=\"line\"><span class=\"comment\">// installed no an engine.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewService</span><span class=\"params\">()</span> *<span class=\"title\">Service</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &amp;Service&#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Install installs registry capabilities to eng.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Service)</span> <span class=\"title\">Install</span><span class=\"params\">(eng *engine.Engine)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    eng.Register(<span class=\"string\">\"auth\"</span>, s.Auth)</div><div class=\"line\">    eng.Register(<span class=\"string\">\"search\"</span>, s.Search)</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"六使用goroutine加载daemon对象\">（六）使用goroutine加载daemon对象</span></h3>\n<p>执行完builtins的加载，回到mainDaemon()的执行，通过一个goroutine来加载daemon对象并开始运行。这一环节的执行，主要包含三个步骤：</p>\n<ul>\n<li>通过init函数中初始化的daemonCfg与eng对象来创建一个daemon对象d；(守护进程)</li>\n<li>通过daemon对象的Install函数，向eng对象中注册众多的Handler；</li>\n<li>在Docker Daemon启动完毕之后，运行名为”acceptconnections”的job，主要工作为向init守护进程发送”READY=1”信号，以便开始正常接受请求。</li>\n</ul>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// load the daemon in the background so we can immediately start</span></div><div class=\"line\"><span class=\"comment\">// the http api so that connections don't fail while the daemon</span></div><div class=\"line\"><span class=\"comment\">// is booting</span></div><div class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    d, err := daemon.NewDaemon(daemonCfg, eng)</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        log.Fatal(err)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> err := d.Install(eng); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        log.Fatal(err)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// after the daemon is done setting up we can tell the api to start</span></div><div class=\"line\">    <span class=\"comment\">// accepting connections</span></div><div class=\"line\">    <span class=\"keyword\">if</span> err := eng.Job(<span class=\"string\">\"acceptconnections\"</span>).Run(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        log.Fatal(err)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;()</div></pre></td></tr></table></figure>\n<h4><span id=\"1-创建daemon对象\">1、创建daemon对象</span></h4>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">d, err := daemon.NewDaemon(daemonCfg, eng)</div><div class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    log.Fatal(err)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>daemon.NewDaemon(daemonCfg, eng)是创建daemon对象d的核心部分。主要作用为初始化Docker Daemon的基本环境，如处理config参数，验证系统支持度，配置Docker工作目录，设置与加载多种driver，创建graph环境等，验证DNS配置等。具体参考<a href=\"http://wiki.haplat.net/display/~huwh/NewDaemon\" target=\"_blank\" rel=\"external\">NewDaemon</a> 。</p>\n<h4><span id=\"2-通过daemon对象为engine注册handler\">2、通过daemon对象为engine注册Handler</span></h4>\n<p>当创建完daemon对象，goroutine执行d.Install(eng)</p>\n<p><strong>/daemon/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Daemon <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    repository     <span class=\"keyword\">string</span></div><div class=\"line\">    sysInitPath    <span class=\"keyword\">string</span></div><div class=\"line\">    containers     *contStore</div><div class=\"line\">    graph          *graph.Graph</div><div class=\"line\">    repositories   *graph.TagStore</div><div class=\"line\">    idIndex        *truncindex.TruncIndex</div><div class=\"line\">    sysInfo        *sysinfo.SysInfo</div><div class=\"line\">    volumes        *graph.Graph</div><div class=\"line\">    eng            *engine.Engine</div><div class=\"line\">    config         *Config</div><div class=\"line\">    containerGraph *graphdb.Database</div><div class=\"line\">    driver         graphdriver.Driver</div><div class=\"line\">    execDriver     execdriver.Driver</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Install installs daemon capabilities to eng.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(daemon *Daemon)</span> <span class=\"title\">Install</span><span class=\"params\">(eng *engine.Engine)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> rename \"delete\" to \"rm\" for consistency with the CLI command</span></div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> rename ContainerDestroy to ContainerRm for consistency with the CLI command</span></div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> remove ImageDelete's dependency on Daemon, then move to graph/</span></div><div class=\"line\">    <span class=\"keyword\">for</span> name, method := <span class=\"keyword\">range</span> <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]engine.Handler&#123;</div><div class=\"line\">        <span class=\"string\">\"attach\"</span>:            daemon.ContainerAttach,</div><div class=\"line\">        <span class=\"string\">\"build\"</span>:             daemon.CmdBuild,</div><div class=\"line\">        <span class=\"string\">\"commit\"</span>:            daemon.ContainerCommit,</div><div class=\"line\">        <span class=\"string\">\"container_changes\"</span>: daemon.ContainerChanges,</div><div class=\"line\">        <span class=\"string\">\"container_copy\"</span>:    daemon.ContainerCopy,</div><div class=\"line\">        <span class=\"string\">\"container_inspect\"</span>: daemon.ContainerInspect,</div><div class=\"line\">        <span class=\"string\">\"containers\"</span>:        daemon.Containers,</div><div class=\"line\">        <span class=\"string\">\"create\"</span>:            daemon.ContainerCreate,</div><div class=\"line\">        <span class=\"string\">\"delete\"</span>:            daemon.ContainerDestroy,</div><div class=\"line\">        <span class=\"string\">\"export\"</span>:            daemon.ContainerExport,</div><div class=\"line\">        <span class=\"string\">\"info\"</span>:              daemon.CmdInfo,</div><div class=\"line\">        <span class=\"string\">\"kill\"</span>:              daemon.ContainerKill,</div><div class=\"line\">        <span class=\"string\">\"logs\"</span>:              daemon.ContainerLogs,</div><div class=\"line\">        <span class=\"string\">\"pause\"</span>:             daemon.ContainerPause,</div><div class=\"line\">        <span class=\"string\">\"resize\"</span>:            daemon.ContainerResize,</div><div class=\"line\">        <span class=\"string\">\"restart\"</span>:           daemon.ContainerRestart,</div><div class=\"line\">        <span class=\"string\">\"start\"</span>:             daemon.ContainerStart,</div><div class=\"line\">        <span class=\"string\">\"stop\"</span>:              daemon.ContainerStop,</div><div class=\"line\">        <span class=\"string\">\"top\"</span>:               daemon.ContainerTop,</div><div class=\"line\">        <span class=\"string\">\"unpause\"</span>:           daemon.ContainerUnpause,</div><div class=\"line\">        <span class=\"string\">\"wait\"</span>:              daemon.ContainerWait,</div><div class=\"line\">        <span class=\"string\">\"image_delete\"</span>:      daemon.ImageDelete, <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> see above</span></div><div class=\"line\">    &#125; &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> err := eng.Register(name, method); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> err</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> err := daemon.Repositories().Install(eng); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> this hack is necessary for legacy integration tests to access</span></div><div class=\"line\">    <span class=\"comment\">// the daemon object.</span></div><div class=\"line\">    eng.Hack_SetGlobalVar(<span class=\"string\">\"httpapi.daemon\"</span>, daemon)</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上代码的实现分为三部分：</p>\n<ul>\n<li>向eng对象中注册众多的Handler对象；</li>\n<li>daemon.Repositories().Install(eng)实现了向eng对象注册多个与image相关的Handler，Install的实现位于<a href=\"https://github.com/docker/docker/blob/v1.2.0/graph/service.go#L12\" target=\"_blank\" rel=\"external\">./docker/graph/service.go</a>；</li>\n<li>eng.Hack_SetGlobalVar(“httpapi.daemon”, daemon)实现向eng对象中map类型的hack对象中添加一条记录，key为”httpapi.daemon”，value为daemon。</li>\n</ul>\n<h4><span id=\"3-运行acceptconnections的job\">3、运行acceptconnections的job</span></h4>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> err := eng.Job(<span class=\"string\">\"acceptconnections\"</span>).Run(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    log.Fatal(err)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在goroutine内部最后运行名为”acceptconnections”的job，主要作用是通知init守护进程，Docker Daemon可以开始接受请求了。</p>\n<p>首先执行eng.Job(“acceptconnections”)，返回一个Job，随后再执行eng.Job(“acceptconnections”).Run()，也就是该执行Job的run函数。</p>\n<p><strong>/engine/engine.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Job creates a new job which can later be executed.</span></div><div class=\"line\"><span class=\"comment\">// This function mimics `Command` from the standard os/exec package.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(eng *Engine)</span> <span class=\"title\">Job</span><span class=\"params\">(name <span class=\"keyword\">string</span>, args ...<span class=\"keyword\">string</span>)</span> *<span class=\"title\">Job</span></span> &#123;</div><div class=\"line\">    job := &amp;Job&#123;</div><div class=\"line\">        Eng:    eng,</div><div class=\"line\">        Name:   name,</div><div class=\"line\">        Args:   args,</div><div class=\"line\">        Stdin:  NewInput(),</div><div class=\"line\">        Stdout: NewOutput(),</div><div class=\"line\">        Stderr: NewOutput(),</div><div class=\"line\">        env:    &amp;Env&#123;&#125;,</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> eng.Logging &#123;</div><div class=\"line\">        job.Stderr.Add(utils.NopWriteCloser(eng.Stderr))</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Catchall is shadowed by specific Register.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> handler, exists := eng.handlers[name]; exists &#123;</div><div class=\"line\">        job.handler = handler</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> eng.catchall != <span class=\"literal\">nil</span> &amp;&amp; name != <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// empty job names are illegal, catchall or not.</span></div><div class=\"line\">        job.handler = eng.catchall</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> job</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>首先创建一个类型为Job的job对象，该对象中Eng属性为函数的调用者eng，Name属性为”acceptconnections”，没有参数传入。</li>\n<li>另外在eng对象所有的handlers属性中寻找键为”acceptconnections”记录的值，由于在加载builtins操作中的remote(eng)中已经向eng注册过这样的一条记录，key为”acceptconnections”，value为apiserver.AcceptConnections。</li>\n<li>因此job对象的handler为apiserver.AcceptConnections。</li>\n<li>最后返回已经初始化完毕的对象job。</li>\n</ol>\n<p>创建完job对象之后，随即执行该job对象的run()函数。</p>\n<p><strong>/engine/job.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// A job is the fundamental unit of work in the docker engine.</span></div><div class=\"line\"><span class=\"comment\">// Everything docker can do should eventually be exposed as a job.</span></div><div class=\"line\"><span class=\"comment\">// For example: execute a process in a container, create a new container,</span></div><div class=\"line\"><span class=\"comment\">// download an archive from the internet, serve the http api, etc.</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"comment\">// The job API is designed after unix processes: a job has a name, arguments,</span></div><div class=\"line\"><span class=\"comment\">// environment variables, standard streams for input, output and error, and</span></div><div class=\"line\"><span class=\"comment\">// an exit status which can indicate success (0) or error (anything else).</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"comment\">// One slight variation is that jobs report their status as a string. The</span></div><div class=\"line\"><span class=\"comment\">// string \"0\" indicates success, and any other strings indicates an error.</span></div><div class=\"line\"><span class=\"comment\">// This allows for richer error reporting.</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"keyword\">type</span> Job <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    Eng     *Engine</div><div class=\"line\">    Name    <span class=\"keyword\">string</span></div><div class=\"line\">    Args    []<span class=\"keyword\">string</span></div><div class=\"line\">    env     *Env</div><div class=\"line\">    Stdout  *Output</div><div class=\"line\">    Stderr  *Output</div><div class=\"line\">    Stdin   *Input</div><div class=\"line\">    handler Handler</div><div class=\"line\">    status  Status</div><div class=\"line\">    end     time.Time</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">type</span> Status <span class=\"keyword\">int</span></div><div class=\"line\"><span class=\"keyword\">const</span> (</div><div class=\"line\">    StatusOK       Status = <span class=\"number\">0</span></div><div class=\"line\">    StatusErr      Status = <span class=\"number\">1</span></div><div class=\"line\">    StatusNotFound Status = <span class=\"number\">127</span></div><div class=\"line\">)</div><div class=\"line\"><span class=\"comment\">// Run executes the job and blocks until the job completes.</span></div><div class=\"line\"><span class=\"comment\">// If the job returns a failure status, an error is returned</span></div><div class=\"line\"><span class=\"comment\">// which includes the status.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(job *Job)</span> <span class=\"title\">Run</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> job.Eng.IsShutdown() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">\"engine is shutdown\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> this is a temporary workaround to avoid Engine.Shutdown</span></div><div class=\"line\">    <span class=\"comment\">// waiting 5 seconds for server/api.ServeApi to complete (which it never will)</span></div><div class=\"line\">    <span class=\"comment\">// everytime the daemon is cleanly restarted.</span></div><div class=\"line\">    <span class=\"comment\">// The permanent fix is to implement Job.Stop and Job.OnStop so that</span></div><div class=\"line\">    <span class=\"comment\">// ServeApi can cooperate and terminate cleanly.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> job.Name != <span class=\"string\">\"serveapi\"</span> &#123;</div><div class=\"line\">        job.Eng.l.Lock()</div><div class=\"line\">        job.Eng.tasks.Add(<span class=\"number\">1</span>)</div><div class=\"line\">        job.Eng.l.Unlock()</div><div class=\"line\">        <span class=\"keyword\">defer</span> job.Eng.tasks.Done()</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> make this thread-safe</span></div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> implement wait</span></div><div class=\"line\">    <span class=\"keyword\">if</span> !job.end.IsZero() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">\"%s: job has already completed\"</span>, job.Name)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Log beginning and end of the job</span></div><div class=\"line\">    job.Eng.Logf(<span class=\"string\">\"+job %s\"</span>, job.CallString())</div><div class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        job.Eng.Logf(<span class=\"string\">\"-job %s%s\"</span>, job.CallString(), job.StatusString())</div><div class=\"line\">    &#125;()</div><div class=\"line\">    <span class=\"keyword\">var</span> errorMessage = bytes.NewBuffer(<span class=\"literal\">nil</span>)</div><div class=\"line\">    job.Stderr.Add(errorMessage)</div><div class=\"line\">    <span class=\"keyword\">if</span> job.handler == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        job.Errorf(<span class=\"string\">\"%s: command not found\"</span>, job.Name)</div><div class=\"line\">        job.status = <span class=\"number\">127</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        job.status = job.handler(job)</div><div class=\"line\">        job.end = time.Now()</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Wait for all background tasks to complete</span></div><div class=\"line\">    <span class=\"keyword\">if</span> err := job.Stdout.Close(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> err := job.Stderr.Close(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> err := job.Stdin.Close(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> job.status != <span class=\"number\">0</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">\"%s\"</span>, Tail(errorMessage, <span class=\"number\">1</span>))</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Run()函数的实现位于<a href=\"https://github.com/docker/docker/blob/v1.2.0/engine/job.go#L48\" target=\"_blank\" rel=\"external\">./docker/engine/job.go</a>，该函数执行指定的job，并在job执行完成前一直阻塞。对于名为”acceptconnections”的job对象，运行代码为<a href=\"https://github.com/docker/docker/blob/v1.2.0/engine/job.go#L79\" target=\"_blank\" rel=\"external\">job.status = job.handler(job)</a>，由于job.handler值为apiserver.AcceptConnections，故真正执行的是job.status = apiserver.AcceptConnections(job)。</p>\n<p>进入AcceptConnections的具体实现，位于<a href=\"https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1370\" target=\"_blank\" rel=\"external\">./docker/api/server/server.go</a>,如下：</p>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">AcceptConnections</span><span class=\"params\">(job *engine.Job)</span> <span class=\"title\">engine</span>.<span class=\"title\">Status</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Tell the init daemon we are accepting requests</span></div><div class=\"line\">    <span class=\"keyword\">go</span>  systemd.SdNotify(<span class=\"string\">\"READY=1\"</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> activationLock != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">close</span>(activationLock)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> engine.StatusOK</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>重点为go systemd.SdNotify(“READY=1”)的实现，位于<a href=\"https://github.com/docker/docker/blob/v1.2.0/pkg/systemd/sd_notify.go#L12\" target=\"_blank\" rel=\"external\">./docker/pkg/system/sd_notify.go</a>，主要作用是通知init守护进程Docker Daemon的启动已经全部完成，潜在的功能是使得Docker Daemon开始接受Docker Client发送来的API请求。</p>\n<p>至此，已经完成通过goroutine来加载daemon对象并运行。</p>\n<h3><span id=\"七打印docker版本及驱动信息\">（七）打印Docker版本及驱动信息</span></h3>\n<p>显示docker的版本信息，以及ExecDriver和GraphDriver这两个驱动的具体信息</p>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// TODO actually have a resolved graphdriver to show?</span></div><div class=\"line\">log.Printf(<span class=\"string\">\"docker daemon: %s %s; execdriver: %s; graphdriver: %s\"</span>,</div><div class=\"line\">    dockerversion.VERSION,</div><div class=\"line\">    dockerversion.GITCOMMIT,</div><div class=\"line\">    daemonCfg.ExecDriver,</div><div class=\"line\">    daemonCfg.GraphDriver,</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<h3><span id=\"八serveapi的创建与运行\">（八）serveapi的创建与运行</span></h3>\n<p>打印部分Docker具体信息之后，Docker Daemon立即创建并运行名为”serveapi”的job，主要作用为让Docker Daemon提供API访问服务。</p>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Serve api</span></div><div class=\"line\">job := eng.Job(<span class=\"string\">\"serveapi\"</span>, flHosts...)</div><div class=\"line\">job.SetenvBool(<span class=\"string\">\"Logging\"</span>, <span class=\"literal\">true</span>)</div><div class=\"line\">job.SetenvBool(<span class=\"string\">\"EnableCors\"</span>, *flEnableCors)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"Version\"</span>, dockerversion.VERSION)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"SocketGroup\"</span>, *flSocketGroup)</div><div class=\"line\">job.SetenvBool(<span class=\"string\">\"Tls\"</span>, *flTls)</div><div class=\"line\">job.SetenvBool(<span class=\"string\">\"TlsVerify\"</span>, *flTlsVerify)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"TlsCa\"</span>, *flCa)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"TlsCert\"</span>, *flCert)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"TlsKey\"</span>, *flKey)</div><div class=\"line\">job.SetenvBool(<span class=\"string\">\"BufferRequests\"</span>, <span class=\"literal\">true</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> err := job.Run(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    log.Fatal(err)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>创建一个名为”serveapi”的job，并将flHosts的值赋给job.Args。flHost的作用主要是为Docker Daemon提供使用的协议与监听的地址。</li>\n<li>Docker Daemon为该job设置了众多的环境变量，如安全传输层协议的环境变量等。最后通过job.Run()运行该serveapi的job。</li>\n</ol>\n<p>由于在eng中key为”serveapi”的handler，value为apiserver.ServeApi，故该job运行时，执行apiserver.ServeApi函数，位于<a href=\"https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1339\" target=\"_blank\" rel=\"external\">./docker/api/server/server.go</a>。ServeApi函数的作用主要是对于用户定义的所有支持协议，Docker Daemon均创建一个goroutine来启动相应的http.Server，分别为不同的协议服务。具体参考<a href=\"http://wiki.haplat.net/display/~huwh/Docker+Server\" target=\"_blank\" rel=\"external\">Docker Server</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>一、Docker Daemon架构示意图</h2>\n<p><img src=\"/img/article/docker/docker%E6%BA%90%E7%A0%81%E4%B9%8BDocker-Daemon/Daemon%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg\" alt=\"Daemon架构图\"></p>\n<p>Docker Daemon是Docker架构中运行在后台的守护进程，大致可以分为Docker Server、Engine和Job三部分。</p>\n<p>Docker Daemon可以认为是通过Docker Server模块接受Docker Client的请求，并在Engine中处理请求，然后根据请求类型，创建出指定的Job并运行。</p>\n<p>运行过程的作用有以下几种可能：</p>\n<ul>\n<li>向Docker Registry获取镜像，</li>\n<li>通过graphdriver执行容器镜像的本地化操作，</li>\n<li>通过networkdriver执行容器网络环境的配置，</li>\n<li>通过execdriver执行容器内部运行的执行工作等。</li>\n</ul>\n<p>说明：本文分析的代码为Docker 1.2.0版本。</p>\n<h2>二、Docker Daemon启动流程图</h2>\n<p><img src=\"/img/article/docker/docker%E6%BA%90%E7%A0%81%E4%B9%8BDocker-Daemon/Daemon%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.jpg\" alt=\"Daemon启动流程\"></p>\n<p>启动Docker Daemon时，一般可以使用以下命令：docker --daemon=true; docker –d; docker –d=true等。接着由docker的main()函数来解析以上命令的相应flag参数，并最终完成Docker Daemon的启动。</p>\n<p><strong>/docker/docker.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">if</span> *flDaemon &#123;</div><div class=\"line\">        mainDaemon()</div><div class=\"line\">        <span class=\"keyword\">return</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2>三、mainDaemon的具体实现</h2>\n<p>宏观来讲，mainDaemon()完成创建一个daemon进程，并使其正常运行。</p>\n<p>从功能的角度来说，mainDaemon()实现了两部分内容：</p>\n<ul>\n<li>第一，创建Docker运行环境；</li>\n<li>第二，服务于Docker Client，接收并处理相应请求。</li>\n</ul>\n<h3>（一）配置初始化</h3>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> (</div><div class=\"line\">    daemonCfg = &amp;daemon.Config&#123;&#125;</div><div class=\"line\">)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    daemonCfg.InstallFlags()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在mainDaemon()运行之前，关于Docker Daemon所需要的config配置信息均已经初始化完毕。</p>\n<p>声明一个为daemon包中Config类型的变量，名为daemonCfg。而Config对象，定义了Docker Daemon所需的配置信息。在Docker Daemon在启动时，daemonCfg变量被传递至Docker Daemon并被使用。</p>\n<p><strong>/daemon/config.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Config <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    Pidfile                  <span class=\"keyword\">string</span>   <span class=\"comment\">//Docker Daemon所属进程的PID文件</span></div><div class=\"line\">    Root                   <span class=\"keyword\">string</span>   <span class=\"comment\">//Docker运行时所使用的root路径</span></div><div class=\"line\">    AutoRestart             <span class=\"keyword\">bool</span>    <span class=\"comment\">//已被启用，转而支持docker run时的重启</span></div><div class=\"line\">    Dns                   []<span class=\"keyword\">string</span>  <span class=\"comment\">//Docker使用的DNS Server地址</span></div><div class=\"line\">    DnsSearch              []<span class=\"keyword\">string</span>  <span class=\"comment\">//Docker使用的指定的DNS查找域名</span></div><div class=\"line\">    Mirrors                 []<span class=\"keyword\">string</span>  <span class=\"comment\">//指定的优先Docker Registry镜像</span></div><div class=\"line\">    EnableIptables           <span class=\"keyword\">bool</span>    <span class=\"comment\">//启用Docker的iptables功能</span></div><div class=\"line\">    EnableIpForward         <span class=\"keyword\">bool</span>    <span class=\"comment\">//启用net.ipv4.ip_forward功能</span></div><div class=\"line\">    EnableIpMasq            <span class=\"keyword\">bool</span>      <span class=\"comment\">//启用IP伪装技术</span></div><div class=\"line\">    DefaultIp                net.IP     <span class=\"comment\">//绑定容器端口时使用的默认IP</span></div><div class=\"line\">    BridgeIface              <span class=\"keyword\">string</span>      <span class=\"comment\">//添加容器网络至已有的网桥</span></div><div class=\"line\">    BridgeIP                 <span class=\"keyword\">string</span>     <span class=\"comment\">//创建网桥的IP地址</span></div><div class=\"line\">    FixedCIDR               <span class=\"keyword\">string</span>     <span class=\"comment\">//指定IP的IPv4子网，必须被网桥子网包含</span></div><div class=\"line\">    InterContainerCommunication   <span class=\"keyword\">bool</span>  <span class=\"comment\">//是否允许相同host上容器间的通信</span></div><div class=\"line\">    GraphDriver             <span class=\"keyword\">string</span>      <span class=\"comment\">//Docker运行时使用的特定存储驱动</span></div><div class=\"line\">    GraphOptions            []<span class=\"keyword\">string</span>   <span class=\"comment\">//可设置的存储驱动选项</span></div><div class=\"line\">    ExecDriver               <span class=\"keyword\">string</span>    <span class=\"comment\">// Docker运行时使用的特定exec驱动</span></div><div class=\"line\">    Mtu                    <span class=\"keyword\">int</span>      <span class=\"comment\">//设置容器网络的MTU</span></div><div class=\"line\">    DisableNetwork          <span class=\"keyword\">bool</span>     <span class=\"comment\">//有定义，之后未初始化</span></div><div class=\"line\">    EnableSelinuxSupport      <span class=\"keyword\">bool</span>     <span class=\"comment\">//启用SELinux功能的支持</span></div><div class=\"line\">    Context                 <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>][]<span class=\"keyword\">string</span>   <span class=\"comment\">//有定义，之后未初始化</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>init()函数实现了daemonCfg变量中各属性的赋值，具体的实现为：daemonCfg.InstallFlags()</p>\n<p><strong>/daemon/config.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// InstallFlags adds command-line options to the top-level flag parser for</span></div><div class=\"line\"><span class=\"comment\">// the current process.</span></div><div class=\"line\"><span class=\"comment\">// Subsequent calls to `flag.Parse` will populate config with values parsed</span></div><div class=\"line\"><span class=\"comment\">// from the command-line.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(config *Config)</span> <span class=\"title\">InstallFlags</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    flag.StringVar(&amp;config.Pidfile, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"p\"</span>, <span class=\"string\">\"-pidfile\"</span>&#125;, <span class=\"string\">\"/var/run/docker.pid\"</span>, <span class=\"string\">\"Path to use for daemon PID file\"</span>)</div><div class=\"line\">    flag.StringVar(&amp;config.Root, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"g\"</span>, <span class=\"string\">\"-graph\"</span>&#125;, <span class=\"string\">\"/var/lib/docker\"</span>, <span class=\"string\">\"Path to use as the root of the Docker runtime\"</span>)</div><div class=\"line\">    flag.BoolVar(&amp;config.AutoRestart, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#r\"</span>, <span class=\"string\">\"#-restart\"</span>&#125;, <span class=\"literal\">true</span>, <span class=\"string\">\"--restart on the daemon has been deprecated infavor of --restart policies on docker run\"</span>)</div><div class=\"line\">    flag.BoolVar(&amp;config.EnableIptables, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#iptables\"</span>, <span class=\"string\">\"-iptables\"</span>&#125;, <span class=\"literal\">true</span>, <span class=\"string\">\"Enable Docker's addition of iptables rules\"</span>)</div><div class=\"line\">    flag.BoolVar(&amp;config.EnableIpForward, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#ip-forward\"</span>, <span class=\"string\">\"-ip-forward\"</span>&#125;, <span class=\"literal\">true</span>, <span class=\"string\">\"Enable net.ipv4.ip_forward\"</span>)</div><div class=\"line\">    flag.StringVar(&amp;config.BridgeIP, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#bip\"</span>, <span class=\"string\">\"-bip\"</span>&#125;, <span class=\"string\">\"\"</span>, <span class=\"string\">\"Use this CIDR notation address for the network bridge's IP, not compatible with -b\"</span>)</div><div class=\"line\">    flag.StringVar(&amp;config.BridgeIface, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"b\"</span>, <span class=\"string\">\"-bridge\"</span>&#125;, <span class=\"string\">\"\"</span>, <span class=\"string\">\"Attach containers to a pre-existing network bridge/nuse 'none' to disable container networking\"</span>)</div><div class=\"line\">    flag.BoolVar(&amp;config.InterContainerCommunication, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#icc\"</span>, <span class=\"string\">\"-icc\"</span>&#125;, <span class=\"literal\">true</span>, <span class=\"string\">\"Enable inter-container communication\"</span>)</div><div class=\"line\">    flag.StringVar(&amp;config.GraphDriver, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"s\"</span>, <span class=\"string\">\"-storage-driver\"</span>&#125;, <span class=\"string\">\"\"</span>, <span class=\"string\">\"Force the Docker runtime to use a specific storage driver\"</span>)</div><div class=\"line\">    flag.StringVar(&amp;config.ExecDriver, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"e\"</span>, <span class=\"string\">\"-exec-driver\"</span>&#125;, <span class=\"string\">\"native\"</span>, <span class=\"string\">\"Force the Docker runtime to use a specific exec driver\"</span>)</div><div class=\"line\">    flag.BoolVar(&amp;config.EnableSelinuxSupport, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-selinux-enabled\"</span>&#125;, <span class=\"literal\">false</span>, <span class=\"string\">\"Enable selinux support. SELinux does not presently support the BTRFS storage driver\"</span>)</div><div class=\"line\">    flag.IntVar(&amp;config.Mtu, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#mtu\"</span>, <span class=\"string\">\"-mtu\"</span>&#125;, <span class=\"number\">0</span>, <span class=\"string\">\"Set the containers network MTU/nif no value is provided: default to the default route MTU or 1500 if no default route is available\"</span>)</div><div class=\"line\">    opts.IPVar(&amp;config.DefaultIp, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#ip\"</span>, <span class=\"string\">\"-ip\"</span>&#125;, <span class=\"string\">\"0.0.0.0\"</span>, <span class=\"string\">\"Default IP address to use when binding container ports\"</span>)</div><div class=\"line\">    opts.ListVar(&amp;config.GraphOptions, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-storage-opt\"</span>&#125;, <span class=\"string\">\"Set storage driver options\"</span>)</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> why the inconsistency between \"hosts\" and \"sockets\"?</span></div><div class=\"line\">    opts.IPListVar(&amp;config.Dns, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#dns\"</span>, <span class=\"string\">\"-dns\"</span>&#125;, <span class=\"string\">\"Force Docker to use specific DNS servers\"</span>)</div><div class=\"line\">    opts.DnsSearchListVar(&amp;config.DnsSearch, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-dns-search\"</span>&#125;, <span class=\"string\">\"Force Docker to use specific DNS search domains\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在InstallFlags()函数的实现过程中，主要是定义某种类型的flag参数，并将该参数的值绑定在config变量的指定属性上，如：</p>\n<p>flag.StringVar(&amp;config.Pidfile, []string{“p”, “-pidfile”}, &quot; /var/run/docker.pid&quot;, “Path to use for daemon PID file”)</p>\n<p>以上语句的含义为：</p>\n<ul>\n<li>定义一个为String类型的flag参数；</li>\n<li>该flag的名称为”p”或者”-pidfile”;</li>\n<li>该flag的值为” /var/run/docker.pid”,并将该值绑定在变量config.Pidfile上；</li>\n<li>该flag的描述信息为&quot;Path to use for daemon PID file&quot;。</li>\n</ul>\n<h3>（二）flag参数检查</h3>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> flag.NArg() != <span class=\"number\">0</span> &#123;</div><div class=\"line\">    flag.Usage()</div><div class=\"line\">    <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>参数个数不为0，则说明在启动Docker Daemon的时候，传入了多余的参数，此时会输出错误提示，并退出运行程序。</li>\n<li>若为0，则说明Docker Daemon的启动命令无误，正常运行。</li>\n</ul>\n<h3>（三）创建engine对象</h3>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">eng := engine.New()</div></pre></td></tr></table></figure>\n<p>Engine是Docker架构中的运行引擎，同时也是Docker运行的核心模块。Engine扮演着Docker container存储仓库的角色，并且通过job的形式来管理这些容器。</p>\n<p><strong>/engine/engine.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Engine <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    handlers   <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Handler</div><div class=\"line\">    catchall   Handler</div><div class=\"line\">    hack       Hack <span class=\"comment\">// data for temporary hackery (see hack.go)</span></div><div class=\"line\">    id         <span class=\"keyword\">string</span></div><div class=\"line\">    Stdout     io.Writer</div><div class=\"line\">    Stderr     io.Writer</div><div class=\"line\">    Stdin      io.Reader</div><div class=\"line\">    Logging    <span class=\"keyword\">bool</span></div><div class=\"line\">    tasks      sync.WaitGroup</div><div class=\"line\">    l          sync.RWMutex <span class=\"comment\">// lock for shutdown</span></div><div class=\"line\">    shutdown   <span class=\"keyword\">bool</span></div><div class=\"line\">    onShutdown []<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> // <span class=\"title\">shutdown</span> <span class=\"title\">handlers</span></span></div><div class=\"line\"><span class=\"function\">&#125;</span></div></pre></td></tr></table></figure>\n<p>Engine结构体中最为重要的即为handlers属性。该handlers属性为map类型，key为string类型，value为Handler类型。Handler为一个定义的函数。该函数传入的参数为Job指针，返回为Status状态。</p>\n<p><strong>/engine/engine.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Handler <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*Job)</span> <span class=\"title\">Status</span></span></div></pre></td></tr></table></figure>\n<p>New()函数的实现:</p>\n<p><strong>/engine/engine.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// New initializes a new engine.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span> *<span class=\"title\">Engine</span></span> &#123;</div><div class=\"line\">    eng := &amp;Engine&#123;</div><div class=\"line\">        handlers: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Handler),</div><div class=\"line\">        id:       utils.RandomString(),</div><div class=\"line\">        Stdout:   os.Stdout,</div><div class=\"line\">        Stderr:   os.Stderr,</div><div class=\"line\">        Stdin:    os.Stdin,</div><div class=\"line\">        Logging:  <span class=\"literal\">true</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\">    eng.Register(<span class=\"string\">\"commands\"</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(job *Job)</span> <span class=\"title\">Status</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> _, name := <span class=\"keyword\">range</span> eng.commands() &#123;</div><div class=\"line\">            job.Printf(<span class=\"string\">\"%s/n\"</span>, name)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> StatusOK</div><div class=\"line\">    &#125;)</div><div class=\"line\">    <span class=\"comment\">// Copy existing global handlers</span></div><div class=\"line\">    <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> globalHandlers &#123;</div><div class=\"line\">        eng.handlers[k] = v</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> eng</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>创建一个Engine结构体实例eng</li>\n<li>向eng对象注册名为commands的Handler，其中Handler为临时定义的函数func(job *Job) Status{ } , 该函数的作用是通过job来打印所有已经注册完毕的command名称，最终返回状态StatusOK。</li>\n<li>将已定义的变量globalHandlers中的所有的Handler，都复制到eng对象的handlers属性中。最后成功返回eng对象。</li>\n</ol>\n<h3>（四）设置engine的信号捕获</h3>\n<p><strong>/daemon/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">signal.Trap(eng.Shutdown)</div></pre></td></tr></table></figure>\n<p>在Docker Daemon的运行中，设置Trap特定信号的处理方法，特定信号有SIGINT，SIGTERM以及SIGQUIT；当程序捕获到SIGINT或者SIGTERM信号时，执行相应的善后操作，最后保证Docker Daemon程序退出。</p>\n<p><strong>/pkg/signal/trap.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Trap sets up a simplified signal \"trap\", appropriate for common</span></div><div class=\"line\"><span class=\"comment\">// behavior expected from a vanilla unix command-line tool in general</span></div><div class=\"line\"><span class=\"comment\">// (and the Docker engine in particular).</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"comment\">// * If SIGINT or SIGTERM are received, `cleanup` is called, then the process is terminated.</span></div><div class=\"line\"><span class=\"comment\">// * If SIGINT or SIGTERM are repeated 3 times before cleanup is complete, then cleanup is</span></div><div class=\"line\"><span class=\"comment\">// skipped and the process terminated directly.</span></div><div class=\"line\"><span class=\"comment\">// * If \"DEBUG\" is set in the environment, SIGQUIT causes an exit without cleanup.</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Trap</span><span class=\"params\">(cleanup <span class=\"keyword\">func</span>()</span>)</span> &#123;</div><div class=\"line\">    c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> os.Signal, <span class=\"number\">1</span>)</div><div class=\"line\">    signals := []os.Signal&#123;os.Interrupt, syscall.SIGTERM&#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> os.Getenv(<span class=\"string\">\"DEBUG\"</span>) == <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        signals = <span class=\"built_in\">append</span>(signals, syscall.SIGQUIT)</div><div class=\"line\">    &#125;</div><div class=\"line\">    gosignal.Notify(c, signals...)</div><div class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        interruptCount := <span class=\"keyword\">uint32</span>(<span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">for</span> sig := <span class=\"keyword\">range</span> c &#123;</div><div class=\"line\">            <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(sig os.Signal)</span></span> &#123;</div><div class=\"line\">                log.Printf(<span class=\"string\">\"Received signal '%v', starting shutdown of docker.../n\"</span>, sig)</div><div class=\"line\">                <span class=\"keyword\">switch</span> sig &#123;</div><div class=\"line\">                <span class=\"keyword\">case</span> os.Interrupt, syscall.SIGTERM:</div><div class=\"line\">                    <span class=\"comment\">// If the user really wants to interrupt, let him do so.</span></div><div class=\"line\">                    <span class=\"keyword\">if</span> atomic.LoadUint32(&amp;interruptCount) &lt; <span class=\"number\">3</span> &#123;</div><div class=\"line\">                        atomic.AddUint32(&amp;interruptCount, <span class=\"number\">1</span>)</div><div class=\"line\">                        <span class=\"comment\">// Initiate the cleanup only once</span></div><div class=\"line\">                        <span class=\"keyword\">if</span> atomic.LoadUint32(&amp;interruptCount) == <span class=\"number\">1</span> &#123;</div><div class=\"line\">                            <span class=\"comment\">// Call cleanup handler</span></div><div class=\"line\">                            cleanup()</div><div class=\"line\">                            os.Exit(<span class=\"number\">0</span>)</div><div class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                            <span class=\"keyword\">return</span></div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                        log.Printf(<span class=\"string\">\"Force shutdown of docker, interrupting cleanup/n\"</span>)</div><div class=\"line\">                    &#125;</div><div class=\"line\">                <span class=\"keyword\">case</span> syscall.SIGQUIT:</div><div class=\"line\">                &#125;</div><div class=\"line\">                os.Exit(<span class=\"number\">128</span> + <span class=\"keyword\">int</span>(sig.(syscall.Signal)))</div><div class=\"line\">            &#125;(sig)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>创建并设置一个channel，用于发送信号通知；</li>\n<li>定义signals数组变量，初始值为os.SIGINT, os.SIGTERM;若环境变量DEBUG为空的话，则添加os.SIGQUIT至signals数组；</li>\n<li>通过gosignal.Notify(c, signals…)中Notify函数来实现将接收到的signal信号传递给c。需要注意的是只有signals中被罗列出的信号才会被传递给c，其余信号会被直接忽略；</li>\n<li>创建一个goroutine来处理具体的signal信号，当信号类型为os.Interrupt或者syscall.SIGTERM时，执行传入Trap函数的具体执行方法，形参为cleanup(),实参为eng.Shutdown。</li>\n</ul>\n<p>Shutdown()函数的定义位于<a href=\"https://github.com/docker/docker/blob/v1.2.0/engine/engine.go#L153\" target=\"_blank\" rel=\"external\">./docker/engine/engine.go</a>，主要做的工作是为Docker Daemon的关闭做一些善后工作。</p>\n<p><strong>/engine/engine.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Shutdown permanently shuts down eng as follows:</span></div><div class=\"line\"><span class=\"comment\">// - It refuses all new jobs, permanently.</span></div><div class=\"line\"><span class=\"comment\">// - It waits for all active jobs to complete (with no timeout)</span></div><div class=\"line\"><span class=\"comment\">// - It calls all shutdown handlers concurrently (if any)</span></div><div class=\"line\"><span class=\"comment\">// - It returns when all handlers complete, or after 15 seconds,</span></div><div class=\"line\"><span class=\"comment\">//    whichever happens first.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(eng *Engine)</span> <span class=\"title\">Shutdown</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    eng.l.Lock()</div><div class=\"line\">    <span class=\"keyword\">if</span> eng.shutdown &#123;</div><div class=\"line\">        eng.l.Unlock()</div><div class=\"line\">        <span class=\"keyword\">return</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    eng.shutdown = <span class=\"literal\">true</span></div><div class=\"line\">    eng.l.Unlock()</div><div class=\"line\">    <span class=\"comment\">// We don't need to protect the rest with a lock, to allow</span></div><div class=\"line\">    <span class=\"comment\">// for other calls to immediately fail with \"shutdown\" instead</span></div><div class=\"line\">    <span class=\"comment\">// of hanging for 15 seconds.</span></div><div class=\"line\">    <span class=\"comment\">// This requires all concurrent calls to check for shutdown, otherwise</span></div><div class=\"line\">    <span class=\"comment\">// it might cause a race.</span></div><div class=\"line\">    <span class=\"comment\">// Wait for all jobs to complete.</span></div><div class=\"line\">    <span class=\"comment\">// Timeout after 5 seconds.</span></div><div class=\"line\">    tasksDone := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</div><div class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        eng.tasks.Wait()</div><div class=\"line\">        <span class=\"built_in\">close</span>(tasksDone)</div><div class=\"line\">    &#125;()</div><div class=\"line\">    <span class=\"keyword\">select</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> &lt;-time.After(time.Second * <span class=\"number\">5</span>):</div><div class=\"line\">    <span class=\"keyword\">case</span> &lt;-tasksDone:</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Call shutdown handlers, if any.</span></div><div class=\"line\">    <span class=\"comment\">// Timeout after 10 seconds.</span></div><div class=\"line\">    <span class=\"keyword\">var</span> wg sync.WaitGroup</div><div class=\"line\">    <span class=\"keyword\">for</span> _, h := <span class=\"keyword\">range</span> eng.onShutdown &#123;</div><div class=\"line\">        wg.Add(<span class=\"number\">1</span>)</div><div class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(h <span class=\"keyword\">func</span>()</span>)</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">defer</span> wg.Done()</div><div class=\"line\">            h()</div><div class=\"line\">        &#125;(h)</div><div class=\"line\">    &#125;</div><div class=\"line\">    done := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</div><div class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        wg.Wait()</div><div class=\"line\">        <span class=\"built_in\">close</span>(done)</div><div class=\"line\">    &#125;()</div><div class=\"line\">    <span class=\"keyword\">select</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> &lt;-time.After(time.Second * <span class=\"number\">10</span>):</div><div class=\"line\">    <span class=\"keyword\">case</span> &lt;-done:</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>Docker Daemon不再接收任何新的Job；</li>\n<li>Docker Daemon等待所有存活的Job执行完毕；</li>\n<li>Docker Daemon调用所有shutdown的处理方法；</li>\n<li>当所有的handler执行完毕，或者15秒之后，Shutdown()函数返回。</li>\n</ul>\n<p>由于在signal.Trap( eng.Shutdown )函数的具体实现中执行eng.Shutdown，在执行完eng.Shutdown之后，随即执行<a href=\"https://github.com/docker/docker/blob/v1.2.0/pkg/signal/trap.go#L41\" target=\"_blank\" rel=\"external\">os.Exit(0)</a>，完成当前程序的立即退出。</p>\n<h3>（五）加载builtins</h3>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> err := builtins.Register(eng); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    log.Fatal(err)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为engine注册多个Handler，以便后续在执行相应任务时，运行指定的Handler。</p>\n<p>这些Handler包括：</p>\n<ul>\n<li>网络初始化、</li>\n<li>web API服务、</li>\n<li>事件查询、</li>\n<li>版本查看、</li>\n<li>Docker Registry验证与搜索。</li>\n</ul>\n<p><strong>/builtins/builtins.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Register</span><span class=\"params\">(eng *engine.Engine)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> err := daemon(eng); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> err := remote(eng); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> err := events.New().Install(eng); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> err := eng.Register(<span class=\"string\">\"version\"</span>, dockerVersion); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> registry.NewService().Install(eng)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4>1、注册初始化网络驱动的Handler</h4>\n<p>daemon(eng)的实现过程，主要为eng对象注册了一个key为”init_networkdriver”的Handler，该Handler的值为bridge.InitDriver函数，代码如下：</p>\n<p><strong>/builtins/builtins.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">daemon</span><span class=\"params\">(eng *engine.Engine)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> eng.Register(<span class=\"string\">\"init_networkdriver\"</span>, bridge.InitDriver)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要注意的是，向eng对象注册Handler，并不代表Handler的值函数会被直接运行，如bridge.InitDriver，并不会直接运行，而是将bridge.InitDriver的函数入口，写入eng的handlers属性中。</p>\n<p><strong>/daemon/networkdriver/bridge/driver.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">InitDriver</span><span class=\"params\">(job *engine.Job)</span> <span class=\"title\">engine</span>.<span class=\"title\">Status</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> (</div><div class=\"line\">        network        *net.IPNet</div><div class=\"line\">        enableIPTables = job.GetenvBool(<span class=\"string\">\"EnableIptables\"</span>)</div><div class=\"line\">        icc            = job.GetenvBool(<span class=\"string\">\"InterContainerCommunication\"</span>)</div><div class=\"line\">        ipForward      = job.GetenvBool(<span class=\"string\">\"EnableIpForward\"</span>)</div><div class=\"line\">        bridgeIP       = job.Getenv(<span class=\"string\">\"BridgeIP\"</span>)</div><div class=\"line\">    )</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> defaultIP := job.Getenv(<span class=\"string\">\"DefaultBindingIP\"</span>); defaultIP != <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        defaultBindingIP = net.ParseIP(defaultIP)</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    bridgeIface = job.Getenv(<span class=\"string\">\"BridgeIface\"</span>)</div><div class=\"line\">    usingDefaultBridge := <span class=\"literal\">false</span></div><div class=\"line\">    <span class=\"keyword\">if</span> bridgeIface == <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        usingDefaultBridge = <span class=\"literal\">true</span></div><div class=\"line\">        bridgeIface = DefaultNetworkBridge</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    addr, err := networkdriver.GetIfaceAddr(bridgeIface)</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// If we're not using the default bridge, fail without trying to create it</span></div><div class=\"line\">        <span class=\"keyword\">if</span> !usingDefaultBridge &#123;</div><div class=\"line\">            job.Logf(<span class=\"string\">\"bridge not found: %s\"</span>, bridgeIface)</div><div class=\"line\">            <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// If the iface is not found, try to create it</span></div><div class=\"line\">        job.Logf(<span class=\"string\">\"creating new bridge for %s\"</span>, bridgeIface)</div><div class=\"line\">        <span class=\"keyword\">if</span> err := createBridge(bridgeIP); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        job.Logf(<span class=\"string\">\"getting iface addr\"</span>)</div><div class=\"line\">        addr, err = networkdriver.GetIfaceAddr(bridgeIface)</div><div class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">        &#125;</div><div class=\"line\">        network = addr.(*net.IPNet)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        network = addr.(*net.IPNet)</div><div class=\"line\">        <span class=\"comment\">// validate that the bridge ip matches the ip specified by BridgeIP</span></div><div class=\"line\">        <span class=\"keyword\">if</span> bridgeIP != <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">            bip, _, err := net.ParseCIDR(bridgeIP)</div><div class=\"line\">            <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> !network.IP.Equal(bip) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> job.Errorf(<span class=\"string\">\"bridge ip (%s) does not match existing bridge configuration %s\"</span>, network.IP, bip)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">// Configure iptables for link support</span></div><div class=\"line\">    <span class=\"keyword\">if</span> enableIPTables &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> err := setupIPTables(addr, icc); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> ipForward &#123;</div><div class=\"line\">        <span class=\"comment\">// Enable IPv4 forwarding</span></div><div class=\"line\">        <span class=\"keyword\">if</span> err := ioutil.WriteFile(<span class=\"string\">\"/proc/sys/net/ipv4/ip_forward\"</span>, []<span class=\"keyword\">byte</span>&#123;<span class=\"string\">'1'</span>, <span class=\"string\">'/n'</span>&#125;, <span class=\"number\">0644</span>); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            job.Logf(<span class=\"string\">\"WARNING: unable to enable IPv4 forwarding: %s/n\"</span>, err)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">// We can always try removing the iptables</span></div><div class=\"line\">    <span class=\"keyword\">if</span> err := iptables.RemoveExistingChain(<span class=\"string\">\"DOCKER\"</span>); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> enableIPTables &#123;</div><div class=\"line\">        chain, err := iptables.NewChain(<span class=\"string\">\"DOCKER\"</span>, bridgeIface)</div><div class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">        &#125;</div><div class=\"line\">        portmapper.SetIptablesChain(chain)</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    bridgeNetwork = network</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">// https://github.com/docker/docker/issues/2768</span></div><div class=\"line\">    job.Eng.Hack_SetGlobalVar(<span class=\"string\">\"httpapi.bridgeIP\"</span>, bridgeNetwork.IP)</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">for</span> name, f := <span class=\"keyword\">range</span> <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]engine.Handler&#123;</div><div class=\"line\">        <span class=\"string\">\"allocate_interface\"</span>: Allocate,</div><div class=\"line\">        <span class=\"string\">\"release_interface\"</span>:  Release,</div><div class=\"line\">        <span class=\"string\">\"allocate_port\"</span>:      AllocatePort,</div><div class=\"line\">        <span class=\"string\">\"link\"</span>:               LinkContainers,</div><div class=\"line\">    &#125; &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> err := job.Eng.Register(name, f); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> engine.StatusOK</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Bridge.InitDriver的作用：</p>\n<ul>\n<li>获取为Docker服务的网络设备的地址；</li>\n<li>创建指定IP地址的网桥；</li>\n<li>配置网络iptables规则；</li>\n<li>另外还为eng对象注册了多个Handler,如 ”allocate_interface”， ”release_interface”， ”allocate_port”，”link”。</li>\n</ul>\n<h4>2、注册API服务的Handler</h4>\n<p>remote(eng)的实现过程，主要为eng对象注册了两个Handler，分别为”serveapi”与”acceptconnections”。代码实现如下：</p>\n<p><strong>/builtins/builtins.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">remote</span><span class=\"params\">(eng *engine.Engine)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> err := eng.Register(<span class=\"string\">\"serveapi\"</span>, apiserver.ServeApi); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> eng.Register(<span class=\"string\">\"acceptconnections\"</span>, apiserver.AcceptConnections)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注册的两个Handler名称分别为”serveapi”与”acceptconnections”</p>\n<ul>\n<li>ServeApi执行时，通过循环多种协议，创建出goroutine来配置指定的http.Server，最终为不同的协议请求服务；</li>\n<li>AcceptConnections的实现主要是为了通知init守护进程，Docker Daemon已经启动完毕，可以让Docker Daemon进程接受请求。(守护进程)</li>\n</ul>\n<h4>3、注册events事件的Handler</h4>\n<p>events.New().Install(eng)的实现过程，为Docker注册了多个event事件，功能是给Docker用户提供API，使得用户可以通过这些API查看Docker内部的events信息，log信息以及subscribers_count信息。</p>\n<p><strong>/events/events.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Events <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    mu          sync.RWMutex</div><div class=\"line\">    events      []*utils.JSONMessage</div><div class=\"line\">    subscribers []listener</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span> *<span class=\"title\">Events</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &amp;Events&#123;</div><div class=\"line\">        events: <span class=\"built_in\">make</span>([]*utils.JSONMessage, <span class=\"number\">0</span>, eventsLimit),</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Install installs events public api in docker engine</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Events)</span> <span class=\"title\">Install</span><span class=\"params\">(eng *engine.Engine)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Here you should describe public interface</span></div><div class=\"line\">    jobs := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]engine.Handler&#123;</div><div class=\"line\">        <span class=\"string\">\"events\"</span>:            e.Get,</div><div class=\"line\">        <span class=\"string\">\"log\"</span>:               e.Log,</div><div class=\"line\">        <span class=\"string\">\"subscribers_count\"</span>: e.SubscribersCount,</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> name, job := <span class=\"keyword\">range</span> jobs &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> err := eng.Register(name, job); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> err</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4>4、注册版本的Handler</h4>\n<p>eng.Register(“version”,dockerVersion)的实现过程，向eng对象注册key为”version”，value为”dockerVersion”执行方法的Handler，dockerVersion的执行过程中，会向名为version的job的标准输出中写入Docker的版本，Docker API的版本，git版本，Go语言运行时版本以及操作系统等版本信息。</p>\n<p><strong>/builtins/builtins.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// builtins jobs independent of any subsystem</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dockerVersion</span><span class=\"params\">(job *engine.Job)</span> <span class=\"title\">engine</span>.<span class=\"title\">Status</span></span> &#123;</div><div class=\"line\">    v := &amp;engine.Env&#123;&#125;</div><div class=\"line\">    v.SetJson(<span class=\"string\">\"Version\"</span>, dockerversion.VERSION)</div><div class=\"line\">    v.SetJson(<span class=\"string\">\"ApiVersion\"</span>, api.APIVERSION)</div><div class=\"line\">    v.Set(<span class=\"string\">\"GitCommit\"</span>, dockerversion.GITCOMMIT)</div><div class=\"line\">    v.Set(<span class=\"string\">\"GoVersion\"</span>, runtime.Version())</div><div class=\"line\">    v.Set(<span class=\"string\">\"Os\"</span>, runtime.GOOS)</div><div class=\"line\">    v.Set(<span class=\"string\">\"Arch\"</span>, runtime.GOARCH)</div><div class=\"line\">    <span class=\"keyword\">if</span> kernelVersion, err := kernel.GetKernelVersion(); err == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        v.Set(<span class=\"string\">\"KernelVersion\"</span>, kernelVersion.String())</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> _, err := v.WriteTo(job.Stdout); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> engine.StatusOK</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4>5、注册registry的Handler</h4>\n<p>registry.NewService().Install(eng)的实现过程位于<a href=\"https://github.com/docker/docker/blob/v1.2.0/registry/service.go#L25\" target=\"_blank\" rel=\"external\">./docker/registry/service.go</a>，在eng对象对外暴露的API信息中添加docker registry的信息。当registry.NewService()成功被Install安装完毕的话，则有两个调用能够被eng使用：”auth”，向公有registry进行认证；”search”，在公有registry上搜索指定的镜像。</p>\n<p><strong>/registry/service.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// NewService returns a new instance of Service ready to be</span></div><div class=\"line\"><span class=\"comment\">// installed no an engine.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewService</span><span class=\"params\">()</span> *<span class=\"title\">Service</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &amp;Service&#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Install installs registry capabilities to eng.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Service)</span> <span class=\"title\">Install</span><span class=\"params\">(eng *engine.Engine)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    eng.Register(<span class=\"string\">\"auth\"</span>, s.Auth)</div><div class=\"line\">    eng.Register(<span class=\"string\">\"search\"</span>, s.Search)</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>（六）使用goroutine加载daemon对象</h3>\n<p>执行完builtins的加载，回到mainDaemon()的执行，通过一个goroutine来加载daemon对象并开始运行。这一环节的执行，主要包含三个步骤：</p>\n<ul>\n<li>通过init函数中初始化的daemonCfg与eng对象来创建一个daemon对象d；(守护进程)</li>\n<li>通过daemon对象的Install函数，向eng对象中注册众多的Handler；</li>\n<li>在Docker Daemon启动完毕之后，运行名为”acceptconnections”的job，主要工作为向init守护进程发送”READY=1”信号，以便开始正常接受请求。</li>\n</ul>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// load the daemon in the background so we can immediately start</span></div><div class=\"line\"><span class=\"comment\">// the http api so that connections don't fail while the daemon</span></div><div class=\"line\"><span class=\"comment\">// is booting</span></div><div class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    d, err := daemon.NewDaemon(daemonCfg, eng)</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        log.Fatal(err)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> err := d.Install(eng); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        log.Fatal(err)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// after the daemon is done setting up we can tell the api to start</span></div><div class=\"line\">    <span class=\"comment\">// accepting connections</span></div><div class=\"line\">    <span class=\"keyword\">if</span> err := eng.Job(<span class=\"string\">\"acceptconnections\"</span>).Run(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        log.Fatal(err)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;()</div></pre></td></tr></table></figure>\n<h4>1、创建daemon对象</h4>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">d, err := daemon.NewDaemon(daemonCfg, eng)</div><div class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    log.Fatal(err)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>daemon.NewDaemon(daemonCfg, eng)是创建daemon对象d的核心部分。主要作用为初始化Docker Daemon的基本环境，如处理config参数，验证系统支持度，配置Docker工作目录，设置与加载多种driver，创建graph环境等，验证DNS配置等。具体参考<a href=\"http://wiki.haplat.net/display/~huwh/NewDaemon\" target=\"_blank\" rel=\"external\">NewDaemon</a> 。</p>\n<h4>2、通过daemon对象为engine注册Handler</h4>\n<p>当创建完daemon对象，goroutine执行d.Install(eng)</p>\n<p><strong>/daemon/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Daemon <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    repository     <span class=\"keyword\">string</span></div><div class=\"line\">    sysInitPath    <span class=\"keyword\">string</span></div><div class=\"line\">    containers     *contStore</div><div class=\"line\">    graph          *graph.Graph</div><div class=\"line\">    repositories   *graph.TagStore</div><div class=\"line\">    idIndex        *truncindex.TruncIndex</div><div class=\"line\">    sysInfo        *sysinfo.SysInfo</div><div class=\"line\">    volumes        *graph.Graph</div><div class=\"line\">    eng            *engine.Engine</div><div class=\"line\">    config         *Config</div><div class=\"line\">    containerGraph *graphdb.Database</div><div class=\"line\">    driver         graphdriver.Driver</div><div class=\"line\">    execDriver     execdriver.Driver</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Install installs daemon capabilities to eng.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(daemon *Daemon)</span> <span class=\"title\">Install</span><span class=\"params\">(eng *engine.Engine)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> rename \"delete\" to \"rm\" for consistency with the CLI command</span></div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> rename ContainerDestroy to ContainerRm for consistency with the CLI command</span></div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> remove ImageDelete's dependency on Daemon, then move to graph/</span></div><div class=\"line\">    <span class=\"keyword\">for</span> name, method := <span class=\"keyword\">range</span> <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]engine.Handler&#123;</div><div class=\"line\">        <span class=\"string\">\"attach\"</span>:            daemon.ContainerAttach,</div><div class=\"line\">        <span class=\"string\">\"build\"</span>:             daemon.CmdBuild,</div><div class=\"line\">        <span class=\"string\">\"commit\"</span>:            daemon.ContainerCommit,</div><div class=\"line\">        <span class=\"string\">\"container_changes\"</span>: daemon.ContainerChanges,</div><div class=\"line\">        <span class=\"string\">\"container_copy\"</span>:    daemon.ContainerCopy,</div><div class=\"line\">        <span class=\"string\">\"container_inspect\"</span>: daemon.ContainerInspect,</div><div class=\"line\">        <span class=\"string\">\"containers\"</span>:        daemon.Containers,</div><div class=\"line\">        <span class=\"string\">\"create\"</span>:            daemon.ContainerCreate,</div><div class=\"line\">        <span class=\"string\">\"delete\"</span>:            daemon.ContainerDestroy,</div><div class=\"line\">        <span class=\"string\">\"export\"</span>:            daemon.ContainerExport,</div><div class=\"line\">        <span class=\"string\">\"info\"</span>:              daemon.CmdInfo,</div><div class=\"line\">        <span class=\"string\">\"kill\"</span>:              daemon.ContainerKill,</div><div class=\"line\">        <span class=\"string\">\"logs\"</span>:              daemon.ContainerLogs,</div><div class=\"line\">        <span class=\"string\">\"pause\"</span>:             daemon.ContainerPause,</div><div class=\"line\">        <span class=\"string\">\"resize\"</span>:            daemon.ContainerResize,</div><div class=\"line\">        <span class=\"string\">\"restart\"</span>:           daemon.ContainerRestart,</div><div class=\"line\">        <span class=\"string\">\"start\"</span>:             daemon.ContainerStart,</div><div class=\"line\">        <span class=\"string\">\"stop\"</span>:              daemon.ContainerStop,</div><div class=\"line\">        <span class=\"string\">\"top\"</span>:               daemon.ContainerTop,</div><div class=\"line\">        <span class=\"string\">\"unpause\"</span>:           daemon.ContainerUnpause,</div><div class=\"line\">        <span class=\"string\">\"wait\"</span>:              daemon.ContainerWait,</div><div class=\"line\">        <span class=\"string\">\"image_delete\"</span>:      daemon.ImageDelete, <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> see above</span></div><div class=\"line\">    &#125; &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> err := eng.Register(name, method); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> err</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> err := daemon.Repositories().Install(eng); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> this hack is necessary for legacy integration tests to access</span></div><div class=\"line\">    <span class=\"comment\">// the daemon object.</span></div><div class=\"line\">    eng.Hack_SetGlobalVar(<span class=\"string\">\"httpapi.daemon\"</span>, daemon)</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上代码的实现分为三部分：</p>\n<ul>\n<li>向eng对象中注册众多的Handler对象；</li>\n<li>daemon.Repositories().Install(eng)实现了向eng对象注册多个与image相关的Handler，Install的实现位于<a href=\"https://github.com/docker/docker/blob/v1.2.0/graph/service.go#L12\" target=\"_blank\" rel=\"external\">./docker/graph/service.go</a>；</li>\n<li>eng.Hack_SetGlobalVar(“httpapi.daemon”, daemon)实现向eng对象中map类型的hack对象中添加一条记录，key为”httpapi.daemon”，value为daemon。</li>\n</ul>\n<h4>3、运行acceptconnections的job</h4>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> err := eng.Job(<span class=\"string\">\"acceptconnections\"</span>).Run(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    log.Fatal(err)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在goroutine内部最后运行名为”acceptconnections”的job，主要作用是通知init守护进程，Docker Daemon可以开始接受请求了。</p>\n<p>首先执行eng.Job(“acceptconnections”)，返回一个Job，随后再执行eng.Job(“acceptconnections”).Run()，也就是该执行Job的run函数。</p>\n<p><strong>/engine/engine.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Job creates a new job which can later be executed.</span></div><div class=\"line\"><span class=\"comment\">// This function mimics `Command` from the standard os/exec package.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(eng *Engine)</span> <span class=\"title\">Job</span><span class=\"params\">(name <span class=\"keyword\">string</span>, args ...<span class=\"keyword\">string</span>)</span> *<span class=\"title\">Job</span></span> &#123;</div><div class=\"line\">    job := &amp;Job&#123;</div><div class=\"line\">        Eng:    eng,</div><div class=\"line\">        Name:   name,</div><div class=\"line\">        Args:   args,</div><div class=\"line\">        Stdin:  NewInput(),</div><div class=\"line\">        Stdout: NewOutput(),</div><div class=\"line\">        Stderr: NewOutput(),</div><div class=\"line\">        env:    &amp;Env&#123;&#125;,</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> eng.Logging &#123;</div><div class=\"line\">        job.Stderr.Add(utils.NopWriteCloser(eng.Stderr))</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Catchall is shadowed by specific Register.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> handler, exists := eng.handlers[name]; exists &#123;</div><div class=\"line\">        job.handler = handler</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> eng.catchall != <span class=\"literal\">nil</span> &amp;&amp; name != <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// empty job names are illegal, catchall or not.</span></div><div class=\"line\">        job.handler = eng.catchall</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> job</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>首先创建一个类型为Job的job对象，该对象中Eng属性为函数的调用者eng，Name属性为”acceptconnections”，没有参数传入。</li>\n<li>另外在eng对象所有的handlers属性中寻找键为”acceptconnections”记录的值，由于在加载builtins操作中的remote(eng)中已经向eng注册过这样的一条记录，key为”acceptconnections”，value为apiserver.AcceptConnections。</li>\n<li>因此job对象的handler为apiserver.AcceptConnections。</li>\n<li>最后返回已经初始化完毕的对象job。</li>\n</ol>\n<p>创建完job对象之后，随即执行该job对象的run()函数。</p>\n<p><strong>/engine/job.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// A job is the fundamental unit of work in the docker engine.</span></div><div class=\"line\"><span class=\"comment\">// Everything docker can do should eventually be exposed as a job.</span></div><div class=\"line\"><span class=\"comment\">// For example: execute a process in a container, create a new container,</span></div><div class=\"line\"><span class=\"comment\">// download an archive from the internet, serve the http api, etc.</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"comment\">// The job API is designed after unix processes: a job has a name, arguments,</span></div><div class=\"line\"><span class=\"comment\">// environment variables, standard streams for input, output and error, and</span></div><div class=\"line\"><span class=\"comment\">// an exit status which can indicate success (0) or error (anything else).</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"comment\">// One slight variation is that jobs report their status as a string. The</span></div><div class=\"line\"><span class=\"comment\">// string \"0\" indicates success, and any other strings indicates an error.</span></div><div class=\"line\"><span class=\"comment\">// This allows for richer error reporting.</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"keyword\">type</span> Job <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    Eng     *Engine</div><div class=\"line\">    Name    <span class=\"keyword\">string</span></div><div class=\"line\">    Args    []<span class=\"keyword\">string</span></div><div class=\"line\">    env     *Env</div><div class=\"line\">    Stdout  *Output</div><div class=\"line\">    Stderr  *Output</div><div class=\"line\">    Stdin   *Input</div><div class=\"line\">    handler Handler</div><div class=\"line\">    status  Status</div><div class=\"line\">    end     time.Time</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">type</span> Status <span class=\"keyword\">int</span></div><div class=\"line\"><span class=\"keyword\">const</span> (</div><div class=\"line\">    StatusOK       Status = <span class=\"number\">0</span></div><div class=\"line\">    StatusErr      Status = <span class=\"number\">1</span></div><div class=\"line\">    StatusNotFound Status = <span class=\"number\">127</span></div><div class=\"line\">)</div><div class=\"line\"><span class=\"comment\">// Run executes the job and blocks until the job completes.</span></div><div class=\"line\"><span class=\"comment\">// If the job returns a failure status, an error is returned</span></div><div class=\"line\"><span class=\"comment\">// which includes the status.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(job *Job)</span> <span class=\"title\">Run</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> job.Eng.IsShutdown() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">\"engine is shutdown\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> this is a temporary workaround to avoid Engine.Shutdown</span></div><div class=\"line\">    <span class=\"comment\">// waiting 5 seconds for server/api.ServeApi to complete (which it never will)</span></div><div class=\"line\">    <span class=\"comment\">// everytime the daemon is cleanly restarted.</span></div><div class=\"line\">    <span class=\"comment\">// The permanent fix is to implement Job.Stop and Job.OnStop so that</span></div><div class=\"line\">    <span class=\"comment\">// ServeApi can cooperate and terminate cleanly.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> job.Name != <span class=\"string\">\"serveapi\"</span> &#123;</div><div class=\"line\">        job.Eng.l.Lock()</div><div class=\"line\">        job.Eng.tasks.Add(<span class=\"number\">1</span>)</div><div class=\"line\">        job.Eng.l.Unlock()</div><div class=\"line\">        <span class=\"keyword\">defer</span> job.Eng.tasks.Done()</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> make this thread-safe</span></div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> implement wait</span></div><div class=\"line\">    <span class=\"keyword\">if</span> !job.end.IsZero() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">\"%s: job has already completed\"</span>, job.Name)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Log beginning and end of the job</span></div><div class=\"line\">    job.Eng.Logf(<span class=\"string\">\"+job %s\"</span>, job.CallString())</div><div class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        job.Eng.Logf(<span class=\"string\">\"-job %s%s\"</span>, job.CallString(), job.StatusString())</div><div class=\"line\">    &#125;()</div><div class=\"line\">    <span class=\"keyword\">var</span> errorMessage = bytes.NewBuffer(<span class=\"literal\">nil</span>)</div><div class=\"line\">    job.Stderr.Add(errorMessage)</div><div class=\"line\">    <span class=\"keyword\">if</span> job.handler == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        job.Errorf(<span class=\"string\">\"%s: command not found\"</span>, job.Name)</div><div class=\"line\">        job.status = <span class=\"number\">127</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        job.status = job.handler(job)</div><div class=\"line\">        job.end = time.Now()</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Wait for all background tasks to complete</span></div><div class=\"line\">    <span class=\"keyword\">if</span> err := job.Stdout.Close(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> err := job.Stderr.Close(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> err := job.Stdin.Close(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> job.status != <span class=\"number\">0</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">\"%s\"</span>, Tail(errorMessage, <span class=\"number\">1</span>))</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Run()函数的实现位于<a href=\"https://github.com/docker/docker/blob/v1.2.0/engine/job.go#L48\" target=\"_blank\" rel=\"external\">./docker/engine/job.go</a>，该函数执行指定的job，并在job执行完成前一直阻塞。对于名为”acceptconnections”的job对象，运行代码为<a href=\"https://github.com/docker/docker/blob/v1.2.0/engine/job.go#L79\" target=\"_blank\" rel=\"external\">job.status = job.handler(job)</a>，由于job.handler值为apiserver.AcceptConnections，故真正执行的是job.status = apiserver.AcceptConnections(job)。</p>\n<p>进入AcceptConnections的具体实现，位于<a href=\"https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1370\" target=\"_blank\" rel=\"external\">./docker/api/server/server.go</a>,如下：</p>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">AcceptConnections</span><span class=\"params\">(job *engine.Job)</span> <span class=\"title\">engine</span>.<span class=\"title\">Status</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Tell the init daemon we are accepting requests</span></div><div class=\"line\">    <span class=\"keyword\">go</span>  systemd.SdNotify(<span class=\"string\">\"READY=1\"</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> activationLock != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">close</span>(activationLock)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> engine.StatusOK</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>重点为go systemd.SdNotify(“READY=1”)的实现，位于<a href=\"https://github.com/docker/docker/blob/v1.2.0/pkg/systemd/sd_notify.go#L12\" target=\"_blank\" rel=\"external\">./docker/pkg/system/sd_notify.go</a>，主要作用是通知init守护进程Docker Daemon的启动已经全部完成，潜在的功能是使得Docker Daemon开始接受Docker Client发送来的API请求。</p>\n<p>至此，已经完成通过goroutine来加载daemon对象并运行。</p>\n<h3>（七）打印Docker版本及驱动信息</h3>\n<p>显示docker的版本信息，以及ExecDriver和GraphDriver这两个驱动的具体信息</p>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// TODO actually have a resolved graphdriver to show?</span></div><div class=\"line\">log.Printf(<span class=\"string\">\"docker daemon: %s %s; execdriver: %s; graphdriver: %s\"</span>,</div><div class=\"line\">    dockerversion.VERSION,</div><div class=\"line\">    dockerversion.GITCOMMIT,</div><div class=\"line\">    daemonCfg.ExecDriver,</div><div class=\"line\">    daemonCfg.GraphDriver,</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<h3>（八）serveapi的创建与运行</h3>\n<p>打印部分Docker具体信息之后，Docker Daemon立即创建并运行名为”serveapi”的job，主要作用为让Docker Daemon提供API访问服务。</p>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Serve api</span></div><div class=\"line\">job := eng.Job(<span class=\"string\">\"serveapi\"</span>, flHosts...)</div><div class=\"line\">job.SetenvBool(<span class=\"string\">\"Logging\"</span>, <span class=\"literal\">true</span>)</div><div class=\"line\">job.SetenvBool(<span class=\"string\">\"EnableCors\"</span>, *flEnableCors)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"Version\"</span>, dockerversion.VERSION)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"SocketGroup\"</span>, *flSocketGroup)</div><div class=\"line\">job.SetenvBool(<span class=\"string\">\"Tls\"</span>, *flTls)</div><div class=\"line\">job.SetenvBool(<span class=\"string\">\"TlsVerify\"</span>, *flTlsVerify)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"TlsCa\"</span>, *flCa)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"TlsCert\"</span>, *flCert)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"TlsKey\"</span>, *flKey)</div><div class=\"line\">job.SetenvBool(<span class=\"string\">\"BufferRequests\"</span>, <span class=\"literal\">true</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> err := job.Run(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    log.Fatal(err)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>创建一个名为”serveapi”的job，并将flHosts的值赋给job.Args。flHost的作用主要是为Docker Daemon提供使用的协议与监听的地址。</li>\n<li>Docker Daemon为该job设置了众多的环境变量，如安全传输层协议的环境变量等。最后通过job.Run()运行该serveapi的job。</li>\n</ol>\n<p>由于在eng中key为”serveapi”的handler，value为apiserver.ServeApi，故该job运行时，执行apiserver.ServeApi函数，位于<a href=\"https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1339\" target=\"_blank\" rel=\"external\">./docker/api/server/server.go</a>。ServeApi函数的作用主要是对于用户定义的所有支持协议，Docker Daemon均创建一个goroutine来启动相应的http.Server，分别为不同的协议服务。具体参考<a href=\"http://wiki.haplat.net/display/~huwh/Docker+Server\" target=\"_blank\" rel=\"external\">Docker Server</a>。</p>\n"},{"title":"[Docker] Docker源码分析（三）之Docker Server","catalog":true,"date":"2017-07-09T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Docker"],"_content":"\n## 一、Docker Server创建流程\n\nDocker Server是Daemon Server的重要组成部分，功能：接收Docker Client发送的请求，并按照相应的路由规则实现请求的路由分发，最终将请求处理的结果返回给Docker Client。\nDocker Daemon启动，在mainDaemon()运行的最后创建并运行serverapi的Job，让Docker Daemon提供API访问服务。\nDocker Server的整个生命周期\n\n1. 创建Docker Server的Job\n2. 配置Job的环境变量\n3. 触发执行Job\n\n说明：本文分析的代码为Docker 1.2.0版本。\n\n### （一）创建“serverapi”的Job\n\n**/docker/daemon.go**\n\n```go\nfunc mainDaemon() {\n      ...\n      // Serve api\n      job := eng.Job(\"serveapi\", flHosts...)\n      ...\n  }\n```\n\n运行serverapi的Job时，会执行该Job的处理方法api.ServeApi。\n\n### （二）配置Job环境变量\n\n**/docker/daemon.go**\n\n```go\njob.SetenvBool(\"Logging\", true)\njob.SetenvBool(\"EnableCors\", *flEnableCors)\njob.Setenv(\"Version\", dockerversion.VERSION)\njob.Setenv(\"SocketGroup\", *flSocketGroup)\n \njob.SetenvBool(\"Tls\", *flTls)\njob.SetenvBool(\"TlsVerify\", *flTlsVerify)\njob.Setenv(\"TlsCa\", *flCa)\njob.Setenv(\"TlsCert\", *flCert)\njob.Setenv(\"TlsKey\", *flKey)\njob.SetenvBool(\"BufferRequests\", true)\n```\n\n参数分为两种\n\n- 创建Job实例时，用指定参数直接初始化Job的Args属性\n- 创建Job后，给Job添加指定的环境变量\n\n| 环境变量名         | FLAG参数        | 默认     | 作用值                                |\n| ------------- | ------------- | ------ | ---------------------------------- |\n| Logging       |               | true   | 启用Docker容器的日志输出                    |\n| EnableCors    | flEnableCors  | false  | 在远程API中提供CORS头                     |\n| Version       |               |        | 显示Docker版本号                        |\n| SocketGroup   | flSockerGroup | docker | 在daemon模式中unix domain socket分配用户组名 |\n| Tls           | flTls         | false  | 使用TLS安全传输协议                        |\n| TlsVerify     | flTlsVerify   | false  | 使用TLS并验证远程客户端                      |\n| TlsCa         | flCa          |        | 指定CA文件路径                           |\n| TlsCert       | flCert        |        | TLS证书文件路径                          |\n| TlsKey        | flKey         |        | TLS密钥文件路径                          |\n| BufferRequest |               | true   | 缓存Docker Client请求                  |\n\n### （三）运行Job\n\n**/api/server/server.go**\n\n```go\nif err := job.Run(); err != nil {\n    log.Fatal(err)\n}\n```\n\nDocker在eng对象中注册过键位serverapi的处理方法，在运行Job的时候执行这个处理方法的值函数，相应的处理方法的值为api.ServeApi。\n\n## 二、ServeApi运行流程\n\n​     ServeApi属于Docker Server提供API服务的部分，作为一个监听请求、处理请求、响应请求的服务端，支持三种协议：TCP协议、UNIX Socket形式以及fd的形式。功能是：循环检查Docker Daemon支持的所有协议，并为每一种协议创建一个协程goroutine，并在协程内部配置一个服务于HTTP请求的服务端。\n\n**/api/server/server.go**\n\n```go\n// ServeApi loops through all of the protocols sent in to docker and spawns\n// off a go routine to setup a serving http.Server for each.\nfunc ServeApi(job *engine.Job) engine.Status {\n    if len(job.Args) == 0 {\n        return job.Errorf(\"usage: %s PROTO://ADDR [PROTO://ADDR ...]\", job.Name)\n    }\n    var (\n        protoAddrs = job.Args\n        chErrors   = make(chan error, len(protoAddrs))\n    )\n    activationLock = make(chan struct{})\n \n    for _, protoAddr := range protoAddrs {\n        protoAddrParts := strings.SplitN(protoAddr, \"://\", 2)\n        if len(protoAddrParts) != 2 {\n            return job.Errorf(\"usage: %s PROTO://ADDR [PROTO://ADDR ...]\", job.Name)\n        }\n        go func() {\n            log.Infof(\"Listening for HTTP on %s (%s)\", protoAddrParts[0], protoAddrParts[1])\n            chErrors <- ListenAndServe(protoAddrParts[0], protoAddrParts[1], job)\n        }()\n    }\n \n    for i := 0; i < len(protoAddrs); i += 1 {\n        err := <-chErrors\n        if err != nil {\n            return job.Error(err)\n        }\n    }\n \n    return engine.StatusOK\n}\n```\n\nServeApi执行流程：\n\n1. 检查Job参数，确保传入参数无误\n2. 定义Docker Server的监听协议与地址，以及错误信息管理channel\n3. 遍历协议地址，针对协议创建相应的服务端\n4. 通过chErrors建立goroutine与主进程之间的协调关系\n\n### （一）判断Job参数\n\n判断Job参数，job.Args，即数组flHost，若flHost的长度为0，则说明没有监听的协议与地址，参数有误。\n\n**/api/server/server.go**\n\n```go\nfunc ServeApi(job *engine.Job) engine.Status {\n    if len(job.Args) == 0 {\n        return job.Errorf(\"usage: %s PROTO://ADDR [PROTO://ADDR ...]\", job.Name)\n    }\n    ...\n}\n```\n\n### （二）定义监听协议与地址及错误信息\n\n**/api/server/server.go**\n\n```go\nvar (\n       protoAddrs = job.Args\n       chErrors   = make(chan error, len(protoAddrs))\n   )\n   activationLock = make(chan struct{})\n```\n\n定义protoAddrs[flHosts的内容]、chErrors[错误类型管道]与activationLock[同步serveapi和acceptconnections两个job执行的管道]三个变量，\n\n### （三）遍历协议地址\n\n**/api/server/server.go**\n\n```go\nfor _, protoAddr := range protoAddrs {\n    protoAddrParts := strings.SplitN(protoAddr, \"://\", 2)\n    if len(protoAddrParts) != 2 {\n        return job.Errorf(\"usage: %s PROTO://ADDR [PROTO://ADDR ...]\", job.Name)\n    }\n    go func() {\n        log.Infof(\"Listening for HTTP on %s (%s)\", protoAddrParts[0], protoAddrParts[1])\n        chErrors <- ListenAndServe(protoAddrParts[0], protoAddrParts[1], job)\n    }()\n}\n```\n\n遍历协议地址，针对协议创建相应的服务端。协议地址\n\n### （四）协调chErrors与主进程关系\n\n根据chErrors的值运行，如果chErrors这个管道中有错误内容，则ServerApi一次循环结束，若无错误内容，循环被阻塞。即chErrors确保ListenAndServe所对应的协程能和主函数ServeApi进行协调，如果协程出错，主函数ServeApi仍然可以捕获这样的错误，从而导致程序退出。\n\n**/api/server/server.go**\n\n```go\nfor i := 0; i < len(protoAddrs); i += 1 {\n    err := <-chErrors\n    if err != nil {\n        return job.Error(err)\n    }\n}\nreturn engine.StatusOK\n```\n\n## 三、ListenAndServe实现\n\nListenAndServe的功能：使Docker Server监听某一指定地址，并接收该地址的请求，并对以上请求路由转发至相应的处理方法处。\nListenAndServe执行流程：\n\n1. 创建route路由实例\n2. 创建listener监听实例\n3. 创建http.Server\n4. 启动API服务\n\n流程图：\n![流程图](/img/article/docker/docker源码分析之Docker-Server/流程图.jpg)\n\n### （一）创建route路由实例\n\n**/api/server/server.go**\n\n```go\n// ListenAndServe sets up the required http.Server and gets it listening for\n// each addr passed in and does protocol specific checking.\nfunc ListenAndServe(proto, addr string, job *engine.Job) error {\n    var l net.Listener\n    r, err := createRouter(job.Eng, job.GetenvBool(\"Logging\"), job.GetenvBool(\"EnableCors\"), job.Getenv(\"Version\"))\n    if err != nil {\n        return err\n    }\n    ...\n}\n```\n\n路由实例的作用：负责Docker Server对外部请求的路由及转发。\n实现过程：\n\n1. 创建全新的route路由实例\n2. 为route实例添加路由记录\n\n#### 1、创建空路由实例\n\n**/api/server/server.go**\n\n```go\nfunc createRouter(eng *engine.Engine, logging, enableCors bool, dockerVersion string) (*mux.Router, error) {\n     r := mux.NewRouter()\n     ...\n }\n```\n\n**/vendor/src/github.com/gorilla/mux/mux.go**\n\n```go\n// NewRouter returns a new router instance.\nfunc NewRouter() *Router {\n    return &Router{namedRoutes: make(map[string]*Route), KeepContext: false}\n}\n \n// This will send all incoming requests to the router.\ntype Router struct {\n    // Configurable Handler to be used when no route matches.\n    NotFoundHandler http.Handler\n    // Parent route, if this is a subrouter.\n    parent parentRoute\n    // Routes to be matched, in order.\n    routes []*Route\n    // Routes by name for URL building.\n    namedRoutes map[string]*Route\n    // See Router.StrictSlash(). This defines the flag for new routes.\n    strictSlash bool\n    // If true, do not clear the request context after handling the request\n    KeepContext bool\n}\n```\n\nNewRoute()函数返回一个全新的route实例r，类型为mux.Router。实例初始化nameRoutes和KeepContext。\n\n- nameRoutes：map类型，key为string类型，value为Route路由记录类型\n- KeepContext：属性为false，则处理完请求后清除请求内容，不对请求做存储操作\n\nmux.Router会通过一系列已经注册过的路由记录，来匹配接收的请求。先通过请求的URL或者其他条件找到相应的路由记录，并调用这条记录中的执行处理方法。\nmux.Router特性\n\n- 请求可以基于URL的主机名、路径、路径前缀、shemes、请求头和请求值、HTTP请求方法类型或者使用自定义的匹配规则\n- URL主机名和路径可以通过一个正则表达式来表示\n- 注册的URL可以直接被运用，也可以保留从而保证维护资源的使用\n- 路由记录同样看可以作用于子路由记录\n\n#### 2、添加路由记录\n\n**/api/server/server.go**\n\n```go\nif os.Getenv(\"DEBUG\") != \"\" {\n       AttachProfiler(r)\n   }\n \n   m := map[string]map[string]HttpApiFunc{\n       \"GET\": {\n           \"/_ping\":                          ping,\n           \"/events\":                         getEvents,\n           \"/info\":                           getInfo,\n           \"/version\":                        getVersion,\n           \"/images/json\":                    getImagesJSON,\n           \"/images/viz\":                     getImagesViz,\n           \"/images/search\":                  getImagesSearch,\n           \"/images/{name:.*}/get\":           getImagesGet,\n           \"/images/{name:.*}/history\":       getImagesHistory,\n           \"/images/{name:.*}/json\":          getImagesByName,\n           \"/containers/ps\":                  getContainersJSON,\n           \"/containers/json\":                getContainersJSON,\n           \"/containers/{name:.*}/export\":    getContainersExport,\n           \"/containers/{name:.*}/changes\":   getContainersChanges,\n           \"/containers/{name:.*}/json\":      getContainersByName,\n           \"/containers/{name:.*}/top\":       getContainersTop,\n           \"/containers/{name:.*}/logs\":      getContainersLogs,\n           \"/containers/{name:.*}/attach/ws\": wsContainersAttach,\n       },\n       \"POST\": {\n           \"/auth\":                         postAuth,\n           \"/commit\":                       postCommit,\n           \"/build\":                        postBuild,\n           \"/images/create\":                postImagesCreate,\n           \"/images/load\":                  postImagesLoad,\n           \"/images/{name:.*}/push\":        postImagesPush,\n           \"/images/{name:.*}/tag\":         postImagesTag,\n           \"/containers/create\":            postContainersCreate,\n           \"/containers/{name:.*}/kill\":    postContainersKill,\n           \"/containers/{name:.*}/pause\":   postContainersPause,\n           \"/containers/{name:.*}/unpause\": postContainersUnpause,\n           \"/containers/{name:.*}/restart\": postContainersRestart,\n           \"/containers/{name:.*}/start\":   postContainersStart,\n           \"/containers/{name:.*}/stop\":    postContainersStop,\n           \"/containers/{name:.*}/wait\":    postContainersWait,\n           \"/containers/{name:.*}/resize\":  postContainersResize,\n           \"/containers/{name:.*}/attach\":  postContainersAttach,\n           \"/containers/{name:.*}/copy\":    postContainersCopy,\n       },\n       \"DELETE\": {\n           \"/containers/{name:.*}\": deleteContainers,\n           \"/images/{name:.*}\":     deleteImages,\n       },\n       \"OPTIONS\": {\n           \"\": optionsHandler,\n       },\n   }\n```\n\nm的类型为映射，key表示HTTP的请求类型，如GET、POST、DELETE等，value为映射类型，代表URL与执行处理方法的映射。\n\n**/api/server/server.go**\n\n```go\ntype HttpApiFunc func(eng *engine.Engine, version version.Version, w http.ResponseWriter, r *http.Request, vars map[string]string) error\n```\n\n### （二）创建listener监听实例\n\n路由模块完成请求的路由与分发，监听模块完成请求的监听功能。Listener是一种面向流协议的通用网络监听模块。\n\n**/api/server/server.go**\n\n```go\nvar l net.Listener\n ...\n if job.GetenvBool(\"BufferRequests\") {\n     l, err = listenbuffer.NewListenBuffer(proto, addr, activationLock)\n } else {\n     l, err = net.Listen(proto, addr)\n```\n\nListenbuffer的作用：让Docker Server立即监听指定协议地址上的请求，但将这些请求暂时先缓存下来，等Docker Daemon全部启动完毕之后才让Docker Server开始接受这些请求。\n\n**/pkg/listenbuffer/buffer.go**\n\n```go\n// NewListenBuffer returns a listener listening on addr with the protocol.\nfunc NewListenBuffer(proto, addr string, activate chan struct{}) (net.Listener, error) {\n    wrapped, err := net.Listen(proto, addr)\n    if err != nil {\n        return nil, err\n    }\n \n    return &defaultListener{\n        wrapped:  wrapped,\n        activate: activate,\n    }, nil\n}\n```\n\n若协议类型为TCP，Job环境变量中Tls或TlsVerity有一个为true，则说明Docker Server需要支持HTTPS服务。需要建立一个tls.Config类型实例tlsConfig，在tlsConfig中加载证书、认证信息，通过tls包中的NewListener函数创建HTTPS协议请求的Listener实例。\n\n**/api/server/server.go**\n\n```go\nl = tls.NewListener(l, tlsConfig)\n```\n\n### （三）创建http.Server\n\n**/api/server/server.go**\n\n```go\nhttpSrv := http.Server{Addr: addr, Handler: r}\n```\n\nDocker Server需要创建一个Server对象来运行HTTP/HTTPS服务端，创建http.Server，addr为需要监听的地址，r为mux.Router。\n\n### （四）启动API服务\n\n创建http.Server实例后，即启动API服务，监听请求，并对每一个请求生成一个新的协程来做专属服务。对于每个请求，协程会读取请求，查询路由表中的路由记录项，找到匹配的路由记录，最终调用路由记录中的处理方法，执行完毕返回响应信息。\n\n**/api/server/server.go**\n\n```go\nreturn httpSrv.Serve(l)\n```\n\n ","source":"_posts/Docker/Docker源码/Docker源码分析（三）之Docker Server.md","raw":"---\ntitle: \"[Docker] Docker源码分析（三）之Docker Server\"\ncatalog: true\ndate: 2017-07-09 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Docker\ncatagories:\n- Docker\n---\n\n## 一、Docker Server创建流程\n\nDocker Server是Daemon Server的重要组成部分，功能：接收Docker Client发送的请求，并按照相应的路由规则实现请求的路由分发，最终将请求处理的结果返回给Docker Client。\nDocker Daemon启动，在mainDaemon()运行的最后创建并运行serverapi的Job，让Docker Daemon提供API访问服务。\nDocker Server的整个生命周期\n\n1. 创建Docker Server的Job\n2. 配置Job的环境变量\n3. 触发执行Job\n\n说明：本文分析的代码为Docker 1.2.0版本。\n\n### （一）创建“serverapi”的Job\n\n**/docker/daemon.go**\n\n```go\nfunc mainDaemon() {\n      ...\n      // Serve api\n      job := eng.Job(\"serveapi\", flHosts...)\n      ...\n  }\n```\n\n运行serverapi的Job时，会执行该Job的处理方法api.ServeApi。\n\n### （二）配置Job环境变量\n\n**/docker/daemon.go**\n\n```go\njob.SetenvBool(\"Logging\", true)\njob.SetenvBool(\"EnableCors\", *flEnableCors)\njob.Setenv(\"Version\", dockerversion.VERSION)\njob.Setenv(\"SocketGroup\", *flSocketGroup)\n \njob.SetenvBool(\"Tls\", *flTls)\njob.SetenvBool(\"TlsVerify\", *flTlsVerify)\njob.Setenv(\"TlsCa\", *flCa)\njob.Setenv(\"TlsCert\", *flCert)\njob.Setenv(\"TlsKey\", *flKey)\njob.SetenvBool(\"BufferRequests\", true)\n```\n\n参数分为两种\n\n- 创建Job实例时，用指定参数直接初始化Job的Args属性\n- 创建Job后，给Job添加指定的环境变量\n\n| 环境变量名         | FLAG参数        | 默认     | 作用值                                |\n| ------------- | ------------- | ------ | ---------------------------------- |\n| Logging       |               | true   | 启用Docker容器的日志输出                    |\n| EnableCors    | flEnableCors  | false  | 在远程API中提供CORS头                     |\n| Version       |               |        | 显示Docker版本号                        |\n| SocketGroup   | flSockerGroup | docker | 在daemon模式中unix domain socket分配用户组名 |\n| Tls           | flTls         | false  | 使用TLS安全传输协议                        |\n| TlsVerify     | flTlsVerify   | false  | 使用TLS并验证远程客户端                      |\n| TlsCa         | flCa          |        | 指定CA文件路径                           |\n| TlsCert       | flCert        |        | TLS证书文件路径                          |\n| TlsKey        | flKey         |        | TLS密钥文件路径                          |\n| BufferRequest |               | true   | 缓存Docker Client请求                  |\n\n### （三）运行Job\n\n**/api/server/server.go**\n\n```go\nif err := job.Run(); err != nil {\n    log.Fatal(err)\n}\n```\n\nDocker在eng对象中注册过键位serverapi的处理方法，在运行Job的时候执行这个处理方法的值函数，相应的处理方法的值为api.ServeApi。\n\n## 二、ServeApi运行流程\n\n​     ServeApi属于Docker Server提供API服务的部分，作为一个监听请求、处理请求、响应请求的服务端，支持三种协议：TCP协议、UNIX Socket形式以及fd的形式。功能是：循环检查Docker Daemon支持的所有协议，并为每一种协议创建一个协程goroutine，并在协程内部配置一个服务于HTTP请求的服务端。\n\n**/api/server/server.go**\n\n```go\n// ServeApi loops through all of the protocols sent in to docker and spawns\n// off a go routine to setup a serving http.Server for each.\nfunc ServeApi(job *engine.Job) engine.Status {\n    if len(job.Args) == 0 {\n        return job.Errorf(\"usage: %s PROTO://ADDR [PROTO://ADDR ...]\", job.Name)\n    }\n    var (\n        protoAddrs = job.Args\n        chErrors   = make(chan error, len(protoAddrs))\n    )\n    activationLock = make(chan struct{})\n \n    for _, protoAddr := range protoAddrs {\n        protoAddrParts := strings.SplitN(protoAddr, \"://\", 2)\n        if len(protoAddrParts) != 2 {\n            return job.Errorf(\"usage: %s PROTO://ADDR [PROTO://ADDR ...]\", job.Name)\n        }\n        go func() {\n            log.Infof(\"Listening for HTTP on %s (%s)\", protoAddrParts[0], protoAddrParts[1])\n            chErrors <- ListenAndServe(protoAddrParts[0], protoAddrParts[1], job)\n        }()\n    }\n \n    for i := 0; i < len(protoAddrs); i += 1 {\n        err := <-chErrors\n        if err != nil {\n            return job.Error(err)\n        }\n    }\n \n    return engine.StatusOK\n}\n```\n\nServeApi执行流程：\n\n1. 检查Job参数，确保传入参数无误\n2. 定义Docker Server的监听协议与地址，以及错误信息管理channel\n3. 遍历协议地址，针对协议创建相应的服务端\n4. 通过chErrors建立goroutine与主进程之间的协调关系\n\n### （一）判断Job参数\n\n判断Job参数，job.Args，即数组flHost，若flHost的长度为0，则说明没有监听的协议与地址，参数有误。\n\n**/api/server/server.go**\n\n```go\nfunc ServeApi(job *engine.Job) engine.Status {\n    if len(job.Args) == 0 {\n        return job.Errorf(\"usage: %s PROTO://ADDR [PROTO://ADDR ...]\", job.Name)\n    }\n    ...\n}\n```\n\n### （二）定义监听协议与地址及错误信息\n\n**/api/server/server.go**\n\n```go\nvar (\n       protoAddrs = job.Args\n       chErrors   = make(chan error, len(protoAddrs))\n   )\n   activationLock = make(chan struct{})\n```\n\n定义protoAddrs[flHosts的内容]、chErrors[错误类型管道]与activationLock[同步serveapi和acceptconnections两个job执行的管道]三个变量，\n\n### （三）遍历协议地址\n\n**/api/server/server.go**\n\n```go\nfor _, protoAddr := range protoAddrs {\n    protoAddrParts := strings.SplitN(protoAddr, \"://\", 2)\n    if len(protoAddrParts) != 2 {\n        return job.Errorf(\"usage: %s PROTO://ADDR [PROTO://ADDR ...]\", job.Name)\n    }\n    go func() {\n        log.Infof(\"Listening for HTTP on %s (%s)\", protoAddrParts[0], protoAddrParts[1])\n        chErrors <- ListenAndServe(protoAddrParts[0], protoAddrParts[1], job)\n    }()\n}\n```\n\n遍历协议地址，针对协议创建相应的服务端。协议地址\n\n### （四）协调chErrors与主进程关系\n\n根据chErrors的值运行，如果chErrors这个管道中有错误内容，则ServerApi一次循环结束，若无错误内容，循环被阻塞。即chErrors确保ListenAndServe所对应的协程能和主函数ServeApi进行协调，如果协程出错，主函数ServeApi仍然可以捕获这样的错误，从而导致程序退出。\n\n**/api/server/server.go**\n\n```go\nfor i := 0; i < len(protoAddrs); i += 1 {\n    err := <-chErrors\n    if err != nil {\n        return job.Error(err)\n    }\n}\nreturn engine.StatusOK\n```\n\n## 三、ListenAndServe实现\n\nListenAndServe的功能：使Docker Server监听某一指定地址，并接收该地址的请求，并对以上请求路由转发至相应的处理方法处。\nListenAndServe执行流程：\n\n1. 创建route路由实例\n2. 创建listener监听实例\n3. 创建http.Server\n4. 启动API服务\n\n流程图：\n![流程图](/img/article/docker/docker源码分析之Docker-Server/流程图.jpg)\n\n### （一）创建route路由实例\n\n**/api/server/server.go**\n\n```go\n// ListenAndServe sets up the required http.Server and gets it listening for\n// each addr passed in and does protocol specific checking.\nfunc ListenAndServe(proto, addr string, job *engine.Job) error {\n    var l net.Listener\n    r, err := createRouter(job.Eng, job.GetenvBool(\"Logging\"), job.GetenvBool(\"EnableCors\"), job.Getenv(\"Version\"))\n    if err != nil {\n        return err\n    }\n    ...\n}\n```\n\n路由实例的作用：负责Docker Server对外部请求的路由及转发。\n实现过程：\n\n1. 创建全新的route路由实例\n2. 为route实例添加路由记录\n\n#### 1、创建空路由实例\n\n**/api/server/server.go**\n\n```go\nfunc createRouter(eng *engine.Engine, logging, enableCors bool, dockerVersion string) (*mux.Router, error) {\n     r := mux.NewRouter()\n     ...\n }\n```\n\n**/vendor/src/github.com/gorilla/mux/mux.go**\n\n```go\n// NewRouter returns a new router instance.\nfunc NewRouter() *Router {\n    return &Router{namedRoutes: make(map[string]*Route), KeepContext: false}\n}\n \n// This will send all incoming requests to the router.\ntype Router struct {\n    // Configurable Handler to be used when no route matches.\n    NotFoundHandler http.Handler\n    // Parent route, if this is a subrouter.\n    parent parentRoute\n    // Routes to be matched, in order.\n    routes []*Route\n    // Routes by name for URL building.\n    namedRoutes map[string]*Route\n    // See Router.StrictSlash(). This defines the flag for new routes.\n    strictSlash bool\n    // If true, do not clear the request context after handling the request\n    KeepContext bool\n}\n```\n\nNewRoute()函数返回一个全新的route实例r，类型为mux.Router。实例初始化nameRoutes和KeepContext。\n\n- nameRoutes：map类型，key为string类型，value为Route路由记录类型\n- KeepContext：属性为false，则处理完请求后清除请求内容，不对请求做存储操作\n\nmux.Router会通过一系列已经注册过的路由记录，来匹配接收的请求。先通过请求的URL或者其他条件找到相应的路由记录，并调用这条记录中的执行处理方法。\nmux.Router特性\n\n- 请求可以基于URL的主机名、路径、路径前缀、shemes、请求头和请求值、HTTP请求方法类型或者使用自定义的匹配规则\n- URL主机名和路径可以通过一个正则表达式来表示\n- 注册的URL可以直接被运用，也可以保留从而保证维护资源的使用\n- 路由记录同样看可以作用于子路由记录\n\n#### 2、添加路由记录\n\n**/api/server/server.go**\n\n```go\nif os.Getenv(\"DEBUG\") != \"\" {\n       AttachProfiler(r)\n   }\n \n   m := map[string]map[string]HttpApiFunc{\n       \"GET\": {\n           \"/_ping\":                          ping,\n           \"/events\":                         getEvents,\n           \"/info\":                           getInfo,\n           \"/version\":                        getVersion,\n           \"/images/json\":                    getImagesJSON,\n           \"/images/viz\":                     getImagesViz,\n           \"/images/search\":                  getImagesSearch,\n           \"/images/{name:.*}/get\":           getImagesGet,\n           \"/images/{name:.*}/history\":       getImagesHistory,\n           \"/images/{name:.*}/json\":          getImagesByName,\n           \"/containers/ps\":                  getContainersJSON,\n           \"/containers/json\":                getContainersJSON,\n           \"/containers/{name:.*}/export\":    getContainersExport,\n           \"/containers/{name:.*}/changes\":   getContainersChanges,\n           \"/containers/{name:.*}/json\":      getContainersByName,\n           \"/containers/{name:.*}/top\":       getContainersTop,\n           \"/containers/{name:.*}/logs\":      getContainersLogs,\n           \"/containers/{name:.*}/attach/ws\": wsContainersAttach,\n       },\n       \"POST\": {\n           \"/auth\":                         postAuth,\n           \"/commit\":                       postCommit,\n           \"/build\":                        postBuild,\n           \"/images/create\":                postImagesCreate,\n           \"/images/load\":                  postImagesLoad,\n           \"/images/{name:.*}/push\":        postImagesPush,\n           \"/images/{name:.*}/tag\":         postImagesTag,\n           \"/containers/create\":            postContainersCreate,\n           \"/containers/{name:.*}/kill\":    postContainersKill,\n           \"/containers/{name:.*}/pause\":   postContainersPause,\n           \"/containers/{name:.*}/unpause\": postContainersUnpause,\n           \"/containers/{name:.*}/restart\": postContainersRestart,\n           \"/containers/{name:.*}/start\":   postContainersStart,\n           \"/containers/{name:.*}/stop\":    postContainersStop,\n           \"/containers/{name:.*}/wait\":    postContainersWait,\n           \"/containers/{name:.*}/resize\":  postContainersResize,\n           \"/containers/{name:.*}/attach\":  postContainersAttach,\n           \"/containers/{name:.*}/copy\":    postContainersCopy,\n       },\n       \"DELETE\": {\n           \"/containers/{name:.*}\": deleteContainers,\n           \"/images/{name:.*}\":     deleteImages,\n       },\n       \"OPTIONS\": {\n           \"\": optionsHandler,\n       },\n   }\n```\n\nm的类型为映射，key表示HTTP的请求类型，如GET、POST、DELETE等，value为映射类型，代表URL与执行处理方法的映射。\n\n**/api/server/server.go**\n\n```go\ntype HttpApiFunc func(eng *engine.Engine, version version.Version, w http.ResponseWriter, r *http.Request, vars map[string]string) error\n```\n\n### （二）创建listener监听实例\n\n路由模块完成请求的路由与分发，监听模块完成请求的监听功能。Listener是一种面向流协议的通用网络监听模块。\n\n**/api/server/server.go**\n\n```go\nvar l net.Listener\n ...\n if job.GetenvBool(\"BufferRequests\") {\n     l, err = listenbuffer.NewListenBuffer(proto, addr, activationLock)\n } else {\n     l, err = net.Listen(proto, addr)\n```\n\nListenbuffer的作用：让Docker Server立即监听指定协议地址上的请求，但将这些请求暂时先缓存下来，等Docker Daemon全部启动完毕之后才让Docker Server开始接受这些请求。\n\n**/pkg/listenbuffer/buffer.go**\n\n```go\n// NewListenBuffer returns a listener listening on addr with the protocol.\nfunc NewListenBuffer(proto, addr string, activate chan struct{}) (net.Listener, error) {\n    wrapped, err := net.Listen(proto, addr)\n    if err != nil {\n        return nil, err\n    }\n \n    return &defaultListener{\n        wrapped:  wrapped,\n        activate: activate,\n    }, nil\n}\n```\n\n若协议类型为TCP，Job环境变量中Tls或TlsVerity有一个为true，则说明Docker Server需要支持HTTPS服务。需要建立一个tls.Config类型实例tlsConfig，在tlsConfig中加载证书、认证信息，通过tls包中的NewListener函数创建HTTPS协议请求的Listener实例。\n\n**/api/server/server.go**\n\n```go\nl = tls.NewListener(l, tlsConfig)\n```\n\n### （三）创建http.Server\n\n**/api/server/server.go**\n\n```go\nhttpSrv := http.Server{Addr: addr, Handler: r}\n```\n\nDocker Server需要创建一个Server对象来运行HTTP/HTTPS服务端，创建http.Server，addr为需要监听的地址，r为mux.Router。\n\n### （四）启动API服务\n\n创建http.Server实例后，即启动API服务，监听请求，并对每一个请求生成一个新的协程来做专属服务。对于每个请求，协程会读取请求，查询路由表中的路由记录项，找到匹配的路由记录，最终调用路由记录中的处理方法，执行完毕返回响应信息。\n\n**/api/server/server.go**\n\n```go\nreturn httpSrv.Serve(l)\n```\n\n ","slug":"Docker/Docker源码/Docker源码分析（三）之Docker Server","published":1,"updated":"2017-10-02T09:00:27.113Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740jy001030vuh5f4ru2q","content":"<h2><span id=\"一-docker-server创建流程\">一、Docker Server创建流程</span></h2>\n<p>Docker Server是Daemon Server的重要组成部分，功能：接收Docker Client发送的请求，并按照相应的路由规则实现请求的路由分发，最终将请求处理的结果返回给Docker Client。<br>\nDocker Daemon启动，在mainDaemon()运行的最后创建并运行serverapi的Job，让Docker Daemon提供API访问服务。<br>\nDocker Server的整个生命周期</p>\n<ol>\n<li>创建Docker Server的Job</li>\n<li>配置Job的环境变量</li>\n<li>触发执行Job</li>\n</ol>\n<p>说明：本文分析的代码为Docker 1.2.0版本。</p>\n<h3><span id=\"一创建serverapi的job\">（一）创建“serverapi”的Job</span></h3>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mainDaemon</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">      ...</div><div class=\"line\">      <span class=\"comment\">// Serve api</span></div><div class=\"line\">      job := eng.Job(<span class=\"string\">\"serveapi\"</span>, flHosts...)</div><div class=\"line\">      ...</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>运行serverapi的Job时，会执行该Job的处理方法api.ServeApi。</p>\n<h3><span id=\"二配置job环境变量\">（二）配置Job环境变量</span></h3>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">job.SetenvBool(<span class=\"string\">\"Logging\"</span>, <span class=\"literal\">true</span>)</div><div class=\"line\">job.SetenvBool(<span class=\"string\">\"EnableCors\"</span>, *flEnableCors)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"Version\"</span>, dockerversion.VERSION)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"SocketGroup\"</span>, *flSocketGroup)</div><div class=\"line\"> </div><div class=\"line\">job.SetenvBool(<span class=\"string\">\"Tls\"</span>, *flTls)</div><div class=\"line\">job.SetenvBool(<span class=\"string\">\"TlsVerify\"</span>, *flTlsVerify)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"TlsCa\"</span>, *flCa)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"TlsCert\"</span>, *flCert)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"TlsKey\"</span>, *flKey)</div><div class=\"line\">job.SetenvBool(<span class=\"string\">\"BufferRequests\"</span>, <span class=\"literal\">true</span>)</div></pre></td></tr></table></figure>\n<p>参数分为两种</p>\n<ul>\n<li>创建Job实例时，用指定参数直接初始化Job的Args属性</li>\n<li>创建Job后，给Job添加指定的环境变量</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>环境变量名</th>\n<th>FLAG参数</th>\n<th>默认</th>\n<th>作用值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Logging</td>\n<td></td>\n<td>true</td>\n<td>启用Docker容器的日志输出</td>\n</tr>\n<tr>\n<td>EnableCors</td>\n<td>flEnableCors</td>\n<td>false</td>\n<td>在远程API中提供CORS头</td>\n</tr>\n<tr>\n<td>Version</td>\n<td></td>\n<td></td>\n<td>显示Docker版本号</td>\n</tr>\n<tr>\n<td>SocketGroup</td>\n<td>flSockerGroup</td>\n<td>docker</td>\n<td>在daemon模式中unix domain socket分配用户组名</td>\n</tr>\n<tr>\n<td>Tls</td>\n<td>flTls</td>\n<td>false</td>\n<td>使用TLS安全传输协议</td>\n</tr>\n<tr>\n<td>TlsVerify</td>\n<td>flTlsVerify</td>\n<td>false</td>\n<td>使用TLS并验证远程客户端</td>\n</tr>\n<tr>\n<td>TlsCa</td>\n<td>flCa</td>\n<td></td>\n<td>指定CA文件路径</td>\n</tr>\n<tr>\n<td>TlsCert</td>\n<td>flCert</td>\n<td></td>\n<td>TLS证书文件路径</td>\n</tr>\n<tr>\n<td>TlsKey</td>\n<td>flKey</td>\n<td></td>\n<td>TLS密钥文件路径</td>\n</tr>\n<tr>\n<td>BufferRequest</td>\n<td></td>\n<td>true</td>\n<td>缓存Docker Client请求</td>\n</tr>\n</tbody>\n</table>\n<h3><span id=\"三运行job\">（三）运行Job</span></h3>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> err := job.Run(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    log.Fatal(err)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Docker在eng对象中注册过键位serverapi的处理方法，在运行Job的时候执行这个处理方法的值函数，相应的处理方法的值为api.ServeApi。</p>\n<h2><span id=\"二-serveapi运行流程\">二、ServeApi运行流程</span></h2>\n<p>​     ServeApi属于Docker Server提供API服务的部分，作为一个监听请求、处理请求、响应请求的服务端，支持三种协议：TCP协议、UNIX Socket形式以及fd的形式。功能是：循环检查Docker Daemon支持的所有协议，并为每一种协议创建一个协程goroutine，并在协程内部配置一个服务于HTTP请求的服务端。</p>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ServeApi loops through all of the protocols sent in to docker and spawns</span></div><div class=\"line\"><span class=\"comment\">// off a go routine to setup a serving http.Server for each.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ServeApi</span><span class=\"params\">(job *engine.Job)</span> <span class=\"title\">engine</span>.<span class=\"title\">Status</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(job.Args) == <span class=\"number\">0</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> job.Errorf(<span class=\"string\">\"usage: %s PROTO://ADDR [PROTO://ADDR ...]\"</span>, job.Name)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> (</div><div class=\"line\">        protoAddrs = job.Args</div><div class=\"line\">        chErrors   = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> error, <span class=\"built_in\">len</span>(protoAddrs))</div><div class=\"line\">    )</div><div class=\"line\">    activationLock = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">for</span> _, protoAddr := <span class=\"keyword\">range</span> protoAddrs &#123;</div><div class=\"line\">        protoAddrParts := strings.SplitN(protoAddr, <span class=\"string\">\"://\"</span>, <span class=\"number\">2</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(protoAddrParts) != <span class=\"number\">2</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> job.Errorf(<span class=\"string\">\"usage: %s PROTO://ADDR [PROTO://ADDR ...]\"</span>, job.Name)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">            log.Infof(<span class=\"string\">\"Listening for HTTP on %s (%s)\"</span>, protoAddrParts[<span class=\"number\">0</span>], protoAddrParts[<span class=\"number\">1</span>])</div><div class=\"line\">            chErrors &lt;- ListenAndServe(protoAddrParts[<span class=\"number\">0</span>], protoAddrParts[<span class=\"number\">1</span>], job)</div><div class=\"line\">        &#125;()</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(protoAddrs); i += <span class=\"number\">1</span> &#123;</div><div class=\"line\">        err := &lt;-chErrors</div><div class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">return</span> engine.StatusOK</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ServeApi执行流程：</p>\n<ol>\n<li>检查Job参数，确保传入参数无误</li>\n<li>定义Docker Server的监听协议与地址，以及错误信息管理channel</li>\n<li>遍历协议地址，针对协议创建相应的服务端</li>\n<li>通过chErrors建立goroutine与主进程之间的协调关系</li>\n</ol>\n<h3><span id=\"一判断job参数\">（一）判断Job参数</span></h3>\n<p>判断Job参数，job.Args，即数组flHost，若flHost的长度为0，则说明没有监听的协议与地址，参数有误。</p>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ServeApi</span><span class=\"params\">(job *engine.Job)</span> <span class=\"title\">engine</span>.<span class=\"title\">Status</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(job.Args) == <span class=\"number\">0</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> job.Errorf(<span class=\"string\">\"usage: %s PROTO://ADDR [PROTO://ADDR ...]\"</span>, job.Name)</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"二定义监听协议与地址及错误信息\">（二）定义监听协议与地址及错误信息</span></h3>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> (</div><div class=\"line\">       protoAddrs = job.Args</div><div class=\"line\">       chErrors   = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> error, <span class=\"built_in\">len</span>(protoAddrs))</div><div class=\"line\">   )</div><div class=\"line\">   activationLock = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</div></pre></td></tr></table></figure>\n<p>定义protoAddrs[flHosts的内容]、chErrors[错误类型管道]与activationLock[同步serveapi和acceptconnections两个job执行的管道]三个变量，</p>\n<h3><span id=\"三遍历协议地址\">（三）遍历协议地址</span></h3>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> _, protoAddr := <span class=\"keyword\">range</span> protoAddrs &#123;</div><div class=\"line\">    protoAddrParts := strings.SplitN(protoAddr, <span class=\"string\">\"://\"</span>, <span class=\"number\">2</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(protoAddrParts) != <span class=\"number\">2</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> job.Errorf(<span class=\"string\">\"usage: %s PROTO://ADDR [PROTO://ADDR ...]\"</span>, job.Name)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        log.Infof(<span class=\"string\">\"Listening for HTTP on %s (%s)\"</span>, protoAddrParts[<span class=\"number\">0</span>], protoAddrParts[<span class=\"number\">1</span>])</div><div class=\"line\">        chErrors &lt;- ListenAndServe(protoAddrParts[<span class=\"number\">0</span>], protoAddrParts[<span class=\"number\">1</span>], job)</div><div class=\"line\">    &#125;()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>遍历协议地址，针对协议创建相应的服务端。协议地址</p>\n<h3><span id=\"四协调cherrors与主进程关系\">（四）协调chErrors与主进程关系</span></h3>\n<p>根据chErrors的值运行，如果chErrors这个管道中有错误内容，则ServerApi一次循环结束，若无错误内容，循环被阻塞。即chErrors确保ListenAndServe所对应的协程能和主函数ServeApi进行协调，如果协程出错，主函数ServeApi仍然可以捕获这样的错误，从而导致程序退出。</p>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(protoAddrs); i += <span class=\"number\">1</span> &#123;</div><div class=\"line\">    err := &lt;-chErrors</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">return</span> engine.StatusOK</div></pre></td></tr></table></figure>\n<h2><span id=\"三-listenandserve实现\">三、ListenAndServe实现</span></h2>\n<p>ListenAndServe的功能：使Docker Server监听某一指定地址，并接收该地址的请求，并对以上请求路由转发至相应的处理方法处。<br>\nListenAndServe执行流程：</p>\n<ol>\n<li>创建route路由实例</li>\n<li>创建listener监听实例</li>\n<li>创建http.Server</li>\n<li>启动API服务</li>\n</ol>\n<p>流程图：<br>\n<img src=\"/img/article/docker/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BDocker-Server/%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg\" alt=\"流程图\"></p>\n<h3><span id=\"一创建route路由实例\">（一）创建route路由实例</span></h3>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ListenAndServe sets up the required http.Server and gets it listening for</span></div><div class=\"line\"><span class=\"comment\">// each addr passed in and does protocol specific checking.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">(proto, addr <span class=\"keyword\">string</span>, job *engine.Job)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> l net.Listener</div><div class=\"line\">    r, err := createRouter(job.Eng, job.GetenvBool(<span class=\"string\">\"Logging\"</span>), job.GetenvBool(<span class=\"string\">\"EnableCors\"</span>), job.Getenv(<span class=\"string\">\"Version\"</span>))</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>路由实例的作用：负责Docker Server对外部请求的路由及转发。<br>\n实现过程：</p>\n<ol>\n<li>创建全新的route路由实例</li>\n<li>为route实例添加路由记录</li>\n</ol>\n<h4><span id=\"1-创建空路由实例\">1、创建空路由实例</span></h4>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createRouter</span><span class=\"params\">(eng *engine.Engine, logging, enableCors <span class=\"keyword\">bool</span>, dockerVersion <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*mux.Router, error)</span></span> &#123;</div><div class=\"line\">     r := mux.NewRouter()</div><div class=\"line\">     ...</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p><strong>/vendor/src/github.com/gorilla/mux/mux.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// NewRouter returns a new router instance.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewRouter</span><span class=\"params\">()</span> *<span class=\"title\">Router</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &amp;Router&#123;namedRoutes: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*Route), KeepContext: <span class=\"literal\">false</span>&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// This will send all incoming requests to the router.</span></div><div class=\"line\"><span class=\"keyword\">type</span> Router <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Configurable Handler to be used when no route matches.</span></div><div class=\"line\">    NotFoundHandler http.Handler</div><div class=\"line\">    <span class=\"comment\">// Parent route, if this is a subrouter.</span></div><div class=\"line\">    parent parentRoute</div><div class=\"line\">    <span class=\"comment\">// Routes to be matched, in order.</span></div><div class=\"line\">    routes []*Route</div><div class=\"line\">    <span class=\"comment\">// Routes by name for URL building.</span></div><div class=\"line\">    namedRoutes <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*Route</div><div class=\"line\">    <span class=\"comment\">// See Router.StrictSlash(). This defines the flag for new routes.</span></div><div class=\"line\">    strictSlash <span class=\"keyword\">bool</span></div><div class=\"line\">    <span class=\"comment\">// If true, do not clear the request context after handling the request</span></div><div class=\"line\">    KeepContext <span class=\"keyword\">bool</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>NewRoute()函数返回一个全新的route实例r，类型为mux.Router。实例初始化nameRoutes和KeepContext。</p>\n<ul>\n<li>nameRoutes：map类型，key为string类型，value为Route路由记录类型</li>\n<li>KeepContext：属性为false，则处理完请求后清除请求内容，不对请求做存储操作</li>\n</ul>\n<p>mux.Router会通过一系列已经注册过的路由记录，来匹配接收的请求。先通过请求的URL或者其他条件找到相应的路由记录，并调用这条记录中的执行处理方法。<br>\nmux.Router特性</p>\n<ul>\n<li>请求可以基于URL的主机名、路径、路径前缀、shemes、请求头和请求值、HTTP请求方法类型或者使用自定义的匹配规则</li>\n<li>URL主机名和路径可以通过一个正则表达式来表示</li>\n<li>注册的URL可以直接被运用，也可以保留从而保证维护资源的使用</li>\n<li>路由记录同样看可以作用于子路由记录</li>\n</ul>\n<h4><span id=\"2-添加路由记录\">2、添加路由记录</span></h4>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> os.Getenv(<span class=\"string\">\"DEBUG\"</span>) != <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">       AttachProfiler(r)</div><div class=\"line\">   &#125;</div><div class=\"line\"> </div><div class=\"line\">   m := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]HttpApiFunc&#123;</div><div class=\"line\">       <span class=\"string\">\"GET\"</span>: &#123;</div><div class=\"line\">           <span class=\"string\">\"/_ping\"</span>:                          ping,</div><div class=\"line\">           <span class=\"string\">\"/events\"</span>:                         getEvents,</div><div class=\"line\">           <span class=\"string\">\"/info\"</span>:                           getInfo,</div><div class=\"line\">           <span class=\"string\">\"/version\"</span>:                        getVersion,</div><div class=\"line\">           <span class=\"string\">\"/images/json\"</span>:                    getImagesJSON,</div><div class=\"line\">           <span class=\"string\">\"/images/viz\"</span>:                     getImagesViz,</div><div class=\"line\">           <span class=\"string\">\"/images/search\"</span>:                  getImagesSearch,</div><div class=\"line\">           <span class=\"string\">\"/images/&#123;name:.*&#125;/get\"</span>:           getImagesGet,</div><div class=\"line\">           <span class=\"string\">\"/images/&#123;name:.*&#125;/history\"</span>:       getImagesHistory,</div><div class=\"line\">           <span class=\"string\">\"/images/&#123;name:.*&#125;/json\"</span>:          getImagesByName,</div><div class=\"line\">           <span class=\"string\">\"/containers/ps\"</span>:                  getContainersJSON,</div><div class=\"line\">           <span class=\"string\">\"/containers/json\"</span>:                getContainersJSON,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/export\"</span>:    getContainersExport,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/changes\"</span>:   getContainersChanges,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/json\"</span>:      getContainersByName,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/top\"</span>:       getContainersTop,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/logs\"</span>:      getContainersLogs,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/attach/ws\"</span>: wsContainersAttach,</div><div class=\"line\">       &#125;,</div><div class=\"line\">       <span class=\"string\">\"POST\"</span>: &#123;</div><div class=\"line\">           <span class=\"string\">\"/auth\"</span>:                         postAuth,</div><div class=\"line\">           <span class=\"string\">\"/commit\"</span>:                       postCommit,</div><div class=\"line\">           <span class=\"string\">\"/build\"</span>:                        postBuild,</div><div class=\"line\">           <span class=\"string\">\"/images/create\"</span>:                postImagesCreate,</div><div class=\"line\">           <span class=\"string\">\"/images/load\"</span>:                  postImagesLoad,</div><div class=\"line\">           <span class=\"string\">\"/images/&#123;name:.*&#125;/push\"</span>:        postImagesPush,</div><div class=\"line\">           <span class=\"string\">\"/images/&#123;name:.*&#125;/tag\"</span>:         postImagesTag,</div><div class=\"line\">           <span class=\"string\">\"/containers/create\"</span>:            postContainersCreate,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/kill\"</span>:    postContainersKill,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/pause\"</span>:   postContainersPause,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/unpause\"</span>: postContainersUnpause,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/restart\"</span>: postContainersRestart,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/start\"</span>:   postContainersStart,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/stop\"</span>:    postContainersStop,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/wait\"</span>:    postContainersWait,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/resize\"</span>:  postContainersResize,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/attach\"</span>:  postContainersAttach,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/copy\"</span>:    postContainersCopy,</div><div class=\"line\">       &#125;,</div><div class=\"line\">       <span class=\"string\">\"DELETE\"</span>: &#123;</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;\"</span>: deleteContainers,</div><div class=\"line\">           <span class=\"string\">\"/images/&#123;name:.*&#125;\"</span>:     deleteImages,</div><div class=\"line\">       &#125;,</div><div class=\"line\">       <span class=\"string\">\"OPTIONS\"</span>: &#123;</div><div class=\"line\">           <span class=\"string\">\"\"</span>: optionsHandler,</div><div class=\"line\">       &#125;,</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>m的类型为映射，key表示HTTP的请求类型，如GET、POST、DELETE等，value为映射类型，代表URL与执行处理方法的映射。</p>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> HttpApiFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(eng *engine.Engine, version version.Version, w http.ResponseWriter, r *http.Request, vars <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span></div></pre></td></tr></table></figure>\n<h3><span id=\"二创建listener监听实例\">（二）创建listener监听实例</span></h3>\n<p>路由模块完成请求的路由与分发，监听模块完成请求的监听功能。Listener是一种面向流协议的通用网络监听模块。</p>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> l net.Listener</div><div class=\"line\"> ...</div><div class=\"line\"> <span class=\"keyword\">if</span> job.GetenvBool(<span class=\"string\">\"BufferRequests\"</span>) &#123;</div><div class=\"line\">     l, err = listenbuffer.NewListenBuffer(proto, addr, activationLock)</div><div class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">     l, err = net.Listen(proto, addr)</div></pre></td></tr></table></figure>\n<p>Listenbuffer的作用：让Docker Server立即监听指定协议地址上的请求，但将这些请求暂时先缓存下来，等Docker Daemon全部启动完毕之后才让Docker Server开始接受这些请求。</p>\n<p><strong>/pkg/listenbuffer/buffer.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// NewListenBuffer returns a listener listening on addr with the protocol.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewListenBuffer</span><span class=\"params\">(proto, addr <span class=\"keyword\">string</span>, activate <span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span> <span class=\"params\">(net.Listener, error)</span></span> &#123;</div><div class=\"line\">    wrapped, err := net.Listen(proto, addr)</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">return</span> &amp;defaultListener&#123;</div><div class=\"line\">        wrapped:  wrapped,</div><div class=\"line\">        activate: activate,</div><div class=\"line\">    &#125;, <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>若协议类型为TCP，Job环境变量中Tls或TlsVerity有一个为true，则说明Docker Server需要支持HTTPS服务。需要建立一个tls.Config类型实例tlsConfig，在tlsConfig中加载证书、认证信息，通过tls包中的NewListener函数创建HTTPS协议请求的Listener实例。</p>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">l = tls.NewListener(l, tlsConfig)</div></pre></td></tr></table></figure>\n<h3><span id=\"三创建httpserver\">（三）创建http.Server</span></h3>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">httpSrv := http.Server&#123;Addr: addr, Handler: r&#125;</div></pre></td></tr></table></figure>\n<p>Docker Server需要创建一个Server对象来运行HTTP/HTTPS服务端，创建http.Server，addr为需要监听的地址，r为mux.Router。</p>\n<h3><span id=\"四启动api服务\">（四）启动API服务</span></h3>\n<p>创建http.Server实例后，即启动API服务，监听请求，并对每一个请求生成一个新的协程来做专属服务。对于每个请求，协程会读取请求，查询路由表中的路由记录项，找到匹配的路由记录，最终调用路由记录中的处理方法，执行完毕返回响应信息。</p>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> httpSrv.Serve(l)</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2>一、Docker Server创建流程</h2>\n<p>Docker Server是Daemon Server的重要组成部分，功能：接收Docker Client发送的请求，并按照相应的路由规则实现请求的路由分发，最终将请求处理的结果返回给Docker Client。<br>\nDocker Daemon启动，在mainDaemon()运行的最后创建并运行serverapi的Job，让Docker Daemon提供API访问服务。<br>\nDocker Server的整个生命周期</p>\n<ol>\n<li>创建Docker Server的Job</li>\n<li>配置Job的环境变量</li>\n<li>触发执行Job</li>\n</ol>\n<p>说明：本文分析的代码为Docker 1.2.0版本。</p>\n<h3>（一）创建“serverapi”的Job</h3>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mainDaemon</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">      ...</div><div class=\"line\">      <span class=\"comment\">// Serve api</span></div><div class=\"line\">      job := eng.Job(<span class=\"string\">\"serveapi\"</span>, flHosts...)</div><div class=\"line\">      ...</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>运行serverapi的Job时，会执行该Job的处理方法api.ServeApi。</p>\n<h3>（二）配置Job环境变量</h3>\n<p><strong>/docker/daemon.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">job.SetenvBool(<span class=\"string\">\"Logging\"</span>, <span class=\"literal\">true</span>)</div><div class=\"line\">job.SetenvBool(<span class=\"string\">\"EnableCors\"</span>, *flEnableCors)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"Version\"</span>, dockerversion.VERSION)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"SocketGroup\"</span>, *flSocketGroup)</div><div class=\"line\"> </div><div class=\"line\">job.SetenvBool(<span class=\"string\">\"Tls\"</span>, *flTls)</div><div class=\"line\">job.SetenvBool(<span class=\"string\">\"TlsVerify\"</span>, *flTlsVerify)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"TlsCa\"</span>, *flCa)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"TlsCert\"</span>, *flCert)</div><div class=\"line\">job.Setenv(<span class=\"string\">\"TlsKey\"</span>, *flKey)</div><div class=\"line\">job.SetenvBool(<span class=\"string\">\"BufferRequests\"</span>, <span class=\"literal\">true</span>)</div></pre></td></tr></table></figure>\n<p>参数分为两种</p>\n<ul>\n<li>创建Job实例时，用指定参数直接初始化Job的Args属性</li>\n<li>创建Job后，给Job添加指定的环境变量</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>环境变量名</th>\n<th>FLAG参数</th>\n<th>默认</th>\n<th>作用值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Logging</td>\n<td></td>\n<td>true</td>\n<td>启用Docker容器的日志输出</td>\n</tr>\n<tr>\n<td>EnableCors</td>\n<td>flEnableCors</td>\n<td>false</td>\n<td>在远程API中提供CORS头</td>\n</tr>\n<tr>\n<td>Version</td>\n<td></td>\n<td></td>\n<td>显示Docker版本号</td>\n</tr>\n<tr>\n<td>SocketGroup</td>\n<td>flSockerGroup</td>\n<td>docker</td>\n<td>在daemon模式中unix domain socket分配用户组名</td>\n</tr>\n<tr>\n<td>Tls</td>\n<td>flTls</td>\n<td>false</td>\n<td>使用TLS安全传输协议</td>\n</tr>\n<tr>\n<td>TlsVerify</td>\n<td>flTlsVerify</td>\n<td>false</td>\n<td>使用TLS并验证远程客户端</td>\n</tr>\n<tr>\n<td>TlsCa</td>\n<td>flCa</td>\n<td></td>\n<td>指定CA文件路径</td>\n</tr>\n<tr>\n<td>TlsCert</td>\n<td>flCert</td>\n<td></td>\n<td>TLS证书文件路径</td>\n</tr>\n<tr>\n<td>TlsKey</td>\n<td>flKey</td>\n<td></td>\n<td>TLS密钥文件路径</td>\n</tr>\n<tr>\n<td>BufferRequest</td>\n<td></td>\n<td>true</td>\n<td>缓存Docker Client请求</td>\n</tr>\n</tbody>\n</table>\n<h3>（三）运行Job</h3>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> err := job.Run(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    log.Fatal(err)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Docker在eng对象中注册过键位serverapi的处理方法，在运行Job的时候执行这个处理方法的值函数，相应的处理方法的值为api.ServeApi。</p>\n<h2>二、ServeApi运行流程</h2>\n<p>​     ServeApi属于Docker Server提供API服务的部分，作为一个监听请求、处理请求、响应请求的服务端，支持三种协议：TCP协议、UNIX Socket形式以及fd的形式。功能是：循环检查Docker Daemon支持的所有协议，并为每一种协议创建一个协程goroutine，并在协程内部配置一个服务于HTTP请求的服务端。</p>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ServeApi loops through all of the protocols sent in to docker and spawns</span></div><div class=\"line\"><span class=\"comment\">// off a go routine to setup a serving http.Server for each.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ServeApi</span><span class=\"params\">(job *engine.Job)</span> <span class=\"title\">engine</span>.<span class=\"title\">Status</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(job.Args) == <span class=\"number\">0</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> job.Errorf(<span class=\"string\">\"usage: %s PROTO://ADDR [PROTO://ADDR ...]\"</span>, job.Name)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> (</div><div class=\"line\">        protoAddrs = job.Args</div><div class=\"line\">        chErrors   = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> error, <span class=\"built_in\">len</span>(protoAddrs))</div><div class=\"line\">    )</div><div class=\"line\">    activationLock = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">for</span> _, protoAddr := <span class=\"keyword\">range</span> protoAddrs &#123;</div><div class=\"line\">        protoAddrParts := strings.SplitN(protoAddr, <span class=\"string\">\"://\"</span>, <span class=\"number\">2</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(protoAddrParts) != <span class=\"number\">2</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> job.Errorf(<span class=\"string\">\"usage: %s PROTO://ADDR [PROTO://ADDR ...]\"</span>, job.Name)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">            log.Infof(<span class=\"string\">\"Listening for HTTP on %s (%s)\"</span>, protoAddrParts[<span class=\"number\">0</span>], protoAddrParts[<span class=\"number\">1</span>])</div><div class=\"line\">            chErrors &lt;- ListenAndServe(protoAddrParts[<span class=\"number\">0</span>], protoAddrParts[<span class=\"number\">1</span>], job)</div><div class=\"line\">        &#125;()</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(protoAddrs); i += <span class=\"number\">1</span> &#123;</div><div class=\"line\">        err := &lt;-chErrors</div><div class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">return</span> engine.StatusOK</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ServeApi执行流程：</p>\n<ol>\n<li>检查Job参数，确保传入参数无误</li>\n<li>定义Docker Server的监听协议与地址，以及错误信息管理channel</li>\n<li>遍历协议地址，针对协议创建相应的服务端</li>\n<li>通过chErrors建立goroutine与主进程之间的协调关系</li>\n</ol>\n<h3>（一）判断Job参数</h3>\n<p>判断Job参数，job.Args，即数组flHost，若flHost的长度为0，则说明没有监听的协议与地址，参数有误。</p>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ServeApi</span><span class=\"params\">(job *engine.Job)</span> <span class=\"title\">engine</span>.<span class=\"title\">Status</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(job.Args) == <span class=\"number\">0</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> job.Errorf(<span class=\"string\">\"usage: %s PROTO://ADDR [PROTO://ADDR ...]\"</span>, job.Name)</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>（二）定义监听协议与地址及错误信息</h3>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> (</div><div class=\"line\">       protoAddrs = job.Args</div><div class=\"line\">       chErrors   = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> error, <span class=\"built_in\">len</span>(protoAddrs))</div><div class=\"line\">   )</div><div class=\"line\">   activationLock = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</div></pre></td></tr></table></figure>\n<p>定义protoAddrs[flHosts的内容]、chErrors[错误类型管道]与activationLock[同步serveapi和acceptconnections两个job执行的管道]三个变量，</p>\n<h3>（三）遍历协议地址</h3>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> _, protoAddr := <span class=\"keyword\">range</span> protoAddrs &#123;</div><div class=\"line\">    protoAddrParts := strings.SplitN(protoAddr, <span class=\"string\">\"://\"</span>, <span class=\"number\">2</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(protoAddrParts) != <span class=\"number\">2</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> job.Errorf(<span class=\"string\">\"usage: %s PROTO://ADDR [PROTO://ADDR ...]\"</span>, job.Name)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        log.Infof(<span class=\"string\">\"Listening for HTTP on %s (%s)\"</span>, protoAddrParts[<span class=\"number\">0</span>], protoAddrParts[<span class=\"number\">1</span>])</div><div class=\"line\">        chErrors &lt;- ListenAndServe(protoAddrParts[<span class=\"number\">0</span>], protoAddrParts[<span class=\"number\">1</span>], job)</div><div class=\"line\">    &#125;()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>遍历协议地址，针对协议创建相应的服务端。协议地址</p>\n<h3>（四）协调chErrors与主进程关系</h3>\n<p>根据chErrors的值运行，如果chErrors这个管道中有错误内容，则ServerApi一次循环结束，若无错误内容，循环被阻塞。即chErrors确保ListenAndServe所对应的协程能和主函数ServeApi进行协调，如果协程出错，主函数ServeApi仍然可以捕获这样的错误，从而导致程序退出。</p>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(protoAddrs); i += <span class=\"number\">1</span> &#123;</div><div class=\"line\">    err := &lt;-chErrors</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> job.Error(err)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">return</span> engine.StatusOK</div></pre></td></tr></table></figure>\n<h2>三、ListenAndServe实现</h2>\n<p>ListenAndServe的功能：使Docker Server监听某一指定地址，并接收该地址的请求，并对以上请求路由转发至相应的处理方法处。<br>\nListenAndServe执行流程：</p>\n<ol>\n<li>创建route路由实例</li>\n<li>创建listener监听实例</li>\n<li>创建http.Server</li>\n<li>启动API服务</li>\n</ol>\n<p>流程图：<br>\n<img src=\"/img/article/docker/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BDocker-Server/%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg\" alt=\"流程图\"></p>\n<h3>（一）创建route路由实例</h3>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ListenAndServe sets up the required http.Server and gets it listening for</span></div><div class=\"line\"><span class=\"comment\">// each addr passed in and does protocol specific checking.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">(proto, addr <span class=\"keyword\">string</span>, job *engine.Job)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> l net.Listener</div><div class=\"line\">    r, err := createRouter(job.Eng, job.GetenvBool(<span class=\"string\">\"Logging\"</span>), job.GetenvBool(<span class=\"string\">\"EnableCors\"</span>), job.Getenv(<span class=\"string\">\"Version\"</span>))</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>路由实例的作用：负责Docker Server对外部请求的路由及转发。<br>\n实现过程：</p>\n<ol>\n<li>创建全新的route路由实例</li>\n<li>为route实例添加路由记录</li>\n</ol>\n<h4>1、创建空路由实例</h4>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createRouter</span><span class=\"params\">(eng *engine.Engine, logging, enableCors <span class=\"keyword\">bool</span>, dockerVersion <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*mux.Router, error)</span></span> &#123;</div><div class=\"line\">     r := mux.NewRouter()</div><div class=\"line\">     ...</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p><strong>/vendor/src/github.com/gorilla/mux/mux.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// NewRouter returns a new router instance.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewRouter</span><span class=\"params\">()</span> *<span class=\"title\">Router</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &amp;Router&#123;namedRoutes: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*Route), KeepContext: <span class=\"literal\">false</span>&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// This will send all incoming requests to the router.</span></div><div class=\"line\"><span class=\"keyword\">type</span> Router <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Configurable Handler to be used when no route matches.</span></div><div class=\"line\">    NotFoundHandler http.Handler</div><div class=\"line\">    <span class=\"comment\">// Parent route, if this is a subrouter.</span></div><div class=\"line\">    parent parentRoute</div><div class=\"line\">    <span class=\"comment\">// Routes to be matched, in order.</span></div><div class=\"line\">    routes []*Route</div><div class=\"line\">    <span class=\"comment\">// Routes by name for URL building.</span></div><div class=\"line\">    namedRoutes <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*Route</div><div class=\"line\">    <span class=\"comment\">// See Router.StrictSlash(). This defines the flag for new routes.</span></div><div class=\"line\">    strictSlash <span class=\"keyword\">bool</span></div><div class=\"line\">    <span class=\"comment\">// If true, do not clear the request context after handling the request</span></div><div class=\"line\">    KeepContext <span class=\"keyword\">bool</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>NewRoute()函数返回一个全新的route实例r，类型为mux.Router。实例初始化nameRoutes和KeepContext。</p>\n<ul>\n<li>nameRoutes：map类型，key为string类型，value为Route路由记录类型</li>\n<li>KeepContext：属性为false，则处理完请求后清除请求内容，不对请求做存储操作</li>\n</ul>\n<p>mux.Router会通过一系列已经注册过的路由记录，来匹配接收的请求。先通过请求的URL或者其他条件找到相应的路由记录，并调用这条记录中的执行处理方法。<br>\nmux.Router特性</p>\n<ul>\n<li>请求可以基于URL的主机名、路径、路径前缀、shemes、请求头和请求值、HTTP请求方法类型或者使用自定义的匹配规则</li>\n<li>URL主机名和路径可以通过一个正则表达式来表示</li>\n<li>注册的URL可以直接被运用，也可以保留从而保证维护资源的使用</li>\n<li>路由记录同样看可以作用于子路由记录</li>\n</ul>\n<h4>2、添加路由记录</h4>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> os.Getenv(<span class=\"string\">\"DEBUG\"</span>) != <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">       AttachProfiler(r)</div><div class=\"line\">   &#125;</div><div class=\"line\"> </div><div class=\"line\">   m := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]HttpApiFunc&#123;</div><div class=\"line\">       <span class=\"string\">\"GET\"</span>: &#123;</div><div class=\"line\">           <span class=\"string\">\"/_ping\"</span>:                          ping,</div><div class=\"line\">           <span class=\"string\">\"/events\"</span>:                         getEvents,</div><div class=\"line\">           <span class=\"string\">\"/info\"</span>:                           getInfo,</div><div class=\"line\">           <span class=\"string\">\"/version\"</span>:                        getVersion,</div><div class=\"line\">           <span class=\"string\">\"/images/json\"</span>:                    getImagesJSON,</div><div class=\"line\">           <span class=\"string\">\"/images/viz\"</span>:                     getImagesViz,</div><div class=\"line\">           <span class=\"string\">\"/images/search\"</span>:                  getImagesSearch,</div><div class=\"line\">           <span class=\"string\">\"/images/&#123;name:.*&#125;/get\"</span>:           getImagesGet,</div><div class=\"line\">           <span class=\"string\">\"/images/&#123;name:.*&#125;/history\"</span>:       getImagesHistory,</div><div class=\"line\">           <span class=\"string\">\"/images/&#123;name:.*&#125;/json\"</span>:          getImagesByName,</div><div class=\"line\">           <span class=\"string\">\"/containers/ps\"</span>:                  getContainersJSON,</div><div class=\"line\">           <span class=\"string\">\"/containers/json\"</span>:                getContainersJSON,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/export\"</span>:    getContainersExport,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/changes\"</span>:   getContainersChanges,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/json\"</span>:      getContainersByName,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/top\"</span>:       getContainersTop,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/logs\"</span>:      getContainersLogs,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/attach/ws\"</span>: wsContainersAttach,</div><div class=\"line\">       &#125;,</div><div class=\"line\">       <span class=\"string\">\"POST\"</span>: &#123;</div><div class=\"line\">           <span class=\"string\">\"/auth\"</span>:                         postAuth,</div><div class=\"line\">           <span class=\"string\">\"/commit\"</span>:                       postCommit,</div><div class=\"line\">           <span class=\"string\">\"/build\"</span>:                        postBuild,</div><div class=\"line\">           <span class=\"string\">\"/images/create\"</span>:                postImagesCreate,</div><div class=\"line\">           <span class=\"string\">\"/images/load\"</span>:                  postImagesLoad,</div><div class=\"line\">           <span class=\"string\">\"/images/&#123;name:.*&#125;/push\"</span>:        postImagesPush,</div><div class=\"line\">           <span class=\"string\">\"/images/&#123;name:.*&#125;/tag\"</span>:         postImagesTag,</div><div class=\"line\">           <span class=\"string\">\"/containers/create\"</span>:            postContainersCreate,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/kill\"</span>:    postContainersKill,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/pause\"</span>:   postContainersPause,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/unpause\"</span>: postContainersUnpause,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/restart\"</span>: postContainersRestart,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/start\"</span>:   postContainersStart,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/stop\"</span>:    postContainersStop,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/wait\"</span>:    postContainersWait,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/resize\"</span>:  postContainersResize,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/attach\"</span>:  postContainersAttach,</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;/copy\"</span>:    postContainersCopy,</div><div class=\"line\">       &#125;,</div><div class=\"line\">       <span class=\"string\">\"DELETE\"</span>: &#123;</div><div class=\"line\">           <span class=\"string\">\"/containers/&#123;name:.*&#125;\"</span>: deleteContainers,</div><div class=\"line\">           <span class=\"string\">\"/images/&#123;name:.*&#125;\"</span>:     deleteImages,</div><div class=\"line\">       &#125;,</div><div class=\"line\">       <span class=\"string\">\"OPTIONS\"</span>: &#123;</div><div class=\"line\">           <span class=\"string\">\"\"</span>: optionsHandler,</div><div class=\"line\">       &#125;,</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>m的类型为映射，key表示HTTP的请求类型，如GET、POST、DELETE等，value为映射类型，代表URL与执行处理方法的映射。</p>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> HttpApiFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(eng *engine.Engine, version version.Version, w http.ResponseWriter, r *http.Request, vars <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span></div></pre></td></tr></table></figure>\n<h3>（二）创建listener监听实例</h3>\n<p>路由模块完成请求的路由与分发，监听模块完成请求的监听功能。Listener是一种面向流协议的通用网络监听模块。</p>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> l net.Listener</div><div class=\"line\"> ...</div><div class=\"line\"> <span class=\"keyword\">if</span> job.GetenvBool(<span class=\"string\">\"BufferRequests\"</span>) &#123;</div><div class=\"line\">     l, err = listenbuffer.NewListenBuffer(proto, addr, activationLock)</div><div class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">     l, err = net.Listen(proto, addr)</div></pre></td></tr></table></figure>\n<p>Listenbuffer的作用：让Docker Server立即监听指定协议地址上的请求，但将这些请求暂时先缓存下来，等Docker Daemon全部启动完毕之后才让Docker Server开始接受这些请求。</p>\n<p><strong>/pkg/listenbuffer/buffer.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// NewListenBuffer returns a listener listening on addr with the protocol.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewListenBuffer</span><span class=\"params\">(proto, addr <span class=\"keyword\">string</span>, activate <span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span> <span class=\"params\">(net.Listener, error)</span></span> &#123;</div><div class=\"line\">    wrapped, err := net.Listen(proto, addr)</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">return</span> &amp;defaultListener&#123;</div><div class=\"line\">        wrapped:  wrapped,</div><div class=\"line\">        activate: activate,</div><div class=\"line\">    &#125;, <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>若协议类型为TCP，Job环境变量中Tls或TlsVerity有一个为true，则说明Docker Server需要支持HTTPS服务。需要建立一个tls.Config类型实例tlsConfig，在tlsConfig中加载证书、认证信息，通过tls包中的NewListener函数创建HTTPS协议请求的Listener实例。</p>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">l = tls.NewListener(l, tlsConfig)</div></pre></td></tr></table></figure>\n<h3>（三）创建http.Server</h3>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">httpSrv := http.Server&#123;Addr: addr, Handler: r&#125;</div></pre></td></tr></table></figure>\n<p>Docker Server需要创建一个Server对象来运行HTTP/HTTPS服务端，创建http.Server，addr为需要监听的地址，r为mux.Router。</p>\n<h3>（四）启动API服务</h3>\n<p>创建http.Server实例后，即启动API服务，监听请求，并对每一个请求生成一个新的协程来做专属服务。对于每个请求，协程会读取请求，查询路由表中的路由记录项，找到匹配的路由记录，最终调用路由记录中的处理方法，执行完毕返回响应信息。</p>\n<p><strong>/api/server/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> httpSrv.Serve(l)</div></pre></td></tr></table></figure>"},{"title":"[Docker] Docker源码分析（一）之Docker Client","catalog":true,"date":"2017-07-09T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Docker"],"_content":"\n## 一、创建Docker Client\n\n​    Docker是一个client/server的架构，通过二进制文件docker创建Docker客户端将请求类型与参数发送给Docker Server，Docker Server具体执行命令调用。\nDocker Client运行流程图如下：\n![docker client流程图](/img/article/docker/docker源码之docker-client/docker-client流程图.jpg)\n\n说明：本文分析的代码为Docker 1.2.0版本。\n\n### （一）Docker命令flag参数解析\n\nDocker Server与Docker Client由可执行文件docker命令创建并启动。\n\n- Docker Server的启动：docker -d或docker --daemon=true\n- Docker Client的启动：docker --daemon=false ps等\n\ndocker参数分为两类：\n\n- 命令行参数（flag参数）:--daemon=true,-d\n- 实际请求参数:ps ,images, pull, push等\n\n**/docker/docker.go**\n\n```go\nfunc main() {\n       if reexec.Init() {\n           return\n       }\n       flag.Parse()\n       // FIXME: validate daemon flags here\n       ......\n   }\n```\n\nreexec.Init()作用：协调execdriver与容器创建时dockerinit的关系。如果返回值为真则直接退出运行，否则继续执行。判断reexec.Init()之后，调用flag.Parse()解析命令行中的flag参数。\n\n**/docker/flag.go**\n\n```go\nvar (\n      flVersion     = flag.Bool([]string{\"v\", \"-version\"}, false, \"Print version information and quit\")\n      flDaemon      = flag.Bool([]string{\"d\", \"-daemon\"}, false, \"Enable daemon mode\")\n      flDebug       = flag.Bool([]string{\"D\", \"-debug\"}, false, \"Enable debug mode\")\n      flSocketGroup = flag.String([]string{\"G\", \"-group\"}, \"docker\", \"Group to assign the unix socket specified by -H when running in daemon mode/nuse '' (the empty string) to disable setting of a group\")\n      flEnableCors  = flag.Bool([]string{\"#api-enable-cors\", \"-api-enable-cors\"}, false, \"Enable CORS headers in the remote API\")\n      flTls         = flag.Bool([]string{\"-tls\"}, false, \"Use TLS; implied by tls-verify flags\")\n      flTlsVerify   = flag.Bool([]string{\"-tlsverify\"}, false, \"Use TLS and verify the remote (daemon: verify client, client: verify daemon)\")\n \n      // these are initialized in init() below since their default values depend on dockerCertPath which isn't fully initialized until init() runs\n      flCa    *string\n      flCert  *string\n      flKey   *string\n      flHosts []string\n  )\n \n  func init() {\n      flCa = flag.String([]string{\"-tlscacert\"}, filepath.Join(dockerCertPath, defaultCaFile), \"Trust only remotes providing a certificate signed by the CA given here\")\n      flCert = flag.String([]string{\"-tlscert\"}, filepath.Join(dockerCertPath, defaultCertFile), \"Path to TLS certificate file\")\n      flKey = flag.String([]string{\"-tlskey\"}, filepath.Join(dockerCertPath, defaultKeyFile), \"Path to TLS key file\")\n      opts.HostListVar(&flHosts, []string{\"H\", \"-host\"}, \"The socket(s) to bind to in daemon mode/nspecified using one or more tcp://host:port, unix:///path/to/socket, fd://* or fd://socketfd.\")\n  }\n```\n\nflag.go定义了flag参数，并执行了init的初始化。\n\nGo中的init函数\n\n1. 用于程序执行前包的初始化工作，比如初始化变量\n2. 每个包或源文件可以包含多个init函数\n3. init函数不能被调用，而是在mian函数调用前自动被调用\n4. 不同init函数的执行顺序，按照包导入的顺序执行\n\n当解析到第一个非flag参数时，flag解析工作就结束。例如docker --daemon=flase --version=false ps\n\n- 完成flag的解析，--daemon=false\n- 遇到第一个非flag参数ps，则将ps及其后的参数存入flag.Args()，以便执行之后的具体请求。\n\n### （二）处理flag参数并收集Docker Client的配置信息\n\n处理的flag参数有flVersion,flDebug,flDaemon,flTlsVerify以及flTls。\n\n**/docker/docker.go**\n\n```go\nfunc main() {\n    ......\n    if len(flHosts) == 0 {\n        defaultHost := os.Getenv(\"DOCKER_HOST\")\n        if defaultHost == \"\" || *flDaemon {\n            // If we do not have a host, default to unix socket\n            defaultHost = fmt.Sprintf(\"unix://%s\", api.DEFAULTUNIXSOCKET)\n        }\n        if _, err := api.ValidateHost(defaultHost); err != nil {\n            log.Fatal(err)\n        }\n        flHosts = append(flHosts, defaultHost)\n    }\n    ......\n}\n```\n\nflHosts的作用是为Docker Client提供所要连接的host对象，也就是为Docker Server提供所要监听的对象。\n当flHosts为空，默认取环境变量DOCKER_HOST，若仍为空或flDaemon为真，则设置为unix socket，值为[unix:///var/run/docker.sock。取自/api/common.go中的常量DEFAULTUNIXSOCKET。]()\n\n**/docker/docker.go**\n\n```go\nfunc main() {  \n    ...\n    if *flDaemon {\n        mainDaemon()\n        return\n    }\n    ...\n}\n```\n\n若flDaemon为真，表示启动Docker Daemon，调用/docker/daemon.go中的func mainDaemon()。\n\n**/docker/docker.go**\n\n```go\nif len(flHosts) > 1 {\n    log.Fatal(\"Please specify only one -H\")\n}\nprotoAddrParts := strings.SplitN(flHosts[0], \"://\", 2)\n```\n\nprotoAddrParts的作用是解析出Docker Client 与Docker Server建立通信的协议与地址，通过strings.SplitN函数分割存储。flHosts[0]的值可以是[tcp://0.0.0.0.2375或者unix:///var/run/docker.sock等。]()\n\n**/docker/docker.go**\n\n```go\nvar (\n    cli       *client.DockerCli\n    tlsConfig tls.Config\n)\ntlsConfig.InsecureSkipVerify = true\n```\n\ntlsConfig对象的创建是为了保障cli在传输数据的时候遵循安全传输层协议（TLS）。flTlsVerity参数为真，则说明Docker Client 需Docker Server一起验证连接的安全性，如果flTls和flTlsVerity两个参数中有一个为真，则说明需要加载并发送客户端的证书。\n\n**/docker/flags.go**\n\n```go\nflTls         = flag.Bool([]string{\"-tls\"}, false, \"Use TLS; implied by tls-verify flags\")\nflTlsVerify   = flag.Bool([]string{\"-tlsverify\"}, false, \"Use TLS and verify the remote (daemon: verify client, client: verify daemon)\")\n```\n\n### （三）如何创建Docker Client\n\n**/docker/docker.go**\n\n```go\nif *flTls || *flTlsVerify {\n    cli = client.NewDockerCli(os.Stdin, os.Stdout, os.Stderr, protoAddrParts[0], protoAddrParts[1], &tlsConfig)\n} else {\n    cli = client.NewDockerCli(os.Stdin, os.Stdout, os.Stderr, protoAddrParts[0], protoAddrParts[1], nil)\n}\n```\n\n在已有配置参数的情况下，通过/api/client/cli.go中的NewDockerCli方法创建Docker Client实例cli。\n\n**/api/client/cli.go**\n\n```go\ntype DockerCli struct {\n    proto      string\n    addr       string\n    configFile *registry.ConfigFile\n    in         io.ReadCloser\n    out        io.Writer\n    err        io.Writer\n    isTerminal bool\n    terminalFd uintptr\n    tlsConfig  *tls.Config\n    scheme     string\n}\n \nfunc NewDockerCli(in io.ReadCloser, out, err io.Writer, proto, addr string, tlsConfig *tls.Config) *DockerCli {\n    var (\n        isTerminal = false\n        terminalFd uintptr\n        scheme     = \"http\"\n    )\n \n    if tlsConfig != nil {\n        scheme = \"https\"\n    }\n \n    if in != nil {\n        if file, ok := out.(*os.File); ok {\n            terminalFd = file.Fd()\n            isTerminal = term.IsTerminal(terminalFd)\n        }\n    }\n \n    if err == nil {\n        err = out\n    }\n    return &DockerCli{\n        proto:      proto,\n        addr:       addr,\n        in:         in,\n        out:        out,\n        err:        err,\n        isTerminal: isTerminal,\n        terminalFd: terminalFd,\n        tlsConfig:  tlsConfig,\n        scheme:     scheme,\n    }\n}\n```\n\n## 二、Docke命令执行\n\n### （一）Docker Client解析请求命令\n\n创建Docker Client，docker命令中的请求参数（例如ps，经flag解析后放入flag.Args()），分析请求参数及请求的类型，转义为Docker Server可识别的请求后发给Docker Server。\n\n**/docker/docker.go**\n\n```go\nif err := cli.Cmd(flag.Args()...); err != nil {\n    if sterr, ok := err.(*utils.StatusError); ok {\n        if sterr.Status != \"\" {\n            log.Println(sterr.Status)\n        }\n        os.Exit(sterr.StatusCode)\n    }\n    log.Fatal(err)\n}\n```\n\n解析flag.Args()的具体请求参数，执行cli.Cmd函数。代码在/api/client/cli.go\n\n**/api/client/cli.go**\n\n```go\n    // Cmd executes the specified command\n    func (cli *DockerCli) Cmd(args ...string) error {\n        if len(args) > 0 {\n            method, exists := cli.getMethod(args[0])\n            if !exists {\n                fmt.Println(\"Error: Command not found:\", args[0])\n                return cli.CmdHelp(args[1:]...)\n            }\n            return method(args[1:]...)\n        }\n        return cli.CmdHelp(args...)\n    }\n \nmethod, exists := cli.getMethod(args[0])获取请求参数，例如docker pull ImageName，args[0]等于pull。\n \n    func (cli *DockerCli) getMethod(name string) (func(...string) error, bool) {\n        if len(name) == 0 {\n            return nil, false\n        }\n        methodName := \"Cmd\" + strings.ToUpper(name[:1]) + strings.ToLower(name[1:])\n        method := reflect.ValueOf(cli).MethodByName(methodName)\n        if !method.IsValid() {\n            return nil, false\n        }\n        return method.Interface().(func(...string) error), true\n    }\n```\n\n在getMethod中，返回method值为“CmdPull”。最后执行method(args[1:]...)，即CmdPull(args[1:]...)。\n\n### （二）Docker Client执行请求命令\n\ndocker pull ImageName中，即执行CmdPull(args[1:]...)，args[1:]即为ImageName。命令代码在/api/client/command.go。\n\n**/api/client/commands.go**\n\n```go\nfunc (cli *DockerCli) CmdPull(args ...string) error {\n    cmd := cli.Subcmd(\"pull\", \"NAME[:TAG]\", \"Pull an image or a repository from the registry\")\n    tag := cmd.String([]string{\"#t\", \"#-tag\"}, \"\", \"Download tagged image in a repository\")\n    if err := cmd.Parse(args); err != nil {\n        return nil\n    }\n    ...\n}\n```\n\n将args参数进行第二次flag参数解析，解析过程中先提取是否有符合tag这个flag的参数，若有赋值给tag参数，其余存入cmd.NArg()，若没有则所有的参数存入cmd.NArg()中。\n\n**/api/client/commands.go**\n\n```go\nvar (\n     v      = url.Values{}\n     remote = cmd.Arg(0)\n )\n \n v.Set(\"fromImage\", remote)\n \n if *tag == \"\" {\n     v.Set(\"tag\", *tag)\n }\n \n remote, _ = parsers.ParseRepositoryTag(remote)\n // Resolve the Repository name from fqn to hostname + name\n hostname, _, err := registry.ResolveRepositoryName(remote)\n if err != nil {\n     return err\n }\n```\n\n通过remote变量先得到镜像的repository名称，并赋值给remote自身，随后解析改变后的remote，得出镜像所在的host地址，即Docker Registry的地址。若没有指定默认为Docker Hub地址[https://index.docker.io/v1/。]()\n\n**/api/client/commands.go**\n\n```go\ncli.LoadConfigFile()\n \n// Resolve the Auth config relevant for this server\nauthConfig := cli.configFile.ResolveAuthConfig(hostname)\n```\n\n通过cli对象获取与Docker Server的认证配置信息。\n\n**/api/client/commands.go**\n\n```go\npull := func(authConfig registry.AuthConfig) error {\n    buf, err := json.Marshal(authConfig)\n    if err != nil {\n        return err\n    }\n    registryAuthHeader := []string{\n        base64.URLEncoding.EncodeToString(buf),\n    }\n \n    return cli.stream(\"POST\", \"/images/create?\"+v.Encode(), nil, cli.out, map[string][]string{\n        \"X-Registry-Auth\": registryAuthHeader,\n    })\n}\n```\n\n定义pull函数：cli.stream(\"POST\", \"/images/create?\"+v.Encode(),...)像Docker Server发送POST请求，请求url为“\"/images/create?\"+v.Encode()”，请求的认证信息为：map[string][]string{\"X-Registry-Auth\": registryAuthHeader,}\n\n**/api/client/commands.go**\n\n```go\nif err := pull(authConfig); err != nil {\n    if strings.Contains(err.Error(), \"Status 401\") {\n        fmt.Fprintln(cli.out, \"/nPlease login prior to pull:\")\n        if err := cli.CmdLogin(hostname); err != nil {\n            return err\n        }\n        authConfig := cli.configFile.ResolveAuthConfig(hostname)\n        return pull(authConfig)\n    }\n    return err\n}\n \nreturn nil\n```\n\n调用pull函数，实现下载请求发送。后续有Docker Server接收到请求后具体实现。\n\n ","source":"_posts/Docker/Docker源码/Docker源码分析（一）之Docker Client.md","raw":"---\ntitle: \"[Docker] Docker源码分析（一）之Docker Client\"\ncatalog: true\ndate: 2017-07-09 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Docker\ncatagories:\n- Docker\n---\n\n## 一、创建Docker Client\n\n​    Docker是一个client/server的架构，通过二进制文件docker创建Docker客户端将请求类型与参数发送给Docker Server，Docker Server具体执行命令调用。\nDocker Client运行流程图如下：\n![docker client流程图](/img/article/docker/docker源码之docker-client/docker-client流程图.jpg)\n\n说明：本文分析的代码为Docker 1.2.0版本。\n\n### （一）Docker命令flag参数解析\n\nDocker Server与Docker Client由可执行文件docker命令创建并启动。\n\n- Docker Server的启动：docker -d或docker --daemon=true\n- Docker Client的启动：docker --daemon=false ps等\n\ndocker参数分为两类：\n\n- 命令行参数（flag参数）:--daemon=true,-d\n- 实际请求参数:ps ,images, pull, push等\n\n**/docker/docker.go**\n\n```go\nfunc main() {\n       if reexec.Init() {\n           return\n       }\n       flag.Parse()\n       // FIXME: validate daemon flags here\n       ......\n   }\n```\n\nreexec.Init()作用：协调execdriver与容器创建时dockerinit的关系。如果返回值为真则直接退出运行，否则继续执行。判断reexec.Init()之后，调用flag.Parse()解析命令行中的flag参数。\n\n**/docker/flag.go**\n\n```go\nvar (\n      flVersion     = flag.Bool([]string{\"v\", \"-version\"}, false, \"Print version information and quit\")\n      flDaemon      = flag.Bool([]string{\"d\", \"-daemon\"}, false, \"Enable daemon mode\")\n      flDebug       = flag.Bool([]string{\"D\", \"-debug\"}, false, \"Enable debug mode\")\n      flSocketGroup = flag.String([]string{\"G\", \"-group\"}, \"docker\", \"Group to assign the unix socket specified by -H when running in daemon mode/nuse '' (the empty string) to disable setting of a group\")\n      flEnableCors  = flag.Bool([]string{\"#api-enable-cors\", \"-api-enable-cors\"}, false, \"Enable CORS headers in the remote API\")\n      flTls         = flag.Bool([]string{\"-tls\"}, false, \"Use TLS; implied by tls-verify flags\")\n      flTlsVerify   = flag.Bool([]string{\"-tlsverify\"}, false, \"Use TLS and verify the remote (daemon: verify client, client: verify daemon)\")\n \n      // these are initialized in init() below since their default values depend on dockerCertPath which isn't fully initialized until init() runs\n      flCa    *string\n      flCert  *string\n      flKey   *string\n      flHosts []string\n  )\n \n  func init() {\n      flCa = flag.String([]string{\"-tlscacert\"}, filepath.Join(dockerCertPath, defaultCaFile), \"Trust only remotes providing a certificate signed by the CA given here\")\n      flCert = flag.String([]string{\"-tlscert\"}, filepath.Join(dockerCertPath, defaultCertFile), \"Path to TLS certificate file\")\n      flKey = flag.String([]string{\"-tlskey\"}, filepath.Join(dockerCertPath, defaultKeyFile), \"Path to TLS key file\")\n      opts.HostListVar(&flHosts, []string{\"H\", \"-host\"}, \"The socket(s) to bind to in daemon mode/nspecified using one or more tcp://host:port, unix:///path/to/socket, fd://* or fd://socketfd.\")\n  }\n```\n\nflag.go定义了flag参数，并执行了init的初始化。\n\nGo中的init函数\n\n1. 用于程序执行前包的初始化工作，比如初始化变量\n2. 每个包或源文件可以包含多个init函数\n3. init函数不能被调用，而是在mian函数调用前自动被调用\n4. 不同init函数的执行顺序，按照包导入的顺序执行\n\n当解析到第一个非flag参数时，flag解析工作就结束。例如docker --daemon=flase --version=false ps\n\n- 完成flag的解析，--daemon=false\n- 遇到第一个非flag参数ps，则将ps及其后的参数存入flag.Args()，以便执行之后的具体请求。\n\n### （二）处理flag参数并收集Docker Client的配置信息\n\n处理的flag参数有flVersion,flDebug,flDaemon,flTlsVerify以及flTls。\n\n**/docker/docker.go**\n\n```go\nfunc main() {\n    ......\n    if len(flHosts) == 0 {\n        defaultHost := os.Getenv(\"DOCKER_HOST\")\n        if defaultHost == \"\" || *flDaemon {\n            // If we do not have a host, default to unix socket\n            defaultHost = fmt.Sprintf(\"unix://%s\", api.DEFAULTUNIXSOCKET)\n        }\n        if _, err := api.ValidateHost(defaultHost); err != nil {\n            log.Fatal(err)\n        }\n        flHosts = append(flHosts, defaultHost)\n    }\n    ......\n}\n```\n\nflHosts的作用是为Docker Client提供所要连接的host对象，也就是为Docker Server提供所要监听的对象。\n当flHosts为空，默认取环境变量DOCKER_HOST，若仍为空或flDaemon为真，则设置为unix socket，值为[unix:///var/run/docker.sock。取自/api/common.go中的常量DEFAULTUNIXSOCKET。]()\n\n**/docker/docker.go**\n\n```go\nfunc main() {  \n    ...\n    if *flDaemon {\n        mainDaemon()\n        return\n    }\n    ...\n}\n```\n\n若flDaemon为真，表示启动Docker Daemon，调用/docker/daemon.go中的func mainDaemon()。\n\n**/docker/docker.go**\n\n```go\nif len(flHosts) > 1 {\n    log.Fatal(\"Please specify only one -H\")\n}\nprotoAddrParts := strings.SplitN(flHosts[0], \"://\", 2)\n```\n\nprotoAddrParts的作用是解析出Docker Client 与Docker Server建立通信的协议与地址，通过strings.SplitN函数分割存储。flHosts[0]的值可以是[tcp://0.0.0.0.2375或者unix:///var/run/docker.sock等。]()\n\n**/docker/docker.go**\n\n```go\nvar (\n    cli       *client.DockerCli\n    tlsConfig tls.Config\n)\ntlsConfig.InsecureSkipVerify = true\n```\n\ntlsConfig对象的创建是为了保障cli在传输数据的时候遵循安全传输层协议（TLS）。flTlsVerity参数为真，则说明Docker Client 需Docker Server一起验证连接的安全性，如果flTls和flTlsVerity两个参数中有一个为真，则说明需要加载并发送客户端的证书。\n\n**/docker/flags.go**\n\n```go\nflTls         = flag.Bool([]string{\"-tls\"}, false, \"Use TLS; implied by tls-verify flags\")\nflTlsVerify   = flag.Bool([]string{\"-tlsverify\"}, false, \"Use TLS and verify the remote (daemon: verify client, client: verify daemon)\")\n```\n\n### （三）如何创建Docker Client\n\n**/docker/docker.go**\n\n```go\nif *flTls || *flTlsVerify {\n    cli = client.NewDockerCli(os.Stdin, os.Stdout, os.Stderr, protoAddrParts[0], protoAddrParts[1], &tlsConfig)\n} else {\n    cli = client.NewDockerCli(os.Stdin, os.Stdout, os.Stderr, protoAddrParts[0], protoAddrParts[1], nil)\n}\n```\n\n在已有配置参数的情况下，通过/api/client/cli.go中的NewDockerCli方法创建Docker Client实例cli。\n\n**/api/client/cli.go**\n\n```go\ntype DockerCli struct {\n    proto      string\n    addr       string\n    configFile *registry.ConfigFile\n    in         io.ReadCloser\n    out        io.Writer\n    err        io.Writer\n    isTerminal bool\n    terminalFd uintptr\n    tlsConfig  *tls.Config\n    scheme     string\n}\n \nfunc NewDockerCli(in io.ReadCloser, out, err io.Writer, proto, addr string, tlsConfig *tls.Config) *DockerCli {\n    var (\n        isTerminal = false\n        terminalFd uintptr\n        scheme     = \"http\"\n    )\n \n    if tlsConfig != nil {\n        scheme = \"https\"\n    }\n \n    if in != nil {\n        if file, ok := out.(*os.File); ok {\n            terminalFd = file.Fd()\n            isTerminal = term.IsTerminal(terminalFd)\n        }\n    }\n \n    if err == nil {\n        err = out\n    }\n    return &DockerCli{\n        proto:      proto,\n        addr:       addr,\n        in:         in,\n        out:        out,\n        err:        err,\n        isTerminal: isTerminal,\n        terminalFd: terminalFd,\n        tlsConfig:  tlsConfig,\n        scheme:     scheme,\n    }\n}\n```\n\n## 二、Docke命令执行\n\n### （一）Docker Client解析请求命令\n\n创建Docker Client，docker命令中的请求参数（例如ps，经flag解析后放入flag.Args()），分析请求参数及请求的类型，转义为Docker Server可识别的请求后发给Docker Server。\n\n**/docker/docker.go**\n\n```go\nif err := cli.Cmd(flag.Args()...); err != nil {\n    if sterr, ok := err.(*utils.StatusError); ok {\n        if sterr.Status != \"\" {\n            log.Println(sterr.Status)\n        }\n        os.Exit(sterr.StatusCode)\n    }\n    log.Fatal(err)\n}\n```\n\n解析flag.Args()的具体请求参数，执行cli.Cmd函数。代码在/api/client/cli.go\n\n**/api/client/cli.go**\n\n```go\n    // Cmd executes the specified command\n    func (cli *DockerCli) Cmd(args ...string) error {\n        if len(args) > 0 {\n            method, exists := cli.getMethod(args[0])\n            if !exists {\n                fmt.Println(\"Error: Command not found:\", args[0])\n                return cli.CmdHelp(args[1:]...)\n            }\n            return method(args[1:]...)\n        }\n        return cli.CmdHelp(args...)\n    }\n \nmethod, exists := cli.getMethod(args[0])获取请求参数，例如docker pull ImageName，args[0]等于pull。\n \n    func (cli *DockerCli) getMethod(name string) (func(...string) error, bool) {\n        if len(name) == 0 {\n            return nil, false\n        }\n        methodName := \"Cmd\" + strings.ToUpper(name[:1]) + strings.ToLower(name[1:])\n        method := reflect.ValueOf(cli).MethodByName(methodName)\n        if !method.IsValid() {\n            return nil, false\n        }\n        return method.Interface().(func(...string) error), true\n    }\n```\n\n在getMethod中，返回method值为“CmdPull”。最后执行method(args[1:]...)，即CmdPull(args[1:]...)。\n\n### （二）Docker Client执行请求命令\n\ndocker pull ImageName中，即执行CmdPull(args[1:]...)，args[1:]即为ImageName。命令代码在/api/client/command.go。\n\n**/api/client/commands.go**\n\n```go\nfunc (cli *DockerCli) CmdPull(args ...string) error {\n    cmd := cli.Subcmd(\"pull\", \"NAME[:TAG]\", \"Pull an image or a repository from the registry\")\n    tag := cmd.String([]string{\"#t\", \"#-tag\"}, \"\", \"Download tagged image in a repository\")\n    if err := cmd.Parse(args); err != nil {\n        return nil\n    }\n    ...\n}\n```\n\n将args参数进行第二次flag参数解析，解析过程中先提取是否有符合tag这个flag的参数，若有赋值给tag参数，其余存入cmd.NArg()，若没有则所有的参数存入cmd.NArg()中。\n\n**/api/client/commands.go**\n\n```go\nvar (\n     v      = url.Values{}\n     remote = cmd.Arg(0)\n )\n \n v.Set(\"fromImage\", remote)\n \n if *tag == \"\" {\n     v.Set(\"tag\", *tag)\n }\n \n remote, _ = parsers.ParseRepositoryTag(remote)\n // Resolve the Repository name from fqn to hostname + name\n hostname, _, err := registry.ResolveRepositoryName(remote)\n if err != nil {\n     return err\n }\n```\n\n通过remote变量先得到镜像的repository名称，并赋值给remote自身，随后解析改变后的remote，得出镜像所在的host地址，即Docker Registry的地址。若没有指定默认为Docker Hub地址[https://index.docker.io/v1/。]()\n\n**/api/client/commands.go**\n\n```go\ncli.LoadConfigFile()\n \n// Resolve the Auth config relevant for this server\nauthConfig := cli.configFile.ResolveAuthConfig(hostname)\n```\n\n通过cli对象获取与Docker Server的认证配置信息。\n\n**/api/client/commands.go**\n\n```go\npull := func(authConfig registry.AuthConfig) error {\n    buf, err := json.Marshal(authConfig)\n    if err != nil {\n        return err\n    }\n    registryAuthHeader := []string{\n        base64.URLEncoding.EncodeToString(buf),\n    }\n \n    return cli.stream(\"POST\", \"/images/create?\"+v.Encode(), nil, cli.out, map[string][]string{\n        \"X-Registry-Auth\": registryAuthHeader,\n    })\n}\n```\n\n定义pull函数：cli.stream(\"POST\", \"/images/create?\"+v.Encode(),...)像Docker Server发送POST请求，请求url为“\"/images/create?\"+v.Encode()”，请求的认证信息为：map[string][]string{\"X-Registry-Auth\": registryAuthHeader,}\n\n**/api/client/commands.go**\n\n```go\nif err := pull(authConfig); err != nil {\n    if strings.Contains(err.Error(), \"Status 401\") {\n        fmt.Fprintln(cli.out, \"/nPlease login prior to pull:\")\n        if err := cli.CmdLogin(hostname); err != nil {\n            return err\n        }\n        authConfig := cli.configFile.ResolveAuthConfig(hostname)\n        return pull(authConfig)\n    }\n    return err\n}\n \nreturn nil\n```\n\n调用pull函数，实现下载请求发送。后续有Docker Server接收到请求后具体实现。\n\n ","slug":"Docker/Docker源码/Docker源码分析（一）之Docker Client","published":1,"updated":"2017-10-02T08:56:05.788Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740k0001230vuwlr9wtxj","content":"<h2><span id=\"一-创建docker-client\">一、创建Docker Client</span></h2>\n<p>​    Docker是一个client/server的架构，通过二进制文件docker创建Docker客户端将请求类型与参数发送给Docker Server，Docker Server具体执行命令调用。<br>\nDocker Client运行流程图如下：<br>\n<img src=\"/img/article/docker/docker%E6%BA%90%E7%A0%81%E4%B9%8Bdocker-client/docker-client%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg\" alt=\"docker client流程图\"></p>\n<p>说明：本文分析的代码为Docker 1.2.0版本。</p>\n<h3><span id=\"一docker命令flag参数解析\">（一）Docker命令flag参数解析</span></h3>\n<p>Docker Server与Docker Client由可执行文件docker命令创建并启动。</p>\n<ul>\n<li>Docker Server的启动：docker -d或docker --daemon=true</li>\n<li>Docker Client的启动：docker --daemon=false ps等</li>\n</ul>\n<p>docker参数分为两类：</p>\n<ul>\n<li>命令行参数（flag参数）:–daemon=true,-d</li>\n<li>实际请求参数:ps ,images, pull, push等</li>\n</ul>\n<p><strong>/docker/docker.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> reexec.Init() &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       flag.Parse()</div><div class=\"line\">       <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> validate daemon flags here</span></div><div class=\"line\">       ......</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>reexec.Init()作用：协调execdriver与容器创建时dockerinit的关系。如果返回值为真则直接退出运行，否则继续执行。判断reexec.Init()之后，调用flag.Parse()解析命令行中的flag参数。</p>\n<p><strong>/docker/flag.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> (</div><div class=\"line\">      flVersion     = flag.Bool([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"v\"</span>, <span class=\"string\">\"-version\"</span>&#125;, <span class=\"literal\">false</span>, <span class=\"string\">\"Print version information and quit\"</span>)</div><div class=\"line\">      flDaemon      = flag.Bool([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"d\"</span>, <span class=\"string\">\"-daemon\"</span>&#125;, <span class=\"literal\">false</span>, <span class=\"string\">\"Enable daemon mode\"</span>)</div><div class=\"line\">      flDebug       = flag.Bool([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"D\"</span>, <span class=\"string\">\"-debug\"</span>&#125;, <span class=\"literal\">false</span>, <span class=\"string\">\"Enable debug mode\"</span>)</div><div class=\"line\">      flSocketGroup = flag.String([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"G\"</span>, <span class=\"string\">\"-group\"</span>&#125;, <span class=\"string\">\"docker\"</span>, <span class=\"string\">\"Group to assign the unix socket specified by -H when running in daemon mode/nuse '' (the empty string) to disable setting of a group\"</span>)</div><div class=\"line\">      flEnableCors  = flag.Bool([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#api-enable-cors\"</span>, <span class=\"string\">\"-api-enable-cors\"</span>&#125;, <span class=\"literal\">false</span>, <span class=\"string\">\"Enable CORS headers in the remote API\"</span>)</div><div class=\"line\">      flTls         = flag.Bool([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-tls\"</span>&#125;, <span class=\"literal\">false</span>, <span class=\"string\">\"Use TLS; implied by tls-verify flags\"</span>)</div><div class=\"line\">      flTlsVerify   = flag.Bool([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-tlsverify\"</span>&#125;, <span class=\"literal\">false</span>, <span class=\"string\">\"Use TLS and verify the remote (daemon: verify client, client: verify daemon)\"</span>)</div><div class=\"line\"> </div><div class=\"line\">      <span class=\"comment\">// these are initialized in init() below since their default values depend on dockerCertPath which isn't fully initialized until init() runs</span></div><div class=\"line\">      flCa    *<span class=\"keyword\">string</span></div><div class=\"line\">      flCert  *<span class=\"keyword\">string</span></div><div class=\"line\">      flKey   *<span class=\"keyword\">string</span></div><div class=\"line\">      flHosts []<span class=\"keyword\">string</span></div><div class=\"line\">  )</div><div class=\"line\"> </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">      flCa = flag.String([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-tlscacert\"</span>&#125;, filepath.Join(dockerCertPath, defaultCaFile), <span class=\"string\">\"Trust only remotes providing a certificate signed by the CA given here\"</span>)</div><div class=\"line\">      flCert = flag.String([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-tlscert\"</span>&#125;, filepath.Join(dockerCertPath, defaultCertFile), <span class=\"string\">\"Path to TLS certificate file\"</span>)</div><div class=\"line\">      flKey = flag.String([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-tlskey\"</span>&#125;, filepath.Join(dockerCertPath, defaultKeyFile), <span class=\"string\">\"Path to TLS key file\"</span>)</div><div class=\"line\">      opts.HostListVar(&amp;flHosts, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"H\"</span>, <span class=\"string\">\"-host\"</span>&#125;, <span class=\"string\">\"The socket(s) to bind to in daemon mode/nspecified using one or more tcp://host:port, unix:///path/to/socket, fd://* or fd://socketfd.\"</span>)</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>flag.go定义了flag参数，并执行了init的初始化。</p>\n<p>Go中的init函数</p>\n<ol>\n<li>用于程序执行前包的初始化工作，比如初始化变量</li>\n<li>每个包或源文件可以包含多个init函数</li>\n<li>init函数不能被调用，而是在mian函数调用前自动被调用</li>\n<li>不同init函数的执行顺序，按照包导入的顺序执行</li>\n</ol>\n<p>当解析到第一个非flag参数时，flag解析工作就结束。例如docker --daemon=flase --version=false ps</p>\n<ul>\n<li>完成flag的解析，–daemon=false</li>\n<li>遇到第一个非flag参数ps，则将ps及其后的参数存入flag.Args()，以便执行之后的具体请求。</li>\n</ul>\n<h3><span id=\"二处理flag参数并收集docker-client的配置信息\">（二）处理flag参数并收集Docker Client的配置信息</span></h3>\n<p>处理的flag参数有flVersion,flDebug,flDaemon,flTlsVerify以及flTls。</p>\n<p><strong>/docker/docker.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    ......</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(flHosts) == <span class=\"number\">0</span> &#123;</div><div class=\"line\">        defaultHost := os.Getenv(<span class=\"string\">\"DOCKER_HOST\"</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> defaultHost == <span class=\"string\">\"\"</span> || *flDaemon &#123;</div><div class=\"line\">            <span class=\"comment\">// If we do not have a host, default to unix socket</span></div><div class=\"line\">            defaultHost = fmt.Sprintf(<span class=\"string\">\"unix://%s\"</span>, api.DEFAULTUNIXSOCKET)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> _, err := api.ValidateHost(defaultHost); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            log.Fatal(err)</div><div class=\"line\">        &#125;</div><div class=\"line\">        flHosts = <span class=\"built_in\">append</span>(flHosts, defaultHost)</div><div class=\"line\">    &#125;</div><div class=\"line\">    ......</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>flHosts的作用是为Docker Client提供所要连接的host对象，也就是为Docker Server提供所要监听的对象。<br>\n当flHosts为空，默认取环境变量DOCKER_HOST，若仍为空或flDaemon为真，则设置为unix socket，值为<a href=\"\">unix:///var/run/docker.sock。取自/api/common.go中的常量DEFAULTUNIXSOCKET。</a></p>\n<p><strong>/docker/docker.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;  </div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">if</span> *flDaemon &#123;</div><div class=\"line\">        mainDaemon()</div><div class=\"line\">        <span class=\"keyword\">return</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>若flDaemon为真，表示启动Docker Daemon，调用/docker/daemon.go中的func mainDaemon()。</p>\n<p><strong>/docker/docker.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(flHosts) &gt; <span class=\"number\">1</span> &#123;</div><div class=\"line\">    log.Fatal(<span class=\"string\">\"Please specify only one -H\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">protoAddrParts := strings.SplitN(flHosts[<span class=\"number\">0</span>], <span class=\"string\">\"://\"</span>, <span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<p>protoAddrParts的作用是解析出Docker Client 与Docker Server建立通信的协议与地址，通过strings.SplitN函数分割存储。flHosts[0]的值可以是<a href=\"\">tcp://0.0.0.0.2375或者unix:///var/run/docker.sock等。</a></p>\n<p><strong>/docker/docker.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> (</div><div class=\"line\">    cli       *client.DockerCli</div><div class=\"line\">    tlsConfig tls.Config</div><div class=\"line\">)</div><div class=\"line\">tlsConfig.InsecureSkipVerify = <span class=\"literal\">true</span></div></pre></td></tr></table></figure>\n<p>tlsConfig对象的创建是为了保障cli在传输数据的时候遵循安全传输层协议（TLS）。flTlsVerity参数为真，则说明Docker Client 需Docker Server一起验证连接的安全性，如果flTls和flTlsVerity两个参数中有一个为真，则说明需要加载并发送客户端的证书。</p>\n<p><strong>/docker/flags.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">flTls         = flag.Bool([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-tls\"</span>&#125;, <span class=\"literal\">false</span>, <span class=\"string\">\"Use TLS; implied by tls-verify flags\"</span>)</div><div class=\"line\">flTlsVerify   = flag.Bool([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-tlsverify\"</span>&#125;, <span class=\"literal\">false</span>, <span class=\"string\">\"Use TLS and verify the remote (daemon: verify client, client: verify daemon)\"</span>)</div></pre></td></tr></table></figure>\n<h3><span id=\"三如何创建docker-client\">（三）如何创建Docker Client</span></h3>\n<p><strong>/docker/docker.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> *flTls || *flTlsVerify &#123;</div><div class=\"line\">    cli = client.NewDockerCli(os.Stdin, os.Stdout, os.Stderr, protoAddrParts[<span class=\"number\">0</span>], protoAddrParts[<span class=\"number\">1</span>], &amp;tlsConfig)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    cli = client.NewDockerCli(os.Stdin, os.Stdout, os.Stderr, protoAddrParts[<span class=\"number\">0</span>], protoAddrParts[<span class=\"number\">1</span>], <span class=\"literal\">nil</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在已有配置参数的情况下，通过/api/client/cli.go中的NewDockerCli方法创建Docker Client实例cli。</p>\n<p><strong>/api/client/cli.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> DockerCli <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    proto      <span class=\"keyword\">string</span></div><div class=\"line\">    addr       <span class=\"keyword\">string</span></div><div class=\"line\">    configFile *registry.ConfigFile</div><div class=\"line\">    in         io.ReadCloser</div><div class=\"line\">    out        io.Writer</div><div class=\"line\">    err        io.Writer</div><div class=\"line\">    isTerminal <span class=\"keyword\">bool</span></div><div class=\"line\">    terminalFd <span class=\"keyword\">uintptr</span></div><div class=\"line\">    tlsConfig  *tls.Config</div><div class=\"line\">    scheme     <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewDockerCli</span><span class=\"params\">(in io.ReadCloser, out, err io.Writer, proto, addr <span class=\"keyword\">string</span>, tlsConfig *tls.Config)</span> *<span class=\"title\">DockerCli</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> (</div><div class=\"line\">        isTerminal = <span class=\"literal\">false</span></div><div class=\"line\">        terminalFd <span class=\"keyword\">uintptr</span></div><div class=\"line\">        scheme     = <span class=\"string\">\"http\"</span></div><div class=\"line\">    )</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> tlsConfig != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        scheme = <span class=\"string\">\"https\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> in != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> file, ok := out.(*os.File); ok &#123;</div><div class=\"line\">            terminalFd = file.Fd()</div><div class=\"line\">            isTerminal = term.IsTerminal(terminalFd)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        err = out</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> &amp;DockerCli&#123;</div><div class=\"line\">        proto:      proto,</div><div class=\"line\">        addr:       addr,</div><div class=\"line\">        in:         in,</div><div class=\"line\">        out:        out,</div><div class=\"line\">        err:        err,</div><div class=\"line\">        isTerminal: isTerminal,</div><div class=\"line\">        terminalFd: terminalFd,</div><div class=\"line\">        tlsConfig:  tlsConfig,</div><div class=\"line\">        scheme:     scheme,</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2><span id=\"二-docke命令执行\">二、Docke命令执行</span></h2>\n<h3><span id=\"一docker-client解析请求命令\">（一）Docker Client解析请求命令</span></h3>\n<p>创建Docker Client，docker命令中的请求参数（例如ps，经flag解析后放入flag.Args()），分析请求参数及请求的类型，转义为Docker Server可识别的请求后发给Docker Server。</p>\n<p><strong>/docker/docker.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> err := cli.Cmd(flag.Args()...); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> sterr, ok := err.(*utils.StatusError); ok &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> sterr.Status != <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">            log.Println(sterr.Status)</div><div class=\"line\">        &#125;</div><div class=\"line\">        os.Exit(sterr.StatusCode)</div><div class=\"line\">    &#125;</div><div class=\"line\">    log.Fatal(err)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析flag.Args()的具体请求参数，执行cli.Cmd函数。代码在/api/client/cli.go</p>\n<p><strong>/api/client/cli.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"comment\">// Cmd executes the specified command</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(cli *DockerCli)</span> <span class=\"title\">Cmd</span><span class=\"params\">(args ...<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(args) &gt; <span class=\"number\">0</span> &#123;</div><div class=\"line\">            method, exists := cli.getMethod(args[<span class=\"number\">0</span>])</div><div class=\"line\">            <span class=\"keyword\">if</span> !exists &#123;</div><div class=\"line\">                fmt.Println(<span class=\"string\">\"Error: Command not found:\"</span>, args[<span class=\"number\">0</span>])</div><div class=\"line\">                <span class=\"keyword\">return</span> cli.CmdHelp(args[<span class=\"number\">1</span>:]...)</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> method(args[<span class=\"number\">1</span>:]...)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> cli.CmdHelp(args...)</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">method, exists := cli.getMethod(args[<span class=\"number\">0</span>])获取请求参数，例如docker pull ImageName，args[<span class=\"number\">0</span>]等于pull。</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(cli *DockerCli)</span> <span class=\"title\">getMethod</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">func</span>(...<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span>, <span class=\"title\">bool</span>)</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(name) == <span class=\"number\">0</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        methodName := <span class=\"string\">\"Cmd\"</span> + strings.ToUpper(name[:<span class=\"number\">1</span>]) + strings.ToLower(name[<span class=\"number\">1</span>:])</div><div class=\"line\">        method := reflect.ValueOf(cli).MethodByName(methodName)</div><div class=\"line\">        <span class=\"keyword\">if</span> !method.IsValid() &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> method.Interface().(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(...<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span>), <span class=\"title\">true</span></span></div><div class=\"line\"><span class=\"function\">    &#125;</span></div></pre></td></tr></table></figure>\n<p>在getMethod中，返回method值为“CmdPull”。最后执行method(args[1:]…)，即CmdPull(args[1:]…)。</p>\n<h3><span id=\"二docker-client执行请求命令\">（二）Docker Client执行请求命令</span></h3>\n<p>docker pull ImageName中，即执行CmdPull(args[1:]…)，args[1:]即为ImageName。命令代码在/api/client/command.go。</p>\n<p><strong>/api/client/commands.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(cli *DockerCli)</span> <span class=\"title\">CmdPull</span><span class=\"params\">(args ...<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    cmd := cli.Subcmd(<span class=\"string\">\"pull\"</span>, <span class=\"string\">\"NAME[:TAG]\"</span>, <span class=\"string\">\"Pull an image or a repository from the registry\"</span>)</div><div class=\"line\">    tag := cmd.String([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#t\"</span>, <span class=\"string\">\"#-tag\"</span>&#125;, <span class=\"string\">\"\"</span>, <span class=\"string\">\"Download tagged image in a repository\"</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> err := cmd.Parse(args); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>将args参数进行第二次flag参数解析，解析过程中先提取是否有符合tag这个flag的参数，若有赋值给tag参数，其余存入cmd.NArg()，若没有则所有的参数存入cmd.NArg()中。</p>\n<p><strong>/api/client/commands.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> (</div><div class=\"line\">     v      = url.Values&#123;&#125;</div><div class=\"line\">     remote = cmd.Arg(<span class=\"number\">0</span>)</div><div class=\"line\"> )</div><div class=\"line\"> </div><div class=\"line\"> v.Set(<span class=\"string\">\"fromImage\"</span>, remote)</div><div class=\"line\"> </div><div class=\"line\"> <span class=\"keyword\">if</span> *tag == <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">     v.Set(<span class=\"string\">\"tag\"</span>, *tag)</div><div class=\"line\"> &#125;</div><div class=\"line\"> </div><div class=\"line\"> remote, _ = parsers.ParseRepositoryTag(remote)</div><div class=\"line\"> <span class=\"comment\">// Resolve the Repository name from fqn to hostname + name</span></div><div class=\"line\"> hostname, _, err := registry.ResolveRepositoryName(remote)</div><div class=\"line\"> <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">     <span class=\"keyword\">return</span> err</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>通过remote变量先得到镜像的repository名称，并赋值给remote自身，随后解析改变后的remote，得出镜像所在的host地址，即Docker Registry的地址。若没有指定默认为Docker Hub地址<a href=\"\">https://index.docker.io/v1/。</a></p>\n<p><strong>/api/client/commands.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">cli.LoadConfigFile()</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// Resolve the Auth config relevant for this server</span></div><div class=\"line\">authConfig := cli.configFile.ResolveAuthConfig(hostname)</div></pre></td></tr></table></figure>\n<p>通过cli对象获取与Docker Server的认证配置信息。</p>\n<p><strong>/api/client/commands.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">pull := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(authConfig registry.AuthConfig)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    buf, err := json.Marshal(authConfig)</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    registryAuthHeader := []<span class=\"keyword\">string</span>&#123;</div><div class=\"line\">        base64.URLEncoding.EncodeToString(buf),</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">return</span> cli.stream(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"/images/create?\"</span>+v.Encode(), <span class=\"literal\">nil</span>, cli.out, <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>][]<span class=\"keyword\">string</span>&#123;</div><div class=\"line\">        <span class=\"string\">\"X-Registry-Auth\"</span>: registryAuthHeader,</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>定义pull函数：cli.stream(“POST”, “/images/create?”+v.Encode(),…)像Docker Server发送POST请求，请求url为“&quot;/images/create?&quot;+v.Encode()”，请求的认证信息为：map[string][]string{“X-Registry-Auth”: registryAuthHeader,}</p>\n<p><strong>/api/client/commands.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> err := pull(authConfig); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> strings.Contains(err.Error(), <span class=\"string\">\"Status 401\"</span>) &#123;</div><div class=\"line\">        fmt.Fprintln(cli.out, <span class=\"string\">\"/nPlease login prior to pull:\"</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> err := cli.CmdLogin(hostname); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> err</div><div class=\"line\">        &#125;</div><div class=\"line\">        authConfig := cli.configFile.ResolveAuthConfig(hostname)</div><div class=\"line\">        <span class=\"keyword\">return</span> pull(authConfig)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> err</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div></pre></td></tr></table></figure>\n<p>调用pull函数，实现下载请求发送。后续有Docker Server接收到请求后具体实现。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>一、创建Docker Client</h2>\n<p>​    Docker是一个client/server的架构，通过二进制文件docker创建Docker客户端将请求类型与参数发送给Docker Server，Docker Server具体执行命令调用。<br>\nDocker Client运行流程图如下：<br>\n<img src=\"/img/article/docker/docker%E6%BA%90%E7%A0%81%E4%B9%8Bdocker-client/docker-client%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg\" alt=\"docker client流程图\"></p>\n<p>说明：本文分析的代码为Docker 1.2.0版本。</p>\n<h3>（一）Docker命令flag参数解析</h3>\n<p>Docker Server与Docker Client由可执行文件docker命令创建并启动。</p>\n<ul>\n<li>Docker Server的启动：docker -d或docker --daemon=true</li>\n<li>Docker Client的启动：docker --daemon=false ps等</li>\n</ul>\n<p>docker参数分为两类：</p>\n<ul>\n<li>命令行参数（flag参数）:–daemon=true,-d</li>\n<li>实际请求参数:ps ,images, pull, push等</li>\n</ul>\n<p><strong>/docker/docker.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> reexec.Init() &#123;</div><div class=\"line\">           <span class=\"keyword\">return</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       flag.Parse()</div><div class=\"line\">       <span class=\"comment\">// <span class=\"doctag\">FIXME:</span> validate daemon flags here</span></div><div class=\"line\">       ......</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>reexec.Init()作用：协调execdriver与容器创建时dockerinit的关系。如果返回值为真则直接退出运行，否则继续执行。判断reexec.Init()之后，调用flag.Parse()解析命令行中的flag参数。</p>\n<p><strong>/docker/flag.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> (</div><div class=\"line\">      flVersion     = flag.Bool([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"v\"</span>, <span class=\"string\">\"-version\"</span>&#125;, <span class=\"literal\">false</span>, <span class=\"string\">\"Print version information and quit\"</span>)</div><div class=\"line\">      flDaemon      = flag.Bool([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"d\"</span>, <span class=\"string\">\"-daemon\"</span>&#125;, <span class=\"literal\">false</span>, <span class=\"string\">\"Enable daemon mode\"</span>)</div><div class=\"line\">      flDebug       = flag.Bool([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"D\"</span>, <span class=\"string\">\"-debug\"</span>&#125;, <span class=\"literal\">false</span>, <span class=\"string\">\"Enable debug mode\"</span>)</div><div class=\"line\">      flSocketGroup = flag.String([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"G\"</span>, <span class=\"string\">\"-group\"</span>&#125;, <span class=\"string\">\"docker\"</span>, <span class=\"string\">\"Group to assign the unix socket specified by -H when running in daemon mode/nuse '' (the empty string) to disable setting of a group\"</span>)</div><div class=\"line\">      flEnableCors  = flag.Bool([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#api-enable-cors\"</span>, <span class=\"string\">\"-api-enable-cors\"</span>&#125;, <span class=\"literal\">false</span>, <span class=\"string\">\"Enable CORS headers in the remote API\"</span>)</div><div class=\"line\">      flTls         = flag.Bool([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-tls\"</span>&#125;, <span class=\"literal\">false</span>, <span class=\"string\">\"Use TLS; implied by tls-verify flags\"</span>)</div><div class=\"line\">      flTlsVerify   = flag.Bool([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-tlsverify\"</span>&#125;, <span class=\"literal\">false</span>, <span class=\"string\">\"Use TLS and verify the remote (daemon: verify client, client: verify daemon)\"</span>)</div><div class=\"line\"> </div><div class=\"line\">      <span class=\"comment\">// these are initialized in init() below since their default values depend on dockerCertPath which isn't fully initialized until init() runs</span></div><div class=\"line\">      flCa    *<span class=\"keyword\">string</span></div><div class=\"line\">      flCert  *<span class=\"keyword\">string</span></div><div class=\"line\">      flKey   *<span class=\"keyword\">string</span></div><div class=\"line\">      flHosts []<span class=\"keyword\">string</span></div><div class=\"line\">  )</div><div class=\"line\"> </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">      flCa = flag.String([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-tlscacert\"</span>&#125;, filepath.Join(dockerCertPath, defaultCaFile), <span class=\"string\">\"Trust only remotes providing a certificate signed by the CA given here\"</span>)</div><div class=\"line\">      flCert = flag.String([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-tlscert\"</span>&#125;, filepath.Join(dockerCertPath, defaultCertFile), <span class=\"string\">\"Path to TLS certificate file\"</span>)</div><div class=\"line\">      flKey = flag.String([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-tlskey\"</span>&#125;, filepath.Join(dockerCertPath, defaultKeyFile), <span class=\"string\">\"Path to TLS key file\"</span>)</div><div class=\"line\">      opts.HostListVar(&amp;flHosts, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"H\"</span>, <span class=\"string\">\"-host\"</span>&#125;, <span class=\"string\">\"The socket(s) to bind to in daemon mode/nspecified using one or more tcp://host:port, unix:///path/to/socket, fd://* or fd://socketfd.\"</span>)</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>flag.go定义了flag参数，并执行了init的初始化。</p>\n<p>Go中的init函数</p>\n<ol>\n<li>用于程序执行前包的初始化工作，比如初始化变量</li>\n<li>每个包或源文件可以包含多个init函数</li>\n<li>init函数不能被调用，而是在mian函数调用前自动被调用</li>\n<li>不同init函数的执行顺序，按照包导入的顺序执行</li>\n</ol>\n<p>当解析到第一个非flag参数时，flag解析工作就结束。例如docker --daemon=flase --version=false ps</p>\n<ul>\n<li>完成flag的解析，–daemon=false</li>\n<li>遇到第一个非flag参数ps，则将ps及其后的参数存入flag.Args()，以便执行之后的具体请求。</li>\n</ul>\n<h3>（二）处理flag参数并收集Docker Client的配置信息</h3>\n<p>处理的flag参数有flVersion,flDebug,flDaemon,flTlsVerify以及flTls。</p>\n<p><strong>/docker/docker.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    ......</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(flHosts) == <span class=\"number\">0</span> &#123;</div><div class=\"line\">        defaultHost := os.Getenv(<span class=\"string\">\"DOCKER_HOST\"</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> defaultHost == <span class=\"string\">\"\"</span> || *flDaemon &#123;</div><div class=\"line\">            <span class=\"comment\">// If we do not have a host, default to unix socket</span></div><div class=\"line\">            defaultHost = fmt.Sprintf(<span class=\"string\">\"unix://%s\"</span>, api.DEFAULTUNIXSOCKET)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> _, err := api.ValidateHost(defaultHost); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            log.Fatal(err)</div><div class=\"line\">        &#125;</div><div class=\"line\">        flHosts = <span class=\"built_in\">append</span>(flHosts, defaultHost)</div><div class=\"line\">    &#125;</div><div class=\"line\">    ......</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>flHosts的作用是为Docker Client提供所要连接的host对象，也就是为Docker Server提供所要监听的对象。<br>\n当flHosts为空，默认取环境变量DOCKER_HOST，若仍为空或flDaemon为真，则设置为unix socket，值为<a href=\"\">unix:///var/run/docker.sock。取自/api/common.go中的常量DEFAULTUNIXSOCKET。</a></p>\n<p><strong>/docker/docker.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;  </div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">if</span> *flDaemon &#123;</div><div class=\"line\">        mainDaemon()</div><div class=\"line\">        <span class=\"keyword\">return</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>若flDaemon为真，表示启动Docker Daemon，调用/docker/daemon.go中的func mainDaemon()。</p>\n<p><strong>/docker/docker.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(flHosts) &gt; <span class=\"number\">1</span> &#123;</div><div class=\"line\">    log.Fatal(<span class=\"string\">\"Please specify only one -H\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">protoAddrParts := strings.SplitN(flHosts[<span class=\"number\">0</span>], <span class=\"string\">\"://\"</span>, <span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<p>protoAddrParts的作用是解析出Docker Client 与Docker Server建立通信的协议与地址，通过strings.SplitN函数分割存储。flHosts[0]的值可以是<a href=\"\">tcp://0.0.0.0.2375或者unix:///var/run/docker.sock等。</a></p>\n<p><strong>/docker/docker.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> (</div><div class=\"line\">    cli       *client.DockerCli</div><div class=\"line\">    tlsConfig tls.Config</div><div class=\"line\">)</div><div class=\"line\">tlsConfig.InsecureSkipVerify = <span class=\"literal\">true</span></div></pre></td></tr></table></figure>\n<p>tlsConfig对象的创建是为了保障cli在传输数据的时候遵循安全传输层协议（TLS）。flTlsVerity参数为真，则说明Docker Client 需Docker Server一起验证连接的安全性，如果flTls和flTlsVerity两个参数中有一个为真，则说明需要加载并发送客户端的证书。</p>\n<p><strong>/docker/flags.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">flTls         = flag.Bool([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-tls\"</span>&#125;, <span class=\"literal\">false</span>, <span class=\"string\">\"Use TLS; implied by tls-verify flags\"</span>)</div><div class=\"line\">flTlsVerify   = flag.Bool([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"-tlsverify\"</span>&#125;, <span class=\"literal\">false</span>, <span class=\"string\">\"Use TLS and verify the remote (daemon: verify client, client: verify daemon)\"</span>)</div></pre></td></tr></table></figure>\n<h3>（三）如何创建Docker Client</h3>\n<p><strong>/docker/docker.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> *flTls || *flTlsVerify &#123;</div><div class=\"line\">    cli = client.NewDockerCli(os.Stdin, os.Stdout, os.Stderr, protoAddrParts[<span class=\"number\">0</span>], protoAddrParts[<span class=\"number\">1</span>], &amp;tlsConfig)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    cli = client.NewDockerCli(os.Stdin, os.Stdout, os.Stderr, protoAddrParts[<span class=\"number\">0</span>], protoAddrParts[<span class=\"number\">1</span>], <span class=\"literal\">nil</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在已有配置参数的情况下，通过/api/client/cli.go中的NewDockerCli方法创建Docker Client实例cli。</p>\n<p><strong>/api/client/cli.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> DockerCli <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    proto      <span class=\"keyword\">string</span></div><div class=\"line\">    addr       <span class=\"keyword\">string</span></div><div class=\"line\">    configFile *registry.ConfigFile</div><div class=\"line\">    in         io.ReadCloser</div><div class=\"line\">    out        io.Writer</div><div class=\"line\">    err        io.Writer</div><div class=\"line\">    isTerminal <span class=\"keyword\">bool</span></div><div class=\"line\">    terminalFd <span class=\"keyword\">uintptr</span></div><div class=\"line\">    tlsConfig  *tls.Config</div><div class=\"line\">    scheme     <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewDockerCli</span><span class=\"params\">(in io.ReadCloser, out, err io.Writer, proto, addr <span class=\"keyword\">string</span>, tlsConfig *tls.Config)</span> *<span class=\"title\">DockerCli</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> (</div><div class=\"line\">        isTerminal = <span class=\"literal\">false</span></div><div class=\"line\">        terminalFd <span class=\"keyword\">uintptr</span></div><div class=\"line\">        scheme     = <span class=\"string\">\"http\"</span></div><div class=\"line\">    )</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> tlsConfig != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        scheme = <span class=\"string\">\"https\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> in != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> file, ok := out.(*os.File); ok &#123;</div><div class=\"line\">            terminalFd = file.Fd()</div><div class=\"line\">            isTerminal = term.IsTerminal(terminalFd)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        err = out</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> &amp;DockerCli&#123;</div><div class=\"line\">        proto:      proto,</div><div class=\"line\">        addr:       addr,</div><div class=\"line\">        in:         in,</div><div class=\"line\">        out:        out,</div><div class=\"line\">        err:        err,</div><div class=\"line\">        isTerminal: isTerminal,</div><div class=\"line\">        terminalFd: terminalFd,</div><div class=\"line\">        tlsConfig:  tlsConfig,</div><div class=\"line\">        scheme:     scheme,</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2>二、Docke命令执行</h2>\n<h3>（一）Docker Client解析请求命令</h3>\n<p>创建Docker Client，docker命令中的请求参数（例如ps，经flag解析后放入flag.Args()），分析请求参数及请求的类型，转义为Docker Server可识别的请求后发给Docker Server。</p>\n<p><strong>/docker/docker.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> err := cli.Cmd(flag.Args()...); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> sterr, ok := err.(*utils.StatusError); ok &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> sterr.Status != <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">            log.Println(sterr.Status)</div><div class=\"line\">        &#125;</div><div class=\"line\">        os.Exit(sterr.StatusCode)</div><div class=\"line\">    &#125;</div><div class=\"line\">    log.Fatal(err)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解析flag.Args()的具体请求参数，执行cli.Cmd函数。代码在/api/client/cli.go</p>\n<p><strong>/api/client/cli.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"comment\">// Cmd executes the specified command</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(cli *DockerCli)</span> <span class=\"title\">Cmd</span><span class=\"params\">(args ...<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(args) &gt; <span class=\"number\">0</span> &#123;</div><div class=\"line\">            method, exists := cli.getMethod(args[<span class=\"number\">0</span>])</div><div class=\"line\">            <span class=\"keyword\">if</span> !exists &#123;</div><div class=\"line\">                fmt.Println(<span class=\"string\">\"Error: Command not found:\"</span>, args[<span class=\"number\">0</span>])</div><div class=\"line\">                <span class=\"keyword\">return</span> cli.CmdHelp(args[<span class=\"number\">1</span>:]...)</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> method(args[<span class=\"number\">1</span>:]...)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> cli.CmdHelp(args...)</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">method, exists := cli.getMethod(args[<span class=\"number\">0</span>])获取请求参数，例如docker pull ImageName，args[<span class=\"number\">0</span>]等于pull。</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(cli *DockerCli)</span> <span class=\"title\">getMethod</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">func</span>(...<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span>, <span class=\"title\">bool</span>)</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(name) == <span class=\"number\">0</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        methodName := <span class=\"string\">\"Cmd\"</span> + strings.ToUpper(name[:<span class=\"number\">1</span>]) + strings.ToLower(name[<span class=\"number\">1</span>:])</div><div class=\"line\">        method := reflect.ValueOf(cli).MethodByName(methodName)</div><div class=\"line\">        <span class=\"keyword\">if</span> !method.IsValid() &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> method.Interface().(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(...<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span>), <span class=\"title\">true</span></span></div><div class=\"line\"><span class=\"function\">    &#125;</span></div></pre></td></tr></table></figure>\n<p>在getMethod中，返回method值为“CmdPull”。最后执行method(args[1:]…)，即CmdPull(args[1:]…)。</p>\n<h3>（二）Docker Client执行请求命令</h3>\n<p>docker pull ImageName中，即执行CmdPull(args[1:]…)，args[1:]即为ImageName。命令代码在/api/client/command.go。</p>\n<p><strong>/api/client/commands.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(cli *DockerCli)</span> <span class=\"title\">CmdPull</span><span class=\"params\">(args ...<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    cmd := cli.Subcmd(<span class=\"string\">\"pull\"</span>, <span class=\"string\">\"NAME[:TAG]\"</span>, <span class=\"string\">\"Pull an image or a repository from the registry\"</span>)</div><div class=\"line\">    tag := cmd.String([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"#t\"</span>, <span class=\"string\">\"#-tag\"</span>&#125;, <span class=\"string\">\"\"</span>, <span class=\"string\">\"Download tagged image in a repository\"</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> err := cmd.Parse(args); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>将args参数进行第二次flag参数解析，解析过程中先提取是否有符合tag这个flag的参数，若有赋值给tag参数，其余存入cmd.NArg()，若没有则所有的参数存入cmd.NArg()中。</p>\n<p><strong>/api/client/commands.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> (</div><div class=\"line\">     v      = url.Values&#123;&#125;</div><div class=\"line\">     remote = cmd.Arg(<span class=\"number\">0</span>)</div><div class=\"line\"> )</div><div class=\"line\"> </div><div class=\"line\"> v.Set(<span class=\"string\">\"fromImage\"</span>, remote)</div><div class=\"line\"> </div><div class=\"line\"> <span class=\"keyword\">if</span> *tag == <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">     v.Set(<span class=\"string\">\"tag\"</span>, *tag)</div><div class=\"line\"> &#125;</div><div class=\"line\"> </div><div class=\"line\"> remote, _ = parsers.ParseRepositoryTag(remote)</div><div class=\"line\"> <span class=\"comment\">// Resolve the Repository name from fqn to hostname + name</span></div><div class=\"line\"> hostname, _, err := registry.ResolveRepositoryName(remote)</div><div class=\"line\"> <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">     <span class=\"keyword\">return</span> err</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>通过remote变量先得到镜像的repository名称，并赋值给remote自身，随后解析改变后的remote，得出镜像所在的host地址，即Docker Registry的地址。若没有指定默认为Docker Hub地址<a href=\"\">https://index.docker.io/v1/。</a></p>\n<p><strong>/api/client/commands.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">cli.LoadConfigFile()</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// Resolve the Auth config relevant for this server</span></div><div class=\"line\">authConfig := cli.configFile.ResolveAuthConfig(hostname)</div></pre></td></tr></table></figure>\n<p>通过cli对象获取与Docker Server的认证配置信息。</p>\n<p><strong>/api/client/commands.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">pull := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(authConfig registry.AuthConfig)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    buf, err := json.Marshal(authConfig)</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    registryAuthHeader := []<span class=\"keyword\">string</span>&#123;</div><div class=\"line\">        base64.URLEncoding.EncodeToString(buf),</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">return</span> cli.stream(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"/images/create?\"</span>+v.Encode(), <span class=\"literal\">nil</span>, cli.out, <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>][]<span class=\"keyword\">string</span>&#123;</div><div class=\"line\">        <span class=\"string\">\"X-Registry-Auth\"</span>: registryAuthHeader,</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>定义pull函数：cli.stream(“POST”, “/images/create?”+v.Encode(),…)像Docker Server发送POST请求，请求url为“&quot;/images/create?&quot;+v.Encode()”，请求的认证信息为：map[string][]string{“X-Registry-Auth”: registryAuthHeader,}</p>\n<p><strong>/api/client/commands.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> err := pull(authConfig); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> strings.Contains(err.Error(), <span class=\"string\">\"Status 401\"</span>) &#123;</div><div class=\"line\">        fmt.Fprintln(cli.out, <span class=\"string\">\"/nPlease login prior to pull:\"</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> err := cli.CmdLogin(hostname); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> err</div><div class=\"line\">        &#125;</div><div class=\"line\">        authConfig := cli.configFile.ResolveAuthConfig(hostname)</div><div class=\"line\">        <span class=\"keyword\">return</span> pull(authConfig)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> err</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div></pre></td></tr></table></figure>\n<p>调用pull函数，实现下载请求发送。后续有Docker Server接收到请求后具体实现。</p>\n"},{"title":"[Kubernetes] Kubernetes核心原理（一）之API Server","catalog":true,"date":"2017-09-18T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Kubernetes"],"_content":"\n## 1. API Server简介\n\nk8s API Server提供了k8s各类资源对象（pod,RC,Service等）的增删改查及watch等HTTP Rest接口，是整个系统的数据总线和数据中心。\n\nkubernetes API Server的功能：\n\n1. 提供了集群管理的REST API接口(包括认证授权、数据校验以及集群状态变更)；\n2. 提供其他模块之间的数据交互和通信的枢纽（其他模块通过API Server查询或修改数据，只有API Server才直接操作etcd）;\n3. 是资源配额控制的入口；\n4. 拥有完备的集群安全机制.\n\n**kube-apiserver工作原理图**\n\n![kube-apiserver](/img/article/kubernetes/kubernetes核心原理/kube-apiserver.png)\n\n## 2. 如何访问kubernetes API\n\nk8s通过kube-apiserver这个进程提供服务，该进程运行在单个k8s-master节点上。默认有两个端口。\n\n### 2.1. 本地端口\n\n1. 该端口用于接收HTTP请求；\n2. 该端口默认值为8080，可以通过API Server的启动参数“--insecure-port”的值来修改默认值；\n3. 默认的IP地址为“localhost”，可以通过启动参数“--insecure-bind-address”的值来修改该IP地址；\n4. 非认证或授权的HTTP请求通过该端口访问API Server。\n\n### 2.2. 安全端口\n\n1. 该端口默认值为6443，可通过启动参数“--secure-port”的值来修改默认值；\n2. 默认IP地址为非本地（Non-Localhost）网络端口，通过启动参数“--bind-address”设置该值；\n3. 该端口用于接收HTTPS请求；\n4. 用于基于Tocken文件或客户端证书及HTTP Base的认证；\n5. 用于基于策略的授权；\n6. 默认不启动HTTPS安全访问控制。\n\n### 2.3. 访问方式\n\nKubernetes REST API可参考[https://kubernetes.io/docs/api-reference/v1.6/](https://kubernetes.io/docs/api-reference/v1.6/)\n\n#### 2.3.1. curl\n\n```shell\ncurl localhost:8080/api\ncurl localhost:8080/api/v1/pods\ncurl localhost:8080/api/v1/services\ncurl localhost:8080/api/v1/replicationcontrollers\n```\n\n#### 2.3.2. Kubectl Proxy\n\nKubectl Proxy代理程序既能作为API Server的反向代理，也能作为普通客户端访问API Server的代理。通过master节点的8080端口来启动该代理程序。\n\nkubectl proxy --port=8080 &\n\n具体见kubectl proxy --help\n\n```shell\n[root@node5 ~]# kubectl proxy --help\nTo proxy all of the kubernetes api and nothing else, use:\nkubectl proxy --api-prefix=/\nTo proxy only part of the kubernetes api and also some static files:\nkubectl proxy --www=/my/files --www-prefix=/static/ --api-prefix=/api/\nThe above lets you 'curl localhost:8001/api/v1/pods'.\nTo proxy the entire kubernetes api at a different root, use:\nkubectl proxy --api-prefix=/custom/\nThe above lets you 'curl localhost:8001/custom/api/v1/pods'\nUsage:\n  kubectl proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix] [flags]\nExamples:\n# Run a proxy to kubernetes apiserver on port 8011, serving static content from ./local/www/\n$ kubectl proxy --port=8011 --www=./local/www/\n# Run a proxy to kubernetes apiserver on an arbitrary local port.\n# The chosen port for the server will be output to stdout.\n$ kubectl proxy --port=0\n# Run a proxy to kubernetes apiserver, changing the api prefix to k8s-api\n# This makes e.g. the pods api available at localhost:8011/k8s-api/v1/pods/\n$ kubectl proxy --api-prefix=/k8s-api\nFlags:\n      --accept-hosts=\"^localhost$,^127//.0//.0//.1$,^//[::1//]$\": Regular expression for hosts that the proxy should accept.\n      --accept-paths=\"^/.*\": Regular expression for paths that the proxy should accept.\n      --api-prefix=\"/\": Prefix to serve the proxied API under.\n      --disable-filter[=false]: If true, disable request filtering in the proxy. This is dangerous, and can leave you vulnerable to XSRF attacks, when used with an accessible port.\n  -p, --port=8001: The port on which to run the proxy. Set to 0 to pick a random port.\n      --reject-methods=\"POST,PUT,PATCH\": Regular expression for HTTP methods that the proxy should reject.\n      --reject-paths=\"^/api/.*/exec,^/api/.*/run\": Regular expression for paths that the proxy should reject.\n  -u, --unix-socket=\"\": Unix socket on which to run the proxy.\n  -w, --www=\"\": Also serve static files from the given directory under the specified prefix.\n  -P, --www-prefix=\"/static/\": Prefix to serve static files under, if static file directory is specified.\n \nGlobal Flags:\n      --alsologtostderr[=false]: log to standard error as well as files\n      --api-version=\"\": The API version to use when talking to the server\n      --certificate-authority=\"\": Path to a cert. file for the certificate authority.\n      --client-certificate=\"\": Path to a client key file for TLS.\n      --client-key=\"\": Path to a client key file for TLS.\n      --cluster=\"\": The name of the kubeconfig cluster to use\n      --context=\"\": The name of the kubeconfig context to use\n      --insecure-skip-tls-verify[=false]: If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kubeconfig=\"\": Path to the kubeconfig file to use for CLI requests.\n      --log-backtrace-at=:0: when logging hits line file:N, emit a stack trace\n      --log-dir=\"\": If non-empty, write log files in this directory\n      --log-flush-frequency=5s: Maximum number of seconds between log flushes\n      --logtostderr[=true]: log to standard error instead of files\n      --match-server-version[=false]: Require server version to match client version\n      --namespace=\"\": If present, the namespace scope for this CLI request.\n      --password=\"\": Password for basic authentication to the API server.\n  -s, --server=\"\": The address and port of the Kubernetes API server\n      --stderrthreshold=2: logs at or above this threshold go to stderr\n      --token=\"\": Bearer token for authentication to the API server.\n      --user=\"\": The name of the kubeconfig user to use\n      --username=\"\": Username for basic authentication to the API server.\n      --v=0: log level for V logs\n      --vmodule=: comma-separated list of pattern=N settings for file-filtered logging\n```\n\n#### 2.3.3. kubectl客户端\n\n命令行工具kubectl客户端，通过命令行参数转换为对API Server的REST API调用，并将调用结果输出。\n\n命令格式：kubectl [command] [options]\n\n具体可参考[k8s常用命令](http://wiki.haplat.net/pages/viewpage.action?pageId=11899446)\n\n#### 2.3.4. 编程方式调用\n\n使用场景：\n\n1、运行在Pod里的用户进程调用kubernetes API,通常用来实现分布式集群搭建的目标。\n\n2、开发基于kubernetes的管理平台，比如调用kubernetes API来完成Pod、Service、RC等资源对象的图形化创建和管理界面。可以使用kubernetes提供的Client Library。\n\n具体可参考[https://github.com/kubernetes/client-go](https://github.com/kubernetes/client-go)。\n\n## 3. 通过API Server访问Node、Pod和Service\n\nk8s API Server最主要的REST接口是资源对象的增删改查，另外还有一类特殊的REST接口—k8s Proxy API接口，这类接口的作用是代理REST请求，即kubernetes API Server把收到的REST请求转发到某个Node上的kubelet守护进程的REST端口上，由该kubelet进程负责响应。\n\n### 3.1. Node相关接口\n\n关于Node相关的接口的REST路径为：/api/v1/proxy/nodes/{name}，其中{name}为节点的名称或IP地址。\n\n```shell\n/api/v1/proxy/nodes/{name}/pods/    #列出指定节点内所有Pod的信息\n/api/v1/proxy/nodes/{name}/stats/   #列出指定节点内物理资源的统计信息\n/api/v1/prxoy/nodes/{name}/spec/    #列出指定节点的概要信息\n```\n\n这里获取的Pod信息来自Node而非etcd数据库，两者时间点可能存在偏差。如果在kubelet进程启动时加--enable-debugging-handles=true参数，那么kubernetes Proxy API还会增加以下接口：\n\n```shell\n/api/v1/proxy/nodes/{name}/run      #在节点上运行某个容器\n/api/v1/proxy/nodes/{name}/exec     #在节点上的某个容器中运行某条命令\n/api/v1/proxy/nodes/{name}/attach   #在节点上attach某个容器\n/api/v1/proxy/nodes/{name}/portForward   #实现节点上的Pod端口转发\n/api/v1/proxy/nodes/{name}/logs     #列出节点的各类日志信息\n/api/v1/proxy/nodes/{name}/metrics  #列出和该节点相关的Metrics信息\n/api/v1/proxy/nodes/{name}/runningpods  #列出节点内运行中的Pod信息\n/api/v1/proxy/nodes/{name}/debug/pprof  #列出节点内当前web服务的状态，包括CPU和内存的使用情况\n```\n\n### 3.2. Pod相关接口\n\n```shell\n/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path:*}      #访问pod的某个服务接口\n/api/v1/proxy/namespaces/{namespace}/pods/{name}               #访问Pod\n#以下写法不同，功能一样\n/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path:*}      #访问pod的某个服务接口\n/api/v1/namespaces/{namespace}/pods/{name}/proxy               #访问Pod\n```\n\n### 3.3. Service相关接口\n\n```shell\n/api/v1/proxy/namespaces/{namespace}/services/{name}\n```\n\nPod的proxy接口的作用：在kubernetes集群之外访问某个pod容器的服务（HTTP服务），可以用Proxy API实现，这种场景多用于管理目的，比如逐一排查Service的Pod副本，检查哪些Pod的服务存在异常问题。\n\n## 4. 集群功能模块之间的通信\n\nkubernetes API Server作为集群的核心，负责集群各功能模块之间的通信，集群内各个功能模块通过API Server将信息存入etcd，当需要获取和操作这些数据时，通过API Server提供的REST接口（GET/LIST/WATCH方法）来实现，从而实现各模块之间的信息交互。\n\n### 4.1. kubelet与API Server交互\n\n每个Node节点上的kubelet定期就会调用API Server的REST接口报告自身状态，API Server接收这些信息后，将节点状态信息更新到etcd中。kubelet也通过API Server的Watch接口监听Pod信息，从而对Node机器上的POD进行管理。\n\n| 监听信息             | kubelet动作          | 备注   |\n| ---------------- | ------------------ | ---- |\n| 新的POD副本被调度绑定到本节点 | 执行POD对应的容器的创建和启动逻辑 |      |\n| POD对象被删除         | 删除本节点上相应的POD容器     |      |\n| 修改POD信息          | 修改本节点的POD容器        |      |\n\n### 4.2. kube-controller-manager与API Server交互\n\nkube-controller-manager中的Node Controller模块通过API Server提供的Watch接口，实时监控Node的信息，并做相应处理。\n\n### 4.3. kube-scheduler与API Server交互\n\nScheduler通过API Server的Watch接口监听到新建Pod副本的信息后，它会检索所有符合该Pod要求的Node列表，开始执行Pod调度逻辑。调度成功后将Pod绑定到目标节点上。\n\n### 4.4. 特别说明\n\n为了缓解各模块对API Server的访问压力，各功能模块都采用缓存机制来缓存数据，各功能模块定时从API Server获取指定的资源对象信息（LIST/WATCH方法），然后将信息保存到本地缓存，功能模块在某些情况下不直接访问API Server，而是通过访问缓存数据来间接访问API Server。\n\n \n\n参考《kubernetes权威指南》","source":"_posts/Kubernetes/kubernetes核心原理/kubernetes核心原理（一）之API Server.md","raw":"---\ntitle: \"[Kubernetes] Kubernetes核心原理（一）之API Server\"\ncatalog: true\ndate: 2017-09-18 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Kubernetes\ncatagories:\n- Kubernetes\n---\n\n## 1. API Server简介\n\nk8s API Server提供了k8s各类资源对象（pod,RC,Service等）的增删改查及watch等HTTP Rest接口，是整个系统的数据总线和数据中心。\n\nkubernetes API Server的功能：\n\n1. 提供了集群管理的REST API接口(包括认证授权、数据校验以及集群状态变更)；\n2. 提供其他模块之间的数据交互和通信的枢纽（其他模块通过API Server查询或修改数据，只有API Server才直接操作etcd）;\n3. 是资源配额控制的入口；\n4. 拥有完备的集群安全机制.\n\n**kube-apiserver工作原理图**\n\n![kube-apiserver](/img/article/kubernetes/kubernetes核心原理/kube-apiserver.png)\n\n## 2. 如何访问kubernetes API\n\nk8s通过kube-apiserver这个进程提供服务，该进程运行在单个k8s-master节点上。默认有两个端口。\n\n### 2.1. 本地端口\n\n1. 该端口用于接收HTTP请求；\n2. 该端口默认值为8080，可以通过API Server的启动参数“--insecure-port”的值来修改默认值；\n3. 默认的IP地址为“localhost”，可以通过启动参数“--insecure-bind-address”的值来修改该IP地址；\n4. 非认证或授权的HTTP请求通过该端口访问API Server。\n\n### 2.2. 安全端口\n\n1. 该端口默认值为6443，可通过启动参数“--secure-port”的值来修改默认值；\n2. 默认IP地址为非本地（Non-Localhost）网络端口，通过启动参数“--bind-address”设置该值；\n3. 该端口用于接收HTTPS请求；\n4. 用于基于Tocken文件或客户端证书及HTTP Base的认证；\n5. 用于基于策略的授权；\n6. 默认不启动HTTPS安全访问控制。\n\n### 2.3. 访问方式\n\nKubernetes REST API可参考[https://kubernetes.io/docs/api-reference/v1.6/](https://kubernetes.io/docs/api-reference/v1.6/)\n\n#### 2.3.1. curl\n\n```shell\ncurl localhost:8080/api\ncurl localhost:8080/api/v1/pods\ncurl localhost:8080/api/v1/services\ncurl localhost:8080/api/v1/replicationcontrollers\n```\n\n#### 2.3.2. Kubectl Proxy\n\nKubectl Proxy代理程序既能作为API Server的反向代理，也能作为普通客户端访问API Server的代理。通过master节点的8080端口来启动该代理程序。\n\nkubectl proxy --port=8080 &\n\n具体见kubectl proxy --help\n\n```shell\n[root@node5 ~]# kubectl proxy --help\nTo proxy all of the kubernetes api and nothing else, use:\nkubectl proxy --api-prefix=/\nTo proxy only part of the kubernetes api and also some static files:\nkubectl proxy --www=/my/files --www-prefix=/static/ --api-prefix=/api/\nThe above lets you 'curl localhost:8001/api/v1/pods'.\nTo proxy the entire kubernetes api at a different root, use:\nkubectl proxy --api-prefix=/custom/\nThe above lets you 'curl localhost:8001/custom/api/v1/pods'\nUsage:\n  kubectl proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix] [flags]\nExamples:\n# Run a proxy to kubernetes apiserver on port 8011, serving static content from ./local/www/\n$ kubectl proxy --port=8011 --www=./local/www/\n# Run a proxy to kubernetes apiserver on an arbitrary local port.\n# The chosen port for the server will be output to stdout.\n$ kubectl proxy --port=0\n# Run a proxy to kubernetes apiserver, changing the api prefix to k8s-api\n# This makes e.g. the pods api available at localhost:8011/k8s-api/v1/pods/\n$ kubectl proxy --api-prefix=/k8s-api\nFlags:\n      --accept-hosts=\"^localhost$,^127//.0//.0//.1$,^//[::1//]$\": Regular expression for hosts that the proxy should accept.\n      --accept-paths=\"^/.*\": Regular expression for paths that the proxy should accept.\n      --api-prefix=\"/\": Prefix to serve the proxied API under.\n      --disable-filter[=false]: If true, disable request filtering in the proxy. This is dangerous, and can leave you vulnerable to XSRF attacks, when used with an accessible port.\n  -p, --port=8001: The port on which to run the proxy. Set to 0 to pick a random port.\n      --reject-methods=\"POST,PUT,PATCH\": Regular expression for HTTP methods that the proxy should reject.\n      --reject-paths=\"^/api/.*/exec,^/api/.*/run\": Regular expression for paths that the proxy should reject.\n  -u, --unix-socket=\"\": Unix socket on which to run the proxy.\n  -w, --www=\"\": Also serve static files from the given directory under the specified prefix.\n  -P, --www-prefix=\"/static/\": Prefix to serve static files under, if static file directory is specified.\n \nGlobal Flags:\n      --alsologtostderr[=false]: log to standard error as well as files\n      --api-version=\"\": The API version to use when talking to the server\n      --certificate-authority=\"\": Path to a cert. file for the certificate authority.\n      --client-certificate=\"\": Path to a client key file for TLS.\n      --client-key=\"\": Path to a client key file for TLS.\n      --cluster=\"\": The name of the kubeconfig cluster to use\n      --context=\"\": The name of the kubeconfig context to use\n      --insecure-skip-tls-verify[=false]: If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure.\n      --kubeconfig=\"\": Path to the kubeconfig file to use for CLI requests.\n      --log-backtrace-at=:0: when logging hits line file:N, emit a stack trace\n      --log-dir=\"\": If non-empty, write log files in this directory\n      --log-flush-frequency=5s: Maximum number of seconds between log flushes\n      --logtostderr[=true]: log to standard error instead of files\n      --match-server-version[=false]: Require server version to match client version\n      --namespace=\"\": If present, the namespace scope for this CLI request.\n      --password=\"\": Password for basic authentication to the API server.\n  -s, --server=\"\": The address and port of the Kubernetes API server\n      --stderrthreshold=2: logs at or above this threshold go to stderr\n      --token=\"\": Bearer token for authentication to the API server.\n      --user=\"\": The name of the kubeconfig user to use\n      --username=\"\": Username for basic authentication to the API server.\n      --v=0: log level for V logs\n      --vmodule=: comma-separated list of pattern=N settings for file-filtered logging\n```\n\n#### 2.3.3. kubectl客户端\n\n命令行工具kubectl客户端，通过命令行参数转换为对API Server的REST API调用，并将调用结果输出。\n\n命令格式：kubectl [command] [options]\n\n具体可参考[k8s常用命令](http://wiki.haplat.net/pages/viewpage.action?pageId=11899446)\n\n#### 2.3.4. 编程方式调用\n\n使用场景：\n\n1、运行在Pod里的用户进程调用kubernetes API,通常用来实现分布式集群搭建的目标。\n\n2、开发基于kubernetes的管理平台，比如调用kubernetes API来完成Pod、Service、RC等资源对象的图形化创建和管理界面。可以使用kubernetes提供的Client Library。\n\n具体可参考[https://github.com/kubernetes/client-go](https://github.com/kubernetes/client-go)。\n\n## 3. 通过API Server访问Node、Pod和Service\n\nk8s API Server最主要的REST接口是资源对象的增删改查，另外还有一类特殊的REST接口—k8s Proxy API接口，这类接口的作用是代理REST请求，即kubernetes API Server把收到的REST请求转发到某个Node上的kubelet守护进程的REST端口上，由该kubelet进程负责响应。\n\n### 3.1. Node相关接口\n\n关于Node相关的接口的REST路径为：/api/v1/proxy/nodes/{name}，其中{name}为节点的名称或IP地址。\n\n```shell\n/api/v1/proxy/nodes/{name}/pods/    #列出指定节点内所有Pod的信息\n/api/v1/proxy/nodes/{name}/stats/   #列出指定节点内物理资源的统计信息\n/api/v1/prxoy/nodes/{name}/spec/    #列出指定节点的概要信息\n```\n\n这里获取的Pod信息来自Node而非etcd数据库，两者时间点可能存在偏差。如果在kubelet进程启动时加--enable-debugging-handles=true参数，那么kubernetes Proxy API还会增加以下接口：\n\n```shell\n/api/v1/proxy/nodes/{name}/run      #在节点上运行某个容器\n/api/v1/proxy/nodes/{name}/exec     #在节点上的某个容器中运行某条命令\n/api/v1/proxy/nodes/{name}/attach   #在节点上attach某个容器\n/api/v1/proxy/nodes/{name}/portForward   #实现节点上的Pod端口转发\n/api/v1/proxy/nodes/{name}/logs     #列出节点的各类日志信息\n/api/v1/proxy/nodes/{name}/metrics  #列出和该节点相关的Metrics信息\n/api/v1/proxy/nodes/{name}/runningpods  #列出节点内运行中的Pod信息\n/api/v1/proxy/nodes/{name}/debug/pprof  #列出节点内当前web服务的状态，包括CPU和内存的使用情况\n```\n\n### 3.2. Pod相关接口\n\n```shell\n/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path:*}      #访问pod的某个服务接口\n/api/v1/proxy/namespaces/{namespace}/pods/{name}               #访问Pod\n#以下写法不同，功能一样\n/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path:*}      #访问pod的某个服务接口\n/api/v1/namespaces/{namespace}/pods/{name}/proxy               #访问Pod\n```\n\n### 3.3. Service相关接口\n\n```shell\n/api/v1/proxy/namespaces/{namespace}/services/{name}\n```\n\nPod的proxy接口的作用：在kubernetes集群之外访问某个pod容器的服务（HTTP服务），可以用Proxy API实现，这种场景多用于管理目的，比如逐一排查Service的Pod副本，检查哪些Pod的服务存在异常问题。\n\n## 4. 集群功能模块之间的通信\n\nkubernetes API Server作为集群的核心，负责集群各功能模块之间的通信，集群内各个功能模块通过API Server将信息存入etcd，当需要获取和操作这些数据时，通过API Server提供的REST接口（GET/LIST/WATCH方法）来实现，从而实现各模块之间的信息交互。\n\n### 4.1. kubelet与API Server交互\n\n每个Node节点上的kubelet定期就会调用API Server的REST接口报告自身状态，API Server接收这些信息后，将节点状态信息更新到etcd中。kubelet也通过API Server的Watch接口监听Pod信息，从而对Node机器上的POD进行管理。\n\n| 监听信息             | kubelet动作          | 备注   |\n| ---------------- | ------------------ | ---- |\n| 新的POD副本被调度绑定到本节点 | 执行POD对应的容器的创建和启动逻辑 |      |\n| POD对象被删除         | 删除本节点上相应的POD容器     |      |\n| 修改POD信息          | 修改本节点的POD容器        |      |\n\n### 4.2. kube-controller-manager与API Server交互\n\nkube-controller-manager中的Node Controller模块通过API Server提供的Watch接口，实时监控Node的信息，并做相应处理。\n\n### 4.3. kube-scheduler与API Server交互\n\nScheduler通过API Server的Watch接口监听到新建Pod副本的信息后，它会检索所有符合该Pod要求的Node列表，开始执行Pod调度逻辑。调度成功后将Pod绑定到目标节点上。\n\n### 4.4. 特别说明\n\n为了缓解各模块对API Server的访问压力，各功能模块都采用缓存机制来缓存数据，各功能模块定时从API Server获取指定的资源对象信息（LIST/WATCH方法），然后将信息保存到本地缓存，功能模块在某些情况下不直接访问API Server，而是通过访问缓存数据来间接访问API Server。\n\n \n\n参考《kubernetes权威指南》","slug":"Kubernetes/kubernetes核心原理/kubernetes核心原理（一）之API Server","published":1,"updated":"2017-10-02T13:11:38.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740kb001430vumzunsimk","content":"<h2><span id=\"1-api-server简介\">1. API Server简介</span></h2>\n<p>k8s API Server提供了k8s各类资源对象（pod,RC,Service等）的增删改查及watch等HTTP Rest接口，是整个系统的数据总线和数据中心。</p>\n<p>kubernetes API Server的功能：</p>\n<ol>\n<li>提供了集群管理的REST API接口(包括认证授权、数据校验以及集群状态变更)；</li>\n<li>提供其他模块之间的数据交互和通信的枢纽（其他模块通过API Server查询或修改数据，只有API Server才直接操作etcd）;</li>\n<li>是资源配额控制的入口；</li>\n<li>拥有完备的集群安全机制.</li>\n</ol>\n<p><strong>kube-apiserver工作原理图</strong></p>\n<p><img src=\"/img/article/kubernetes/kubernetes%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/kube-apiserver.png\" alt=\"kube-apiserver\"></p>\n<h2><span id=\"2-如何访问kubernetes-api\">2. 如何访问kubernetes API</span></h2>\n<p>k8s通过kube-apiserver这个进程提供服务，该进程运行在单个k8s-master节点上。默认有两个端口。</p>\n<h3><span id=\"21-本地端口\">2.1. 本地端口</span></h3>\n<ol>\n<li>该端口用于接收HTTP请求；</li>\n<li>该端口默认值为8080，可以通过API Server的启动参数“–insecure-port”的值来修改默认值；</li>\n<li>默认的IP地址为“localhost”，可以通过启动参数“–insecure-bind-address”的值来修改该IP地址；</li>\n<li>非认证或授权的HTTP请求通过该端口访问API Server。</li>\n</ol>\n<h3><span id=\"22-安全端口\">2.2. 安全端口</span></h3>\n<ol>\n<li>该端口默认值为6443，可通过启动参数“–secure-port”的值来修改默认值；</li>\n<li>默认IP地址为非本地（Non-Localhost）网络端口，通过启动参数“–bind-address”设置该值；</li>\n<li>该端口用于接收HTTPS请求；</li>\n<li>用于基于Tocken文件或客户端证书及HTTP Base的认证；</li>\n<li>用于基于策略的授权；</li>\n<li>默认不启动HTTPS安全访问控制。</li>\n</ol>\n<h3><span id=\"23-访问方式\">2.3. 访问方式</span></h3>\n<p>Kubernetes REST API可参考<a href=\"https://kubernetes.io/docs/api-reference/v1.6/\" target=\"_blank\" rel=\"external\">https://kubernetes.io/docs/api-reference/v1.6/</a></p>\n<h4><span id=\"231-curl\">2.3.1. curl</span></h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl localhost:8080/api</div><div class=\"line\">curl localhost:8080/api/v1/pods</div><div class=\"line\">curl localhost:8080/api/v1/services</div><div class=\"line\">curl localhost:8080/api/v1/replicationcontrollers</div></pre></td></tr></table></figure>\n<h4><span id=\"232-kubectl-proxy\">2.3.2. Kubectl Proxy</span></h4>\n<p>Kubectl Proxy代理程序既能作为API Server的反向代理，也能作为普通客户端访问API Server的代理。通过master节点的8080端口来启动该代理程序。</p>\n<p>kubectl proxy --port=8080 &amp;</p>\n<p>具体见kubectl proxy --help</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@node5 ~]# kubectl proxy --help</div><div class=\"line\">To proxy all of the kubernetes api and nothing else, use:</div><div class=\"line\">kubectl proxy --api-prefix=/</div><div class=\"line\">To proxy only part of the kubernetes api and also some static files:</div><div class=\"line\">kubectl proxy --www=/my/files --www-prefix=/static/ --api-prefix=/api/</div><div class=\"line\">The above lets you 'curl localhost:8001/api/v1/pods'.</div><div class=\"line\">To proxy the entire kubernetes api at a different root, use:</div><div class=\"line\">kubectl proxy --api-prefix=/custom/</div><div class=\"line\">The above lets you 'curl localhost:8001/custom/api/v1/pods'</div><div class=\"line\">Usage:</div><div class=\"line\">  kubectl proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix] [flags]</div><div class=\"line\">Examples:</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Run a proxy to kubernetes apiserver on port 8011, serving static content from ./<span class=\"built_in\">local</span>/www/</span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> kubectl proxy --port=8011 --www=./<span class=\"built_in\">local</span>/www/</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Run a proxy to kubernetes apiserver on an arbitrary <span class=\"built_in\">local</span> port.</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> The chosen port <span class=\"keyword\">for</span> the server will be output to stdout.</span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> kubectl proxy --port=0</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Run a proxy to kubernetes apiserver, changing the api prefix to k8s-api</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This makes e.g. the pods api available at localhost:8011/k8s-api/v1/pods/</span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> kubectl proxy --api-prefix=/k8s-api</span></div><div class=\"line\">Flags:</div><div class=\"line\">      --accept-hosts=\"^localhost$,^127//.0//.0//.1$,^//[::1//]$\": Regular expression for hosts that the proxy should accept.</div><div class=\"line\">      --accept-paths=\"^/.*\": Regular expression for paths that the proxy should accept.</div><div class=\"line\">      --api-prefix=\"/\": Prefix to serve the proxied API under.</div><div class=\"line\">      --disable-filter[=false]: If true, disable request filtering in the proxy. This is dangerous, and can leave you vulnerable to XSRF attacks, when used with an accessible port.</div><div class=\"line\">  -p, --port=8001: The port on which to run the proxy. Set to 0 to pick a random port.</div><div class=\"line\">      --reject-methods=\"POST,PUT,PATCH\": Regular expression for HTTP methods that the proxy should reject.</div><div class=\"line\">      --reject-paths=\"^/api/.*/exec,^/api/.*/run\": Regular expression for paths that the proxy should reject.</div><div class=\"line\">  -u, --unix-socket=\"\": Unix socket on which to run the proxy.</div><div class=\"line\">  -w, --www=\"\": Also serve static files from the given directory under the specified prefix.</div><div class=\"line\">  -P, --www-prefix=\"/static/\": Prefix to serve static files under, if static file directory is specified.</div><div class=\"line\"> </div><div class=\"line\">Global Flags:</div><div class=\"line\">      --alsologtostderr[=false]: log to standard error as well as files</div><div class=\"line\">      --api-version=\"\": The API version to use when talking to the server</div><div class=\"line\">      --certificate-authority=\"\": Path to a cert. file for the certificate authority.</div><div class=\"line\">      --client-certificate=\"\": Path to a client key file for TLS.</div><div class=\"line\">      --client-key=\"\": Path to a client key file for TLS.</div><div class=\"line\">      --cluster=\"\": The name of the kubeconfig cluster to use</div><div class=\"line\">      --context=\"\": The name of the kubeconfig context to use</div><div class=\"line\">      --insecure-skip-tls-verify[=false]: If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure.</div><div class=\"line\">      --kubeconfig=\"\": Path to the kubeconfig file to use for CLI requests.</div><div class=\"line\">      --log-backtrace-at=:0: when logging hits line file:N, emit a stack trace</div><div class=\"line\">      --log-dir=\"\": If non-empty, write log files in this directory</div><div class=\"line\">      --log-flush-frequency=5s: Maximum number of seconds between log flushes</div><div class=\"line\">      --logtostderr[=true]: log to standard error instead of files</div><div class=\"line\">      --match-server-version[=false]: Require server version to match client version</div><div class=\"line\">      --namespace=\"\": If present, the namespace scope for this CLI request.</div><div class=\"line\">      --password=\"\": Password for basic authentication to the API server.</div><div class=\"line\">  -s, --server=\"\": The address and port of the Kubernetes API server</div><div class=\"line\">      --stderrthreshold=2: logs at or above this threshold go to stderr</div><div class=\"line\">      --token=\"\": Bearer token for authentication to the API server.</div><div class=\"line\">      --user=\"\": The name of the kubeconfig user to use</div><div class=\"line\">      --username=\"\": Username for basic authentication to the API server.</div><div class=\"line\">      --v=0: log level for V logs</div><div class=\"line\">      --vmodule=: comma-separated list of pattern=N settings for file-filtered logging</div></pre></td></tr></table></figure>\n<h4><span id=\"233-kubectl客户端\">2.3.3. kubectl客户端</span></h4>\n<p>命令行工具kubectl客户端，通过命令行参数转换为对API Server的REST API调用，并将调用结果输出。</p>\n<p>命令格式：kubectl [command] [options]</p>\n<p>具体可参考<a href=\"http://wiki.haplat.net/pages/viewpage.action?pageId=11899446\" target=\"_blank\" rel=\"external\">k8s常用命令</a></p>\n<h4><span id=\"234-编程方式调用\">2.3.4. 编程方式调用</span></h4>\n<p>使用场景：</p>\n<p>1、运行在Pod里的用户进程调用kubernetes API,通常用来实现分布式集群搭建的目标。</p>\n<p>2、开发基于kubernetes的管理平台，比如调用kubernetes API来完成Pod、Service、RC等资源对象的图形化创建和管理界面。可以使用kubernetes提供的Client Library。</p>\n<p>具体可参考<a href=\"https://github.com/kubernetes/client-go\" target=\"_blank\" rel=\"external\">https://github.com/kubernetes/client-go</a>。</p>\n<h2><span id=\"3-通过api-server访问node-pod和service\">3. 通过API Server访问Node、Pod和Service</span></h2>\n<p>k8s API Server最主要的REST接口是资源对象的增删改查，另外还有一类特殊的REST接口—k8s Proxy API接口，这类接口的作用是代理REST请求，即kubernetes API Server把收到的REST请求转发到某个Node上的kubelet守护进程的REST端口上，由该kubelet进程负责响应。</p>\n<h3><span id=\"31-node相关接口\">3.1. Node相关接口</span></h3>\n<p>关于Node相关的接口的REST路径为：/api/v1/proxy/nodes/{name}，其中{name}为节点的名称或IP地址。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/pods/    #列出指定节点内所有Pod的信息</div><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/stats/   #列出指定节点内物理资源的统计信息</div><div class=\"line\">/api/v1/prxoy/nodes/&#123;name&#125;/spec/    #列出指定节点的概要信息</div></pre></td></tr></table></figure>\n<p>这里获取的Pod信息来自Node而非etcd数据库，两者时间点可能存在偏差。如果在kubelet进程启动时加–enable-debugging-handles=true参数，那么kubernetes Proxy API还会增加以下接口：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/run      #在节点上运行某个容器</div><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/exec     #在节点上的某个容器中运行某条命令</div><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/attach   #在节点上attach某个容器</div><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/portForward   #实现节点上的Pod端口转发</div><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/logs     #列出节点的各类日志信息</div><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/metrics  #列出和该节点相关的Metrics信息</div><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/runningpods  #列出节点内运行中的Pod信息</div><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/debug/pprof  #列出节点内当前web服务的状态，包括CPU和内存的使用情况</div></pre></td></tr></table></figure>\n<h3><span id=\"32-pod相关接口\">3.2. Pod相关接口</span></h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">/api/v1/proxy/namespaces/&#123;namespace&#125;/pods/&#123;name&#125;/&#123;path:*&#125;      #访问pod的某个服务接口</div><div class=\"line\">/api/v1/proxy/namespaces/&#123;namespace&#125;/pods/&#123;name&#125;               #访问Pod</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">以下写法不同，功能一样</span></div><div class=\"line\">/api/v1/namespaces/&#123;namespace&#125;/pods/&#123;name&#125;/proxy/&#123;path:*&#125;      #访问pod的某个服务接口</div><div class=\"line\">/api/v1/namespaces/&#123;namespace&#125;/pods/&#123;name&#125;/proxy               #访问Pod</div></pre></td></tr></table></figure>\n<h3><span id=\"33-service相关接口\">3.3. Service相关接口</span></h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/api/v1/proxy/namespaces/&#123;namespace&#125;/services/&#123;name&#125;</div></pre></td></tr></table></figure>\n<p>Pod的proxy接口的作用：在kubernetes集群之外访问某个pod容器的服务（HTTP服务），可以用Proxy API实现，这种场景多用于管理目的，比如逐一排查Service的Pod副本，检查哪些Pod的服务存在异常问题。</p>\n<h2><span id=\"4-集群功能模块之间的通信\">4. 集群功能模块之间的通信</span></h2>\n<p>kubernetes API Server作为集群的核心，负责集群各功能模块之间的通信，集群内各个功能模块通过API Server将信息存入etcd，当需要获取和操作这些数据时，通过API Server提供的REST接口（GET/LIST/WATCH方法）来实现，从而实现各模块之间的信息交互。</p>\n<h3><span id=\"41-kubelet与api-server交互\">4.1. kubelet与API Server交互</span></h3>\n<p>每个Node节点上的kubelet定期就会调用API Server的REST接口报告自身状态，API Server接收这些信息后，将节点状态信息更新到etcd中。kubelet也通过API Server的Watch接口监听Pod信息，从而对Node机器上的POD进行管理。</p>\n<table>\n<thead>\n<tr>\n<th>监听信息</th>\n<th>kubelet动作</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>新的POD副本被调度绑定到本节点</td>\n<td>执行POD对应的容器的创建和启动逻辑</td>\n<td></td>\n</tr>\n<tr>\n<td>POD对象被删除</td>\n<td>删除本节点上相应的POD容器</td>\n<td></td>\n</tr>\n<tr>\n<td>修改POD信息</td>\n<td>修改本节点的POD容器</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3><span id=\"42-kube-controller-manager与api-server交互\">4.2. kube-controller-manager与API Server交互</span></h3>\n<p>kube-controller-manager中的Node Controller模块通过API Server提供的Watch接口，实时监控Node的信息，并做相应处理。</p>\n<h3><span id=\"43-kube-scheduler与api-server交互\">4.3. kube-scheduler与API Server交互</span></h3>\n<p>Scheduler通过API Server的Watch接口监听到新建Pod副本的信息后，它会检索所有符合该Pod要求的Node列表，开始执行Pod调度逻辑。调度成功后将Pod绑定到目标节点上。</p>\n<h3><span id=\"44-特别说明\">4.4. 特别说明</span></h3>\n<p>为了缓解各模块对API Server的访问压力，各功能模块都采用缓存机制来缓存数据，各功能模块定时从API Server获取指定的资源对象信息（LIST/WATCH方法），然后将信息保存到本地缓存，功能模块在某些情况下不直接访问API Server，而是通过访问缓存数据来间接访问API Server。</p>\n<p>参考《kubernetes权威指南》</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. API Server简介</h2>\n<p>k8s API Server提供了k8s各类资源对象（pod,RC,Service等）的增删改查及watch等HTTP Rest接口，是整个系统的数据总线和数据中心。</p>\n<p>kubernetes API Server的功能：</p>\n<ol>\n<li>提供了集群管理的REST API接口(包括认证授权、数据校验以及集群状态变更)；</li>\n<li>提供其他模块之间的数据交互和通信的枢纽（其他模块通过API Server查询或修改数据，只有API Server才直接操作etcd）;</li>\n<li>是资源配额控制的入口；</li>\n<li>拥有完备的集群安全机制.</li>\n</ol>\n<p><strong>kube-apiserver工作原理图</strong></p>\n<p><img src=\"/img/article/kubernetes/kubernetes%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/kube-apiserver.png\" alt=\"kube-apiserver\"></p>\n<h2>2. 如何访问kubernetes API</h2>\n<p>k8s通过kube-apiserver这个进程提供服务，该进程运行在单个k8s-master节点上。默认有两个端口。</p>\n<h3>2.1. 本地端口</h3>\n<ol>\n<li>该端口用于接收HTTP请求；</li>\n<li>该端口默认值为8080，可以通过API Server的启动参数“–insecure-port”的值来修改默认值；</li>\n<li>默认的IP地址为“localhost”，可以通过启动参数“–insecure-bind-address”的值来修改该IP地址；</li>\n<li>非认证或授权的HTTP请求通过该端口访问API Server。</li>\n</ol>\n<h3>2.2. 安全端口</h3>\n<ol>\n<li>该端口默认值为6443，可通过启动参数“–secure-port”的值来修改默认值；</li>\n<li>默认IP地址为非本地（Non-Localhost）网络端口，通过启动参数“–bind-address”设置该值；</li>\n<li>该端口用于接收HTTPS请求；</li>\n<li>用于基于Tocken文件或客户端证书及HTTP Base的认证；</li>\n<li>用于基于策略的授权；</li>\n<li>默认不启动HTTPS安全访问控制。</li>\n</ol>\n<h3>2.3. 访问方式</h3>\n<p>Kubernetes REST API可参考<a href=\"https://kubernetes.io/docs/api-reference/v1.6/\" target=\"_blank\" rel=\"external\">https://kubernetes.io/docs/api-reference/v1.6/</a></p>\n<h4>2.3.1. curl</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl localhost:8080/api</div><div class=\"line\">curl localhost:8080/api/v1/pods</div><div class=\"line\">curl localhost:8080/api/v1/services</div><div class=\"line\">curl localhost:8080/api/v1/replicationcontrollers</div></pre></td></tr></table></figure>\n<h4>2.3.2. Kubectl Proxy</h4>\n<p>Kubectl Proxy代理程序既能作为API Server的反向代理，也能作为普通客户端访问API Server的代理。通过master节点的8080端口来启动该代理程序。</p>\n<p>kubectl proxy --port=8080 &amp;</p>\n<p>具体见kubectl proxy --help</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@node5 ~]# kubectl proxy --help</div><div class=\"line\">To proxy all of the kubernetes api and nothing else, use:</div><div class=\"line\">kubectl proxy --api-prefix=/</div><div class=\"line\">To proxy only part of the kubernetes api and also some static files:</div><div class=\"line\">kubectl proxy --www=/my/files --www-prefix=/static/ --api-prefix=/api/</div><div class=\"line\">The above lets you 'curl localhost:8001/api/v1/pods'.</div><div class=\"line\">To proxy the entire kubernetes api at a different root, use:</div><div class=\"line\">kubectl proxy --api-prefix=/custom/</div><div class=\"line\">The above lets you 'curl localhost:8001/custom/api/v1/pods'</div><div class=\"line\">Usage:</div><div class=\"line\">  kubectl proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix] [flags]</div><div class=\"line\">Examples:</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Run a proxy to kubernetes apiserver on port 8011, serving static content from ./<span class=\"built_in\">local</span>/www/</span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> kubectl proxy --port=8011 --www=./<span class=\"built_in\">local</span>/www/</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Run a proxy to kubernetes apiserver on an arbitrary <span class=\"built_in\">local</span> port.</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> The chosen port <span class=\"keyword\">for</span> the server will be output to stdout.</span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> kubectl proxy --port=0</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Run a proxy to kubernetes apiserver, changing the api prefix to k8s-api</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This makes e.g. the pods api available at localhost:8011/k8s-api/v1/pods/</span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> kubectl proxy --api-prefix=/k8s-api</span></div><div class=\"line\">Flags:</div><div class=\"line\">      --accept-hosts=\"^localhost$,^127//.0//.0//.1$,^//[::1//]$\": Regular expression for hosts that the proxy should accept.</div><div class=\"line\">      --accept-paths=\"^/.*\": Regular expression for paths that the proxy should accept.</div><div class=\"line\">      --api-prefix=\"/\": Prefix to serve the proxied API under.</div><div class=\"line\">      --disable-filter[=false]: If true, disable request filtering in the proxy. This is dangerous, and can leave you vulnerable to XSRF attacks, when used with an accessible port.</div><div class=\"line\">  -p, --port=8001: The port on which to run the proxy. Set to 0 to pick a random port.</div><div class=\"line\">      --reject-methods=\"POST,PUT,PATCH\": Regular expression for HTTP methods that the proxy should reject.</div><div class=\"line\">      --reject-paths=\"^/api/.*/exec,^/api/.*/run\": Regular expression for paths that the proxy should reject.</div><div class=\"line\">  -u, --unix-socket=\"\": Unix socket on which to run the proxy.</div><div class=\"line\">  -w, --www=\"\": Also serve static files from the given directory under the specified prefix.</div><div class=\"line\">  -P, --www-prefix=\"/static/\": Prefix to serve static files under, if static file directory is specified.</div><div class=\"line\"> </div><div class=\"line\">Global Flags:</div><div class=\"line\">      --alsologtostderr[=false]: log to standard error as well as files</div><div class=\"line\">      --api-version=\"\": The API version to use when talking to the server</div><div class=\"line\">      --certificate-authority=\"\": Path to a cert. file for the certificate authority.</div><div class=\"line\">      --client-certificate=\"\": Path to a client key file for TLS.</div><div class=\"line\">      --client-key=\"\": Path to a client key file for TLS.</div><div class=\"line\">      --cluster=\"\": The name of the kubeconfig cluster to use</div><div class=\"line\">      --context=\"\": The name of the kubeconfig context to use</div><div class=\"line\">      --insecure-skip-tls-verify[=false]: If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure.</div><div class=\"line\">      --kubeconfig=\"\": Path to the kubeconfig file to use for CLI requests.</div><div class=\"line\">      --log-backtrace-at=:0: when logging hits line file:N, emit a stack trace</div><div class=\"line\">      --log-dir=\"\": If non-empty, write log files in this directory</div><div class=\"line\">      --log-flush-frequency=5s: Maximum number of seconds between log flushes</div><div class=\"line\">      --logtostderr[=true]: log to standard error instead of files</div><div class=\"line\">      --match-server-version[=false]: Require server version to match client version</div><div class=\"line\">      --namespace=\"\": If present, the namespace scope for this CLI request.</div><div class=\"line\">      --password=\"\": Password for basic authentication to the API server.</div><div class=\"line\">  -s, --server=\"\": The address and port of the Kubernetes API server</div><div class=\"line\">      --stderrthreshold=2: logs at or above this threshold go to stderr</div><div class=\"line\">      --token=\"\": Bearer token for authentication to the API server.</div><div class=\"line\">      --user=\"\": The name of the kubeconfig user to use</div><div class=\"line\">      --username=\"\": Username for basic authentication to the API server.</div><div class=\"line\">      --v=0: log level for V logs</div><div class=\"line\">      --vmodule=: comma-separated list of pattern=N settings for file-filtered logging</div></pre></td></tr></table></figure>\n<h4>2.3.3. kubectl客户端</h4>\n<p>命令行工具kubectl客户端，通过命令行参数转换为对API Server的REST API调用，并将调用结果输出。</p>\n<p>命令格式：kubectl [command] [options]</p>\n<p>具体可参考<a href=\"http://wiki.haplat.net/pages/viewpage.action?pageId=11899446\" target=\"_blank\" rel=\"external\">k8s常用命令</a></p>\n<h4>2.3.4. 编程方式调用</h4>\n<p>使用场景：</p>\n<p>1、运行在Pod里的用户进程调用kubernetes API,通常用来实现分布式集群搭建的目标。</p>\n<p>2、开发基于kubernetes的管理平台，比如调用kubernetes API来完成Pod、Service、RC等资源对象的图形化创建和管理界面。可以使用kubernetes提供的Client Library。</p>\n<p>具体可参考<a href=\"https://github.com/kubernetes/client-go\" target=\"_blank\" rel=\"external\">https://github.com/kubernetes/client-go</a>。</p>\n<h2>3. 通过API Server访问Node、Pod和Service</h2>\n<p>k8s API Server最主要的REST接口是资源对象的增删改查，另外还有一类特殊的REST接口—k8s Proxy API接口，这类接口的作用是代理REST请求，即kubernetes API Server把收到的REST请求转发到某个Node上的kubelet守护进程的REST端口上，由该kubelet进程负责响应。</p>\n<h3>3.1. Node相关接口</h3>\n<p>关于Node相关的接口的REST路径为：/api/v1/proxy/nodes/{name}，其中{name}为节点的名称或IP地址。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/pods/    #列出指定节点内所有Pod的信息</div><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/stats/   #列出指定节点内物理资源的统计信息</div><div class=\"line\">/api/v1/prxoy/nodes/&#123;name&#125;/spec/    #列出指定节点的概要信息</div></pre></td></tr></table></figure>\n<p>这里获取的Pod信息来自Node而非etcd数据库，两者时间点可能存在偏差。如果在kubelet进程启动时加–enable-debugging-handles=true参数，那么kubernetes Proxy API还会增加以下接口：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/run      #在节点上运行某个容器</div><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/exec     #在节点上的某个容器中运行某条命令</div><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/attach   #在节点上attach某个容器</div><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/portForward   #实现节点上的Pod端口转发</div><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/logs     #列出节点的各类日志信息</div><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/metrics  #列出和该节点相关的Metrics信息</div><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/runningpods  #列出节点内运行中的Pod信息</div><div class=\"line\">/api/v1/proxy/nodes/&#123;name&#125;/debug/pprof  #列出节点内当前web服务的状态，包括CPU和内存的使用情况</div></pre></td></tr></table></figure>\n<h3>3.2. Pod相关接口</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">/api/v1/proxy/namespaces/&#123;namespace&#125;/pods/&#123;name&#125;/&#123;path:*&#125;      #访问pod的某个服务接口</div><div class=\"line\">/api/v1/proxy/namespaces/&#123;namespace&#125;/pods/&#123;name&#125;               #访问Pod</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">以下写法不同，功能一样</span></div><div class=\"line\">/api/v1/namespaces/&#123;namespace&#125;/pods/&#123;name&#125;/proxy/&#123;path:*&#125;      #访问pod的某个服务接口</div><div class=\"line\">/api/v1/namespaces/&#123;namespace&#125;/pods/&#123;name&#125;/proxy               #访问Pod</div></pre></td></tr></table></figure>\n<h3>3.3. Service相关接口</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/api/v1/proxy/namespaces/&#123;namespace&#125;/services/&#123;name&#125;</div></pre></td></tr></table></figure>\n<p>Pod的proxy接口的作用：在kubernetes集群之外访问某个pod容器的服务（HTTP服务），可以用Proxy API实现，这种场景多用于管理目的，比如逐一排查Service的Pod副本，检查哪些Pod的服务存在异常问题。</p>\n<h2>4. 集群功能模块之间的通信</h2>\n<p>kubernetes API Server作为集群的核心，负责集群各功能模块之间的通信，集群内各个功能模块通过API Server将信息存入etcd，当需要获取和操作这些数据时，通过API Server提供的REST接口（GET/LIST/WATCH方法）来实现，从而实现各模块之间的信息交互。</p>\n<h3>4.1. kubelet与API Server交互</h3>\n<p>每个Node节点上的kubelet定期就会调用API Server的REST接口报告自身状态，API Server接收这些信息后，将节点状态信息更新到etcd中。kubelet也通过API Server的Watch接口监听Pod信息，从而对Node机器上的POD进行管理。</p>\n<table>\n<thead>\n<tr>\n<th>监听信息</th>\n<th>kubelet动作</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>新的POD副本被调度绑定到本节点</td>\n<td>执行POD对应的容器的创建和启动逻辑</td>\n<td></td>\n</tr>\n<tr>\n<td>POD对象被删除</td>\n<td>删除本节点上相应的POD容器</td>\n<td></td>\n</tr>\n<tr>\n<td>修改POD信息</td>\n<td>修改本节点的POD容器</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3>4.2. kube-controller-manager与API Server交互</h3>\n<p>kube-controller-manager中的Node Controller模块通过API Server提供的Watch接口，实时监控Node的信息，并做相应处理。</p>\n<h3>4.3. kube-scheduler与API Server交互</h3>\n<p>Scheduler通过API Server的Watch接口监听到新建Pod副本的信息后，它会检索所有符合该Pod要求的Node列表，开始执行Pod调度逻辑。调度成功后将Pod绑定到目标节点上。</p>\n<h3>4.4. 特别说明</h3>\n<p>为了缓解各模块对API Server的访问压力，各功能模块都采用缓存机制来缓存数据，各功能模块定时从API Server获取指定的资源对象信息（LIST/WATCH方法），然后将信息保存到本地缓存，功能模块在某些情况下不直接访问API Server，而是通过访问缓存数据来间接访问API Server。</p>\n<p>参考《kubernetes权威指南》</p>\n"},{"title":"[Kubernetes] Kubernetes核心原理（三）之Scheduler","catalog":true,"date":"2017-08-15T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Kubernetes"],"_content":"\n## 1. Scheduler简介\n\nScheduler负责Pod调度。在整个系统中起\"承上启下\"作用，承上：负责接收Controller Manager创建的新的Pod，为其选择一个合适的Node；启下：Node上的kubelet接管Pod的生命周期。\n\nScheduler：\n\n1）通过调度算法为待调度Pod列表的每个Pod从Node列表中选择一个最适合的Node，并将信息写入etcd中\n\n2）kubelet通过API Server监听到kubernetes Scheduler产生的Pod绑定信息，然后获取对应的Pod清单，下载Image，并启动容器。\n\n![scheduler](/img/article/kubernetes/kubernetes核心原理/scheduler.png)\n\n## 2. 调度流程\n\n1、预选调度过程，即遍历所有目标Node,筛选出符合要求的候选节点，kubernetes内置了多种预选策略（xxx Predicates）供用户选择\n\n2、确定最优节点，在第一步的基础上采用优选策略（xxx Priority）计算出每个候选节点的积分，取最高积分。\n\n调度流程通过插件式加载的“调度算法提供者”（AlgorithmProvider）具体实现，一个调度算法提供者就是包括一组预选策略与一组优选策略的结构体。\n\n## 3. 预选策略\n\n说明：返回true表示该节点满足该Pod的调度条件；返回false表示该节点不满足该Pod的调度条件。\n\n### 3.1. NoDiskConflict\n\n判断备选Pod的数据卷是否与该Node上已存在Pod挂载的数据卷冲突，如果是则返回false，否则返回true。\n\n### 3.2. PodFitsResources\n\n判断备选节点的资源是否满足备选Pod的需求，即节点的剩余资源满不满足该Pod的资源使用。\n\n1. 计算备选Pod和节点中已用资源（该节点所有Pod的使用资源）的总和。\n2. 获取备选节点的状态信息，包括节点资源信息。\n3. 如果（备选Pod+节点已用资源>该节点总资源）则返回false，即剩余资源不满足该Pod使用；否则返回true。\n\n### 3.3. PodSelectorMatches\n\n判断节点是否包含备选Pod的标签选择器指定的标签，即通过标签来选择Node。\n\n1. 如果Pod中没有指定spec.nodeSelector，则返回true。\n2. 否则获得备选节点的标签信息，判断该节点的标签信息中是否包含该Pod的spec.nodeSelector中指定的标签，如果包含返回true，否则返回false。\n\n### 3.4. PodFitsHost\n\n判断备选Pod的spec.nodeName所指定的节点名称与备选节点名称是否一致，如果一致返回true，否则返回false。\n\n### 3.5. CheckNodeLabelPresence\n\n检查备选节点中是否有Scheduler配置的标签，如果有返回true，否则返回false。\n\n### 3.6. CheckServiceAffinity\n\n判断备选节点是否包含Scheduler配置的标签，如果有返回true，否则返回false。\n\n### 3.7. PodFitsPorts\n\n判断备选Pod所用的端口列表中的端口是否在备选节点中已被占用，如果被占用返回false，否则返回true。\n\n## 4. 优选策略\n\n### 4.1. LeastRequestedPriority\n\n优先从备选节点列表中选择资源消耗最小的节点（CPU+内存）。\n\n### 4.2. CalculateNodeLabelPriority\n\n优先选择含有指定Label的节点。\n\n### 4.3. BalancedResourceAllocation\n\n优先从备选节点列表中选择各项资源使用率最均衡的节点。\n\n\n\n参考《Kubernetes权威指南》","source":"_posts/Kubernetes/kubernetes核心原理/kubernetes核心原理（三）之Scheduler.md","raw":"---\ntitle: \"[Kubernetes] Kubernetes核心原理（三）之Scheduler\"\ncatalog: true\ndate: 2017-08-15 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Kubernetes\ncatagories:\n- Kubernetes\n---\n\n## 1. Scheduler简介\n\nScheduler负责Pod调度。在整个系统中起\"承上启下\"作用，承上：负责接收Controller Manager创建的新的Pod，为其选择一个合适的Node；启下：Node上的kubelet接管Pod的生命周期。\n\nScheduler：\n\n1）通过调度算法为待调度Pod列表的每个Pod从Node列表中选择一个最适合的Node，并将信息写入etcd中\n\n2）kubelet通过API Server监听到kubernetes Scheduler产生的Pod绑定信息，然后获取对应的Pod清单，下载Image，并启动容器。\n\n![scheduler](/img/article/kubernetes/kubernetes核心原理/scheduler.png)\n\n## 2. 调度流程\n\n1、预选调度过程，即遍历所有目标Node,筛选出符合要求的候选节点，kubernetes内置了多种预选策略（xxx Predicates）供用户选择\n\n2、确定最优节点，在第一步的基础上采用优选策略（xxx Priority）计算出每个候选节点的积分，取最高积分。\n\n调度流程通过插件式加载的“调度算法提供者”（AlgorithmProvider）具体实现，一个调度算法提供者就是包括一组预选策略与一组优选策略的结构体。\n\n## 3. 预选策略\n\n说明：返回true表示该节点满足该Pod的调度条件；返回false表示该节点不满足该Pod的调度条件。\n\n### 3.1. NoDiskConflict\n\n判断备选Pod的数据卷是否与该Node上已存在Pod挂载的数据卷冲突，如果是则返回false，否则返回true。\n\n### 3.2. PodFitsResources\n\n判断备选节点的资源是否满足备选Pod的需求，即节点的剩余资源满不满足该Pod的资源使用。\n\n1. 计算备选Pod和节点中已用资源（该节点所有Pod的使用资源）的总和。\n2. 获取备选节点的状态信息，包括节点资源信息。\n3. 如果（备选Pod+节点已用资源>该节点总资源）则返回false，即剩余资源不满足该Pod使用；否则返回true。\n\n### 3.3. PodSelectorMatches\n\n判断节点是否包含备选Pod的标签选择器指定的标签，即通过标签来选择Node。\n\n1. 如果Pod中没有指定spec.nodeSelector，则返回true。\n2. 否则获得备选节点的标签信息，判断该节点的标签信息中是否包含该Pod的spec.nodeSelector中指定的标签，如果包含返回true，否则返回false。\n\n### 3.4. PodFitsHost\n\n判断备选Pod的spec.nodeName所指定的节点名称与备选节点名称是否一致，如果一致返回true，否则返回false。\n\n### 3.5. CheckNodeLabelPresence\n\n检查备选节点中是否有Scheduler配置的标签，如果有返回true，否则返回false。\n\n### 3.6. CheckServiceAffinity\n\n判断备选节点是否包含Scheduler配置的标签，如果有返回true，否则返回false。\n\n### 3.7. PodFitsPorts\n\n判断备选Pod所用的端口列表中的端口是否在备选节点中已被占用，如果被占用返回false，否则返回true。\n\n## 4. 优选策略\n\n### 4.1. LeastRequestedPriority\n\n优先从备选节点列表中选择资源消耗最小的节点（CPU+内存）。\n\n### 4.2. CalculateNodeLabelPriority\n\n优先选择含有指定Label的节点。\n\n### 4.3. BalancedResourceAllocation\n\n优先从备选节点列表中选择各项资源使用率最均衡的节点。\n\n\n\n参考《Kubernetes权威指南》","slug":"Kubernetes/kubernetes核心原理/kubernetes核心原理（三）之Scheduler","published":1,"updated":"2017-10-02T11:45:24.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740ke001630vus0jb3jqx","content":"<h2><span id=\"1-scheduler简介\">1. Scheduler简介</span></h2>\n<p>Scheduler负责Pod调度。在整个系统中起&quot;承上启下&quot;作用，承上：负责接收Controller Manager创建的新的Pod，为其选择一个合适的Node；启下：Node上的kubelet接管Pod的生命周期。</p>\n<p>Scheduler：</p>\n<p>1）通过调度算法为待调度Pod列表的每个Pod从Node列表中选择一个最适合的Node，并将信息写入etcd中</p>\n<p>2）kubelet通过API Server监听到kubernetes Scheduler产生的Pod绑定信息，然后获取对应的Pod清单，下载Image，并启动容器。</p>\n<p><img src=\"/img/article/kubernetes/kubernetes%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/scheduler.png\" alt=\"scheduler\"></p>\n<h2><span id=\"2-调度流程\">2. 调度流程</span></h2>\n<p>1、预选调度过程，即遍历所有目标Node,筛选出符合要求的候选节点，kubernetes内置了多种预选策略（xxx Predicates）供用户选择</p>\n<p>2、确定最优节点，在第一步的基础上采用优选策略（xxx Priority）计算出每个候选节点的积分，取最高积分。</p>\n<p>调度流程通过插件式加载的“调度算法提供者”（AlgorithmProvider）具体实现，一个调度算法提供者就是包括一组预选策略与一组优选策略的结构体。</p>\n<h2><span id=\"3-预选策略\">3. 预选策略</span></h2>\n<p>说明：返回true表示该节点满足该Pod的调度条件；返回false表示该节点不满足该Pod的调度条件。</p>\n<h3><span id=\"31-nodiskconflict\">3.1. NoDiskConflict</span></h3>\n<p>判断备选Pod的数据卷是否与该Node上已存在Pod挂载的数据卷冲突，如果是则返回false，否则返回true。</p>\n<h3><span id=\"32-podfitsresources\">3.2. PodFitsResources</span></h3>\n<p>判断备选节点的资源是否满足备选Pod的需求，即节点的剩余资源满不满足该Pod的资源使用。</p>\n<ol>\n<li>计算备选Pod和节点中已用资源（该节点所有Pod的使用资源）的总和。</li>\n<li>获取备选节点的状态信息，包括节点资源信息。</li>\n<li>如果（备选Pod+节点已用资源&gt;该节点总资源）则返回false，即剩余资源不满足该Pod使用；否则返回true。</li>\n</ol>\n<h3><span id=\"33-podselectormatches\">3.3. PodSelectorMatches</span></h3>\n<p>判断节点是否包含备选Pod的标签选择器指定的标签，即通过标签来选择Node。</p>\n<ol>\n<li>如果Pod中没有指定spec.nodeSelector，则返回true。</li>\n<li>否则获得备选节点的标签信息，判断该节点的标签信息中是否包含该Pod的spec.nodeSelector中指定的标签，如果包含返回true，否则返回false。</li>\n</ol>\n<h3><span id=\"34-podfitshost\">3.4. PodFitsHost</span></h3>\n<p>判断备选Pod的spec.nodeName所指定的节点名称与备选节点名称是否一致，如果一致返回true，否则返回false。</p>\n<h3><span id=\"35-checknodelabelpresence\">3.5. CheckNodeLabelPresence</span></h3>\n<p>检查备选节点中是否有Scheduler配置的标签，如果有返回true，否则返回false。</p>\n<h3><span id=\"36-checkserviceaffinity\">3.6. CheckServiceAffinity</span></h3>\n<p>判断备选节点是否包含Scheduler配置的标签，如果有返回true，否则返回false。</p>\n<h3><span id=\"37-podfitsports\">3.7. PodFitsPorts</span></h3>\n<p>判断备选Pod所用的端口列表中的端口是否在备选节点中已被占用，如果被占用返回false，否则返回true。</p>\n<h2><span id=\"4-优选策略\">4. 优选策略</span></h2>\n<h3><span id=\"41-leastrequestedpriority\">4.1. LeastRequestedPriority</span></h3>\n<p>优先从备选节点列表中选择资源消耗最小的节点（CPU+内存）。</p>\n<h3><span id=\"42-calculatenodelabelpriority\">4.2. CalculateNodeLabelPriority</span></h3>\n<p>优先选择含有指定Label的节点。</p>\n<h3><span id=\"43-balancedresourceallocation\">4.3. BalancedResourceAllocation</span></h3>\n<p>优先从备选节点列表中选择各项资源使用率最均衡的节点。</p>\n<p>参考《Kubernetes权威指南》</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. Scheduler简介</h2>\n<p>Scheduler负责Pod调度。在整个系统中起&quot;承上启下&quot;作用，承上：负责接收Controller Manager创建的新的Pod，为其选择一个合适的Node；启下：Node上的kubelet接管Pod的生命周期。</p>\n<p>Scheduler：</p>\n<p>1）通过调度算法为待调度Pod列表的每个Pod从Node列表中选择一个最适合的Node，并将信息写入etcd中</p>\n<p>2）kubelet通过API Server监听到kubernetes Scheduler产生的Pod绑定信息，然后获取对应的Pod清单，下载Image，并启动容器。</p>\n<p><img src=\"/img/article/kubernetes/kubernetes%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/scheduler.png\" alt=\"scheduler\"></p>\n<h2>2. 调度流程</h2>\n<p>1、预选调度过程，即遍历所有目标Node,筛选出符合要求的候选节点，kubernetes内置了多种预选策略（xxx Predicates）供用户选择</p>\n<p>2、确定最优节点，在第一步的基础上采用优选策略（xxx Priority）计算出每个候选节点的积分，取最高积分。</p>\n<p>调度流程通过插件式加载的“调度算法提供者”（AlgorithmProvider）具体实现，一个调度算法提供者就是包括一组预选策略与一组优选策略的结构体。</p>\n<h2>3. 预选策略</h2>\n<p>说明：返回true表示该节点满足该Pod的调度条件；返回false表示该节点不满足该Pod的调度条件。</p>\n<h3>3.1. NoDiskConflict</h3>\n<p>判断备选Pod的数据卷是否与该Node上已存在Pod挂载的数据卷冲突，如果是则返回false，否则返回true。</p>\n<h3>3.2. PodFitsResources</h3>\n<p>判断备选节点的资源是否满足备选Pod的需求，即节点的剩余资源满不满足该Pod的资源使用。</p>\n<ol>\n<li>计算备选Pod和节点中已用资源（该节点所有Pod的使用资源）的总和。</li>\n<li>获取备选节点的状态信息，包括节点资源信息。</li>\n<li>如果（备选Pod+节点已用资源&gt;该节点总资源）则返回false，即剩余资源不满足该Pod使用；否则返回true。</li>\n</ol>\n<h3>3.3. PodSelectorMatches</h3>\n<p>判断节点是否包含备选Pod的标签选择器指定的标签，即通过标签来选择Node。</p>\n<ol>\n<li>如果Pod中没有指定spec.nodeSelector，则返回true。</li>\n<li>否则获得备选节点的标签信息，判断该节点的标签信息中是否包含该Pod的spec.nodeSelector中指定的标签，如果包含返回true，否则返回false。</li>\n</ol>\n<h3>3.4. PodFitsHost</h3>\n<p>判断备选Pod的spec.nodeName所指定的节点名称与备选节点名称是否一致，如果一致返回true，否则返回false。</p>\n<h3>3.5. CheckNodeLabelPresence</h3>\n<p>检查备选节点中是否有Scheduler配置的标签，如果有返回true，否则返回false。</p>\n<h3>3.6. CheckServiceAffinity</h3>\n<p>判断备选节点是否包含Scheduler配置的标签，如果有返回true，否则返回false。</p>\n<h3>3.7. PodFitsPorts</h3>\n<p>判断备选Pod所用的端口列表中的端口是否在备选节点中已被占用，如果被占用返回false，否则返回true。</p>\n<h2>4. 优选策略</h2>\n<h3>4.1. LeastRequestedPriority</h3>\n<p>优先从备选节点列表中选择资源消耗最小的节点（CPU+内存）。</p>\n<h3>4.2. CalculateNodeLabelPriority</h3>\n<p>优先选择含有指定Label的节点。</p>\n<h3>4.3. BalancedResourceAllocation</h3>\n<p>优先从备选节点列表中选择各项资源使用率最均衡的节点。</p>\n<p>参考《Kubernetes权威指南》</p>\n"},{"title":"[Kubernetes] Kubernetes核心原理（二）之Controller Manager","catalog":true,"date":"2017-08-15T03:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Kubernetes"],"_content":"\n## 1. Controller Manager简介\n\nController Manager作为集群内部的管理控制中心，负责集群内的Node、Pod副本、服务端点（Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额（ResourceQuota）的管理，当某个Node意外宕机时，Controller Manager会及时发现并执行自动化修复流程，确保集群始终处于预期的工作状态。\n\n![controller manager](/img/article/kubernetes/kubernetes核心原理/controller-manager.png)\n\n每个Controller通过API Server提供的接口实时监控整个集群的每个资源对象的当前状态，当发生各种故障导致系统状态发生变化时，会尝试将系统状态修复到“期望状态”。\n\n## 2. Replication Controller\n\n为了区分，将资源对象Replication Controller简称RC,而本文中是指Controller Manager中的Replication Controller，称为副本控制器。副本控制器的作用即保证集群中一个RC所关联的Pod副本数始终保持预设值。\n\n1. 只有当Pod的重启策略是Always的时候（RestartPolicy=Always），副本控制器才会管理该Pod的操作（创建、销毁、重启等）。\n2. RC中的Pod模板就像一个模具，模具制造出来的东西一旦离开模具，它们之间就再没关系了。一旦Pod被创建，无论模板如何变化，也不会影响到已经创建的Pod。\n3. Pod可以通过修改label来脱离RC的管控，该方法可以用于将Pod从集群中迁移，数据修复等调试。\n4. 删除一个RC不会影响它所创建的Pod，如果要删除Pod需要将RC的副本数属性设置为0。\n5. 不要越过RC创建Pod，因为RC可以实现自动化控制Pod，提高容灾能力。\n\n### 2.1. Replication Controller的职责\n\n1. 确保集群中有且仅有N个Pod实例，N是RC中定义的Pod副本数量。\n2. 通过调整RC中的spec.replicas属性值来实现系统扩容或缩容。\n3. 通过改变RC中的Pod模板来实现系统的滚动升级。\n\n### 2.2. Replication Controller使用场景\n\n| 使用场景 | 说明                                       | 使用命令                   |\n| ---- | ---------------------------------------- | ---------------------- |\n| 重新调度 | 当发生节点故障或Pod被意外终止运行时，可以重新调度保证集群中仍然运行指定的副本数。 |                        |\n| 弹性伸缩 | 通过手动或自动扩容代理修复副本控制器的spec.replicas属性，可以实现弹性伸缩。 | kubectl scale          |\n| 滚动更新 | 创建一个新的RC文件，通过kubectl 命令或API执行，则会新增一个新的副本同时删除旧的副本，当旧副本为0时，删除旧的RC。 | kubectl rolling-update |\n\n滚动升级，具体可参考kubectl rolling-update --help,官方文档：[https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/](https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/)\n\n## 3. Node Controller\n\nkubelet在启动时会通过API Server注册自身的节点信息，并定时向API Server汇报状态信息，API Server接收到信息后将信息更新到etcd中。\n\nNode Controller通过API Server实时获取Node的相关信息，实现管理和监控集群中的各个Node节点的相关控制功能。流程如下\n\n![Node Controller](/img/article/kubernetes/kubernetes核心原理/NodeController.png)\n\n1、Controller Manager在启动时如果设置了--cluster-cidr参数，那么为每个没有设置Spec.PodCIDR的Node节点生成一个CIDR地址，并用该CIDR地址设置节点的Spec.PodCIDR属性，防止不同的节点的CIDR地址发生冲突。\n\n2、具体流程见以上流程图。\n\n3、逐个读取节点信息，如果节点状态变成非“就绪”状态，则将节点加入待删除队列，否则将节点从该队列删除。\n\n## 4. ResourceQuota Controller\n\n资源配额管理确保指定的资源对象在任何时候都不会超量占用系统物理资源。\n\n支持三个层次的资源配置管理：\n\n1）容器级别：对CPU和Memory进行限制\n\n2）Pod级别：对一个Pod内所有容器的可用资源进行限制\n\n3）Namespace级别：包括\n\n- Pod数量\n- Replication Controller数量\n- Service数量\n- ResourceQuota数量\n- Secret数量\n- 可持有的PV（Persistent Volume）数量\n\n说明：\n\n1. k8s配额管理是通过Admission Control（准入控制）来控制的；\n2. Admission Control提供两种配额约束方式：LimitRanger和ResourceQuota；\n3. LimitRanger作用于Pod和Container；\n4. ResourceQuota作用于Namespace上，限定一个Namespace里的各类资源的使用总额。\n\n**ResourceQuota Controller流程图**：\n\n![ResourceQuota Controller](/img/article/kubernetes/kubernetes核心原理/ResourceQuotaController.png)\n\n## 5. Namespace Controller\n\n用户通过API Server可以创建新的Namespace并保存在etcd中，Namespace Controller定时通过API Server读取这些Namespace信息。\n\n如果Namespace被API标记为优雅删除（即设置删除期限，DeletionTimestamp）,则将该Namespace状态设置为“Terminating”,并保存到etcd中。同时Namespace Controller删除该Namespace下的ServiceAccount、RC、Pod等资源对象。\n\n## 6. Endpoint Controller\n\n**Service、Endpoint、Pod的关系：**\n\n![Endpoint Controller](/img/article/kubernetes/kubernetes核心原理/EndpointController.png)\n\nEndpoints表示了一个Service对应的所有Pod副本的访问地址，而Endpoints Controller负责生成和维护所有Endpoints对象的控制器。它负责监听Service和对应的Pod副本的变化。\n\n1. 如果监测到Service被删除，则删除和该Service同名的Endpoints对象；\n2. 如果监测到新的Service被创建或修改，则根据该Service信息获得相关的Pod列表，然后创建或更新Service对应的Endpoints对象。\n3. 如果监测到Pod的事件，则更新它对应的Service的Endpoints对象。\n\nkube-proxy进程获取每个Service的Endpoints，实现Service的负载均衡功能。\n\n## 7. Service Controller\n\nService Controller是属于kubernetes集群与外部的云平台之间的一个接口控制器。Service Controller监听Service变化，如果是一个LoadBalancer类型的Service，则确保外部的云平台上对该Service对应的LoadBalancer实例被相应地创建、删除及更新路由转发表。\n\n \n\n参考《Kubernetes权威指南》\n\n ","source":"_posts/Kubernetes/kubernetes核心原理/kubernetes核心原理（二）之Controller Manager.md","raw":"---\ntitle: \"[Kubernetes] Kubernetes核心原理（二）之Controller Manager\"\ncatalog: true\ndate: 2017-08-15 11:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Kubernetes\ncatagories:\n- Kubernetes\n---\n\n## 1. Controller Manager简介\n\nController Manager作为集群内部的管理控制中心，负责集群内的Node、Pod副本、服务端点（Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额（ResourceQuota）的管理，当某个Node意外宕机时，Controller Manager会及时发现并执行自动化修复流程，确保集群始终处于预期的工作状态。\n\n![controller manager](/img/article/kubernetes/kubernetes核心原理/controller-manager.png)\n\n每个Controller通过API Server提供的接口实时监控整个集群的每个资源对象的当前状态，当发生各种故障导致系统状态发生变化时，会尝试将系统状态修复到“期望状态”。\n\n## 2. Replication Controller\n\n为了区分，将资源对象Replication Controller简称RC,而本文中是指Controller Manager中的Replication Controller，称为副本控制器。副本控制器的作用即保证集群中一个RC所关联的Pod副本数始终保持预设值。\n\n1. 只有当Pod的重启策略是Always的时候（RestartPolicy=Always），副本控制器才会管理该Pod的操作（创建、销毁、重启等）。\n2. RC中的Pod模板就像一个模具，模具制造出来的东西一旦离开模具，它们之间就再没关系了。一旦Pod被创建，无论模板如何变化，也不会影响到已经创建的Pod。\n3. Pod可以通过修改label来脱离RC的管控，该方法可以用于将Pod从集群中迁移，数据修复等调试。\n4. 删除一个RC不会影响它所创建的Pod，如果要删除Pod需要将RC的副本数属性设置为0。\n5. 不要越过RC创建Pod，因为RC可以实现自动化控制Pod，提高容灾能力。\n\n### 2.1. Replication Controller的职责\n\n1. 确保集群中有且仅有N个Pod实例，N是RC中定义的Pod副本数量。\n2. 通过调整RC中的spec.replicas属性值来实现系统扩容或缩容。\n3. 通过改变RC中的Pod模板来实现系统的滚动升级。\n\n### 2.2. Replication Controller使用场景\n\n| 使用场景 | 说明                                       | 使用命令                   |\n| ---- | ---------------------------------------- | ---------------------- |\n| 重新调度 | 当发生节点故障或Pod被意外终止运行时，可以重新调度保证集群中仍然运行指定的副本数。 |                        |\n| 弹性伸缩 | 通过手动或自动扩容代理修复副本控制器的spec.replicas属性，可以实现弹性伸缩。 | kubectl scale          |\n| 滚动更新 | 创建一个新的RC文件，通过kubectl 命令或API执行，则会新增一个新的副本同时删除旧的副本，当旧副本为0时，删除旧的RC。 | kubectl rolling-update |\n\n滚动升级，具体可参考kubectl rolling-update --help,官方文档：[https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/](https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/)\n\n## 3. Node Controller\n\nkubelet在启动时会通过API Server注册自身的节点信息，并定时向API Server汇报状态信息，API Server接收到信息后将信息更新到etcd中。\n\nNode Controller通过API Server实时获取Node的相关信息，实现管理和监控集群中的各个Node节点的相关控制功能。流程如下\n\n![Node Controller](/img/article/kubernetes/kubernetes核心原理/NodeController.png)\n\n1、Controller Manager在启动时如果设置了--cluster-cidr参数，那么为每个没有设置Spec.PodCIDR的Node节点生成一个CIDR地址，并用该CIDR地址设置节点的Spec.PodCIDR属性，防止不同的节点的CIDR地址发生冲突。\n\n2、具体流程见以上流程图。\n\n3、逐个读取节点信息，如果节点状态变成非“就绪”状态，则将节点加入待删除队列，否则将节点从该队列删除。\n\n## 4. ResourceQuota Controller\n\n资源配额管理确保指定的资源对象在任何时候都不会超量占用系统物理资源。\n\n支持三个层次的资源配置管理：\n\n1）容器级别：对CPU和Memory进行限制\n\n2）Pod级别：对一个Pod内所有容器的可用资源进行限制\n\n3）Namespace级别：包括\n\n- Pod数量\n- Replication Controller数量\n- Service数量\n- ResourceQuota数量\n- Secret数量\n- 可持有的PV（Persistent Volume）数量\n\n说明：\n\n1. k8s配额管理是通过Admission Control（准入控制）来控制的；\n2. Admission Control提供两种配额约束方式：LimitRanger和ResourceQuota；\n3. LimitRanger作用于Pod和Container；\n4. ResourceQuota作用于Namespace上，限定一个Namespace里的各类资源的使用总额。\n\n**ResourceQuota Controller流程图**：\n\n![ResourceQuota Controller](/img/article/kubernetes/kubernetes核心原理/ResourceQuotaController.png)\n\n## 5. Namespace Controller\n\n用户通过API Server可以创建新的Namespace并保存在etcd中，Namespace Controller定时通过API Server读取这些Namespace信息。\n\n如果Namespace被API标记为优雅删除（即设置删除期限，DeletionTimestamp）,则将该Namespace状态设置为“Terminating”,并保存到etcd中。同时Namespace Controller删除该Namespace下的ServiceAccount、RC、Pod等资源对象。\n\n## 6. Endpoint Controller\n\n**Service、Endpoint、Pod的关系：**\n\n![Endpoint Controller](/img/article/kubernetes/kubernetes核心原理/EndpointController.png)\n\nEndpoints表示了一个Service对应的所有Pod副本的访问地址，而Endpoints Controller负责生成和维护所有Endpoints对象的控制器。它负责监听Service和对应的Pod副本的变化。\n\n1. 如果监测到Service被删除，则删除和该Service同名的Endpoints对象；\n2. 如果监测到新的Service被创建或修改，则根据该Service信息获得相关的Pod列表，然后创建或更新Service对应的Endpoints对象。\n3. 如果监测到Pod的事件，则更新它对应的Service的Endpoints对象。\n\nkube-proxy进程获取每个Service的Endpoints，实现Service的负载均衡功能。\n\n## 7. Service Controller\n\nService Controller是属于kubernetes集群与外部的云平台之间的一个接口控制器。Service Controller监听Service变化，如果是一个LoadBalancer类型的Service，则确保外部的云平台上对该Service对应的LoadBalancer实例被相应地创建、删除及更新路由转发表。\n\n \n\n参考《Kubernetes权威指南》\n\n ","slug":"Kubernetes/kubernetes核心原理/kubernetes核心原理（二）之Controller Manager","published":1,"updated":"2017-10-02T11:43:44.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740ly001i30vuct9xss8s","content":"<h2><span id=\"1-controller-manager简介\">1. Controller Manager简介</span></h2>\n<p>Controller Manager作为集群内部的管理控制中心，负责集群内的Node、Pod副本、服务端点（Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额（ResourceQuota）的管理，当某个Node意外宕机时，Controller Manager会及时发现并执行自动化修复流程，确保集群始终处于预期的工作状态。</p>\n<p><img src=\"/img/article/kubernetes/kubernetes%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/controller-manager.png\" alt=\"controller manager\"></p>\n<p>每个Controller通过API Server提供的接口实时监控整个集群的每个资源对象的当前状态，当发生各种故障导致系统状态发生变化时，会尝试将系统状态修复到“期望状态”。</p>\n<h2><span id=\"2-replication-controller\">2. Replication Controller</span></h2>\n<p>为了区分，将资源对象Replication Controller简称RC,而本文中是指Controller Manager中的Replication Controller，称为副本控制器。副本控制器的作用即保证集群中一个RC所关联的Pod副本数始终保持预设值。</p>\n<ol>\n<li>只有当Pod的重启策略是Always的时候（RestartPolicy=Always），副本控制器才会管理该Pod的操作（创建、销毁、重启等）。</li>\n<li>RC中的Pod模板就像一个模具，模具制造出来的东西一旦离开模具，它们之间就再没关系了。一旦Pod被创建，无论模板如何变化，也不会影响到已经创建的Pod。</li>\n<li>Pod可以通过修改label来脱离RC的管控，该方法可以用于将Pod从集群中迁移，数据修复等调试。</li>\n<li>删除一个RC不会影响它所创建的Pod，如果要删除Pod需要将RC的副本数属性设置为0。</li>\n<li>不要越过RC创建Pod，因为RC可以实现自动化控制Pod，提高容灾能力。</li>\n</ol>\n<h3><span id=\"21-replication-controller的职责\">2.1. Replication Controller的职责</span></h3>\n<ol>\n<li>确保集群中有且仅有N个Pod实例，N是RC中定义的Pod副本数量。</li>\n<li>通过调整RC中的spec.replicas属性值来实现系统扩容或缩容。</li>\n<li>通过改变RC中的Pod模板来实现系统的滚动升级。</li>\n</ol>\n<h3><span id=\"22-replication-controller使用场景\">2.2. Replication Controller使用场景</span></h3>\n<table>\n<thead>\n<tr>\n<th>使用场景</th>\n<th>说明</th>\n<th>使用命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>重新调度</td>\n<td>当发生节点故障或Pod被意外终止运行时，可以重新调度保证集群中仍然运行指定的副本数。</td>\n<td></td>\n</tr>\n<tr>\n<td>弹性伸缩</td>\n<td>通过手动或自动扩容代理修复副本控制器的spec.replicas属性，可以实现弹性伸缩。</td>\n<td>kubectl scale</td>\n</tr>\n<tr>\n<td>滚动更新</td>\n<td>创建一个新的RC文件，通过kubectl 命令或API执行，则会新增一个新的副本同时删除旧的副本，当旧副本为0时，删除旧的RC。</td>\n<td>kubectl rolling-update</td>\n</tr>\n</tbody>\n</table>\n<p>滚动升级，具体可参考kubectl rolling-update --help,官方文档：<a href=\"https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/\" target=\"_blank\" rel=\"external\">https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/</a></p>\n<h2><span id=\"3-node-controller\">3. Node Controller</span></h2>\n<p>kubelet在启动时会通过API Server注册自身的节点信息，并定时向API Server汇报状态信息，API Server接收到信息后将信息更新到etcd中。</p>\n<p>Node Controller通过API Server实时获取Node的相关信息，实现管理和监控集群中的各个Node节点的相关控制功能。流程如下</p>\n<p><img src=\"/img/article/kubernetes/kubernetes%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/NodeController.png\" alt=\"Node Controller\"></p>\n<p>1、Controller Manager在启动时如果设置了–cluster-cidr参数，那么为每个没有设置Spec.PodCIDR的Node节点生成一个CIDR地址，并用该CIDR地址设置节点的Spec.PodCIDR属性，防止不同的节点的CIDR地址发生冲突。</p>\n<p>2、具体流程见以上流程图。</p>\n<p>3、逐个读取节点信息，如果节点状态变成非“就绪”状态，则将节点加入待删除队列，否则将节点从该队列删除。</p>\n<h2><span id=\"4-resourcequota-controller\">4. ResourceQuota Controller</span></h2>\n<p>资源配额管理确保指定的资源对象在任何时候都不会超量占用系统物理资源。</p>\n<p>支持三个层次的资源配置管理：</p>\n<p>1）容器级别：对CPU和Memory进行限制</p>\n<p>2）Pod级别：对一个Pod内所有容器的可用资源进行限制</p>\n<p>3）Namespace级别：包括</p>\n<ul>\n<li>Pod数量</li>\n<li>Replication Controller数量</li>\n<li>Service数量</li>\n<li>ResourceQuota数量</li>\n<li>Secret数量</li>\n<li>可持有的PV（Persistent Volume）数量</li>\n</ul>\n<p>说明：</p>\n<ol>\n<li>k8s配额管理是通过Admission Control（准入控制）来控制的；</li>\n<li>Admission Control提供两种配额约束方式：LimitRanger和ResourceQuota；</li>\n<li>LimitRanger作用于Pod和Container；</li>\n<li>ResourceQuota作用于Namespace上，限定一个Namespace里的各类资源的使用总额。</li>\n</ol>\n<p><strong>ResourceQuota Controller流程图</strong>：</p>\n<p><img src=\"/img/article/kubernetes/kubernetes%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/ResourceQuotaController.png\" alt=\"ResourceQuota Controller\"></p>\n<h2><span id=\"5-namespace-controller\">5. Namespace Controller</span></h2>\n<p>用户通过API Server可以创建新的Namespace并保存在etcd中，Namespace Controller定时通过API Server读取这些Namespace信息。</p>\n<p>如果Namespace被API标记为优雅删除（即设置删除期限，DeletionTimestamp）,则将该Namespace状态设置为“Terminating”,并保存到etcd中。同时Namespace Controller删除该Namespace下的ServiceAccount、RC、Pod等资源对象。</p>\n<h2><span id=\"6-endpoint-controller\">6. Endpoint Controller</span></h2>\n<p><strong>Service、Endpoint、Pod的关系：</strong></p>\n<p><img src=\"/img/article/kubernetes/kubernetes%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/EndpointController.png\" alt=\"Endpoint Controller\"></p>\n<p>Endpoints表示了一个Service对应的所有Pod副本的访问地址，而Endpoints Controller负责生成和维护所有Endpoints对象的控制器。它负责监听Service和对应的Pod副本的变化。</p>\n<ol>\n<li>如果监测到Service被删除，则删除和该Service同名的Endpoints对象；</li>\n<li>如果监测到新的Service被创建或修改，则根据该Service信息获得相关的Pod列表，然后创建或更新Service对应的Endpoints对象。</li>\n<li>如果监测到Pod的事件，则更新它对应的Service的Endpoints对象。</li>\n</ol>\n<p>kube-proxy进程获取每个Service的Endpoints，实现Service的负载均衡功能。</p>\n<h2><span id=\"7-service-controller\">7. Service Controller</span></h2>\n<p>Service Controller是属于kubernetes集群与外部的云平台之间的一个接口控制器。Service Controller监听Service变化，如果是一个LoadBalancer类型的Service，则确保外部的云平台上对该Service对应的LoadBalancer实例被相应地创建、删除及更新路由转发表。</p>\n<p>参考《Kubernetes权威指南》</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. Controller Manager简介</h2>\n<p>Controller Manager作为集群内部的管理控制中心，负责集群内的Node、Pod副本、服务端点（Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额（ResourceQuota）的管理，当某个Node意外宕机时，Controller Manager会及时发现并执行自动化修复流程，确保集群始终处于预期的工作状态。</p>\n<p><img src=\"/img/article/kubernetes/kubernetes%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/controller-manager.png\" alt=\"controller manager\"></p>\n<p>每个Controller通过API Server提供的接口实时监控整个集群的每个资源对象的当前状态，当发生各种故障导致系统状态发生变化时，会尝试将系统状态修复到“期望状态”。</p>\n<h2>2. Replication Controller</h2>\n<p>为了区分，将资源对象Replication Controller简称RC,而本文中是指Controller Manager中的Replication Controller，称为副本控制器。副本控制器的作用即保证集群中一个RC所关联的Pod副本数始终保持预设值。</p>\n<ol>\n<li>只有当Pod的重启策略是Always的时候（RestartPolicy=Always），副本控制器才会管理该Pod的操作（创建、销毁、重启等）。</li>\n<li>RC中的Pod模板就像一个模具，模具制造出来的东西一旦离开模具，它们之间就再没关系了。一旦Pod被创建，无论模板如何变化，也不会影响到已经创建的Pod。</li>\n<li>Pod可以通过修改label来脱离RC的管控，该方法可以用于将Pod从集群中迁移，数据修复等调试。</li>\n<li>删除一个RC不会影响它所创建的Pod，如果要删除Pod需要将RC的副本数属性设置为0。</li>\n<li>不要越过RC创建Pod，因为RC可以实现自动化控制Pod，提高容灾能力。</li>\n</ol>\n<h3>2.1. Replication Controller的职责</h3>\n<ol>\n<li>确保集群中有且仅有N个Pod实例，N是RC中定义的Pod副本数量。</li>\n<li>通过调整RC中的spec.replicas属性值来实现系统扩容或缩容。</li>\n<li>通过改变RC中的Pod模板来实现系统的滚动升级。</li>\n</ol>\n<h3>2.2. Replication Controller使用场景</h3>\n<table>\n<thead>\n<tr>\n<th>使用场景</th>\n<th>说明</th>\n<th>使用命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>重新调度</td>\n<td>当发生节点故障或Pod被意外终止运行时，可以重新调度保证集群中仍然运行指定的副本数。</td>\n<td></td>\n</tr>\n<tr>\n<td>弹性伸缩</td>\n<td>通过手动或自动扩容代理修复副本控制器的spec.replicas属性，可以实现弹性伸缩。</td>\n<td>kubectl scale</td>\n</tr>\n<tr>\n<td>滚动更新</td>\n<td>创建一个新的RC文件，通过kubectl 命令或API执行，则会新增一个新的副本同时删除旧的副本，当旧副本为0时，删除旧的RC。</td>\n<td>kubectl rolling-update</td>\n</tr>\n</tbody>\n</table>\n<p>滚动升级，具体可参考kubectl rolling-update --help,官方文档：<a href=\"https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/\" target=\"_blank\" rel=\"external\">https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/</a></p>\n<h2>3. Node Controller</h2>\n<p>kubelet在启动时会通过API Server注册自身的节点信息，并定时向API Server汇报状态信息，API Server接收到信息后将信息更新到etcd中。</p>\n<p>Node Controller通过API Server实时获取Node的相关信息，实现管理和监控集群中的各个Node节点的相关控制功能。流程如下</p>\n<p><img src=\"/img/article/kubernetes/kubernetes%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/NodeController.png\" alt=\"Node Controller\"></p>\n<p>1、Controller Manager在启动时如果设置了–cluster-cidr参数，那么为每个没有设置Spec.PodCIDR的Node节点生成一个CIDR地址，并用该CIDR地址设置节点的Spec.PodCIDR属性，防止不同的节点的CIDR地址发生冲突。</p>\n<p>2、具体流程见以上流程图。</p>\n<p>3、逐个读取节点信息，如果节点状态变成非“就绪”状态，则将节点加入待删除队列，否则将节点从该队列删除。</p>\n<h2>4. ResourceQuota Controller</h2>\n<p>资源配额管理确保指定的资源对象在任何时候都不会超量占用系统物理资源。</p>\n<p>支持三个层次的资源配置管理：</p>\n<p>1）容器级别：对CPU和Memory进行限制</p>\n<p>2）Pod级别：对一个Pod内所有容器的可用资源进行限制</p>\n<p>3）Namespace级别：包括</p>\n<ul>\n<li>Pod数量</li>\n<li>Replication Controller数量</li>\n<li>Service数量</li>\n<li>ResourceQuota数量</li>\n<li>Secret数量</li>\n<li>可持有的PV（Persistent Volume）数量</li>\n</ul>\n<p>说明：</p>\n<ol>\n<li>k8s配额管理是通过Admission Control（准入控制）来控制的；</li>\n<li>Admission Control提供两种配额约束方式：LimitRanger和ResourceQuota；</li>\n<li>LimitRanger作用于Pod和Container；</li>\n<li>ResourceQuota作用于Namespace上，限定一个Namespace里的各类资源的使用总额。</li>\n</ol>\n<p><strong>ResourceQuota Controller流程图</strong>：</p>\n<p><img src=\"/img/article/kubernetes/kubernetes%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/ResourceQuotaController.png\" alt=\"ResourceQuota Controller\"></p>\n<h2>5. Namespace Controller</h2>\n<p>用户通过API Server可以创建新的Namespace并保存在etcd中，Namespace Controller定时通过API Server读取这些Namespace信息。</p>\n<p>如果Namespace被API标记为优雅删除（即设置删除期限，DeletionTimestamp）,则将该Namespace状态设置为“Terminating”,并保存到etcd中。同时Namespace Controller删除该Namespace下的ServiceAccount、RC、Pod等资源对象。</p>\n<h2>6. Endpoint Controller</h2>\n<p><strong>Service、Endpoint、Pod的关系：</strong></p>\n<p><img src=\"/img/article/kubernetes/kubernetes%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/EndpointController.png\" alt=\"Endpoint Controller\"></p>\n<p>Endpoints表示了一个Service对应的所有Pod副本的访问地址，而Endpoints Controller负责生成和维护所有Endpoints对象的控制器。它负责监听Service和对应的Pod副本的变化。</p>\n<ol>\n<li>如果监测到Service被删除，则删除和该Service同名的Endpoints对象；</li>\n<li>如果监测到新的Service被创建或修改，则根据该Service信息获得相关的Pod列表，然后创建或更新Service对应的Endpoints对象。</li>\n<li>如果监测到Pod的事件，则更新它对应的Service的Endpoints对象。</li>\n</ol>\n<p>kube-proxy进程获取每个Service的Endpoints，实现Service的负载均衡功能。</p>\n<h2>7. Service Controller</h2>\n<p>Service Controller是属于kubernetes集群与外部的云平台之间的一个接口控制器。Service Controller监听Service变化，如果是一个LoadBalancer类型的Service，则确保外部的云平台上对该Service对应的LoadBalancer实例被相应地创建、删除及更新路由转发表。</p>\n<p>参考《Kubernetes权威指南》</p>\n"},{"title":"[Kubernetes] Kubernetes核心原理（四）之kubelet","catalog":true,"date":"2017-08-16T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Kubernetes"],"_content":"\n## 1. kubelet简介\n\n在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器。kubelet会在API Server上注册节点信息，定期向Master汇报节点资源使用情况，并通过cAdvisor监控容器和节点资源。可以把kubelet理解成【Server-Agent】架构中的agent，是Node上的pod管家。\n\n更多kubelet配置参数信息可参考kubelet --help\n\n## 2. 节点管理\n\n节点通过设置kubelet的启动参数“--register-node”，来决定是否向API Server注册自己，默认为true。可以通过kubelet --help或者查看kubernetes源码【cmd/kubelet/app/server.go中】来查看该参数。\n\n**kubelet的配置文件**\n\n默认配置文件在/etc/kubernetes/kubelet中，其中\n\n- --api-servers：用来配置Master节点的IP和端口。\n- --kubeconfig：用来配置kubeconfig的路径，kubeconfig文件常用来指定证书。\n- --hostname-override：用来配置该节点在集群中显示的主机名。\n- --node-status-update-frequency：配置kubelet向Master心跳上报的频率，默认为10s。\n\n## 3. Pod管理\n\nkubelet有几种方式获取自身Node上所需要运行的Pod清单。但本文只讨论通过API Server监听etcd目录，同步Pod列表的方式。\n\nkubelet通过API Server Client使用WatchAndList的方式监听etcd中/registry/nodes/${当前节点名称}和/registry/pods的目录，将获取的信息同步到本地缓存中。\n\nkubelet监听etcd，执行对Pod的操作，对容器的操作则是通过Docker Client执行，例如启动删除容器等。\n\n**kubelet创建和修改Pod流程：**\n\n1. 为该Pod创建一个数据目录。\n2. 从API Server读取该Pod清单。\n3. 为该Pod挂载外部卷（External Volume）\n4. 下载Pod用到的Secret。\n5. 检查运行的Pod，执行Pod中未完成的任务。\n6. 先创建一个Pause容器，该容器接管Pod的网络，再创建其他容器。\n7. Pod中容器的处理流程：\n   1）比较容器hash值并做相应处理。\n   2）如果容器被终止了且没有指定重启策略，则不做任何处理。\n   3）调用Docker Client下载容器镜像，调用Docker Client运行容器。\n\n## 4. 容器健康检查\n\nPod通过探针的方式来检查容器的健康状态，具体可参考[Pod详解#Pod健康检查](http://wiki.haplat.net/pages/viewpage.action?pageId=18233849#Pod详解-Pod健康检查)。\n\n## 5. cAdvisor资源监控\n\nkubelet通过cAdvisor获取本节点信息及容器的数据。cAdvisor为谷歌开源的容器资源分析工具，默认集成到kubernetes中。\n\ncAdvisor自动采集CPU,内存，文件系统，网络使用情况，容器中运行的进程，默认端口为4194。可以通过Node IP+Port访问。\n\n更多参考：[http://github.com/google/cadvisor](http://github.com/google/cadvisor)\n\n \n\n参考《Kubernetes权威指南》\n\n ","source":"_posts/Kubernetes/kubernetes核心原理/kubernetes核心原理（四）之Kubelet.md","raw":"---\ntitle: \"[Kubernetes] Kubernetes核心原理（四）之kubelet\"\ncatalog: true\ndate: 2017-08-16 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Kubernetes\ncatagories:\n- Kubernetes\n---\n\n## 1. kubelet简介\n\n在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器。kubelet会在API Server上注册节点信息，定期向Master汇报节点资源使用情况，并通过cAdvisor监控容器和节点资源。可以把kubelet理解成【Server-Agent】架构中的agent，是Node上的pod管家。\n\n更多kubelet配置参数信息可参考kubelet --help\n\n## 2. 节点管理\n\n节点通过设置kubelet的启动参数“--register-node”，来决定是否向API Server注册自己，默认为true。可以通过kubelet --help或者查看kubernetes源码【cmd/kubelet/app/server.go中】来查看该参数。\n\n**kubelet的配置文件**\n\n默认配置文件在/etc/kubernetes/kubelet中，其中\n\n- --api-servers：用来配置Master节点的IP和端口。\n- --kubeconfig：用来配置kubeconfig的路径，kubeconfig文件常用来指定证书。\n- --hostname-override：用来配置该节点在集群中显示的主机名。\n- --node-status-update-frequency：配置kubelet向Master心跳上报的频率，默认为10s。\n\n## 3. Pod管理\n\nkubelet有几种方式获取自身Node上所需要运行的Pod清单。但本文只讨论通过API Server监听etcd目录，同步Pod列表的方式。\n\nkubelet通过API Server Client使用WatchAndList的方式监听etcd中/registry/nodes/${当前节点名称}和/registry/pods的目录，将获取的信息同步到本地缓存中。\n\nkubelet监听etcd，执行对Pod的操作，对容器的操作则是通过Docker Client执行，例如启动删除容器等。\n\n**kubelet创建和修改Pod流程：**\n\n1. 为该Pod创建一个数据目录。\n2. 从API Server读取该Pod清单。\n3. 为该Pod挂载外部卷（External Volume）\n4. 下载Pod用到的Secret。\n5. 检查运行的Pod，执行Pod中未完成的任务。\n6. 先创建一个Pause容器，该容器接管Pod的网络，再创建其他容器。\n7. Pod中容器的处理流程：\n   1）比较容器hash值并做相应处理。\n   2）如果容器被终止了且没有指定重启策略，则不做任何处理。\n   3）调用Docker Client下载容器镜像，调用Docker Client运行容器。\n\n## 4. 容器健康检查\n\nPod通过探针的方式来检查容器的健康状态，具体可参考[Pod详解#Pod健康检查](http://wiki.haplat.net/pages/viewpage.action?pageId=18233849#Pod详解-Pod健康检查)。\n\n## 5. cAdvisor资源监控\n\nkubelet通过cAdvisor获取本节点信息及容器的数据。cAdvisor为谷歌开源的容器资源分析工具，默认集成到kubernetes中。\n\ncAdvisor自动采集CPU,内存，文件系统，网络使用情况，容器中运行的进程，默认端口为4194。可以通过Node IP+Port访问。\n\n更多参考：[http://github.com/google/cadvisor](http://github.com/google/cadvisor)\n\n \n\n参考《Kubernetes权威指南》\n\n ","slug":"Kubernetes/kubernetes核心原理/kubernetes核心原理（四）之Kubelet","published":1,"updated":"2017-10-02T11:47:14.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740m4001k30vug3eif8as","content":"<h2><span id=\"1-kubelet简介\">1. kubelet简介</span></h2>\n<p>在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器。kubelet会在API Server上注册节点信息，定期向Master汇报节点资源使用情况，并通过cAdvisor监控容器和节点资源。可以把kubelet理解成【Server-Agent】架构中的agent，是Node上的pod管家。</p>\n<p>更多kubelet配置参数信息可参考kubelet --help</p>\n<h2><span id=\"2-节点管理\">2. 节点管理</span></h2>\n<p>节点通过设置kubelet的启动参数“–register-node”，来决定是否向API Server注册自己，默认为true。可以通过kubelet --help或者查看kubernetes源码【cmd/kubelet/app/server.go中】来查看该参数。</p>\n<p><strong>kubelet的配置文件</strong></p>\n<p>默认配置文件在/etc/kubernetes/kubelet中，其中</p>\n<ul>\n<li>–api-servers：用来配置Master节点的IP和端口。</li>\n<li>–kubeconfig：用来配置kubeconfig的路径，kubeconfig文件常用来指定证书。</li>\n<li>–hostname-override：用来配置该节点在集群中显示的主机名。</li>\n<li>–node-status-update-frequency：配置kubelet向Master心跳上报的频率，默认为10s。</li>\n</ul>\n<h2><span id=\"3-pod管理\">3. Pod管理</span></h2>\n<p>kubelet有几种方式获取自身Node上所需要运行的Pod清单。但本文只讨论通过API Server监听etcd目录，同步Pod列表的方式。</p>\n<p>kubelet通过API Server Client使用WatchAndList的方式监听etcd中/registry/nodes/${当前节点名称}和/registry/pods的目录，将获取的信息同步到本地缓存中。</p>\n<p>kubelet监听etcd，执行对Pod的操作，对容器的操作则是通过Docker Client执行，例如启动删除容器等。</p>\n<p><strong>kubelet创建和修改Pod流程：</strong></p>\n<ol>\n<li>为该Pod创建一个数据目录。</li>\n<li>从API Server读取该Pod清单。</li>\n<li>为该Pod挂载外部卷（External Volume）</li>\n<li>下载Pod用到的Secret。</li>\n<li>检查运行的Pod，执行Pod中未完成的任务。</li>\n<li>先创建一个Pause容器，该容器接管Pod的网络，再创建其他容器。</li>\n<li>Pod中容器的处理流程：<br>\n1）比较容器hash值并做相应处理。<br>\n2）如果容器被终止了且没有指定重启策略，则不做任何处理。<br>\n3）调用Docker Client下载容器镜像，调用Docker Client运行容器。</li>\n</ol>\n<h2><span id=\"4-容器健康检查\">4. 容器健康检查</span></h2>\n<p>Pod通过探针的方式来检查容器的健康状态，具体可参考<a href=\"http://wiki.haplat.net/pages/viewpage.action?pageId=18233849#Pod%E8%AF%A6%E8%A7%A3-Pod%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5\" target=\"_blank\" rel=\"external\">Pod详解#Pod健康检查</a>。</p>\n<h2><span id=\"5-cadvisor资源监控\">5. cAdvisor资源监控</span></h2>\n<p>kubelet通过cAdvisor获取本节点信息及容器的数据。cAdvisor为谷歌开源的容器资源分析工具，默认集成到kubernetes中。</p>\n<p>cAdvisor自动采集CPU,内存，文件系统，网络使用情况，容器中运行的进程，默认端口为4194。可以通过Node IP+Port访问。</p>\n<p>更多参考：<a href=\"http://github.com/google/cadvisor\" target=\"_blank\" rel=\"external\">http://github.com/google/cadvisor</a></p>\n<p>参考《Kubernetes权威指南》</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. kubelet简介</h2>\n<p>在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器。kubelet会在API Server上注册节点信息，定期向Master汇报节点资源使用情况，并通过cAdvisor监控容器和节点资源。可以把kubelet理解成【Server-Agent】架构中的agent，是Node上的pod管家。</p>\n<p>更多kubelet配置参数信息可参考kubelet --help</p>\n<h2>2. 节点管理</h2>\n<p>节点通过设置kubelet的启动参数“–register-node”，来决定是否向API Server注册自己，默认为true。可以通过kubelet --help或者查看kubernetes源码【cmd/kubelet/app/server.go中】来查看该参数。</p>\n<p><strong>kubelet的配置文件</strong></p>\n<p>默认配置文件在/etc/kubernetes/kubelet中，其中</p>\n<ul>\n<li>–api-servers：用来配置Master节点的IP和端口。</li>\n<li>–kubeconfig：用来配置kubeconfig的路径，kubeconfig文件常用来指定证书。</li>\n<li>–hostname-override：用来配置该节点在集群中显示的主机名。</li>\n<li>–node-status-update-frequency：配置kubelet向Master心跳上报的频率，默认为10s。</li>\n</ul>\n<h2>3. Pod管理</h2>\n<p>kubelet有几种方式获取自身Node上所需要运行的Pod清单。但本文只讨论通过API Server监听etcd目录，同步Pod列表的方式。</p>\n<p>kubelet通过API Server Client使用WatchAndList的方式监听etcd中/registry/nodes/${当前节点名称}和/registry/pods的目录，将获取的信息同步到本地缓存中。</p>\n<p>kubelet监听etcd，执行对Pod的操作，对容器的操作则是通过Docker Client执行，例如启动删除容器等。</p>\n<p><strong>kubelet创建和修改Pod流程：</strong></p>\n<ol>\n<li>为该Pod创建一个数据目录。</li>\n<li>从API Server读取该Pod清单。</li>\n<li>为该Pod挂载外部卷（External Volume）</li>\n<li>下载Pod用到的Secret。</li>\n<li>检查运行的Pod，执行Pod中未完成的任务。</li>\n<li>先创建一个Pause容器，该容器接管Pod的网络，再创建其他容器。</li>\n<li>Pod中容器的处理流程：<br>\n1）比较容器hash值并做相应处理。<br>\n2）如果容器被终止了且没有指定重启策略，则不做任何处理。<br>\n3）调用Docker Client下载容器镜像，调用Docker Client运行容器。</li>\n</ol>\n<h2>4. 容器健康检查</h2>\n<p>Pod通过探针的方式来检查容器的健康状态，具体可参考<a href=\"http://wiki.haplat.net/pages/viewpage.action?pageId=18233849#Pod%E8%AF%A6%E8%A7%A3-Pod%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5\" target=\"_blank\" rel=\"external\">Pod详解#Pod健康检查</a>。</p>\n<h2>5. cAdvisor资源监控</h2>\n<p>kubelet通过cAdvisor获取本节点信息及容器的数据。cAdvisor为谷歌开源的容器资源分析工具，默认集成到kubernetes中。</p>\n<p>cAdvisor自动采集CPU,内存，文件系统，网络使用情况，容器中运行的进程，默认端口为4194。可以通过Node IP+Port访问。</p>\n<p>更多参考：<a href=\"http://github.com/google/cadvisor\" target=\"_blank\" rel=\"external\">http://github.com/google/cadvisor</a></p>\n<p>参考《Kubernetes权威指南》</p>\n"},{"title":"[Kubernetes] cAdvisor介绍","catalog":true,"date":"2017-08-13T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Kubernetes"],"_content":"\n## 1. cAdvisor简介\n\n​\tcAdvisor对Node机器上的资源及容器进行实时监控和性能数据采集，包括CPU使用情况、内存使用情况、网络吞吐量及文件系统使用情况，cAdvisor集成在Kubelet中，当kubelet启动时会自动启动cAdvisor，即一个cAdvisor仅对一台Node机器进行监控。kubelet的启动参数--cadvisor-port可以定义cAdvisor对外提供服务的端口，默认为4194。可以通过浏览器<Node_IP:port>访问。项目主页：[http://github.com/google/cadvisor。]()\n\n## 2. cAdvisor结构图\n\n![cAdvisor](/img/article/kubernetes/监控/cAdvisor.png)\n\n## 3. Metrics\n\n| 分类         | 字段                 | 描述                                       |\n| ---------- | ------------------ | ---------------------------------------- |\n| cpu        | cpu_usage_total    |                                          |\n|            | cpu_usage_system   |                                          |\n|            | cpu_usage_user     |                                          |\n|            | cpu_usage_per_cpu  |                                          |\n|            | load_average       | Smoothed average of number of runnable threads x 1000 |\n| memory     | memory_usage       | Memory Usage                             |\n|            | memory_working_set | Working set size                         |\n| network    | rx_bytes           | Cumulative count of bytes received       |\n|            | rx_errors          | Cumulative count of receive errors encountered |\n|            | tx_bytes           | Cumulative count of bytes transmitted    |\n|            | tx_errors          | Cumulative count of transmit errors encountered |\n| filesystem | fs_device          | Filesystem device                        |\n|            | fs_limit           | Filesystem limit                         |\n|            | fs_usage           | Filesystem usage                         |\n\n## 4. cAdvisor源码\n\n### 4.1. cAdvisor入口函数\n\n**cadvisor.go**\n\n```go\nfunc main() {\n    defer glog.Flush()\n    flag.Parse()\n    if *versionFlag {\n        fmt.Printf(\"cAdvisor version %s (%s)/n\", version.Info[\"version\"], version.Info[\"revision\"])\n        os.Exit(0)\n    }\n    setMaxProcs()\n    memoryStorage, err := NewMemoryStorage()\n    if err != nil {\n        glog.Fatalf(\"Failed to initialize storage driver: %s\", err)\n    }\n    sysFs, err := sysfs.NewRealSysFs()\n    if err != nil {\n        glog.Fatalf(\"Failed to create a system interface: %s\", err)\n    }\n    collectorHttpClient := createCollectorHttpClient(*collectorCert, *collectorKey)\n    containerManager, err := manager.New(memoryStorage, sysFs, *maxHousekeepingInterval, *allowDynamicHousekeeping, ignoreMetrics.MetricSet, &collectorHttpClient)\n    if err != nil {\n        glog.Fatalf(\"Failed to create a Container Manager: %s\", err)\n    }\n    mux := http.NewServeMux()\n    if *enableProfiling {\n        mux.HandleFunc(\"/debug/pprof/\", pprof.Index)\n        mux.HandleFunc(\"/debug/pprof/cmdline\", pprof.Cmdline)\n        mux.HandleFunc(\"/debug/pprof/profile\", pprof.Profile)\n        mux.HandleFunc(\"/debug/pprof/symbol\", pprof.Symbol)\n    }\n    // Register all HTTP handlers.\n    err = cadvisorhttp.RegisterHandlers(mux, containerManager, *httpAuthFile, *httpAuthRealm, *httpDigestFile, *httpDigestRealm)\n    if err != nil {\n        glog.Fatalf(\"Failed to register HTTP handlers: %v\", err)\n    }\n    cadvisorhttp.RegisterPrometheusHandler(mux, containerManager, *prometheusEndpoint, nil)\n    // Start the manager.\n    if err := containerManager.Start(); err != nil {\n        glog.Fatalf(\"Failed to start container manager: %v\", err)\n    }\n    // Install signal handler.\n    installSignalHandler(containerManager)\n    glog.Infof(\"Starting cAdvisor version: %s-%s on port %d\", version.Info[\"version\"], version.Info[\"revision\"], *argPort)\n    addr := fmt.Sprintf(\"%s:%d\", *argIp, *argPort)\n    glog.Fatal(http.ListenAndServe(addr, mux))\n}\n```\n\n核心代码：\n\n```go\nmemoryStorage, err := NewMemoryStorage()\nsysFs, err := sysfs.NewRealSysFs()\n#创建containerManager\ncontainerManager, err := manager.New(memoryStorage, sysFs, *maxHousekeepingInterval, *allowDynamicHousekeeping, ignoreMetrics.MetricSet, &collectorHttpClient)\n#启动containerManager\nerr := containerManager.Start()\n```\n\n### 4.2. cAdvisor Client的使用\n\n```go\nimport \"github.com/google/cadvisor/client\"\nfunc main(){\n    client, err := client.NewClient(\"http://192.168.19.30:4194/\")   //http://<host-ip>:<port>/\n}\n```\n\n#### 4.2.1 client定义\n\n**cadvisor/client/client.go**\n\n```go\n// Client represents the base URL for a cAdvisor client.\ntype Client struct {\n    baseUrl string\n}\n// NewClient returns a new v1.3 client with the specified base URL.\nfunc NewClient(url string) (*Client, error) {\n    if !strings.HasSuffix(url, \"/\") {\n        url += \"/\"\n    }\n    return &Client{\n        baseUrl: fmt.Sprintf(\"%sapi/v1.3/\", url),\n    }, nil\n}\n```\n\n#### 4.2.2. client方法\n\n**1）MachineInfo**\n\n```go\n// MachineInfo returns the JSON machine information for this client.\n// A non-nil error result indicates a problem with obtaining\n// the JSON machine information data.\nfunc (self *Client) MachineInfo() (minfo *v1.MachineInfo, err error) {\n       u := self.machineInfoUrl()\n       ret := new(v1.MachineInfo)\n       if err = self.httpGetJsonData(ret, nil, u, \"machine info\"); err != nil {\n              return\n       }\n       minfo = ret\n       return\n}\n```\n\n**2）ContainerInfo**\n\n```go\n// ContainerInfo returns the JSON container information for the specified\n// container and request.\nfunc (self *Client) ContainerInfo(name string, query *v1.ContainerInfoRequest) (cinfo *v1.ContainerInfo, err error) {\n       u := self.containerInfoUrl(name)\n       ret := new(v1.ContainerInfo)\n       if err = self.httpGetJsonData(ret, query, u, fmt.Sprintf(\"container info for %q\", name)); err != nil {\n              return\n       }\n       cinfo = ret\n       return\n}\n```\n\n**3）DockerContainer**\n\n```go\n// Returns the JSON container information for the specified\n// Docker container and request.\nfunc (self *Client) DockerContainer(name string, query *v1.ContainerInfoRequest) (cinfo v1.ContainerInfo, err error) {\n       u := self.dockerInfoUrl(name)\n       ret := make(map[string]v1.ContainerInfo)\n       if err = self.httpGetJsonData(&ret, query, u, fmt.Sprintf(\"Docker container info for %q\", name)); err != nil {\n              return\n       }\n       if len(ret) != 1 {\n              err = fmt.Errorf(\"expected to only receive 1 Docker container: %+v\", ret)\n              return\n       }\n       for _, cont := range ret {\n              cinfo = cont\n       }\n       return\n}\n```\n\n**4）AllDockerContainers**\n\n```go\n// Returns the JSON container information for all Docker containers.\nfunc (self *Client) AllDockerContainers(query *v1.ContainerInfoRequest) (cinfo []v1.ContainerInfo, err error) {\n       u := self.dockerInfoUrl(\"/\")\n       ret := make(map[string]v1.ContainerInfo)\n       if err = self.httpGetJsonData(&ret, query, u, \"all Docker containers info\"); err != nil {\n              return\n       }\n       cinfo = make([]v1.ContainerInfo, 0, len(ret))\n       for _, cont := range ret {\n              cinfo = append(cinfo, cont)\n       }\n       return\n}\n```","source":"_posts/Kubernetes/监控/cadvisor.md","raw":"---\ntitle: \"[Kubernetes] cAdvisor介绍\"\ncatalog: true\ndate: 2017-08-13 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Kubernetes\ncatagories:\n- Kubernetes\n---\n\n## 1. cAdvisor简介\n\n​\tcAdvisor对Node机器上的资源及容器进行实时监控和性能数据采集，包括CPU使用情况、内存使用情况、网络吞吐量及文件系统使用情况，cAdvisor集成在Kubelet中，当kubelet启动时会自动启动cAdvisor，即一个cAdvisor仅对一台Node机器进行监控。kubelet的启动参数--cadvisor-port可以定义cAdvisor对外提供服务的端口，默认为4194。可以通过浏览器<Node_IP:port>访问。项目主页：[http://github.com/google/cadvisor。]()\n\n## 2. cAdvisor结构图\n\n![cAdvisor](/img/article/kubernetes/监控/cAdvisor.png)\n\n## 3. Metrics\n\n| 分类         | 字段                 | 描述                                       |\n| ---------- | ------------------ | ---------------------------------------- |\n| cpu        | cpu_usage_total    |                                          |\n|            | cpu_usage_system   |                                          |\n|            | cpu_usage_user     |                                          |\n|            | cpu_usage_per_cpu  |                                          |\n|            | load_average       | Smoothed average of number of runnable threads x 1000 |\n| memory     | memory_usage       | Memory Usage                             |\n|            | memory_working_set | Working set size                         |\n| network    | rx_bytes           | Cumulative count of bytes received       |\n|            | rx_errors          | Cumulative count of receive errors encountered |\n|            | tx_bytes           | Cumulative count of bytes transmitted    |\n|            | tx_errors          | Cumulative count of transmit errors encountered |\n| filesystem | fs_device          | Filesystem device                        |\n|            | fs_limit           | Filesystem limit                         |\n|            | fs_usage           | Filesystem usage                         |\n\n## 4. cAdvisor源码\n\n### 4.1. cAdvisor入口函数\n\n**cadvisor.go**\n\n```go\nfunc main() {\n    defer glog.Flush()\n    flag.Parse()\n    if *versionFlag {\n        fmt.Printf(\"cAdvisor version %s (%s)/n\", version.Info[\"version\"], version.Info[\"revision\"])\n        os.Exit(0)\n    }\n    setMaxProcs()\n    memoryStorage, err := NewMemoryStorage()\n    if err != nil {\n        glog.Fatalf(\"Failed to initialize storage driver: %s\", err)\n    }\n    sysFs, err := sysfs.NewRealSysFs()\n    if err != nil {\n        glog.Fatalf(\"Failed to create a system interface: %s\", err)\n    }\n    collectorHttpClient := createCollectorHttpClient(*collectorCert, *collectorKey)\n    containerManager, err := manager.New(memoryStorage, sysFs, *maxHousekeepingInterval, *allowDynamicHousekeeping, ignoreMetrics.MetricSet, &collectorHttpClient)\n    if err != nil {\n        glog.Fatalf(\"Failed to create a Container Manager: %s\", err)\n    }\n    mux := http.NewServeMux()\n    if *enableProfiling {\n        mux.HandleFunc(\"/debug/pprof/\", pprof.Index)\n        mux.HandleFunc(\"/debug/pprof/cmdline\", pprof.Cmdline)\n        mux.HandleFunc(\"/debug/pprof/profile\", pprof.Profile)\n        mux.HandleFunc(\"/debug/pprof/symbol\", pprof.Symbol)\n    }\n    // Register all HTTP handlers.\n    err = cadvisorhttp.RegisterHandlers(mux, containerManager, *httpAuthFile, *httpAuthRealm, *httpDigestFile, *httpDigestRealm)\n    if err != nil {\n        glog.Fatalf(\"Failed to register HTTP handlers: %v\", err)\n    }\n    cadvisorhttp.RegisterPrometheusHandler(mux, containerManager, *prometheusEndpoint, nil)\n    // Start the manager.\n    if err := containerManager.Start(); err != nil {\n        glog.Fatalf(\"Failed to start container manager: %v\", err)\n    }\n    // Install signal handler.\n    installSignalHandler(containerManager)\n    glog.Infof(\"Starting cAdvisor version: %s-%s on port %d\", version.Info[\"version\"], version.Info[\"revision\"], *argPort)\n    addr := fmt.Sprintf(\"%s:%d\", *argIp, *argPort)\n    glog.Fatal(http.ListenAndServe(addr, mux))\n}\n```\n\n核心代码：\n\n```go\nmemoryStorage, err := NewMemoryStorage()\nsysFs, err := sysfs.NewRealSysFs()\n#创建containerManager\ncontainerManager, err := manager.New(memoryStorage, sysFs, *maxHousekeepingInterval, *allowDynamicHousekeeping, ignoreMetrics.MetricSet, &collectorHttpClient)\n#启动containerManager\nerr := containerManager.Start()\n```\n\n### 4.2. cAdvisor Client的使用\n\n```go\nimport \"github.com/google/cadvisor/client\"\nfunc main(){\n    client, err := client.NewClient(\"http://192.168.19.30:4194/\")   //http://<host-ip>:<port>/\n}\n```\n\n#### 4.2.1 client定义\n\n**cadvisor/client/client.go**\n\n```go\n// Client represents the base URL for a cAdvisor client.\ntype Client struct {\n    baseUrl string\n}\n// NewClient returns a new v1.3 client with the specified base URL.\nfunc NewClient(url string) (*Client, error) {\n    if !strings.HasSuffix(url, \"/\") {\n        url += \"/\"\n    }\n    return &Client{\n        baseUrl: fmt.Sprintf(\"%sapi/v1.3/\", url),\n    }, nil\n}\n```\n\n#### 4.2.2. client方法\n\n**1）MachineInfo**\n\n```go\n// MachineInfo returns the JSON machine information for this client.\n// A non-nil error result indicates a problem with obtaining\n// the JSON machine information data.\nfunc (self *Client) MachineInfo() (minfo *v1.MachineInfo, err error) {\n       u := self.machineInfoUrl()\n       ret := new(v1.MachineInfo)\n       if err = self.httpGetJsonData(ret, nil, u, \"machine info\"); err != nil {\n              return\n       }\n       minfo = ret\n       return\n}\n```\n\n**2）ContainerInfo**\n\n```go\n// ContainerInfo returns the JSON container information for the specified\n// container and request.\nfunc (self *Client) ContainerInfo(name string, query *v1.ContainerInfoRequest) (cinfo *v1.ContainerInfo, err error) {\n       u := self.containerInfoUrl(name)\n       ret := new(v1.ContainerInfo)\n       if err = self.httpGetJsonData(ret, query, u, fmt.Sprintf(\"container info for %q\", name)); err != nil {\n              return\n       }\n       cinfo = ret\n       return\n}\n```\n\n**3）DockerContainer**\n\n```go\n// Returns the JSON container information for the specified\n// Docker container and request.\nfunc (self *Client) DockerContainer(name string, query *v1.ContainerInfoRequest) (cinfo v1.ContainerInfo, err error) {\n       u := self.dockerInfoUrl(name)\n       ret := make(map[string]v1.ContainerInfo)\n       if err = self.httpGetJsonData(&ret, query, u, fmt.Sprintf(\"Docker container info for %q\", name)); err != nil {\n              return\n       }\n       if len(ret) != 1 {\n              err = fmt.Errorf(\"expected to only receive 1 Docker container: %+v\", ret)\n              return\n       }\n       for _, cont := range ret {\n              cinfo = cont\n       }\n       return\n}\n```\n\n**4）AllDockerContainers**\n\n```go\n// Returns the JSON container information for all Docker containers.\nfunc (self *Client) AllDockerContainers(query *v1.ContainerInfoRequest) (cinfo []v1.ContainerInfo, err error) {\n       u := self.dockerInfoUrl(\"/\")\n       ret := make(map[string]v1.ContainerInfo)\n       if err = self.httpGetJsonData(&ret, query, u, \"all Docker containers info\"); err != nil {\n              return\n       }\n       cinfo = make([]v1.ContainerInfo, 0, len(ret))\n       for _, cont := range ret {\n              cinfo = append(cinfo, cont)\n       }\n       return\n}\n```","slug":"Kubernetes/监控/cadvisor","published":1,"updated":"2017-10-02T11:52:04.286Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740m6001m30vukb6fuaat","content":"<h2><span id=\"1-cadvisor简介\">1. cAdvisor简介</span></h2>\n<p>​\tcAdvisor对Node机器上的资源及容器进行实时监控和性能数据采集，包括CPU使用情况、内存使用情况、网络吞吐量及文件系统使用情况，cAdvisor集成在Kubelet中，当kubelet启动时会自动启动cAdvisor，即一个cAdvisor仅对一台Node机器进行监控。kubelet的启动参数–cadvisor-port可以定义cAdvisor对外提供服务的端口，默认为4194。可以通过浏览器&lt;Node_IP:port&gt;访问。项目主页：<a href=\"\">http://github.com/google/cadvisor。</a></p>\n<h2><span id=\"2-cadvisor结构图\">2. cAdvisor结构图</span></h2>\n<p><img src=\"/img/article/kubernetes/%E7%9B%91%E6%8E%A7/cAdvisor.png\" alt=\"cAdvisor\"></p>\n<h2><span id=\"3-metrics\">3. Metrics</span></h2>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>字段</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cpu</td>\n<td>cpu_usage_total</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>cpu_usage_system</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>cpu_usage_user</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>cpu_usage_per_cpu</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>load_average</td>\n<td>Smoothed average of number of runnable threads x 1000</td>\n</tr>\n<tr>\n<td>memory</td>\n<td>memory_usage</td>\n<td>Memory Usage</td>\n</tr>\n<tr>\n<td></td>\n<td>memory_working_set</td>\n<td>Working set size</td>\n</tr>\n<tr>\n<td>network</td>\n<td>rx_bytes</td>\n<td>Cumulative count of bytes received</td>\n</tr>\n<tr>\n<td></td>\n<td>rx_errors</td>\n<td>Cumulative count of receive errors encountered</td>\n</tr>\n<tr>\n<td></td>\n<td>tx_bytes</td>\n<td>Cumulative count of bytes transmitted</td>\n</tr>\n<tr>\n<td></td>\n<td>tx_errors</td>\n<td>Cumulative count of transmit errors encountered</td>\n</tr>\n<tr>\n<td>filesystem</td>\n<td>fs_device</td>\n<td>Filesystem device</td>\n</tr>\n<tr>\n<td></td>\n<td>fs_limit</td>\n<td>Filesystem limit</td>\n</tr>\n<tr>\n<td></td>\n<td>fs_usage</td>\n<td>Filesystem usage</td>\n</tr>\n</tbody>\n</table>\n<h2><span id=\"4-cadvisor源码\">4. cAdvisor源码</span></h2>\n<h3><span id=\"41-cadvisor入口函数\">4.1. cAdvisor入口函数</span></h3>\n<p><strong>cadvisor.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">defer</span> glog.Flush()</div><div class=\"line\">    flag.Parse()</div><div class=\"line\">    <span class=\"keyword\">if</span> *versionFlag &#123;</div><div class=\"line\">        fmt.Printf(<span class=\"string\">\"cAdvisor version %s (%s)/n\"</span>, version.Info[<span class=\"string\">\"version\"</span>], version.Info[<span class=\"string\">\"revision\"</span>])</div><div class=\"line\">        os.Exit(<span class=\"number\">0</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    setMaxProcs()</div><div class=\"line\">    memoryStorage, err := NewMemoryStorage()</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        glog.Fatalf(<span class=\"string\">\"Failed to initialize storage driver: %s\"</span>, err)</div><div class=\"line\">    &#125;</div><div class=\"line\">    sysFs, err := sysfs.NewRealSysFs()</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        glog.Fatalf(<span class=\"string\">\"Failed to create a system interface: %s\"</span>, err)</div><div class=\"line\">    &#125;</div><div class=\"line\">    collectorHttpClient := createCollectorHttpClient(*collectorCert, *collectorKey)</div><div class=\"line\">    containerManager, err := manager.New(memoryStorage, sysFs, *maxHousekeepingInterval, *allowDynamicHousekeeping, ignoreMetrics.MetricSet, &amp;collectorHttpClient)</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        glog.Fatalf(<span class=\"string\">\"Failed to create a Container Manager: %s\"</span>, err)</div><div class=\"line\">    &#125;</div><div class=\"line\">    mux := http.NewServeMux()</div><div class=\"line\">    <span class=\"keyword\">if</span> *enableProfiling &#123;</div><div class=\"line\">        mux.HandleFunc(<span class=\"string\">\"/debug/pprof/\"</span>, pprof.Index)</div><div class=\"line\">        mux.HandleFunc(<span class=\"string\">\"/debug/pprof/cmdline\"</span>, pprof.Cmdline)</div><div class=\"line\">        mux.HandleFunc(<span class=\"string\">\"/debug/pprof/profile\"</span>, pprof.Profile)</div><div class=\"line\">        mux.HandleFunc(<span class=\"string\">\"/debug/pprof/symbol\"</span>, pprof.Symbol)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Register all HTTP handlers.</span></div><div class=\"line\">    err = cadvisorhttp.RegisterHandlers(mux, containerManager, *httpAuthFile, *httpAuthRealm, *httpDigestFile, *httpDigestRealm)</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        glog.Fatalf(<span class=\"string\">\"Failed to register HTTP handlers: %v\"</span>, err)</div><div class=\"line\">    &#125;</div><div class=\"line\">    cadvisorhttp.RegisterPrometheusHandler(mux, containerManager, *prometheusEndpoint, <span class=\"literal\">nil</span>)</div><div class=\"line\">    <span class=\"comment\">// Start the manager.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> err := containerManager.Start(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        glog.Fatalf(<span class=\"string\">\"Failed to start container manager: %v\"</span>, err)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Install signal handler.</span></div><div class=\"line\">    installSignalHandler(containerManager)</div><div class=\"line\">    glog.Infof(<span class=\"string\">\"Starting cAdvisor version: %s-%s on port %d\"</span>, version.Info[<span class=\"string\">\"version\"</span>], version.Info[<span class=\"string\">\"revision\"</span>], *argPort)</div><div class=\"line\">    addr := fmt.Sprintf(<span class=\"string\">\"%s:%d\"</span>, *argIp, *argPort)</div><div class=\"line\">    glog.Fatal(http.ListenAndServe(addr, mux))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>核心代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">memoryStorage, err := NewMemoryStorage()</div><div class=\"line\">sysFs, err := sysfs.NewRealSysFs()</div><div class=\"line\">#创建containerManager</div><div class=\"line\">containerManager, err := manager.New(memoryStorage, sysFs, *maxHousekeepingInterval, *allowDynamicHousekeeping, ignoreMetrics.MetricSet, &amp;collectorHttpClient)</div><div class=\"line\">#启动containerManager</div><div class=\"line\">err := containerManager.Start()</div></pre></td></tr></table></figure>\n<h3><span id=\"42-cadvisor-client的使用\">4.2. cAdvisor Client的使用</span></h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"github.com/google/cadvisor/client\"</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    client, err := client.NewClient(<span class=\"string\">\"http://192.168.19.30:4194/\"</span>)   <span class=\"comment\">//http://&lt;host-ip&gt;:&lt;port&gt;/</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4><span id=\"421-client定义\">4.2.1 client定义</span></h4>\n<p><strong>cadvisor/client/client.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Client represents the base URL for a cAdvisor client.</span></div><div class=\"line\"><span class=\"keyword\">type</span> Client <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    baseUrl <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// NewClient returns a new v1.3 client with the specified base URL.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewClient</span><span class=\"params\">(url <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Client, error)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> !strings.HasSuffix(url, <span class=\"string\">\"/\"</span>) &#123;</div><div class=\"line\">        url += <span class=\"string\">\"/\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> &amp;Client&#123;</div><div class=\"line\">        baseUrl: fmt.Sprintf(<span class=\"string\">\"%sapi/v1.3/\"</span>, url),</div><div class=\"line\">    &#125;, <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4><span id=\"422-client方法\">4.2.2. client方法</span></h4>\n<p><strong>1）MachineInfo</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MachineInfo returns the JSON machine information for this client.</span></div><div class=\"line\"><span class=\"comment\">// A non-nil error result indicates a problem with obtaining</span></div><div class=\"line\"><span class=\"comment\">// the JSON machine information data.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Client)</span> <span class=\"title\">MachineInfo</span><span class=\"params\">()</span> <span class=\"params\">(minfo *v1.MachineInfo, err error)</span></span> &#123;</div><div class=\"line\">       u := self.machineInfoUrl()</div><div class=\"line\">       ret := <span class=\"built_in\">new</span>(v1.MachineInfo)</div><div class=\"line\">       <span class=\"keyword\">if</span> err = self.httpGetJsonData(ret, <span class=\"literal\">nil</span>, u, <span class=\"string\">\"machine info\"</span>); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">              <span class=\"keyword\">return</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       minfo = ret</div><div class=\"line\">       <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>2）ContainerInfo</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ContainerInfo returns the JSON container information for the specified</span></div><div class=\"line\"><span class=\"comment\">// container and request.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Client)</span> <span class=\"title\">ContainerInfo</span><span class=\"params\">(name <span class=\"keyword\">string</span>, query *v1.ContainerInfoRequest)</span> <span class=\"params\">(cinfo *v1.ContainerInfo, err error)</span></span> &#123;</div><div class=\"line\">       u := self.containerInfoUrl(name)</div><div class=\"line\">       ret := <span class=\"built_in\">new</span>(v1.ContainerInfo)</div><div class=\"line\">       <span class=\"keyword\">if</span> err = self.httpGetJsonData(ret, query, u, fmt.Sprintf(<span class=\"string\">\"container info for %q\"</span>, name)); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">              <span class=\"keyword\">return</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       cinfo = ret</div><div class=\"line\">       <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>3）DockerContainer</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Returns the JSON container information for the specified</span></div><div class=\"line\"><span class=\"comment\">// Docker container and request.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Client)</span> <span class=\"title\">DockerContainer</span><span class=\"params\">(name <span class=\"keyword\">string</span>, query *v1.ContainerInfoRequest)</span> <span class=\"params\">(cinfo v1.ContainerInfo, err error)</span></span> &#123;</div><div class=\"line\">       u := self.dockerInfoUrl(name)</div><div class=\"line\">       ret := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]v1.ContainerInfo)</div><div class=\"line\">       <span class=\"keyword\">if</span> err = self.httpGetJsonData(&amp;ret, query, u, fmt.Sprintf(<span class=\"string\">\"Docker container info for %q\"</span>, name)); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">              <span class=\"keyword\">return</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(ret) != <span class=\"number\">1</span> &#123;</div><div class=\"line\">              err = fmt.Errorf(<span class=\"string\">\"expected to only receive 1 Docker container: %+v\"</span>, ret)</div><div class=\"line\">              <span class=\"keyword\">return</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">for</span> _, cont := <span class=\"keyword\">range</span> ret &#123;</div><div class=\"line\">              cinfo = cont</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>4）AllDockerContainers</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Returns the JSON container information for all Docker containers.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Client)</span> <span class=\"title\">AllDockerContainers</span><span class=\"params\">(query *v1.ContainerInfoRequest)</span> <span class=\"params\">(cinfo []v1.ContainerInfo, err error)</span></span> &#123;</div><div class=\"line\">       u := self.dockerInfoUrl(<span class=\"string\">\"/\"</span>)</div><div class=\"line\">       ret := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]v1.ContainerInfo)</div><div class=\"line\">       <span class=\"keyword\">if</span> err = self.httpGetJsonData(&amp;ret, query, u, <span class=\"string\">\"all Docker containers info\"</span>); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">              <span class=\"keyword\">return</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       cinfo = <span class=\"built_in\">make</span>([]v1.ContainerInfo, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(ret))</div><div class=\"line\">       <span class=\"keyword\">for</span> _, cont := <span class=\"keyword\">range</span> ret &#123;</div><div class=\"line\">              cinfo = <span class=\"built_in\">append</span>(cinfo, cont)</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2>1. cAdvisor简介</h2>\n<p>​\tcAdvisor对Node机器上的资源及容器进行实时监控和性能数据采集，包括CPU使用情况、内存使用情况、网络吞吐量及文件系统使用情况，cAdvisor集成在Kubelet中，当kubelet启动时会自动启动cAdvisor，即一个cAdvisor仅对一台Node机器进行监控。kubelet的启动参数–cadvisor-port可以定义cAdvisor对外提供服务的端口，默认为4194。可以通过浏览器&lt;Node_IP:port&gt;访问。项目主页：<a href=\"\">http://github.com/google/cadvisor。</a></p>\n<h2>2. cAdvisor结构图</h2>\n<p><img src=\"/img/article/kubernetes/%E7%9B%91%E6%8E%A7/cAdvisor.png\" alt=\"cAdvisor\"></p>\n<h2>3. Metrics</h2>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>字段</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cpu</td>\n<td>cpu_usage_total</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>cpu_usage_system</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>cpu_usage_user</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>cpu_usage_per_cpu</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>load_average</td>\n<td>Smoothed average of number of runnable threads x 1000</td>\n</tr>\n<tr>\n<td>memory</td>\n<td>memory_usage</td>\n<td>Memory Usage</td>\n</tr>\n<tr>\n<td></td>\n<td>memory_working_set</td>\n<td>Working set size</td>\n</tr>\n<tr>\n<td>network</td>\n<td>rx_bytes</td>\n<td>Cumulative count of bytes received</td>\n</tr>\n<tr>\n<td></td>\n<td>rx_errors</td>\n<td>Cumulative count of receive errors encountered</td>\n</tr>\n<tr>\n<td></td>\n<td>tx_bytes</td>\n<td>Cumulative count of bytes transmitted</td>\n</tr>\n<tr>\n<td></td>\n<td>tx_errors</td>\n<td>Cumulative count of transmit errors encountered</td>\n</tr>\n<tr>\n<td>filesystem</td>\n<td>fs_device</td>\n<td>Filesystem device</td>\n</tr>\n<tr>\n<td></td>\n<td>fs_limit</td>\n<td>Filesystem limit</td>\n</tr>\n<tr>\n<td></td>\n<td>fs_usage</td>\n<td>Filesystem usage</td>\n</tr>\n</tbody>\n</table>\n<h2>4. cAdvisor源码</h2>\n<h3>4.1. cAdvisor入口函数</h3>\n<p><strong>cadvisor.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">defer</span> glog.Flush()</div><div class=\"line\">    flag.Parse()</div><div class=\"line\">    <span class=\"keyword\">if</span> *versionFlag &#123;</div><div class=\"line\">        fmt.Printf(<span class=\"string\">\"cAdvisor version %s (%s)/n\"</span>, version.Info[<span class=\"string\">\"version\"</span>], version.Info[<span class=\"string\">\"revision\"</span>])</div><div class=\"line\">        os.Exit(<span class=\"number\">0</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    setMaxProcs()</div><div class=\"line\">    memoryStorage, err := NewMemoryStorage()</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        glog.Fatalf(<span class=\"string\">\"Failed to initialize storage driver: %s\"</span>, err)</div><div class=\"line\">    &#125;</div><div class=\"line\">    sysFs, err := sysfs.NewRealSysFs()</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        glog.Fatalf(<span class=\"string\">\"Failed to create a system interface: %s\"</span>, err)</div><div class=\"line\">    &#125;</div><div class=\"line\">    collectorHttpClient := createCollectorHttpClient(*collectorCert, *collectorKey)</div><div class=\"line\">    containerManager, err := manager.New(memoryStorage, sysFs, *maxHousekeepingInterval, *allowDynamicHousekeeping, ignoreMetrics.MetricSet, &amp;collectorHttpClient)</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        glog.Fatalf(<span class=\"string\">\"Failed to create a Container Manager: %s\"</span>, err)</div><div class=\"line\">    &#125;</div><div class=\"line\">    mux := http.NewServeMux()</div><div class=\"line\">    <span class=\"keyword\">if</span> *enableProfiling &#123;</div><div class=\"line\">        mux.HandleFunc(<span class=\"string\">\"/debug/pprof/\"</span>, pprof.Index)</div><div class=\"line\">        mux.HandleFunc(<span class=\"string\">\"/debug/pprof/cmdline\"</span>, pprof.Cmdline)</div><div class=\"line\">        mux.HandleFunc(<span class=\"string\">\"/debug/pprof/profile\"</span>, pprof.Profile)</div><div class=\"line\">        mux.HandleFunc(<span class=\"string\">\"/debug/pprof/symbol\"</span>, pprof.Symbol)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Register all HTTP handlers.</span></div><div class=\"line\">    err = cadvisorhttp.RegisterHandlers(mux, containerManager, *httpAuthFile, *httpAuthRealm, *httpDigestFile, *httpDigestRealm)</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        glog.Fatalf(<span class=\"string\">\"Failed to register HTTP handlers: %v\"</span>, err)</div><div class=\"line\">    &#125;</div><div class=\"line\">    cadvisorhttp.RegisterPrometheusHandler(mux, containerManager, *prometheusEndpoint, <span class=\"literal\">nil</span>)</div><div class=\"line\">    <span class=\"comment\">// Start the manager.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> err := containerManager.Start(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        glog.Fatalf(<span class=\"string\">\"Failed to start container manager: %v\"</span>, err)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Install signal handler.</span></div><div class=\"line\">    installSignalHandler(containerManager)</div><div class=\"line\">    glog.Infof(<span class=\"string\">\"Starting cAdvisor version: %s-%s on port %d\"</span>, version.Info[<span class=\"string\">\"version\"</span>], version.Info[<span class=\"string\">\"revision\"</span>], *argPort)</div><div class=\"line\">    addr := fmt.Sprintf(<span class=\"string\">\"%s:%d\"</span>, *argIp, *argPort)</div><div class=\"line\">    glog.Fatal(http.ListenAndServe(addr, mux))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>核心代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">memoryStorage, err := NewMemoryStorage()</div><div class=\"line\">sysFs, err := sysfs.NewRealSysFs()</div><div class=\"line\">#创建containerManager</div><div class=\"line\">containerManager, err := manager.New(memoryStorage, sysFs, *maxHousekeepingInterval, *allowDynamicHousekeeping, ignoreMetrics.MetricSet, &amp;collectorHttpClient)</div><div class=\"line\">#启动containerManager</div><div class=\"line\">err := containerManager.Start()</div></pre></td></tr></table></figure>\n<h3>4.2. cAdvisor Client的使用</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"github.com/google/cadvisor/client\"</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    client, err := client.NewClient(<span class=\"string\">\"http://192.168.19.30:4194/\"</span>)   <span class=\"comment\">//http://&lt;host-ip&gt;:&lt;port&gt;/</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4>4.2.1 client定义</h4>\n<p><strong>cadvisor/client/client.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Client represents the base URL for a cAdvisor client.</span></div><div class=\"line\"><span class=\"keyword\">type</span> Client <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    baseUrl <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// NewClient returns a new v1.3 client with the specified base URL.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewClient</span><span class=\"params\">(url <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Client, error)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> !strings.HasSuffix(url, <span class=\"string\">\"/\"</span>) &#123;</div><div class=\"line\">        url += <span class=\"string\">\"/\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> &amp;Client&#123;</div><div class=\"line\">        baseUrl: fmt.Sprintf(<span class=\"string\">\"%sapi/v1.3/\"</span>, url),</div><div class=\"line\">    &#125;, <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4>4.2.2. client方法</h4>\n<p><strong>1）MachineInfo</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MachineInfo returns the JSON machine information for this client.</span></div><div class=\"line\"><span class=\"comment\">// A non-nil error result indicates a problem with obtaining</span></div><div class=\"line\"><span class=\"comment\">// the JSON machine information data.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Client)</span> <span class=\"title\">MachineInfo</span><span class=\"params\">()</span> <span class=\"params\">(minfo *v1.MachineInfo, err error)</span></span> &#123;</div><div class=\"line\">       u := self.machineInfoUrl()</div><div class=\"line\">       ret := <span class=\"built_in\">new</span>(v1.MachineInfo)</div><div class=\"line\">       <span class=\"keyword\">if</span> err = self.httpGetJsonData(ret, <span class=\"literal\">nil</span>, u, <span class=\"string\">\"machine info\"</span>); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">              <span class=\"keyword\">return</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       minfo = ret</div><div class=\"line\">       <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>2）ContainerInfo</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ContainerInfo returns the JSON container information for the specified</span></div><div class=\"line\"><span class=\"comment\">// container and request.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Client)</span> <span class=\"title\">ContainerInfo</span><span class=\"params\">(name <span class=\"keyword\">string</span>, query *v1.ContainerInfoRequest)</span> <span class=\"params\">(cinfo *v1.ContainerInfo, err error)</span></span> &#123;</div><div class=\"line\">       u := self.containerInfoUrl(name)</div><div class=\"line\">       ret := <span class=\"built_in\">new</span>(v1.ContainerInfo)</div><div class=\"line\">       <span class=\"keyword\">if</span> err = self.httpGetJsonData(ret, query, u, fmt.Sprintf(<span class=\"string\">\"container info for %q\"</span>, name)); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">              <span class=\"keyword\">return</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       cinfo = ret</div><div class=\"line\">       <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>3）DockerContainer</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Returns the JSON container information for the specified</span></div><div class=\"line\"><span class=\"comment\">// Docker container and request.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Client)</span> <span class=\"title\">DockerContainer</span><span class=\"params\">(name <span class=\"keyword\">string</span>, query *v1.ContainerInfoRequest)</span> <span class=\"params\">(cinfo v1.ContainerInfo, err error)</span></span> &#123;</div><div class=\"line\">       u := self.dockerInfoUrl(name)</div><div class=\"line\">       ret := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]v1.ContainerInfo)</div><div class=\"line\">       <span class=\"keyword\">if</span> err = self.httpGetJsonData(&amp;ret, query, u, fmt.Sprintf(<span class=\"string\">\"Docker container info for %q\"</span>, name)); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">              <span class=\"keyword\">return</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(ret) != <span class=\"number\">1</span> &#123;</div><div class=\"line\">              err = fmt.Errorf(<span class=\"string\">\"expected to only receive 1 Docker container: %+v\"</span>, ret)</div><div class=\"line\">              <span class=\"keyword\">return</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">for</span> _, cont := <span class=\"keyword\">range</span> ret &#123;</div><div class=\"line\">              cinfo = cont</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>4）AllDockerContainers</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Returns the JSON container information for all Docker containers.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Client)</span> <span class=\"title\">AllDockerContainers</span><span class=\"params\">(query *v1.ContainerInfoRequest)</span> <span class=\"params\">(cinfo []v1.ContainerInfo, err error)</span></span> &#123;</div><div class=\"line\">       u := self.dockerInfoUrl(<span class=\"string\">\"/\"</span>)</div><div class=\"line\">       ret := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]v1.ContainerInfo)</div><div class=\"line\">       <span class=\"keyword\">if</span> err = self.httpGetJsonData(&amp;ret, query, u, <span class=\"string\">\"all Docker containers info\"</span>); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">              <span class=\"keyword\">return</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       cinfo = <span class=\"built_in\">make</span>([]v1.ContainerInfo, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(ret))</div><div class=\"line\">       <span class=\"keyword\">for</span> _, cont := <span class=\"keyword\">range</span> ret &#123;</div><div class=\"line\">              cinfo = <span class=\"built_in\">append</span>(cinfo, cont)</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"[Kubernetes] Heapster介绍","catalog":true,"date":"2017-08-13T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Kubernetes"],"_content":"\n## 1. heapster简介\n\nHeapster是容器集群监控和性能分析工具，天然的支持Kubernetes和CoreOS。\nKubernetes有个出名的监控agent—cAdvisor。在每个kubernetes Node上都会运行cAdvisor，它会收集本机以及容器的监控数据(cpu,memory,filesystem,network,uptime)。\n\n## 2. heapster部署与配置\n\n### 2.1. 注意事项\n\n需同步部署机器和被采集机器的时间：ntpdate time.windows.com\n\n加入定时任务，定期同步时间\n\ncrontab –e\n\n30 5 * * *          /usr/sbin/ntpdate time.windows.com          //每天早晨5点半执行\n\n### 2.2. 容器式部署\n\n```shell\n#拉取镜像\ndocker pull registry.wae.haplat.net/test/heapster:v1.3.0\n#运行容器\ndocker run -d -p 8082:8082 --net=host registry.wae.haplat.net/test/heapster:latest --source=kubernetes:http://<k8s-server-ip>:8080?inClusterConfig=false\\&useServiceAccount=false --sink=influxdb:http://<influxdb-ip>:8086?db=<k8s_env_zone>\n```\n\n### 2.3. 配置说明\n\n可以参考[官方文档](https://github.com/kubernetes/heapster/tree/master/docs)\n\n#### 2.3.1. –source\n\n–source: 指定数据获取源。这里指定kube-apiserver即可。\n后缀参数：\ninClusterConfig:\nkubeletPort: 指定kubelet的使用端口，默认10255\nkubeletHttps: 是否使用https去连接kubelets(默认：false)\napiVersion: 指定K8S的apiversion\ninsecure: 是否使用安全证书(默认：false)\nauth: 安全认证\nuseServiceAccount: 是否使用K8S的安全令牌\n\n#### 2.3.2. –sink\n\n–sink: 指定后端数据存储。这里指定influxdb数据库。\n后缀参数：\nuser: InfluxDB用户\npw: InfluxDB密码\ndb: 数据库名\nsecure: 安全连接到InfluxDB(默认：false)\nwithfields： 使用InfluxDB fields(默认：false)。\n\n## 3. Metrics\n\n| 分类         | Metric Name                   | Description                              | 备注            |\n| ---------- | ----------------------------- | ---------------------------------------- | ------------- |\n| cpu        | cpu/limit                     | CPU hard limit in millicores.            | CPU上限         |\n|            | cpu/node_capacity             | Cpu capacity of a node.                  | Node节点的CPU容量  |\n|            | cpu/node_allocatable          | Cpu allocatable of a node.               | Node节点可分配的CPU |\n|            | cpu/node_reservation          | Share of cpu that is reserved on the node allocatable. |               |\n|            | cpu/node_utilization          | CPU utilization as a share of node allocatable. |               |\n|            | cpu/request                   | CPU request (the guaranteed amount of resources) in millicores. |               |\n|            | cpu/usage                     | Cumulative CPU usage on all cores.       | CPU总使用量       |\n|            | cpu/usage_rate                | CPU usage on all cores in millicores.    |               |\n| filesystem | filesystem/usage              | Total number of bytes consumed on a filesystem. | 文件系统的使用量      |\n|            | filesystem/limit              | The total size of filesystem in bytes.   | 文件系统的使用上限     |\n|            | filesystem/available          | The number of available bytes remaining in a the filesystem | 可用的文件系统容量     |\n|            | filesystem/inodes             | The number of available inodes in a the filesystem |               |\n|            | filesystem/inodes_free        | The number of free inodes remaining in a the filesystem |               |\n| memory     | memory/limit                  | Memory hard limit in bytes.              | 内存上限          |\n|            | memory/major_page_faults      | Number of major page faults.             |               |\n|            | memory/major_page_faults_rate | Number of major page faults per second.  |               |\n|            | memory/node_capacity          | Memory capacity of a node.               |               |\n|            | memory/node_allocatable       | Memory allocatable of a node.            |               |\n|            | memory/node_reservation       | Share of memory that is reserved on the node allocatable. |               |\n|            | memory/node_utilization       | Memory utilization as a share of memory allocatable. |               |\n|            | memory/page_faults            | Number of page faults.                   |               |\n|            | memory/page_faults_rate       | Number of page faults per second.        |               |\n|            | memory/request                | Memory request (the guaranteed amount of resources) in bytes. |               |\n|            | memory/usage                  | Total memory usage.                      |               |\n|            | memory/cache                  | Cache memory usage.                      |               |\n|            | memory/rss                    | RSS memory usage.                        |               |\n|            | memory/working_set            | Total working set usage. Working set is the memory being used and not easily dropped by the kernel. |               |\n| network    | network/rx                    | Cumulative number of bytes received over the network. |               |\n|            | network/rx_errors             | Cumulative number of errors while receiving over the network. |               |\n|            | network/rx_errors_rate        | Number of errors while receiving over the network per second. |               |\n|            | network/rx_rate               | Number of bytes received over the network per second. |               |\n|            | network/tx                    | Cumulative number of bytes sent over the network |               |\n|            | network/tx_errors             | Cumulative number of errors while sending over the network |               |\n|            | network/tx_errors_rate        | Number of errors while sending over the network |               |\n|            | network/tx_rate               | Number of bytes sent over the network per second. |               |\n|            | uptime                        | Number of milliseconds since the container was started. |               |\n\n## 4. Labels\n\n| Label Name           | Description                              |\n| -------------------- | ---------------------------------------- |\n| pod_id               | Unique ID of a Pod                       |\n| pod_name             | User-provided name of a Pod              |\n| pod_namespace        | The namespace of a Pod                   |\n| container_base_image | Base image for the container             |\n| container_name       | User-provided name of the container or full cgroup name for system containers |\n| host_id              | Cloud-provider specified or user specified Identifier of a node |\n| hostname             | Hostname where the container ran         |\n| labels               | Comma-separated(Default) list of user-provided labels. Format is 'key:value' |\n| namespace_id         | UID of the namespace of a Pod            |\n| resource_id          | A unique identifier used to differentiate multiple metrics of the same type. e.x. Fs partitions under filesystem/usage |\n\n## 5. heapster API\n\n见官方文档：[https://github.com/kubernetes/heapster/blob/master/docs/model.md](https://github.com/kubernetes/heapster/blob/master/docs/model.md)\n\n ","source":"_posts/Kubernetes/监控/heapster.md","raw":"---\ntitle: \"[Kubernetes] Heapster介绍\"\ncatalog: true\ndate: 2017-08-13 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Kubernetes\ncatagories:\n- Kubernetes\n---\n\n## 1. heapster简介\n\nHeapster是容器集群监控和性能分析工具，天然的支持Kubernetes和CoreOS。\nKubernetes有个出名的监控agent—cAdvisor。在每个kubernetes Node上都会运行cAdvisor，它会收集本机以及容器的监控数据(cpu,memory,filesystem,network,uptime)。\n\n## 2. heapster部署与配置\n\n### 2.1. 注意事项\n\n需同步部署机器和被采集机器的时间：ntpdate time.windows.com\n\n加入定时任务，定期同步时间\n\ncrontab –e\n\n30 5 * * *          /usr/sbin/ntpdate time.windows.com          //每天早晨5点半执行\n\n### 2.2. 容器式部署\n\n```shell\n#拉取镜像\ndocker pull registry.wae.haplat.net/test/heapster:v1.3.0\n#运行容器\ndocker run -d -p 8082:8082 --net=host registry.wae.haplat.net/test/heapster:latest --source=kubernetes:http://<k8s-server-ip>:8080?inClusterConfig=false\\&useServiceAccount=false --sink=influxdb:http://<influxdb-ip>:8086?db=<k8s_env_zone>\n```\n\n### 2.3. 配置说明\n\n可以参考[官方文档](https://github.com/kubernetes/heapster/tree/master/docs)\n\n#### 2.3.1. –source\n\n–source: 指定数据获取源。这里指定kube-apiserver即可。\n后缀参数：\ninClusterConfig:\nkubeletPort: 指定kubelet的使用端口，默认10255\nkubeletHttps: 是否使用https去连接kubelets(默认：false)\napiVersion: 指定K8S的apiversion\ninsecure: 是否使用安全证书(默认：false)\nauth: 安全认证\nuseServiceAccount: 是否使用K8S的安全令牌\n\n#### 2.3.2. –sink\n\n–sink: 指定后端数据存储。这里指定influxdb数据库。\n后缀参数：\nuser: InfluxDB用户\npw: InfluxDB密码\ndb: 数据库名\nsecure: 安全连接到InfluxDB(默认：false)\nwithfields： 使用InfluxDB fields(默认：false)。\n\n## 3. Metrics\n\n| 分类         | Metric Name                   | Description                              | 备注            |\n| ---------- | ----------------------------- | ---------------------------------------- | ------------- |\n| cpu        | cpu/limit                     | CPU hard limit in millicores.            | CPU上限         |\n|            | cpu/node_capacity             | Cpu capacity of a node.                  | Node节点的CPU容量  |\n|            | cpu/node_allocatable          | Cpu allocatable of a node.               | Node节点可分配的CPU |\n|            | cpu/node_reservation          | Share of cpu that is reserved on the node allocatable. |               |\n|            | cpu/node_utilization          | CPU utilization as a share of node allocatable. |               |\n|            | cpu/request                   | CPU request (the guaranteed amount of resources) in millicores. |               |\n|            | cpu/usage                     | Cumulative CPU usage on all cores.       | CPU总使用量       |\n|            | cpu/usage_rate                | CPU usage on all cores in millicores.    |               |\n| filesystem | filesystem/usage              | Total number of bytes consumed on a filesystem. | 文件系统的使用量      |\n|            | filesystem/limit              | The total size of filesystem in bytes.   | 文件系统的使用上限     |\n|            | filesystem/available          | The number of available bytes remaining in a the filesystem | 可用的文件系统容量     |\n|            | filesystem/inodes             | The number of available inodes in a the filesystem |               |\n|            | filesystem/inodes_free        | The number of free inodes remaining in a the filesystem |               |\n| memory     | memory/limit                  | Memory hard limit in bytes.              | 内存上限          |\n|            | memory/major_page_faults      | Number of major page faults.             |               |\n|            | memory/major_page_faults_rate | Number of major page faults per second.  |               |\n|            | memory/node_capacity          | Memory capacity of a node.               |               |\n|            | memory/node_allocatable       | Memory allocatable of a node.            |               |\n|            | memory/node_reservation       | Share of memory that is reserved on the node allocatable. |               |\n|            | memory/node_utilization       | Memory utilization as a share of memory allocatable. |               |\n|            | memory/page_faults            | Number of page faults.                   |               |\n|            | memory/page_faults_rate       | Number of page faults per second.        |               |\n|            | memory/request                | Memory request (the guaranteed amount of resources) in bytes. |               |\n|            | memory/usage                  | Total memory usage.                      |               |\n|            | memory/cache                  | Cache memory usage.                      |               |\n|            | memory/rss                    | RSS memory usage.                        |               |\n|            | memory/working_set            | Total working set usage. Working set is the memory being used and not easily dropped by the kernel. |               |\n| network    | network/rx                    | Cumulative number of bytes received over the network. |               |\n|            | network/rx_errors             | Cumulative number of errors while receiving over the network. |               |\n|            | network/rx_errors_rate        | Number of errors while receiving over the network per second. |               |\n|            | network/rx_rate               | Number of bytes received over the network per second. |               |\n|            | network/tx                    | Cumulative number of bytes sent over the network |               |\n|            | network/tx_errors             | Cumulative number of errors while sending over the network |               |\n|            | network/tx_errors_rate        | Number of errors while sending over the network |               |\n|            | network/tx_rate               | Number of bytes sent over the network per second. |               |\n|            | uptime                        | Number of milliseconds since the container was started. |               |\n\n## 4. Labels\n\n| Label Name           | Description                              |\n| -------------------- | ---------------------------------------- |\n| pod_id               | Unique ID of a Pod                       |\n| pod_name             | User-provided name of a Pod              |\n| pod_namespace        | The namespace of a Pod                   |\n| container_base_image | Base image for the container             |\n| container_name       | User-provided name of the container or full cgroup name for system containers |\n| host_id              | Cloud-provider specified or user specified Identifier of a node |\n| hostname             | Hostname where the container ran         |\n| labels               | Comma-separated(Default) list of user-provided labels. Format is 'key:value' |\n| namespace_id         | UID of the namespace of a Pod            |\n| resource_id          | A unique identifier used to differentiate multiple metrics of the same type. e.x. Fs partitions under filesystem/usage |\n\n## 5. heapster API\n\n见官方文档：[https://github.com/kubernetes/heapster/blob/master/docs/model.md](https://github.com/kubernetes/heapster/blob/master/docs/model.md)\n\n ","slug":"Kubernetes/监控/heapster","published":1,"updated":"2017-10-02T11:53:00.429Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740m7001o30vu3pfnaip8","content":"<h2><span id=\"1-heapster简介\">1. heapster简介</span></h2>\n<p>Heapster是容器集群监控和性能分析工具，天然的支持Kubernetes和CoreOS。<br>\nKubernetes有个出名的监控agent—cAdvisor。在每个kubernetes Node上都会运行cAdvisor，它会收集本机以及容器的监控数据(cpu,memory,filesystem,network,uptime)。</p>\n<h2><span id=\"2-heapster部署与配置\">2. heapster部署与配置</span></h2>\n<h3><span id=\"21-注意事项\">2.1. 注意事项</span></h3>\n<p>需同步部署机器和被采集机器的时间：ntpdate <a href=\"http://time.windows.com\" target=\"_blank\" rel=\"external\">time.windows.com</a></p>\n<p>加入定时任务，定期同步时间</p>\n<p>crontab –e</p>\n<p>30 5 * * *          /usr/sbin/ntpdate <a href=\"http://time.windows.com\" target=\"_blank\" rel=\"external\">time.windows.com</a>          //每天早晨5点半执行</p>\n<h3><span id=\"22-容器式部署\">2.2. 容器式部署</span></h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">拉取镜像</span></div><div class=\"line\">docker pull registry.wae.haplat.net/test/heapster:v1.3.0</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">运行容器</span></div><div class=\"line\">docker run -d -p 8082:8082 --net=host registry.wae.haplat.net/test/heapster:latest --source=kubernetes:http://&lt;k8s-server-ip&gt;:8080?inClusterConfig=false\\&amp;useServiceAccount=false --sink=influxdb:http://&lt;influxdb-ip&gt;:8086?db=&lt;k8s_env_zone&gt;</div></pre></td></tr></table></figure>\n<h3><span id=\"23-配置说明\">2.3. 配置说明</span></h3>\n<p>可以参考<a href=\"https://github.com/kubernetes/heapster/tree/master/docs\" target=\"_blank\" rel=\"external\">官方文档</a></p>\n<h4><span id=\"231-source\">2.3.1. –source</span></h4>\n<p>–source: 指定数据获取源。这里指定kube-apiserver即可。<br>\n后缀参数：<br>\ninClusterConfig:<br>\nkubeletPort: 指定kubelet的使用端口，默认10255<br>\nkubeletHttps: 是否使用https去连接kubelets(默认：false)<br>\napiVersion: 指定K8S的apiversion<br>\ninsecure: 是否使用安全证书(默认：false)<br>\nauth: 安全认证<br>\nuseServiceAccount: 是否使用K8S的安全令牌</p>\n<h4><span id=\"232-sink\">2.3.2. –sink</span></h4>\n<p>–sink: 指定后端数据存储。这里指定influxdb数据库。<br>\n后缀参数：<br>\nuser: InfluxDB用户<br>\npw: InfluxDB密码<br>\ndb: 数据库名<br>\nsecure: 安全连接到InfluxDB(默认：false)<br>\nwithfields： 使用InfluxDB fields(默认：false)。</p>\n<h2><span id=\"3-metrics\">3. Metrics</span></h2>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>Metric Name</th>\n<th>Description</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cpu</td>\n<td>cpu/limit</td>\n<td>CPU hard limit in millicores.</td>\n<td>CPU上限</td>\n</tr>\n<tr>\n<td></td>\n<td>cpu/node_capacity</td>\n<td>Cpu capacity of a node.</td>\n<td>Node节点的CPU容量</td>\n</tr>\n<tr>\n<td></td>\n<td>cpu/node_allocatable</td>\n<td>Cpu allocatable of a node.</td>\n<td>Node节点可分配的CPU</td>\n</tr>\n<tr>\n<td></td>\n<td>cpu/node_reservation</td>\n<td>Share of cpu that is reserved on the node allocatable.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>cpu/node_utilization</td>\n<td>CPU utilization as a share of node allocatable.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>cpu/request</td>\n<td>CPU request (the guaranteed amount of resources) in millicores.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>cpu/usage</td>\n<td>Cumulative CPU usage on all cores.</td>\n<td>CPU总使用量</td>\n</tr>\n<tr>\n<td></td>\n<td>cpu/usage_rate</td>\n<td>CPU usage on all cores in millicores.</td>\n<td></td>\n</tr>\n<tr>\n<td>filesystem</td>\n<td>filesystem/usage</td>\n<td>Total number of bytes consumed on a filesystem.</td>\n<td>文件系统的使用量</td>\n</tr>\n<tr>\n<td></td>\n<td>filesystem/limit</td>\n<td>The total size of filesystem in bytes.</td>\n<td>文件系统的使用上限</td>\n</tr>\n<tr>\n<td></td>\n<td>filesystem/available</td>\n<td>The number of available bytes remaining in a the filesystem</td>\n<td>可用的文件系统容量</td>\n</tr>\n<tr>\n<td></td>\n<td>filesystem/inodes</td>\n<td>The number of available inodes in a the filesystem</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>filesystem/inodes_free</td>\n<td>The number of free inodes remaining in a the filesystem</td>\n<td></td>\n</tr>\n<tr>\n<td>memory</td>\n<td>memory/limit</td>\n<td>Memory hard limit in bytes.</td>\n<td>内存上限</td>\n</tr>\n<tr>\n<td></td>\n<td>memory/major_page_faults</td>\n<td>Number of major page faults.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/major_page_faults_rate</td>\n<td>Number of major page faults per second.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/node_capacity</td>\n<td>Memory capacity of a node.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/node_allocatable</td>\n<td>Memory allocatable of a node.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/node_reservation</td>\n<td>Share of memory that is reserved on the node allocatable.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/node_utilization</td>\n<td>Memory utilization as a share of memory allocatable.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/page_faults</td>\n<td>Number of page faults.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/page_faults_rate</td>\n<td>Number of page faults per second.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/request</td>\n<td>Memory request (the guaranteed amount of resources) in bytes.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/usage</td>\n<td>Total memory usage.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/cache</td>\n<td>Cache memory usage.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/rss</td>\n<td>RSS memory usage.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/working_set</td>\n<td>Total working set usage. Working set is the memory being used and not easily dropped by the kernel.</td>\n<td></td>\n</tr>\n<tr>\n<td>network</td>\n<td>network/rx</td>\n<td>Cumulative number of bytes received over the network.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>network/rx_errors</td>\n<td>Cumulative number of errors while receiving over the network.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>network/rx_errors_rate</td>\n<td>Number of errors while receiving over the network per second.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>network/rx_rate</td>\n<td>Number of bytes received over the network per second.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>network/tx</td>\n<td>Cumulative number of bytes sent over the network</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>network/tx_errors</td>\n<td>Cumulative number of errors while sending over the network</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>network/tx_errors_rate</td>\n<td>Number of errors while sending over the network</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>network/tx_rate</td>\n<td>Number of bytes sent over the network per second.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>uptime</td>\n<td>Number of milliseconds since the container was started.</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2><span id=\"4-labels\">4. Labels</span></h2>\n<table>\n<thead>\n<tr>\n<th>Label Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pod_id</td>\n<td>Unique ID of a Pod</td>\n</tr>\n<tr>\n<td>pod_name</td>\n<td>User-provided name of a Pod</td>\n</tr>\n<tr>\n<td>pod_namespace</td>\n<td>The namespace of a Pod</td>\n</tr>\n<tr>\n<td>container_base_image</td>\n<td>Base image for the container</td>\n</tr>\n<tr>\n<td>container_name</td>\n<td>User-provided name of the container or full cgroup name for system containers</td>\n</tr>\n<tr>\n<td>host_id</td>\n<td>Cloud-provider specified or user specified Identifier of a node</td>\n</tr>\n<tr>\n<td>hostname</td>\n<td>Hostname where the container ran</td>\n</tr>\n<tr>\n<td>labels</td>\n<td>Comma-separated(Default) list of user-provided labels. Format is ‘key:value’</td>\n</tr>\n<tr>\n<td>namespace_id</td>\n<td>UID of the namespace of a Pod</td>\n</tr>\n<tr>\n<td>resource_id</td>\n<td>A unique identifier used to differentiate multiple metrics of the same type. e.x. Fs partitions under filesystem/usage</td>\n</tr>\n</tbody>\n</table>\n<h2><span id=\"5-heapster-api\">5. heapster API</span></h2>\n<p>见官方文档：<a href=\"https://github.com/kubernetes/heapster/blob/master/docs/model.md\" target=\"_blank\" rel=\"external\">https://github.com/kubernetes/heapster/blob/master/docs/model.md</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. heapster简介</h2>\n<p>Heapster是容器集群监控和性能分析工具，天然的支持Kubernetes和CoreOS。<br>\nKubernetes有个出名的监控agent—cAdvisor。在每个kubernetes Node上都会运行cAdvisor，它会收集本机以及容器的监控数据(cpu,memory,filesystem,network,uptime)。</p>\n<h2>2. heapster部署与配置</h2>\n<h3>2.1. 注意事项</h3>\n<p>需同步部署机器和被采集机器的时间：ntpdate <a href=\"http://time.windows.com\" target=\"_blank\" rel=\"external\">time.windows.com</a></p>\n<p>加入定时任务，定期同步时间</p>\n<p>crontab –e</p>\n<p>30 5 * * *          /usr/sbin/ntpdate <a href=\"http://time.windows.com\" target=\"_blank\" rel=\"external\">time.windows.com</a>          //每天早晨5点半执行</p>\n<h3>2.2. 容器式部署</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">拉取镜像</span></div><div class=\"line\">docker pull registry.wae.haplat.net/test/heapster:v1.3.0</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">运行容器</span></div><div class=\"line\">docker run -d -p 8082:8082 --net=host registry.wae.haplat.net/test/heapster:latest --source=kubernetes:http://&lt;k8s-server-ip&gt;:8080?inClusterConfig=false\\&amp;useServiceAccount=false --sink=influxdb:http://&lt;influxdb-ip&gt;:8086?db=&lt;k8s_env_zone&gt;</div></pre></td></tr></table></figure>\n<h3>2.3. 配置说明</h3>\n<p>可以参考<a href=\"https://github.com/kubernetes/heapster/tree/master/docs\" target=\"_blank\" rel=\"external\">官方文档</a></p>\n<h4>2.3.1. –source</h4>\n<p>–source: 指定数据获取源。这里指定kube-apiserver即可。<br>\n后缀参数：<br>\ninClusterConfig:<br>\nkubeletPort: 指定kubelet的使用端口，默认10255<br>\nkubeletHttps: 是否使用https去连接kubelets(默认：false)<br>\napiVersion: 指定K8S的apiversion<br>\ninsecure: 是否使用安全证书(默认：false)<br>\nauth: 安全认证<br>\nuseServiceAccount: 是否使用K8S的安全令牌</p>\n<h4>2.3.2. –sink</h4>\n<p>–sink: 指定后端数据存储。这里指定influxdb数据库。<br>\n后缀参数：<br>\nuser: InfluxDB用户<br>\npw: InfluxDB密码<br>\ndb: 数据库名<br>\nsecure: 安全连接到InfluxDB(默认：false)<br>\nwithfields： 使用InfluxDB fields(默认：false)。</p>\n<h2>3. Metrics</h2>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>Metric Name</th>\n<th>Description</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cpu</td>\n<td>cpu/limit</td>\n<td>CPU hard limit in millicores.</td>\n<td>CPU上限</td>\n</tr>\n<tr>\n<td></td>\n<td>cpu/node_capacity</td>\n<td>Cpu capacity of a node.</td>\n<td>Node节点的CPU容量</td>\n</tr>\n<tr>\n<td></td>\n<td>cpu/node_allocatable</td>\n<td>Cpu allocatable of a node.</td>\n<td>Node节点可分配的CPU</td>\n</tr>\n<tr>\n<td></td>\n<td>cpu/node_reservation</td>\n<td>Share of cpu that is reserved on the node allocatable.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>cpu/node_utilization</td>\n<td>CPU utilization as a share of node allocatable.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>cpu/request</td>\n<td>CPU request (the guaranteed amount of resources) in millicores.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>cpu/usage</td>\n<td>Cumulative CPU usage on all cores.</td>\n<td>CPU总使用量</td>\n</tr>\n<tr>\n<td></td>\n<td>cpu/usage_rate</td>\n<td>CPU usage on all cores in millicores.</td>\n<td></td>\n</tr>\n<tr>\n<td>filesystem</td>\n<td>filesystem/usage</td>\n<td>Total number of bytes consumed on a filesystem.</td>\n<td>文件系统的使用量</td>\n</tr>\n<tr>\n<td></td>\n<td>filesystem/limit</td>\n<td>The total size of filesystem in bytes.</td>\n<td>文件系统的使用上限</td>\n</tr>\n<tr>\n<td></td>\n<td>filesystem/available</td>\n<td>The number of available bytes remaining in a the filesystem</td>\n<td>可用的文件系统容量</td>\n</tr>\n<tr>\n<td></td>\n<td>filesystem/inodes</td>\n<td>The number of available inodes in a the filesystem</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>filesystem/inodes_free</td>\n<td>The number of free inodes remaining in a the filesystem</td>\n<td></td>\n</tr>\n<tr>\n<td>memory</td>\n<td>memory/limit</td>\n<td>Memory hard limit in bytes.</td>\n<td>内存上限</td>\n</tr>\n<tr>\n<td></td>\n<td>memory/major_page_faults</td>\n<td>Number of major page faults.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/major_page_faults_rate</td>\n<td>Number of major page faults per second.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/node_capacity</td>\n<td>Memory capacity of a node.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/node_allocatable</td>\n<td>Memory allocatable of a node.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/node_reservation</td>\n<td>Share of memory that is reserved on the node allocatable.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/node_utilization</td>\n<td>Memory utilization as a share of memory allocatable.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/page_faults</td>\n<td>Number of page faults.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/page_faults_rate</td>\n<td>Number of page faults per second.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/request</td>\n<td>Memory request (the guaranteed amount of resources) in bytes.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/usage</td>\n<td>Total memory usage.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/cache</td>\n<td>Cache memory usage.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/rss</td>\n<td>RSS memory usage.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>memory/working_set</td>\n<td>Total working set usage. Working set is the memory being used and not easily dropped by the kernel.</td>\n<td></td>\n</tr>\n<tr>\n<td>network</td>\n<td>network/rx</td>\n<td>Cumulative number of bytes received over the network.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>network/rx_errors</td>\n<td>Cumulative number of errors while receiving over the network.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>network/rx_errors_rate</td>\n<td>Number of errors while receiving over the network per second.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>network/rx_rate</td>\n<td>Number of bytes received over the network per second.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>network/tx</td>\n<td>Cumulative number of bytes sent over the network</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>network/tx_errors</td>\n<td>Cumulative number of errors while sending over the network</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>network/tx_errors_rate</td>\n<td>Number of errors while sending over the network</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>network/tx_rate</td>\n<td>Number of bytes sent over the network per second.</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>uptime</td>\n<td>Number of milliseconds since the container was started.</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2>4. Labels</h2>\n<table>\n<thead>\n<tr>\n<th>Label Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pod_id</td>\n<td>Unique ID of a Pod</td>\n</tr>\n<tr>\n<td>pod_name</td>\n<td>User-provided name of a Pod</td>\n</tr>\n<tr>\n<td>pod_namespace</td>\n<td>The namespace of a Pod</td>\n</tr>\n<tr>\n<td>container_base_image</td>\n<td>Base image for the container</td>\n</tr>\n<tr>\n<td>container_name</td>\n<td>User-provided name of the container or full cgroup name for system containers</td>\n</tr>\n<tr>\n<td>host_id</td>\n<td>Cloud-provider specified or user specified Identifier of a node</td>\n</tr>\n<tr>\n<td>hostname</td>\n<td>Hostname where the container ran</td>\n</tr>\n<tr>\n<td>labels</td>\n<td>Comma-separated(Default) list of user-provided labels. Format is ‘key:value’</td>\n</tr>\n<tr>\n<td>namespace_id</td>\n<td>UID of the namespace of a Pod</td>\n</tr>\n<tr>\n<td>resource_id</td>\n<td>A unique identifier used to differentiate multiple metrics of the same type. e.x. Fs partitions under filesystem/usage</td>\n</tr>\n</tbody>\n</table>\n<h2>5. heapster API</h2>\n<p>见官方文档：<a href=\"https://github.com/kubernetes/heapster/blob/master/docs/model.md\" target=\"_blank\" rel=\"external\">https://github.com/kubernetes/heapster/blob/master/docs/model.md</a></p>\n"},{"title":"[Kubernetes] Kubernetes集群监控","catalog":true,"date":"2017-08-13T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Kubernetes"],"_content":"\n## 1. 概述\n\n### 1.1. cAdvisor\n\ncAdvisor对Node机器上的资源及容器进行实时监控和性能数据采集，包括CPU使用情况、内存使用情况、网络吞吐量及文件系统使用情况，cAdvisor集成在Kubelet中，当kubelet启动时会自动启动cAdvisor，即一个cAdvisor仅对一台Node机器进行监控。kubelet的启动参数--cadvisor-port可以定义cAdvisor对外提供服务的端口，默认为4194。可以通过浏览器`Node_IP:port`访问。项目主页：http://github.com/google/cadvisor。\n\n### 1.2. Heapster\n\n是对集群中的各个Node、Pod的资源使用数据进行采集，通过访问每个Node上Kubelet的API，再通过Kubelet调用cAdvisor的API来采集该节点上所有容器的性能数据。由Heapster进行数据汇聚，保存到后端存储系统中，例如InfluxDB，Google Cloud Logging等。项目主页为：https://github.com/kubernetes/heapster。\n\n### 1.3. InfluxDB\n\n是分布式时序数据库（每条记录带有时间戳属性），主要用于实时数据采集、事件跟踪记录、存储时间图表、原始数据等。提供REST API用于数据的存储和查询。项目主页为http://InfluxDB.com。\n\n### 1.4. Grafana\n\n通过Dashboard将InfluxDB的时序数据展现成图表形式，便于查看集群运行状态。项目主页为http://Grafana.org。\n\n### 1.5. 总体架构图\n\n![k8s监控架构图](/img/article/kubernetes/监控/k8s监控架构图.png)\n\n其中当前Kubernetes中，Heapster、InfluxDB、Grafana均以Pod的形式启动和运行。Heapster与Master需配置安全连接。\n\n## 2. 部署与使用\n\n### 2.1. cAdvisor\n\nkubelet的启动参数--cadvisor-port可以定义cAdvisor对外提供服务的端口，默认为4194。可以通过浏览器`Node_IP:port`访问。也提供了REST API供客户端远程调用，API返回的格式为JSON，可以采用URL访问：http://`hostname`:`port`/api/`version`/`request`/\n\n例如：[http://14.152.49.100:4194/api/v1.3/machine](http://14.152.49.100:4194/api/v1.3/machine) 获取主机信息。\n\n### 2.2. Service\n\n#### 2.2.1. heapster-service\n\n**heapster-service.yaml**\n\n```yaml\napiVersion:v1\nkind:Service\nmetadata:\n  label:\n    kubenetes.io/cluster-service:\"true\"\n    kubernetes.io/name:Heapster\n  name:heapster\n  namespace:kube-system\nspec:\n  ports:\n    - port:80\n      targetPort:8082\n  selector:\n    k8s-app:heapster\n```\n\n#### 2.2.2. influxdb-service\n\n**influxdb-service.yaml**\n\n```yaml\napiVersion:v1\nkind:Service\nmetadata:\n  label:null\n  name:monitoring-InfluxDB\n  namespace:kube-system\nspec:\n  type:Nodeport\n  ports:\n    - name:http\n      port:80\n      targetPort:8083\n    - name:api\n      port:8086\n      targetPort:8086\n      Nodeport:8086\n  selector:\n    name:influxGrafana\n```\n\n#### 2.2.3. grafana-service\n\n**grafana-service.yaml**\n\n```yaml\napiVersion:v1\nkind:Service\nmetadata:\n  label:\n    kubenetes.io/cluster-service:\"true\"\n    kubernetes.io/name:monitoring-Grafana\n  name:monitoring-Grafana\n  namespace:kube-system\nspec:\n  type:Nodeport\n  ports:\n      port:80\n      targetPort:8080\n      Nodeport:8085\n  selector:\n    name:influxGrafana\n```\n\n使用type=NodePort将InfluxDB和Grafana暴露在Node的端口上，以便通过浏览器进行访问。\n\n#### 2.2.4. 创建service\n\n```shell\nkubectl create -f heapster-service.yaml\nkubectl create -f InfluxDB-service.yaml\nkubectl create -f Grafana-service.yaml\n```\n\n### 2.3. ReplicationController\n\n#### 2.3.1. influxdb-grafana-controller\n\n**influxdb-grafana-controller-v3.yaml** \n\n```yaml\napiVersion:v1\nkind:ReplicationController\nmetadata:\n  name:monitoring-influxdb-grafana-v3\n  namespace:kube-system\n  labels:\n    k8s-app:influxGrafana\n    version:v3\n    kubernetes.io/cluster-service:\"true\nspec:\n  replicas:1\n  selector:\n    k8s-app:influxGrafana\n    version:v3\n  template:\n    metadata:\n      labels:\n        k8s-app:influxGrafana\n        version:v3\n        kubernetes.io/cluster-service:\"true\n    spec:\n      containers:\n        - image:gcr.io/google_containers/heapster_influxdb:v0.5\n          name:influxdb\n          resources:\n            limits:\n              cpu:100m\n              memory:500Mi\n            requests:\n              cpu:100m\n              memory:500Mi\n          ports:\n            - containerPort:8083\n            - containerPort:8086\n          volumeMounts:\n            -name:influxdb-persistent-storage\n             mountPath:/data\n        - image:grc.io/google_containers/heapster_grafana:v2.6.0-2\n          name:grafana\n          resources:\n            limits:\n              cpu:100m\n              memory:100Mi\n            requests:\n              cpu:100m\n              memory:100Mi\n          env:\n            - name:INFLUXDB_SERVICE_URL\n              value:http://monitoring-influxdb:8086\n            - name:GF_AUTH_BASIC_ENABLED\n              value:\"false\"\n            - name:GF_AUTH_ANONYMOUS_ENABLED\n              value:\"true\"\n            - name:GF_AUTH_ANONYMOUS_ORG_ROLE\n              value:Admin\n            - name:GF_SERVER_ROOT_URL\n              value:/api/v1/proxy/namespace/kube-system/services/monitoring-grafana/\n          volumeMounts:\n            - name:grafana-persistent-storage\n              mountPath:/var\n      volumes:\n        - name:influxdb-persistent-storage\n          emptyDir{}\n        - name:grafana-persistent-storage\n          emptyDir{}\n```\n\n#### 2.3.2. heapster-controller\n\n**heapster-controller.yaml**\n\n```yaml\napiVersion:v1\nkind:ReplicationController\nmetadata:\n    labels:\n        k8s-app:heapster\n        name:heapster\n        version:v6\n    name:heapster\n    namespace:kube-system\nspec:\n    replicas:1\n    selector:\n        name:heapster\n        k8s-app:heapster\n        version:v6\n    template:\n        metadata:\n            labels:\n                k8s-app:heapster\n                version:v6\n        spec:\n            containers:\n                - image:gcr.io/google_containers/heapster:v0.17.0\n                  name:heapster\n                  command:\n                    - /heapster\n                    - --source=kubernetes:http://192.168.1.128:8080?inClusterConfig=flase&kubeletHttps=true&useServiceAccount=true&auth=\n                    - --sink=InfluxDB:http://monitoring-InfluxDB:8086\n```\n\nHeapster设置启动参数说明：\n\n1、–source\n\n配置监控来源，本例中表示从k8s-Master获取各个Node的信息。在URL的参数部分，修改kubeletHttps、inClusterConfig、useServiceAccount的值。\n\n2、–sink\n\n配置后端的存储系统，本例中使用InfluxDB。URL中主机名的地址是InfluxDB的Service名字，需要DNS服务正常工作，如果没有配置DNS服务可使用Service的ClusterIP地址。\n\n#### 2.3.3. 创建ReplicationController\n\n```shell\nkubelet create -f InfluxDB-Grafana-controller.yaml\nkubelet create -f heapster-controller.yaml\n```\n\n## 3. 查看界面及数据\n\n### 3.1. InfluxDB\n\n访问任意一台Node机器的30083端口。\n\n### 3.2. Grafana\n\n访问任意一台Node机器的30080端口。\n\n## 4. 容器化部署\n\n### 4.1. 拉取镜像\n\n```shell\ndocker pull registry.wae.haplat.net/test/influxdb:1.0.0\ndocker pull registry.wae.haplat.net/test/cadvisor:latest\ndocker pull registry.wae.haplat.net/test/grafana:latest\ndocker pull registry.wae.haplat.net/test/heapster:latest\n```\n\n### 4.2. 运行容器\n\n#### 4.2.1. influxdb\n\n```shell\n#influxdb\ndocker run -d -p 8083:8083 -p 8086:8086 --expose 8090 --expose 8099 --volume=/opt/data/influxdb:/data --name influxsrv registry.wae.haplat.net/test/influxdb:1.0.0\n```\n\n#### 4.2.2. cadvisor\n\n```shell\n#cadvisor\ndocker run --volume=/:/rootfs:ro --volume=/var/run:/var/run:rw --volume=/sys:/sys:ro --volume=/var/lib/docker/:/var/lib/docker:ro --publish=8080:8080 --detach=true --link influxsrv:influxsrv --name=cadvisor registry.wae.haplat.net/test/cadvisor:latest -storage_driver=influxdb -storage_driver_db=cadvisor -storage_driver_host=influxsrv:8086\n```\n\n#### 4.2.3. grafana\n\n```shell\n#grafana\ndocker run -d -p 3000:3000 -e INFLUXDB_HOST=influxsrv -e INFLUXDB_PORT=8086 -e INFLUXDB_NAME=cadvisor -e INFLUXDB_USER=root -e INFLUXDB_PASS=root --link influxsrv:influxsrv --name grafana registry.wae.haplat.net/test/grafana:latest\n```\n\n#### 4.2.4. heapster\n\n```shell\ndocker run -d -p 8082:8082 --net=host heapster:canary --source=kubernetes:http://`k8s-server-ip`:8080?inClusterConfig=false/&useServiceAccount=false --sink=influxdb:http://`influxdb-ip`:8086\n```\n\n### 4.3. 访问\n\n在浏览器输入`IP`:`PORT`\n\n ","source":"_posts/Kubernetes/监控/k8s集群监控.md","raw":"---\ntitle: \"[Kubernetes] Kubernetes集群监控\"\ncatalog: true\ndate: 2017-08-13 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Kubernetes\ncatagories:\n- Kubernetes\n---\n\n## 1. 概述\n\n### 1.1. cAdvisor\n\ncAdvisor对Node机器上的资源及容器进行实时监控和性能数据采集，包括CPU使用情况、内存使用情况、网络吞吐量及文件系统使用情况，cAdvisor集成在Kubelet中，当kubelet启动时会自动启动cAdvisor，即一个cAdvisor仅对一台Node机器进行监控。kubelet的启动参数--cadvisor-port可以定义cAdvisor对外提供服务的端口，默认为4194。可以通过浏览器`Node_IP:port`访问。项目主页：http://github.com/google/cadvisor。\n\n### 1.2. Heapster\n\n是对集群中的各个Node、Pod的资源使用数据进行采集，通过访问每个Node上Kubelet的API，再通过Kubelet调用cAdvisor的API来采集该节点上所有容器的性能数据。由Heapster进行数据汇聚，保存到后端存储系统中，例如InfluxDB，Google Cloud Logging等。项目主页为：https://github.com/kubernetes/heapster。\n\n### 1.3. InfluxDB\n\n是分布式时序数据库（每条记录带有时间戳属性），主要用于实时数据采集、事件跟踪记录、存储时间图表、原始数据等。提供REST API用于数据的存储和查询。项目主页为http://InfluxDB.com。\n\n### 1.4. Grafana\n\n通过Dashboard将InfluxDB的时序数据展现成图表形式，便于查看集群运行状态。项目主页为http://Grafana.org。\n\n### 1.5. 总体架构图\n\n![k8s监控架构图](/img/article/kubernetes/监控/k8s监控架构图.png)\n\n其中当前Kubernetes中，Heapster、InfluxDB、Grafana均以Pod的形式启动和运行。Heapster与Master需配置安全连接。\n\n## 2. 部署与使用\n\n### 2.1. cAdvisor\n\nkubelet的启动参数--cadvisor-port可以定义cAdvisor对外提供服务的端口，默认为4194。可以通过浏览器`Node_IP:port`访问。也提供了REST API供客户端远程调用，API返回的格式为JSON，可以采用URL访问：http://`hostname`:`port`/api/`version`/`request`/\n\n例如：[http://14.152.49.100:4194/api/v1.3/machine](http://14.152.49.100:4194/api/v1.3/machine) 获取主机信息。\n\n### 2.2. Service\n\n#### 2.2.1. heapster-service\n\n**heapster-service.yaml**\n\n```yaml\napiVersion:v1\nkind:Service\nmetadata:\n  label:\n    kubenetes.io/cluster-service:\"true\"\n    kubernetes.io/name:Heapster\n  name:heapster\n  namespace:kube-system\nspec:\n  ports:\n    - port:80\n      targetPort:8082\n  selector:\n    k8s-app:heapster\n```\n\n#### 2.2.2. influxdb-service\n\n**influxdb-service.yaml**\n\n```yaml\napiVersion:v1\nkind:Service\nmetadata:\n  label:null\n  name:monitoring-InfluxDB\n  namespace:kube-system\nspec:\n  type:Nodeport\n  ports:\n    - name:http\n      port:80\n      targetPort:8083\n    - name:api\n      port:8086\n      targetPort:8086\n      Nodeport:8086\n  selector:\n    name:influxGrafana\n```\n\n#### 2.2.3. grafana-service\n\n**grafana-service.yaml**\n\n```yaml\napiVersion:v1\nkind:Service\nmetadata:\n  label:\n    kubenetes.io/cluster-service:\"true\"\n    kubernetes.io/name:monitoring-Grafana\n  name:monitoring-Grafana\n  namespace:kube-system\nspec:\n  type:Nodeport\n  ports:\n      port:80\n      targetPort:8080\n      Nodeport:8085\n  selector:\n    name:influxGrafana\n```\n\n使用type=NodePort将InfluxDB和Grafana暴露在Node的端口上，以便通过浏览器进行访问。\n\n#### 2.2.4. 创建service\n\n```shell\nkubectl create -f heapster-service.yaml\nkubectl create -f InfluxDB-service.yaml\nkubectl create -f Grafana-service.yaml\n```\n\n### 2.3. ReplicationController\n\n#### 2.3.1. influxdb-grafana-controller\n\n**influxdb-grafana-controller-v3.yaml** \n\n```yaml\napiVersion:v1\nkind:ReplicationController\nmetadata:\n  name:monitoring-influxdb-grafana-v3\n  namespace:kube-system\n  labels:\n    k8s-app:influxGrafana\n    version:v3\n    kubernetes.io/cluster-service:\"true\nspec:\n  replicas:1\n  selector:\n    k8s-app:influxGrafana\n    version:v3\n  template:\n    metadata:\n      labels:\n        k8s-app:influxGrafana\n        version:v3\n        kubernetes.io/cluster-service:\"true\n    spec:\n      containers:\n        - image:gcr.io/google_containers/heapster_influxdb:v0.5\n          name:influxdb\n          resources:\n            limits:\n              cpu:100m\n              memory:500Mi\n            requests:\n              cpu:100m\n              memory:500Mi\n          ports:\n            - containerPort:8083\n            - containerPort:8086\n          volumeMounts:\n            -name:influxdb-persistent-storage\n             mountPath:/data\n        - image:grc.io/google_containers/heapster_grafana:v2.6.0-2\n          name:grafana\n          resources:\n            limits:\n              cpu:100m\n              memory:100Mi\n            requests:\n              cpu:100m\n              memory:100Mi\n          env:\n            - name:INFLUXDB_SERVICE_URL\n              value:http://monitoring-influxdb:8086\n            - name:GF_AUTH_BASIC_ENABLED\n              value:\"false\"\n            - name:GF_AUTH_ANONYMOUS_ENABLED\n              value:\"true\"\n            - name:GF_AUTH_ANONYMOUS_ORG_ROLE\n              value:Admin\n            - name:GF_SERVER_ROOT_URL\n              value:/api/v1/proxy/namespace/kube-system/services/monitoring-grafana/\n          volumeMounts:\n            - name:grafana-persistent-storage\n              mountPath:/var\n      volumes:\n        - name:influxdb-persistent-storage\n          emptyDir{}\n        - name:grafana-persistent-storage\n          emptyDir{}\n```\n\n#### 2.3.2. heapster-controller\n\n**heapster-controller.yaml**\n\n```yaml\napiVersion:v1\nkind:ReplicationController\nmetadata:\n    labels:\n        k8s-app:heapster\n        name:heapster\n        version:v6\n    name:heapster\n    namespace:kube-system\nspec:\n    replicas:1\n    selector:\n        name:heapster\n        k8s-app:heapster\n        version:v6\n    template:\n        metadata:\n            labels:\n                k8s-app:heapster\n                version:v6\n        spec:\n            containers:\n                - image:gcr.io/google_containers/heapster:v0.17.0\n                  name:heapster\n                  command:\n                    - /heapster\n                    - --source=kubernetes:http://192.168.1.128:8080?inClusterConfig=flase&kubeletHttps=true&useServiceAccount=true&auth=\n                    - --sink=InfluxDB:http://monitoring-InfluxDB:8086\n```\n\nHeapster设置启动参数说明：\n\n1、–source\n\n配置监控来源，本例中表示从k8s-Master获取各个Node的信息。在URL的参数部分，修改kubeletHttps、inClusterConfig、useServiceAccount的值。\n\n2、–sink\n\n配置后端的存储系统，本例中使用InfluxDB。URL中主机名的地址是InfluxDB的Service名字，需要DNS服务正常工作，如果没有配置DNS服务可使用Service的ClusterIP地址。\n\n#### 2.3.3. 创建ReplicationController\n\n```shell\nkubelet create -f InfluxDB-Grafana-controller.yaml\nkubelet create -f heapster-controller.yaml\n```\n\n## 3. 查看界面及数据\n\n### 3.1. InfluxDB\n\n访问任意一台Node机器的30083端口。\n\n### 3.2. Grafana\n\n访问任意一台Node机器的30080端口。\n\n## 4. 容器化部署\n\n### 4.1. 拉取镜像\n\n```shell\ndocker pull registry.wae.haplat.net/test/influxdb:1.0.0\ndocker pull registry.wae.haplat.net/test/cadvisor:latest\ndocker pull registry.wae.haplat.net/test/grafana:latest\ndocker pull registry.wae.haplat.net/test/heapster:latest\n```\n\n### 4.2. 运行容器\n\n#### 4.2.1. influxdb\n\n```shell\n#influxdb\ndocker run -d -p 8083:8083 -p 8086:8086 --expose 8090 --expose 8099 --volume=/opt/data/influxdb:/data --name influxsrv registry.wae.haplat.net/test/influxdb:1.0.0\n```\n\n#### 4.2.2. cadvisor\n\n```shell\n#cadvisor\ndocker run --volume=/:/rootfs:ro --volume=/var/run:/var/run:rw --volume=/sys:/sys:ro --volume=/var/lib/docker/:/var/lib/docker:ro --publish=8080:8080 --detach=true --link influxsrv:influxsrv --name=cadvisor registry.wae.haplat.net/test/cadvisor:latest -storage_driver=influxdb -storage_driver_db=cadvisor -storage_driver_host=influxsrv:8086\n```\n\n#### 4.2.3. grafana\n\n```shell\n#grafana\ndocker run -d -p 3000:3000 -e INFLUXDB_HOST=influxsrv -e INFLUXDB_PORT=8086 -e INFLUXDB_NAME=cadvisor -e INFLUXDB_USER=root -e INFLUXDB_PASS=root --link influxsrv:influxsrv --name grafana registry.wae.haplat.net/test/grafana:latest\n```\n\n#### 4.2.4. heapster\n\n```shell\ndocker run -d -p 8082:8082 --net=host heapster:canary --source=kubernetes:http://`k8s-server-ip`:8080?inClusterConfig=false/&useServiceAccount=false --sink=influxdb:http://`influxdb-ip`:8086\n```\n\n### 4.3. 访问\n\n在浏览器输入`IP`:`PORT`\n\n ","slug":"Kubernetes/监控/k8s集群监控","published":1,"updated":"2017-10-02T11:49:53.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740ma001q30vugqj7g1e4","content":"<h2><span id=\"1-概述\">1. 概述</span></h2>\n<h3><span id=\"11-cadvisor\">1.1. cAdvisor</span></h3>\n<p>cAdvisor对Node机器上的资源及容器进行实时监控和性能数据采集，包括CPU使用情况、内存使用情况、网络吞吐量及文件系统使用情况，cAdvisor集成在Kubelet中，当kubelet启动时会自动启动cAdvisor，即一个cAdvisor仅对一台Node机器进行监控。kubelet的启动参数–cadvisor-port可以定义cAdvisor对外提供服务的端口，默认为4194。可以通过浏览器<code>Node_IP:port</code>访问。项目主页：<a href=\"http://github.com/google/cadvisor%E3%80%82\" target=\"_blank\" rel=\"external\">http://github.com/google/cadvisor。</a></p>\n<h3><span id=\"12-heapster\">1.2. Heapster</span></h3>\n<p>是对集群中的各个Node、Pod的资源使用数据进行采集，通过访问每个Node上Kubelet的API，再通过Kubelet调用cAdvisor的API来采集该节点上所有容器的性能数据。由Heapster进行数据汇聚，保存到后端存储系统中，例如InfluxDB，Google Cloud Logging等。项目主页为：<a href=\"https://github.com/kubernetes/heapster%E3%80%82\" target=\"_blank\" rel=\"external\">https://github.com/kubernetes/heapster。</a></p>\n<h3><span id=\"13-influxdb\">1.3. InfluxDB</span></h3>\n<p>是分布式时序数据库（每条记录带有时间戳属性），主要用于实时数据采集、事件跟踪记录、存储时间图表、原始数据等。提供REST API用于数据的存储和查询。项目主页为http://InfluxDB.com。</p>\n<h3><span id=\"14-grafana\">1.4. Grafana</span></h3>\n<p>通过Dashboard将InfluxDB的时序数据展现成图表形式，便于查看集群运行状态。项目主页为http://Grafana.org。</p>\n<h3><span id=\"15-总体架构图\">1.5. 总体架构图</span></h3>\n<p><img src=\"/img/article/kubernetes/%E7%9B%91%E6%8E%A7/k8s%E7%9B%91%E6%8E%A7%E6%9E%B6%E6%9E%84%E5%9B%BE.png\" alt=\"k8s监控架构图\"></p>\n<p>其中当前Kubernetes中，Heapster、InfluxDB、Grafana均以Pod的形式启动和运行。Heapster与Master需配置安全连接。</p>\n<h2><span id=\"2-部署与使用\">2. 部署与使用</span></h2>\n<h3><span id=\"21-cadvisor\">2.1. cAdvisor</span></h3>\n<p>kubelet的启动参数–cadvisor-port可以定义cAdvisor对外提供服务的端口，默认为4194。可以通过浏览器<code>Node_IP:port</code>访问。也提供了REST API供客户端远程调用，API返回的格式为JSON，可以采用URL访问：http://<code>hostname</code>:<code>port</code>/api/<code>version</code>/<code>request</code>/</p>\n<p>例如：<a href=\"http://14.152.49.100:4194/api/v1.3/machine\" target=\"_blank\" rel=\"external\">http://14.152.49.100:4194/api/v1.3/machine</a> 获取主机信息。</p>\n<h3><span id=\"22-service\">2.2. Service</span></h3>\n<h4><span id=\"221-heapster-service\">2.2.1. heapster-service</span></h4>\n<p><strong>heapster-service.yaml</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">apiVersion:</span><span class=\"string\">v1</span></div><div class=\"line\"><span class=\"attr\">kind:</span><span class=\"string\">Service</span></div><div class=\"line\"><span class=\"attr\">metadata:</span></div><div class=\"line\"><span class=\"attr\">  label:</span></div><div class=\"line\">    <span class=\"string\">kubenetes.io/cluster-service:\"true\"</span></div><div class=\"line\">    <span class=\"string\">kubernetes.io/name:Heapster</span></div><div class=\"line\"><span class=\"attr\">  name:</span><span class=\"string\">heapster</span></div><div class=\"line\"><span class=\"attr\">  namespace:</span><span class=\"string\">kube-system</span></div><div class=\"line\"><span class=\"attr\">spec:</span></div><div class=\"line\"><span class=\"attr\">  ports:</span></div><div class=\"line\"><span class=\"attr\">    - port:</span><span class=\"number\">80</span></div><div class=\"line\"><span class=\"attr\">      targetPort:</span><span class=\"number\">8082</span></div><div class=\"line\"><span class=\"attr\">  selector:</span></div><div class=\"line\"><span class=\"attr\">    k8s-app:</span><span class=\"string\">heapster</span></div></pre></td></tr></table></figure>\n<h4><span id=\"222-influxdb-service\">2.2.2. influxdb-service</span></h4>\n<p><strong>influxdb-service.yaml</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">apiVersion:</span><span class=\"string\">v1</span></div><div class=\"line\"><span class=\"attr\">kind:</span><span class=\"string\">Service</span></div><div class=\"line\"><span class=\"attr\">metadata:</span></div><div class=\"line\"><span class=\"attr\">  label:</span><span class=\"literal\">null</span></div><div class=\"line\"><span class=\"attr\">  name:</span><span class=\"string\">monitoring-InfluxDB</span></div><div class=\"line\"><span class=\"attr\">  namespace:</span><span class=\"string\">kube-system</span></div><div class=\"line\"><span class=\"attr\">spec:</span></div><div class=\"line\"><span class=\"attr\">  type:</span><span class=\"string\">Nodeport</span></div><div class=\"line\"><span class=\"attr\">  ports:</span></div><div class=\"line\"><span class=\"attr\">    - name:</span><span class=\"string\">http</span></div><div class=\"line\"><span class=\"attr\">      port:</span><span class=\"number\">80</span></div><div class=\"line\"><span class=\"attr\">      targetPort:</span><span class=\"number\">8083</span></div><div class=\"line\"><span class=\"attr\">    - name:</span><span class=\"string\">api</span></div><div class=\"line\"><span class=\"attr\">      port:</span><span class=\"number\">8086</span></div><div class=\"line\"><span class=\"attr\">      targetPort:</span><span class=\"number\">8086</span></div><div class=\"line\"><span class=\"attr\">      Nodeport:</span><span class=\"number\">8086</span></div><div class=\"line\"><span class=\"attr\">  selector:</span></div><div class=\"line\"><span class=\"attr\">    name:</span><span class=\"string\">influxGrafana</span></div></pre></td></tr></table></figure>\n<h4><span id=\"223-grafana-service\">2.2.3. grafana-service</span></h4>\n<p><strong>grafana-service.yaml</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">apiVersion:</span><span class=\"string\">v1</span></div><div class=\"line\"><span class=\"attr\">kind:</span><span class=\"string\">Service</span></div><div class=\"line\"><span class=\"attr\">metadata:</span></div><div class=\"line\"><span class=\"attr\">  label:</span></div><div class=\"line\">    <span class=\"string\">kubenetes.io/cluster-service:\"true\"</span></div><div class=\"line\">    <span class=\"string\">kubernetes.io/name:monitoring-Grafana</span></div><div class=\"line\"><span class=\"attr\">  name:</span><span class=\"string\">monitoring-Grafana</span></div><div class=\"line\"><span class=\"attr\">  namespace:</span><span class=\"string\">kube-system</span></div><div class=\"line\"><span class=\"attr\">spec:</span></div><div class=\"line\"><span class=\"attr\">  type:</span><span class=\"string\">Nodeport</span></div><div class=\"line\"><span class=\"attr\">  ports:</span></div><div class=\"line\"><span class=\"attr\">      port:</span><span class=\"number\">80</span></div><div class=\"line\"><span class=\"attr\">      targetPort:</span><span class=\"number\">8080</span></div><div class=\"line\"><span class=\"attr\">      Nodeport:</span><span class=\"number\">8085</span></div><div class=\"line\"><span class=\"attr\">  selector:</span></div><div class=\"line\"><span class=\"attr\">    name:</span><span class=\"string\">influxGrafana</span></div></pre></td></tr></table></figure>\n<p>使用type=NodePort将InfluxDB和Grafana暴露在Node的端口上，以便通过浏览器进行访问。</p>\n<h4><span id=\"224-创建service\">2.2.4. 创建service</span></h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl create -f heapster-service.yaml</div><div class=\"line\">kubectl create -f InfluxDB-service.yaml</div><div class=\"line\">kubectl create -f Grafana-service.yaml</div></pre></td></tr></table></figure>\n<h3><span id=\"23-replicationcontroller\">2.3. ReplicationController</span></h3>\n<h4><span id=\"231-influxdb-grafana-controller\">2.3.1. influxdb-grafana-controller</span></h4>\n<p><strong>influxdb-grafana-controller-v3.yaml</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">apiVersion:</span><span class=\"string\">v1</span></div><div class=\"line\"><span class=\"attr\">kind:</span><span class=\"string\">ReplicationController</span></div><div class=\"line\"><span class=\"attr\">metadata:</span></div><div class=\"line\"><span class=\"attr\">  name:</span><span class=\"string\">monitoring-influxdb-grafana-v3</span></div><div class=\"line\"><span class=\"attr\">  namespace:</span><span class=\"string\">kube-system</span></div><div class=\"line\"><span class=\"attr\">  labels:</span></div><div class=\"line\"><span class=\"attr\">    k8s-app:</span><span class=\"string\">influxGrafana</span></div><div class=\"line\"><span class=\"attr\">    version:</span><span class=\"string\">v3</span></div><div class=\"line\">    <span class=\"string\">kubernetes.io/cluster-service:\"true</span></div><div class=\"line\"><span class=\"attr\">spec:</span></div><div class=\"line\"><span class=\"attr\">  replicas:</span><span class=\"number\">1</span></div><div class=\"line\"><span class=\"attr\">  selector:</span></div><div class=\"line\"><span class=\"attr\">    k8s-app:</span><span class=\"string\">influxGrafana</span></div><div class=\"line\"><span class=\"attr\">    version:</span><span class=\"string\">v3</span></div><div class=\"line\"><span class=\"attr\">  template:</span></div><div class=\"line\"><span class=\"attr\">    metadata:</span></div><div class=\"line\"><span class=\"attr\">      labels:</span></div><div class=\"line\"><span class=\"attr\">        k8s-app:</span><span class=\"string\">influxGrafana</span></div><div class=\"line\"><span class=\"attr\">        version:</span><span class=\"string\">v3</span></div><div class=\"line\">        <span class=\"string\">kubernetes.io/cluster-service:\"true</span></div><div class=\"line\"><span class=\"attr\">    spec:</span></div><div class=\"line\"><span class=\"attr\">      containers:</span></div><div class=\"line\"><span class=\"attr\">        - image:</span><span class=\"string\">gcr.io/google_containers/heapster_influxdb:v0.5</span></div><div class=\"line\"><span class=\"attr\">          name:</span><span class=\"string\">influxdb</span></div><div class=\"line\"><span class=\"attr\">          resources:</span></div><div class=\"line\"><span class=\"attr\">            limits:</span></div><div class=\"line\"><span class=\"attr\">              cpu:</span><span class=\"number\">100</span><span class=\"string\">m</span></div><div class=\"line\"><span class=\"attr\">              memory:</span><span class=\"number\">500</span><span class=\"string\">Mi</span></div><div class=\"line\"><span class=\"attr\">            requests:</span></div><div class=\"line\"><span class=\"attr\">              cpu:</span><span class=\"number\">100</span><span class=\"string\">m</span></div><div class=\"line\"><span class=\"attr\">              memory:</span><span class=\"number\">500</span><span class=\"string\">Mi</span></div><div class=\"line\"><span class=\"attr\">          ports:</span></div><div class=\"line\"><span class=\"attr\">            - containerPort:</span><span class=\"number\">8083</span></div><div class=\"line\"><span class=\"attr\">            - containerPort:</span><span class=\"number\">8086</span></div><div class=\"line\"><span class=\"attr\">          volumeMounts:</span></div><div class=\"line\"><span class=\"attr\">            -name:</span><span class=\"string\">influxdb-persistent-storage</span></div><div class=\"line\"><span class=\"attr\">             mountPath:</span><span class=\"string\">/data</span></div><div class=\"line\"><span class=\"attr\">        - image:</span><span class=\"string\">grc.io/google_containers/heapster_grafana:v2.6.0-2</span></div><div class=\"line\"><span class=\"attr\">          name:</span><span class=\"string\">grafana</span></div><div class=\"line\"><span class=\"attr\">          resources:</span></div><div class=\"line\"><span class=\"attr\">            limits:</span></div><div class=\"line\"><span class=\"attr\">              cpu:</span><span class=\"number\">100</span><span class=\"string\">m</span></div><div class=\"line\"><span class=\"attr\">              memory:</span><span class=\"number\">100</span><span class=\"string\">Mi</span></div><div class=\"line\"><span class=\"attr\">            requests:</span></div><div class=\"line\"><span class=\"attr\">              cpu:</span><span class=\"number\">100</span><span class=\"string\">m</span></div><div class=\"line\"><span class=\"attr\">              memory:</span><span class=\"number\">100</span><span class=\"string\">Mi</span></div><div class=\"line\"><span class=\"attr\">          env:</span></div><div class=\"line\"><span class=\"attr\">            - name:</span><span class=\"string\">INFLUXDB_SERVICE_URL</span></div><div class=\"line\"><span class=\"attr\">              value:</span><span class=\"attr\">http://monitoring-influxdb:8086</span></div><div class=\"line\"><span class=\"attr\">            - name:</span><span class=\"string\">GF_AUTH_BASIC_ENABLED</span></div><div class=\"line\"><span class=\"attr\">              value:</span><span class=\"string\">\"false\"</span></div><div class=\"line\"><span class=\"attr\">            - name:</span><span class=\"string\">GF_AUTH_ANONYMOUS_ENABLED</span></div><div class=\"line\"><span class=\"attr\">              value:</span><span class=\"string\">\"true\"</span></div><div class=\"line\"><span class=\"attr\">            - name:</span><span class=\"string\">GF_AUTH_ANONYMOUS_ORG_ROLE</span></div><div class=\"line\"><span class=\"attr\">              value:</span><span class=\"string\">Admin</span></div><div class=\"line\"><span class=\"attr\">            - name:</span><span class=\"string\">GF_SERVER_ROOT_URL</span></div><div class=\"line\"><span class=\"attr\">              value:</span><span class=\"string\">/api/v1/proxy/namespace/kube-system/services/monitoring-grafana/</span></div><div class=\"line\"><span class=\"attr\">          volumeMounts:</span></div><div class=\"line\"><span class=\"attr\">            - name:</span><span class=\"string\">grafana-persistent-storage</span></div><div class=\"line\"><span class=\"attr\">              mountPath:</span><span class=\"string\">/var</span></div><div class=\"line\"><span class=\"attr\">      volumes:</span></div><div class=\"line\"><span class=\"attr\">        - name:</span><span class=\"string\">influxdb-persistent-storage</span></div><div class=\"line\">          <span class=\"string\">emptyDir&#123;&#125;</span></div><div class=\"line\"><span class=\"attr\">        - name:</span><span class=\"string\">grafana-persistent-storage</span></div><div class=\"line\">          <span class=\"string\">emptyDir&#123;&#125;</span></div></pre></td></tr></table></figure>\n<h4><span id=\"232-heapster-controller\">2.3.2. heapster-controller</span></h4>\n<p><strong>heapster-controller.yaml</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">apiVersion:</span><span class=\"string\">v1</span></div><div class=\"line\"><span class=\"attr\">kind:</span><span class=\"string\">ReplicationController</span></div><div class=\"line\"><span class=\"attr\">metadata:</span></div><div class=\"line\"><span class=\"attr\">    labels:</span></div><div class=\"line\"><span class=\"attr\">        k8s-app:</span><span class=\"string\">heapster</span></div><div class=\"line\"><span class=\"attr\">        name:</span><span class=\"string\">heapster</span></div><div class=\"line\"><span class=\"attr\">        version:</span><span class=\"string\">v6</span></div><div class=\"line\"><span class=\"attr\">    name:</span><span class=\"string\">heapster</span></div><div class=\"line\"><span class=\"attr\">    namespace:</span><span class=\"string\">kube-system</span></div><div class=\"line\"><span class=\"attr\">spec:</span></div><div class=\"line\"><span class=\"attr\">    replicas:</span><span class=\"number\">1</span></div><div class=\"line\"><span class=\"attr\">    selector:</span></div><div class=\"line\"><span class=\"attr\">        name:</span><span class=\"string\">heapster</span></div><div class=\"line\"><span class=\"attr\">        k8s-app:</span><span class=\"string\">heapster</span></div><div class=\"line\"><span class=\"attr\">        version:</span><span class=\"string\">v6</span></div><div class=\"line\"><span class=\"attr\">    template:</span></div><div class=\"line\"><span class=\"attr\">        metadata:</span></div><div class=\"line\"><span class=\"attr\">            labels:</span></div><div class=\"line\"><span class=\"attr\">                k8s-app:</span><span class=\"string\">heapster</span></div><div class=\"line\"><span class=\"attr\">                version:</span><span class=\"string\">v6</span></div><div class=\"line\"><span class=\"attr\">        spec:</span></div><div class=\"line\"><span class=\"attr\">            containers:</span></div><div class=\"line\"><span class=\"attr\">                - image:</span><span class=\"string\">gcr.io/google_containers/heapster:v0.17.0</span></div><div class=\"line\"><span class=\"attr\">                  name:</span><span class=\"string\">heapster</span></div><div class=\"line\"><span class=\"attr\">                  command:</span></div><div class=\"line\"><span class=\"bullet\">                    -</span> <span class=\"string\">/heapster</span></div><div class=\"line\"><span class=\"bullet\">                    -</span> <span class=\"bullet\">--source=kubernetes:http://192.168.1.128:8080?inClusterConfig=flase&amp;kubeletHttps=true&amp;useServiceAccount=true&amp;auth=</span></div><div class=\"line\"><span class=\"bullet\">                    -</span> <span class=\"bullet\">--sink=InfluxDB:http://monitoring-InfluxDB:8086</span></div></pre></td></tr></table></figure>\n<p>Heapster设置启动参数说明：</p>\n<p>1、–source</p>\n<p>配置监控来源，本例中表示从k8s-Master获取各个Node的信息。在URL的参数部分，修改kubeletHttps、inClusterConfig、useServiceAccount的值。</p>\n<p>2、–sink</p>\n<p>配置后端的存储系统，本例中使用InfluxDB。URL中主机名的地址是InfluxDB的Service名字，需要DNS服务正常工作，如果没有配置DNS服务可使用Service的ClusterIP地址。</p>\n<h4><span id=\"233-创建replicationcontroller\">2.3.3. 创建ReplicationController</span></h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubelet create -f InfluxDB-Grafana-controller.yaml</div><div class=\"line\">kubelet create -f heapster-controller.yaml</div></pre></td></tr></table></figure>\n<h2><span id=\"3-查看界面及数据\">3. 查看界面及数据</span></h2>\n<h3><span id=\"31-influxdb\">3.1. InfluxDB</span></h3>\n<p>访问任意一台Node机器的30083端口。</p>\n<h3><span id=\"32-grafana\">3.2. Grafana</span></h3>\n<p>访问任意一台Node机器的30080端口。</p>\n<h2><span id=\"4-容器化部署\">4. 容器化部署</span></h2>\n<h3><span id=\"41-拉取镜像\">4.1. 拉取镜像</span></h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker pull registry.wae.haplat.net/test/influxdb:1.0.0</div><div class=\"line\">docker pull registry.wae.haplat.net/test/cadvisor:latest</div><div class=\"line\">docker pull registry.wae.haplat.net/test/grafana:latest</div><div class=\"line\">docker pull registry.wae.haplat.net/test/heapster:latest</div></pre></td></tr></table></figure>\n<h3><span id=\"42-运行容器\">4.2. 运行容器</span></h3>\n<h4><span id=\"421-influxdb\">4.2.1. influxdb</span></h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">influxdb</span></div><div class=\"line\">docker run -d -p 8083:8083 -p 8086:8086 --expose 8090 --expose 8099 --volume=/opt/data/influxdb:/data --name influxsrv registry.wae.haplat.net/test/influxdb:1.0.0</div></pre></td></tr></table></figure>\n<h4><span id=\"422-cadvisor\">4.2.2. cadvisor</span></h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">cadvisor</span></div><div class=\"line\">docker run --volume=/:/rootfs:ro --volume=/var/run:/var/run:rw --volume=/sys:/sys:ro --volume=/var/lib/docker/:/var/lib/docker:ro --publish=8080:8080 --detach=true --link influxsrv:influxsrv --name=cadvisor registry.wae.haplat.net/test/cadvisor:latest -storage_driver=influxdb -storage_driver_db=cadvisor -storage_driver_host=influxsrv:8086</div></pre></td></tr></table></figure>\n<h4><span id=\"423-grafana\">4.2.3. grafana</span></h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">grafana</span></div><div class=\"line\">docker run -d -p 3000:3000 -e INFLUXDB_HOST=influxsrv -e INFLUXDB_PORT=8086 -e INFLUXDB_NAME=cadvisor -e INFLUXDB_USER=root -e INFLUXDB_PASS=root --link influxsrv:influxsrv --name grafana registry.wae.haplat.net/test/grafana:latest</div></pre></td></tr></table></figure>\n<h4><span id=\"424-heapster\">4.2.4. heapster</span></h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker run -d -p 8082:8082 --net=host heapster:canary --source=kubernetes:http://`k8s-server-ip`:8080?inClusterConfig=false/&amp;useServiceAccount=false --sink=influxdb:http://`influxdb-ip`:8086</div></pre></td></tr></table></figure>\n<h3><span id=\"43-访问\">4.3. 访问</span></h3>\n<p>在浏览器输入<code>IP</code>:<code>PORT</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 概述</h2>\n<h3>1.1. cAdvisor</h3>\n<p>cAdvisor对Node机器上的资源及容器进行实时监控和性能数据采集，包括CPU使用情况、内存使用情况、网络吞吐量及文件系统使用情况，cAdvisor集成在Kubelet中，当kubelet启动时会自动启动cAdvisor，即一个cAdvisor仅对一台Node机器进行监控。kubelet的启动参数–cadvisor-port可以定义cAdvisor对外提供服务的端口，默认为4194。可以通过浏览器<code>Node_IP:port</code>访问。项目主页：<a href=\"http://github.com/google/cadvisor%E3%80%82\" target=\"_blank\" rel=\"external\">http://github.com/google/cadvisor。</a></p>\n<h3>1.2. Heapster</h3>\n<p>是对集群中的各个Node、Pod的资源使用数据进行采集，通过访问每个Node上Kubelet的API，再通过Kubelet调用cAdvisor的API来采集该节点上所有容器的性能数据。由Heapster进行数据汇聚，保存到后端存储系统中，例如InfluxDB，Google Cloud Logging等。项目主页为：<a href=\"https://github.com/kubernetes/heapster%E3%80%82\" target=\"_blank\" rel=\"external\">https://github.com/kubernetes/heapster。</a></p>\n<h3>1.3. InfluxDB</h3>\n<p>是分布式时序数据库（每条记录带有时间戳属性），主要用于实时数据采集、事件跟踪记录、存储时间图表、原始数据等。提供REST API用于数据的存储和查询。项目主页为http://InfluxDB.com。</p>\n<h3>1.4. Grafana</h3>\n<p>通过Dashboard将InfluxDB的时序数据展现成图表形式，便于查看集群运行状态。项目主页为http://Grafana.org。</p>\n<h3>1.5. 总体架构图</h3>\n<p><img src=\"/img/article/kubernetes/%E7%9B%91%E6%8E%A7/k8s%E7%9B%91%E6%8E%A7%E6%9E%B6%E6%9E%84%E5%9B%BE.png\" alt=\"k8s监控架构图\"></p>\n<p>其中当前Kubernetes中，Heapster、InfluxDB、Grafana均以Pod的形式启动和运行。Heapster与Master需配置安全连接。</p>\n<h2>2. 部署与使用</h2>\n<h3>2.1. cAdvisor</h3>\n<p>kubelet的启动参数–cadvisor-port可以定义cAdvisor对外提供服务的端口，默认为4194。可以通过浏览器<code>Node_IP:port</code>访问。也提供了REST API供客户端远程调用，API返回的格式为JSON，可以采用URL访问：http://<code>hostname</code>:<code>port</code>/api/<code>version</code>/<code>request</code>/</p>\n<p>例如：<a href=\"http://14.152.49.100:4194/api/v1.3/machine\" target=\"_blank\" rel=\"external\">http://14.152.49.100:4194/api/v1.3/machine</a> 获取主机信息。</p>\n<h3>2.2. Service</h3>\n<h4>2.2.1. heapster-service</h4>\n<p><strong>heapster-service.yaml</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">apiVersion:</span><span class=\"string\">v1</span></div><div class=\"line\"><span class=\"attr\">kind:</span><span class=\"string\">Service</span></div><div class=\"line\"><span class=\"attr\">metadata:</span></div><div class=\"line\"><span class=\"attr\">  label:</span></div><div class=\"line\">    <span class=\"string\">kubenetes.io/cluster-service:\"true\"</span></div><div class=\"line\">    <span class=\"string\">kubernetes.io/name:Heapster</span></div><div class=\"line\"><span class=\"attr\">  name:</span><span class=\"string\">heapster</span></div><div class=\"line\"><span class=\"attr\">  namespace:</span><span class=\"string\">kube-system</span></div><div class=\"line\"><span class=\"attr\">spec:</span></div><div class=\"line\"><span class=\"attr\">  ports:</span></div><div class=\"line\"><span class=\"attr\">    - port:</span><span class=\"number\">80</span></div><div class=\"line\"><span class=\"attr\">      targetPort:</span><span class=\"number\">8082</span></div><div class=\"line\"><span class=\"attr\">  selector:</span></div><div class=\"line\"><span class=\"attr\">    k8s-app:</span><span class=\"string\">heapster</span></div></pre></td></tr></table></figure>\n<h4>2.2.2. influxdb-service</h4>\n<p><strong>influxdb-service.yaml</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">apiVersion:</span><span class=\"string\">v1</span></div><div class=\"line\"><span class=\"attr\">kind:</span><span class=\"string\">Service</span></div><div class=\"line\"><span class=\"attr\">metadata:</span></div><div class=\"line\"><span class=\"attr\">  label:</span><span class=\"literal\">null</span></div><div class=\"line\"><span class=\"attr\">  name:</span><span class=\"string\">monitoring-InfluxDB</span></div><div class=\"line\"><span class=\"attr\">  namespace:</span><span class=\"string\">kube-system</span></div><div class=\"line\"><span class=\"attr\">spec:</span></div><div class=\"line\"><span class=\"attr\">  type:</span><span class=\"string\">Nodeport</span></div><div class=\"line\"><span class=\"attr\">  ports:</span></div><div class=\"line\"><span class=\"attr\">    - name:</span><span class=\"string\">http</span></div><div class=\"line\"><span class=\"attr\">      port:</span><span class=\"number\">80</span></div><div class=\"line\"><span class=\"attr\">      targetPort:</span><span class=\"number\">8083</span></div><div class=\"line\"><span class=\"attr\">    - name:</span><span class=\"string\">api</span></div><div class=\"line\"><span class=\"attr\">      port:</span><span class=\"number\">8086</span></div><div class=\"line\"><span class=\"attr\">      targetPort:</span><span class=\"number\">8086</span></div><div class=\"line\"><span class=\"attr\">      Nodeport:</span><span class=\"number\">8086</span></div><div class=\"line\"><span class=\"attr\">  selector:</span></div><div class=\"line\"><span class=\"attr\">    name:</span><span class=\"string\">influxGrafana</span></div></pre></td></tr></table></figure>\n<h4>2.2.3. grafana-service</h4>\n<p><strong>grafana-service.yaml</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">apiVersion:</span><span class=\"string\">v1</span></div><div class=\"line\"><span class=\"attr\">kind:</span><span class=\"string\">Service</span></div><div class=\"line\"><span class=\"attr\">metadata:</span></div><div class=\"line\"><span class=\"attr\">  label:</span></div><div class=\"line\">    <span class=\"string\">kubenetes.io/cluster-service:\"true\"</span></div><div class=\"line\">    <span class=\"string\">kubernetes.io/name:monitoring-Grafana</span></div><div class=\"line\"><span class=\"attr\">  name:</span><span class=\"string\">monitoring-Grafana</span></div><div class=\"line\"><span class=\"attr\">  namespace:</span><span class=\"string\">kube-system</span></div><div class=\"line\"><span class=\"attr\">spec:</span></div><div class=\"line\"><span class=\"attr\">  type:</span><span class=\"string\">Nodeport</span></div><div class=\"line\"><span class=\"attr\">  ports:</span></div><div class=\"line\"><span class=\"attr\">      port:</span><span class=\"number\">80</span></div><div class=\"line\"><span class=\"attr\">      targetPort:</span><span class=\"number\">8080</span></div><div class=\"line\"><span class=\"attr\">      Nodeport:</span><span class=\"number\">8085</span></div><div class=\"line\"><span class=\"attr\">  selector:</span></div><div class=\"line\"><span class=\"attr\">    name:</span><span class=\"string\">influxGrafana</span></div></pre></td></tr></table></figure>\n<p>使用type=NodePort将InfluxDB和Grafana暴露在Node的端口上，以便通过浏览器进行访问。</p>\n<h4>2.2.4. 创建service</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubectl create -f heapster-service.yaml</div><div class=\"line\">kubectl create -f InfluxDB-service.yaml</div><div class=\"line\">kubectl create -f Grafana-service.yaml</div></pre></td></tr></table></figure>\n<h3>2.3. ReplicationController</h3>\n<h4>2.3.1. influxdb-grafana-controller</h4>\n<p><strong>influxdb-grafana-controller-v3.yaml</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">apiVersion:</span><span class=\"string\">v1</span></div><div class=\"line\"><span class=\"attr\">kind:</span><span class=\"string\">ReplicationController</span></div><div class=\"line\"><span class=\"attr\">metadata:</span></div><div class=\"line\"><span class=\"attr\">  name:</span><span class=\"string\">monitoring-influxdb-grafana-v3</span></div><div class=\"line\"><span class=\"attr\">  namespace:</span><span class=\"string\">kube-system</span></div><div class=\"line\"><span class=\"attr\">  labels:</span></div><div class=\"line\"><span class=\"attr\">    k8s-app:</span><span class=\"string\">influxGrafana</span></div><div class=\"line\"><span class=\"attr\">    version:</span><span class=\"string\">v3</span></div><div class=\"line\">    <span class=\"string\">kubernetes.io/cluster-service:\"true</span></div><div class=\"line\"><span class=\"attr\">spec:</span></div><div class=\"line\"><span class=\"attr\">  replicas:</span><span class=\"number\">1</span></div><div class=\"line\"><span class=\"attr\">  selector:</span></div><div class=\"line\"><span class=\"attr\">    k8s-app:</span><span class=\"string\">influxGrafana</span></div><div class=\"line\"><span class=\"attr\">    version:</span><span class=\"string\">v3</span></div><div class=\"line\"><span class=\"attr\">  template:</span></div><div class=\"line\"><span class=\"attr\">    metadata:</span></div><div class=\"line\"><span class=\"attr\">      labels:</span></div><div class=\"line\"><span class=\"attr\">        k8s-app:</span><span class=\"string\">influxGrafana</span></div><div class=\"line\"><span class=\"attr\">        version:</span><span class=\"string\">v3</span></div><div class=\"line\">        <span class=\"string\">kubernetes.io/cluster-service:\"true</span></div><div class=\"line\"><span class=\"attr\">    spec:</span></div><div class=\"line\"><span class=\"attr\">      containers:</span></div><div class=\"line\"><span class=\"attr\">        - image:</span><span class=\"string\">gcr.io/google_containers/heapster_influxdb:v0.5</span></div><div class=\"line\"><span class=\"attr\">          name:</span><span class=\"string\">influxdb</span></div><div class=\"line\"><span class=\"attr\">          resources:</span></div><div class=\"line\"><span class=\"attr\">            limits:</span></div><div class=\"line\"><span class=\"attr\">              cpu:</span><span class=\"number\">100</span><span class=\"string\">m</span></div><div class=\"line\"><span class=\"attr\">              memory:</span><span class=\"number\">500</span><span class=\"string\">Mi</span></div><div class=\"line\"><span class=\"attr\">            requests:</span></div><div class=\"line\"><span class=\"attr\">              cpu:</span><span class=\"number\">100</span><span class=\"string\">m</span></div><div class=\"line\"><span class=\"attr\">              memory:</span><span class=\"number\">500</span><span class=\"string\">Mi</span></div><div class=\"line\"><span class=\"attr\">          ports:</span></div><div class=\"line\"><span class=\"attr\">            - containerPort:</span><span class=\"number\">8083</span></div><div class=\"line\"><span class=\"attr\">            - containerPort:</span><span class=\"number\">8086</span></div><div class=\"line\"><span class=\"attr\">          volumeMounts:</span></div><div class=\"line\"><span class=\"attr\">            -name:</span><span class=\"string\">influxdb-persistent-storage</span></div><div class=\"line\"><span class=\"attr\">             mountPath:</span><span class=\"string\">/data</span></div><div class=\"line\"><span class=\"attr\">        - image:</span><span class=\"string\">grc.io/google_containers/heapster_grafana:v2.6.0-2</span></div><div class=\"line\"><span class=\"attr\">          name:</span><span class=\"string\">grafana</span></div><div class=\"line\"><span class=\"attr\">          resources:</span></div><div class=\"line\"><span class=\"attr\">            limits:</span></div><div class=\"line\"><span class=\"attr\">              cpu:</span><span class=\"number\">100</span><span class=\"string\">m</span></div><div class=\"line\"><span class=\"attr\">              memory:</span><span class=\"number\">100</span><span class=\"string\">Mi</span></div><div class=\"line\"><span class=\"attr\">            requests:</span></div><div class=\"line\"><span class=\"attr\">              cpu:</span><span class=\"number\">100</span><span class=\"string\">m</span></div><div class=\"line\"><span class=\"attr\">              memory:</span><span class=\"number\">100</span><span class=\"string\">Mi</span></div><div class=\"line\"><span class=\"attr\">          env:</span></div><div class=\"line\"><span class=\"attr\">            - name:</span><span class=\"string\">INFLUXDB_SERVICE_URL</span></div><div class=\"line\"><span class=\"attr\">              value:</span><span class=\"attr\">http://monitoring-influxdb:8086</span></div><div class=\"line\"><span class=\"attr\">            - name:</span><span class=\"string\">GF_AUTH_BASIC_ENABLED</span></div><div class=\"line\"><span class=\"attr\">              value:</span><span class=\"string\">\"false\"</span></div><div class=\"line\"><span class=\"attr\">            - name:</span><span class=\"string\">GF_AUTH_ANONYMOUS_ENABLED</span></div><div class=\"line\"><span class=\"attr\">              value:</span><span class=\"string\">\"true\"</span></div><div class=\"line\"><span class=\"attr\">            - name:</span><span class=\"string\">GF_AUTH_ANONYMOUS_ORG_ROLE</span></div><div class=\"line\"><span class=\"attr\">              value:</span><span class=\"string\">Admin</span></div><div class=\"line\"><span class=\"attr\">            - name:</span><span class=\"string\">GF_SERVER_ROOT_URL</span></div><div class=\"line\"><span class=\"attr\">              value:</span><span class=\"string\">/api/v1/proxy/namespace/kube-system/services/monitoring-grafana/</span></div><div class=\"line\"><span class=\"attr\">          volumeMounts:</span></div><div class=\"line\"><span class=\"attr\">            - name:</span><span class=\"string\">grafana-persistent-storage</span></div><div class=\"line\"><span class=\"attr\">              mountPath:</span><span class=\"string\">/var</span></div><div class=\"line\"><span class=\"attr\">      volumes:</span></div><div class=\"line\"><span class=\"attr\">        - name:</span><span class=\"string\">influxdb-persistent-storage</span></div><div class=\"line\">          <span class=\"string\">emptyDir&#123;&#125;</span></div><div class=\"line\"><span class=\"attr\">        - name:</span><span class=\"string\">grafana-persistent-storage</span></div><div class=\"line\">          <span class=\"string\">emptyDir&#123;&#125;</span></div></pre></td></tr></table></figure>\n<h4>2.3.2. heapster-controller</h4>\n<p><strong>heapster-controller.yaml</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">apiVersion:</span><span class=\"string\">v1</span></div><div class=\"line\"><span class=\"attr\">kind:</span><span class=\"string\">ReplicationController</span></div><div class=\"line\"><span class=\"attr\">metadata:</span></div><div class=\"line\"><span class=\"attr\">    labels:</span></div><div class=\"line\"><span class=\"attr\">        k8s-app:</span><span class=\"string\">heapster</span></div><div class=\"line\"><span class=\"attr\">        name:</span><span class=\"string\">heapster</span></div><div class=\"line\"><span class=\"attr\">        version:</span><span class=\"string\">v6</span></div><div class=\"line\"><span class=\"attr\">    name:</span><span class=\"string\">heapster</span></div><div class=\"line\"><span class=\"attr\">    namespace:</span><span class=\"string\">kube-system</span></div><div class=\"line\"><span class=\"attr\">spec:</span></div><div class=\"line\"><span class=\"attr\">    replicas:</span><span class=\"number\">1</span></div><div class=\"line\"><span class=\"attr\">    selector:</span></div><div class=\"line\"><span class=\"attr\">        name:</span><span class=\"string\">heapster</span></div><div class=\"line\"><span class=\"attr\">        k8s-app:</span><span class=\"string\">heapster</span></div><div class=\"line\"><span class=\"attr\">        version:</span><span class=\"string\">v6</span></div><div class=\"line\"><span class=\"attr\">    template:</span></div><div class=\"line\"><span class=\"attr\">        metadata:</span></div><div class=\"line\"><span class=\"attr\">            labels:</span></div><div class=\"line\"><span class=\"attr\">                k8s-app:</span><span class=\"string\">heapster</span></div><div class=\"line\"><span class=\"attr\">                version:</span><span class=\"string\">v6</span></div><div class=\"line\"><span class=\"attr\">        spec:</span></div><div class=\"line\"><span class=\"attr\">            containers:</span></div><div class=\"line\"><span class=\"attr\">                - image:</span><span class=\"string\">gcr.io/google_containers/heapster:v0.17.0</span></div><div class=\"line\"><span class=\"attr\">                  name:</span><span class=\"string\">heapster</span></div><div class=\"line\"><span class=\"attr\">                  command:</span></div><div class=\"line\"><span class=\"bullet\">                    -</span> <span class=\"string\">/heapster</span></div><div class=\"line\"><span class=\"bullet\">                    -</span> <span class=\"bullet\">--source=kubernetes:http://192.168.1.128:8080?inClusterConfig=flase&amp;kubeletHttps=true&amp;useServiceAccount=true&amp;auth=</span></div><div class=\"line\"><span class=\"bullet\">                    -</span> <span class=\"bullet\">--sink=InfluxDB:http://monitoring-InfluxDB:8086</span></div></pre></td></tr></table></figure>\n<p>Heapster设置启动参数说明：</p>\n<p>1、–source</p>\n<p>配置监控来源，本例中表示从k8s-Master获取各个Node的信息。在URL的参数部分，修改kubeletHttps、inClusterConfig、useServiceAccount的值。</p>\n<p>2、–sink</p>\n<p>配置后端的存储系统，本例中使用InfluxDB。URL中主机名的地址是InfluxDB的Service名字，需要DNS服务正常工作，如果没有配置DNS服务可使用Service的ClusterIP地址。</p>\n<h4>2.3.3. 创建ReplicationController</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">kubelet create -f InfluxDB-Grafana-controller.yaml</div><div class=\"line\">kubelet create -f heapster-controller.yaml</div></pre></td></tr></table></figure>\n<h2>3. 查看界面及数据</h2>\n<h3>3.1. InfluxDB</h3>\n<p>访问任意一台Node机器的30083端口。</p>\n<h3>3.2. Grafana</h3>\n<p>访问任意一台Node机器的30080端口。</p>\n<h2>4. 容器化部署</h2>\n<h3>4.1. 拉取镜像</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker pull registry.wae.haplat.net/test/influxdb:1.0.0</div><div class=\"line\">docker pull registry.wae.haplat.net/test/cadvisor:latest</div><div class=\"line\">docker pull registry.wae.haplat.net/test/grafana:latest</div><div class=\"line\">docker pull registry.wae.haplat.net/test/heapster:latest</div></pre></td></tr></table></figure>\n<h3>4.2. 运行容器</h3>\n<h4>4.2.1. influxdb</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">influxdb</span></div><div class=\"line\">docker run -d -p 8083:8083 -p 8086:8086 --expose 8090 --expose 8099 --volume=/opt/data/influxdb:/data --name influxsrv registry.wae.haplat.net/test/influxdb:1.0.0</div></pre></td></tr></table></figure>\n<h4>4.2.2. cadvisor</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">cadvisor</span></div><div class=\"line\">docker run --volume=/:/rootfs:ro --volume=/var/run:/var/run:rw --volume=/sys:/sys:ro --volume=/var/lib/docker/:/var/lib/docker:ro --publish=8080:8080 --detach=true --link influxsrv:influxsrv --name=cadvisor registry.wae.haplat.net/test/cadvisor:latest -storage_driver=influxdb -storage_driver_db=cadvisor -storage_driver_host=influxsrv:8086</div></pre></td></tr></table></figure>\n<h4>4.2.3. grafana</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">grafana</span></div><div class=\"line\">docker run -d -p 3000:3000 -e INFLUXDB_HOST=influxsrv -e INFLUXDB_PORT=8086 -e INFLUXDB_NAME=cadvisor -e INFLUXDB_USER=root -e INFLUXDB_PASS=root --link influxsrv:influxsrv --name grafana registry.wae.haplat.net/test/grafana:latest</div></pre></td></tr></table></figure>\n<h4>4.2.4. heapster</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker run -d -p 8082:8082 --net=host heapster:canary --source=kubernetes:http://`k8s-server-ip`:8080?inClusterConfig=false/&amp;useServiceAccount=false --sink=influxdb:http://`influxdb-ip`:8086</div></pre></td></tr></table></figure>\n<h3>4.3. 访问</h3>\n<p>在浏览器输入<code>IP</code>:<code>PORT</code></p>\n"},{"title":"[Kubernetes] Influxdb介绍","catalog":true,"date":"2017-08-13T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Kubernetes"],"_content":"\n## 1. InfluxDB简介\n\nInfluxDB是一个当下比较流行的时序数据库，InfluxDB使用 Go 语言编写，无需外部依赖，安装配置非常方便，适合构建大型分布式系统的监控系统。\n\n主要特色功能：\n\n1）基于时间序列，支持与时间有关的相关函数（如最大，最小，求和等）\n\n2）可度量性：你可以实时对大量数据进行计算\n\n3）基于事件：它支持任意的事件数据\n\n## 2. InfluxDB安装\n\n### 1）安装\n\nwget [https://dl.influxdata.com/influxdb/releases/influxdb-0.13.0.x86_64.rpm](https://dl.influxdata.com/influxdb/releases/influxdb-0.13.0.x86_64.rpm)\n\nyum localinstall influxdb-0.13.0.armhf.rpm\n\n### 2）启动\n\nservice influxdb start\n\n### 3）访问\n\nhttp://服务器IP:8083\n\n### 4）docker image方式安装\n\ndocker pull influxdb\n\ndocker run -d -p 8083:8083 -p 8086:8086 --expose 8090 --expose 8099 --volume=/opt/data/influxdb:/data --name influxsrv registry.wae.haplat.net/test/influxdb:1.0.0\n\n## 3. InfluxDB的基本概念\n\n### 3.1. 与传统数据库中的名词做比较\n\n| influxDB中的名词 | 传统数据库中的概念 |\n| ------------ | --------- |\n| database     | 数据库       |\n| measurement  | 数据库中的表    |\n| points       | 表里面的一行数据  |\n\n### 3.2. InfluxDB中独有的概念\n\n#### 3.2.1. Point\n\nPoint由时间戳（time）、数据（field）、标签（tags）组成。\n\nPoint相当于传统数据库里的一行数据，如下表所示：\n\n| Point属性 | 传统数据库中的概念                    |\n| ------- | ---------------------------- |\n| time    | 每个数据记录时间，是数据库中的主索引(会自动生成)    |\n| fields  | 各种记录值（没有索引的属性）也就是记录的值：温度， 湿度 |\n| tags    | 各种有索引的属性：地区，海拔               |\n\n#### 3.2.2. series\n\n所有在数据库中的数据，都需要通过图表来展示，而这个series表示这个表里面的数据，可以在图表上画成几条线：通过tags排列组合算出来\n\nshow series from cpu\n\n## 4. InfluxDB的基本操作\n\nInfluxDB提供三种操作方式：\n\n1）客户端命令行方式\n\n2）HTTP API接口\n\n3）各语言API库\n\n### 4.1. InfluxDB数据库操作\n\n| 操作      | 命令                        |\n| ------- | ------------------------- |\n| 显示数据库   | show databases            |\n| 创建数据库   | create database `db_name` |\n| 删除数据库   | drop database `db_name`   |\n| 使用某个数据库 | use `db_name`             |\n\n### 4.2. InfluxDB数据表操作\n\n| 操作       | 命令                                       | 说明                                       |\n| -------- | ---------------------------------------- | ---------------------------------------- |\n| 显示所有表    | SHOW MEASUREMENTS                        |                                          |\n| 创建数据表    | insert `table_name`,hostname=server01 value=442221834240i 1435362189575692182 | 其中 disk_free 就是表名，hostname是索引，value=xx是记录值，记录值可以有多个，最后是指定的时间 |\n| 删除数据表    | drop measurement `table_name`            |                                          |\n| 查看表内容    | select * from `table_name`               |                                          |\n| 查看series | show series from `table_name`            | series表示这个表里面的数据，可以在图表上画成几条线，series主要通过tags排列组合算出来 |","source":"_posts/Kubernetes/监控/influxdb.md","raw":"---\ntitle: \"[Kubernetes] Influxdb介绍\"\ncatalog: true\ndate: 2017-08-13 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Kubernetes\ncatagories:\n- Kubernetes\n---\n\n## 1. InfluxDB简介\n\nInfluxDB是一个当下比较流行的时序数据库，InfluxDB使用 Go 语言编写，无需外部依赖，安装配置非常方便，适合构建大型分布式系统的监控系统。\n\n主要特色功能：\n\n1）基于时间序列，支持与时间有关的相关函数（如最大，最小，求和等）\n\n2）可度量性：你可以实时对大量数据进行计算\n\n3）基于事件：它支持任意的事件数据\n\n## 2. InfluxDB安装\n\n### 1）安装\n\nwget [https://dl.influxdata.com/influxdb/releases/influxdb-0.13.0.x86_64.rpm](https://dl.influxdata.com/influxdb/releases/influxdb-0.13.0.x86_64.rpm)\n\nyum localinstall influxdb-0.13.0.armhf.rpm\n\n### 2）启动\n\nservice influxdb start\n\n### 3）访问\n\nhttp://服务器IP:8083\n\n### 4）docker image方式安装\n\ndocker pull influxdb\n\ndocker run -d -p 8083:8083 -p 8086:8086 --expose 8090 --expose 8099 --volume=/opt/data/influxdb:/data --name influxsrv registry.wae.haplat.net/test/influxdb:1.0.0\n\n## 3. InfluxDB的基本概念\n\n### 3.1. 与传统数据库中的名词做比较\n\n| influxDB中的名词 | 传统数据库中的概念 |\n| ------------ | --------- |\n| database     | 数据库       |\n| measurement  | 数据库中的表    |\n| points       | 表里面的一行数据  |\n\n### 3.2. InfluxDB中独有的概念\n\n#### 3.2.1. Point\n\nPoint由时间戳（time）、数据（field）、标签（tags）组成。\n\nPoint相当于传统数据库里的一行数据，如下表所示：\n\n| Point属性 | 传统数据库中的概念                    |\n| ------- | ---------------------------- |\n| time    | 每个数据记录时间，是数据库中的主索引(会自动生成)    |\n| fields  | 各种记录值（没有索引的属性）也就是记录的值：温度， 湿度 |\n| tags    | 各种有索引的属性：地区，海拔               |\n\n#### 3.2.2. series\n\n所有在数据库中的数据，都需要通过图表来展示，而这个series表示这个表里面的数据，可以在图表上画成几条线：通过tags排列组合算出来\n\nshow series from cpu\n\n## 4. InfluxDB的基本操作\n\nInfluxDB提供三种操作方式：\n\n1）客户端命令行方式\n\n2）HTTP API接口\n\n3）各语言API库\n\n### 4.1. InfluxDB数据库操作\n\n| 操作      | 命令                        |\n| ------- | ------------------------- |\n| 显示数据库   | show databases            |\n| 创建数据库   | create database `db_name` |\n| 删除数据库   | drop database `db_name`   |\n| 使用某个数据库 | use `db_name`             |\n\n### 4.2. InfluxDB数据表操作\n\n| 操作       | 命令                                       | 说明                                       |\n| -------- | ---------------------------------------- | ---------------------------------------- |\n| 显示所有表    | SHOW MEASUREMENTS                        |                                          |\n| 创建数据表    | insert `table_name`,hostname=server01 value=442221834240i 1435362189575692182 | 其中 disk_free 就是表名，hostname是索引，value=xx是记录值，记录值可以有多个，最后是指定的时间 |\n| 删除数据表    | drop measurement `table_name`            |                                          |\n| 查看表内容    | select * from `table_name`               |                                          |\n| 查看series | show series from `table_name`            | series表示这个表里面的数据，可以在图表上画成几条线，series主要通过tags排列组合算出来 |","slug":"Kubernetes/监控/influxdb","published":1,"updated":"2017-10-02T11:54:08.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8b740mc001s30vufcnlc05l","content":"<h2><span id=\"1-influxdb简介\">1. InfluxDB简介</span></h2>\n<p>InfluxDB是一个当下比较流行的时序数据库，InfluxDB使用 Go 语言编写，无需外部依赖，安装配置非常方便，适合构建大型分布式系统的监控系统。</p>\n<p>主要特色功能：</p>\n<p>1）基于时间序列，支持与时间有关的相关函数（如最大，最小，求和等）</p>\n<p>2）可度量性：你可以实时对大量数据进行计算</p>\n<p>3）基于事件：它支持任意的事件数据</p>\n<h2><span id=\"2-influxdb安装\">2. InfluxDB安装</span></h2>\n<h3><span id=\"1安装\">1）安装</span></h3>\n<p>wget <a href=\"https://dl.influxdata.com/influxdb/releases/influxdb-0.13.0.x86_64.rpm\" target=\"_blank\" rel=\"external\">https://dl.influxdata.com/influxdb/releases/influxdb-0.13.0.x86_64.rpm</a></p>\n<p>yum localinstall influxdb-0.13.0.armhf.rpm</p>\n<h3><span id=\"2启动\">2）启动</span></h3>\n<p>service influxdb start</p>\n<h3><span id=\"3访问\">3）访问</span></h3>\n<p><a href=\"http://xn--IP-fr5c86lx7z:8083\" target=\"_blank\" rel=\"external\">http://服务器IP:8083</a></p>\n<h3><span id=\"4docker-image方式安装\">4）docker image方式安装</span></h3>\n<p>docker pull influxdb</p>\n<p>docker run -d -p 8083:8083 -p 8086:8086 --expose 8090 --expose 8099 --volume=/opt/data/influxdb:/data --name influxsrv <a href=\"http://registry.wae.haplat.net/test/influxdb:1.0.0\" target=\"_blank\" rel=\"external\">registry.wae.haplat.net/test/influxdb:1.0.0</a></p>\n<h2><span id=\"3-influxdb的基本概念\">3. InfluxDB的基本概念</span></h2>\n<h3><span id=\"31-与传统数据库中的名词做比较\">3.1. 与传统数据库中的名词做比较</span></h3>\n<table>\n<thead>\n<tr>\n<th>influxDB中的名词</th>\n<th>传统数据库中的概念</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>database</td>\n<td>数据库</td>\n</tr>\n<tr>\n<td>measurement</td>\n<td>数据库中的表</td>\n</tr>\n<tr>\n<td>points</td>\n<td>表里面的一行数据</td>\n</tr>\n</tbody>\n</table>\n<h3><span id=\"32-influxdb中独有的概念\">3.2. InfluxDB中独有的概念</span></h3>\n<h4><span id=\"321-point\">3.2.1. Point</span></h4>\n<p>Point由时间戳（time）、数据（field）、标签（tags）组成。</p>\n<p>Point相当于传统数据库里的一行数据，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>Point属性</th>\n<th>传统数据库中的概念</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>time</td>\n<td>每个数据记录时间，是数据库中的主索引(会自动生成)</td>\n</tr>\n<tr>\n<td>fields</td>\n<td>各种记录值（没有索引的属性）也就是记录的值：温度， 湿度</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>各种有索引的属性：地区，海拔</td>\n</tr>\n</tbody>\n</table>\n<h4><span id=\"322-series\">3.2.2. series</span></h4>\n<p>所有在数据库中的数据，都需要通过图表来展示，而这个series表示这个表里面的数据，可以在图表上画成几条线：通过tags排列组合算出来</p>\n<p>show series from cpu</p>\n<h2><span id=\"4-influxdb的基本操作\">4. InfluxDB的基本操作</span></h2>\n<p>InfluxDB提供三种操作方式：</p>\n<p>1）客户端命令行方式</p>\n<p>2）HTTP API接口</p>\n<p>3）各语言API库</p>\n<h3><span id=\"41-influxdb数据库操作\">4.1. InfluxDB数据库操作</span></h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>显示数据库</td>\n<td>show databases</td>\n</tr>\n<tr>\n<td>创建数据库</td>\n<td>create database <code>db_name</code></td>\n</tr>\n<tr>\n<td>删除数据库</td>\n<td>drop database <code>db_name</code></td>\n</tr>\n<tr>\n<td>使用某个数据库</td>\n<td>use <code>db_name</code></td>\n</tr>\n</tbody>\n</table>\n<h3><span id=\"42-influxdb数据表操作\">4.2. InfluxDB数据表操作</span></h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>显示所有表</td>\n<td>SHOW MEASUREMENTS</td>\n<td></td>\n</tr>\n<tr>\n<td>创建数据表</td>\n<td>insert <code>table_name</code>,hostname=server01 value=442221834240i 1435362189575692182</td>\n<td>其中 disk_free 就是表名，hostname是索引，value=xx是记录值，记录值可以有多个，最后是指定的时间</td>\n</tr>\n<tr>\n<td>删除数据表</td>\n<td>drop measurement <code>table_name</code></td>\n<td></td>\n</tr>\n<tr>\n<td>查看表内容</td>\n<td>select * from <code>table_name</code></td>\n<td></td>\n</tr>\n<tr>\n<td>查看series</td>\n<td>show series from <code>table_name</code></td>\n<td>series表示这个表里面的数据，可以在图表上画成几条线，series主要通过tags排列组合算出来</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. InfluxDB简介</h2>\n<p>InfluxDB是一个当下比较流行的时序数据库，InfluxDB使用 Go 语言编写，无需外部依赖，安装配置非常方便，适合构建大型分布式系统的监控系统。</p>\n<p>主要特色功能：</p>\n<p>1）基于时间序列，支持与时间有关的相关函数（如最大，最小，求和等）</p>\n<p>2）可度量性：你可以实时对大量数据进行计算</p>\n<p>3）基于事件：它支持任意的事件数据</p>\n<h2>2. InfluxDB安装</h2>\n<h3>1）安装</h3>\n<p>wget <a href=\"https://dl.influxdata.com/influxdb/releases/influxdb-0.13.0.x86_64.rpm\" target=\"_blank\" rel=\"external\">https://dl.influxdata.com/influxdb/releases/influxdb-0.13.0.x86_64.rpm</a></p>\n<p>yum localinstall influxdb-0.13.0.armhf.rpm</p>\n<h3>2）启动</h3>\n<p>service influxdb start</p>\n<h3>3）访问</h3>\n<p><a href=\"http://xn--IP-fr5c86lx7z:8083\" target=\"_blank\" rel=\"external\">http://服务器IP:8083</a></p>\n<h3>4）docker image方式安装</h3>\n<p>docker pull influxdb</p>\n<p>docker run -d -p 8083:8083 -p 8086:8086 --expose 8090 --expose 8099 --volume=/opt/data/influxdb:/data --name influxsrv <a href=\"http://registry.wae.haplat.net/test/influxdb:1.0.0\" target=\"_blank\" rel=\"external\">registry.wae.haplat.net/test/influxdb:1.0.0</a></p>\n<h2>3. InfluxDB的基本概念</h2>\n<h3>3.1. 与传统数据库中的名词做比较</h3>\n<table>\n<thead>\n<tr>\n<th>influxDB中的名词</th>\n<th>传统数据库中的概念</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>database</td>\n<td>数据库</td>\n</tr>\n<tr>\n<td>measurement</td>\n<td>数据库中的表</td>\n</tr>\n<tr>\n<td>points</td>\n<td>表里面的一行数据</td>\n</tr>\n</tbody>\n</table>\n<h3>3.2. InfluxDB中独有的概念</h3>\n<h4>3.2.1. Point</h4>\n<p>Point由时间戳（time）、数据（field）、标签（tags）组成。</p>\n<p>Point相当于传统数据库里的一行数据，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>Point属性</th>\n<th>传统数据库中的概念</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>time</td>\n<td>每个数据记录时间，是数据库中的主索引(会自动生成)</td>\n</tr>\n<tr>\n<td>fields</td>\n<td>各种记录值（没有索引的属性）也就是记录的值：温度， 湿度</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>各种有索引的属性：地区，海拔</td>\n</tr>\n</tbody>\n</table>\n<h4>3.2.2. series</h4>\n<p>所有在数据库中的数据，都需要通过图表来展示，而这个series表示这个表里面的数据，可以在图表上画成几条线：通过tags排列组合算出来</p>\n<p>show series from cpu</p>\n<h2>4. InfluxDB的基本操作</h2>\n<p>InfluxDB提供三种操作方式：</p>\n<p>1）客户端命令行方式</p>\n<p>2）HTTP API接口</p>\n<p>3）各语言API库</p>\n<h3>4.1. InfluxDB数据库操作</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>显示数据库</td>\n<td>show databases</td>\n</tr>\n<tr>\n<td>创建数据库</td>\n<td>create database <code>db_name</code></td>\n</tr>\n<tr>\n<td>删除数据库</td>\n<td>drop database <code>db_name</code></td>\n</tr>\n<tr>\n<td>使用某个数据库</td>\n<td>use <code>db_name</code></td>\n</tr>\n</tbody>\n</table>\n<h3>4.2. InfluxDB数据表操作</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>显示所有表</td>\n<td>SHOW MEASUREMENTS</td>\n<td></td>\n</tr>\n<tr>\n<td>创建数据表</td>\n<td>insert <code>table_name</code>,hostname=server01 value=442221834240i 1435362189575692182</td>\n<td>其中 disk_free 就是表名，hostname是索引，value=xx是记录值，记录值可以有多个，最后是指定的时间</td>\n</tr>\n<tr>\n<td>删除数据表</td>\n<td>drop measurement <code>table_name</code></td>\n<td></td>\n</tr>\n<tr>\n<td>查看表内容</td>\n<td>select * from <code>table_name</code></td>\n<td></td>\n</tr>\n<tr>\n<td>查看series</td>\n<td>show series from <code>table_name</code></td>\n<td>series表示这个表里面的数据，可以在图表上画成几条线，series主要通过tags排列组合算出来</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"[Golang] govendor的使用","catalog":true,"date":"2017-09-01T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Golang"],"_content":"\n## 1. govendor简介\n\ngolang工程的依赖包经常使用go get 的方式来获取，例如：go get github.com/kardianos/govendor ，会将依赖包下载到GOPATH的路径下。\n\n常用的依赖包管理工具有godep，govendor等，在Golang1.5之后，Go提供了 `GO15VENDOREXPERIMENT` 环境变量，用于将go build时的应用路径搜索调整成为 `当前项目目录/vendor` 目录方式。通过这种形式，我们可以实现类似于 `godep` 方式的项目依赖管理。\n\n## 2. 安装与使用\n\n### 2.1. 安装\n\n```go\ngo get -u -v github.com/kardianos/govendor\n```\n\n### 2.2. 使用\n\n```shell\n#进入到项目目录\ncd /home/gopath/src/waetool\n#初始化vendor目录\ngovendor init\n#查看vendor目录\n[root@CC54425A waetool]# ls\ncommands  main.go  vendor  waetool_test.sh\n#进入vendor目录\ncd vendor\n#将GOPATH中本工程使用到的依赖包自动移动到vendor目录中\n#说明：如果本地GOPATH没有依赖包，先go get相应的依赖包\ngovendor add +external\n#通过设置环境变量 GO15VENDOREXPERIMENT=1 使用vendor文件夹构建文件。\n#可以选择 export GO15VENDOREXPERIMENT=1 或 GO15VENDOREXPERIMENT=1 go build 执行编译\nexport GO15VENDOREXPERIMENT=1\n```\n\n### 2.3. 说明\n\ngovendor只是用来管理项目的依赖包，如果GOPATH中本身没有项目的依赖包，则需要通过go get先下载到GOPATH中，再通过govendor add +external 拷贝到vendor目录中。\n\n## 3. govendor使用命令\n\n```shell\n[root@CC54425A waetool]# govendor\ngovendor (v1.0.8): record dependencies and copy into vendor folder\n    -govendor-licenses    Show govendor's licenses.\n    -version              Show govendor version\n    -cpuprofile 'file'    Writes a CPU profile to 'file' for debugging.\n    -memprofile 'file'    Writes a heap profile to 'file' for debugging.\nSub-Commands\n    init     Create the \"vendor\" folder and the \"vendor.json\" file.\n    list     List and filter existing dependencies and packages.\n    add      Add packages from $GOPATH.\n    update   Update packages from $GOPATH.\n    remove   Remove packages from the vendor folder.\n    status   Lists any packages missing, out-of-date, or modified locally.\n    fetch    Add new or update vendor folder packages from remote repository.\n    sync     Pull packages into vendor folder from remote repository with revisions\n                 from vendor.json file.\n    migrate  Move packages from a legacy tool to the vendor folder with metadata.\n    get      Like \"go get\" but copies dependencies into a \"vendor\" folder.\n    license  List discovered licenses for the given status or import paths.\n    shell    Run a \"shell\" to make multiple sub-commands more efficient for large\n                 projects.\n    go tool commands that are wrapped:\n      \"+status\" package selection may be used with them\n    fmt, build, install, clean, test, vet, generate, tool\nStatus Types\n    +local    (l) packages in your project\n    +external (e) referenced packages in GOPATH but not in current project\n    +vendor   (v) packages in the vendor folder\n    +std      (s) packages in the standard library\n    +excluded (x) external packages explicitly excluded from vendoring\n    +unused   (u) packages in the vendor folder, but unused\n    +missing  (m) referenced packages but not found\n    +program  (p) package is a main package\n    +outside  +external +missing\n    +all      +all packages\n    Status can be referenced by their initial letters.\nPackage specifier\n    <path>[::<origin>][{/...|/^}][@[<version-spec>]]\nIgnoring files with build tags, or excluding packages from being vendored:\n    The \"vendor.json\" file contains a string field named \"ignore\".\n    It may contain a space separated list of build tags to ignore when\n    listing and copying files.\n    This list may also contain package prefixes (containing a \"/\", possibly\n    as last character) to exclude when copying files in the vendor folder.\n    If \"foo/\" appears in this field, then package \"foo\" and all its sub-packages\n    (\"foo/bar\", …) will be excluded (but package \"bar/foo\" will not).\n    By default the init command adds the \"test\" tag to the ignore list.\nIf using go1.5, ensure GO15VENDOREXPERIMENT=1 is set.\n```\n\n## 4. vendor.json\n\n```json\n{\n    \"comment\": \"\",\n    \"ignore\": \"test\",\n    \"package\": [\n        {\n            \"checksumSHA1\": \"uGalSICR4r7354vvKuNnh7Y/R/4=\",\n            \"path\": \"github.com/urfave/cli\",\n            \"revision\": \"b99aa811b4c1dd84cc6bccb8499c82c72098085a\",\n            \"revisionTime\": \"2017-08-04T09:34:15Z\"\n        }\n    ],\n    \"rootPath\": \"waetool\"\n}\n```\n\n","source":"_posts/Golang/govendor的使用.md","raw":"---\ntitle: \"[Golang] govendor的使用\"\ncatalog: true\ndate: 2017-09-01 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Golang\ncatagories:\n- Golang\n---\n\n## 1. govendor简介\n\ngolang工程的依赖包经常使用go get 的方式来获取，例如：go get github.com/kardianos/govendor ，会将依赖包下载到GOPATH的路径下。\n\n常用的依赖包管理工具有godep，govendor等，在Golang1.5之后，Go提供了 `GO15VENDOREXPERIMENT` 环境变量，用于将go build时的应用路径搜索调整成为 `当前项目目录/vendor` 目录方式。通过这种形式，我们可以实现类似于 `godep` 方式的项目依赖管理。\n\n## 2. 安装与使用\n\n### 2.1. 安装\n\n```go\ngo get -u -v github.com/kardianos/govendor\n```\n\n### 2.2. 使用\n\n```shell\n#进入到项目目录\ncd /home/gopath/src/waetool\n#初始化vendor目录\ngovendor init\n#查看vendor目录\n[root@CC54425A waetool]# ls\ncommands  main.go  vendor  waetool_test.sh\n#进入vendor目录\ncd vendor\n#将GOPATH中本工程使用到的依赖包自动移动到vendor目录中\n#说明：如果本地GOPATH没有依赖包，先go get相应的依赖包\ngovendor add +external\n#通过设置环境变量 GO15VENDOREXPERIMENT=1 使用vendor文件夹构建文件。\n#可以选择 export GO15VENDOREXPERIMENT=1 或 GO15VENDOREXPERIMENT=1 go build 执行编译\nexport GO15VENDOREXPERIMENT=1\n```\n\n### 2.3. 说明\n\ngovendor只是用来管理项目的依赖包，如果GOPATH中本身没有项目的依赖包，则需要通过go get先下载到GOPATH中，再通过govendor add +external 拷贝到vendor目录中。\n\n## 3. govendor使用命令\n\n```shell\n[root@CC54425A waetool]# govendor\ngovendor (v1.0.8): record dependencies and copy into vendor folder\n    -govendor-licenses    Show govendor's licenses.\n    -version              Show govendor version\n    -cpuprofile 'file'    Writes a CPU profile to 'file' for debugging.\n    -memprofile 'file'    Writes a heap profile to 'file' for debugging.\nSub-Commands\n    init     Create the \"vendor\" folder and the \"vendor.json\" file.\n    list     List and filter existing dependencies and packages.\n    add      Add packages from $GOPATH.\n    update   Update packages from $GOPATH.\n    remove   Remove packages from the vendor folder.\n    status   Lists any packages missing, out-of-date, or modified locally.\n    fetch    Add new or update vendor folder packages from remote repository.\n    sync     Pull packages into vendor folder from remote repository with revisions\n                 from vendor.json file.\n    migrate  Move packages from a legacy tool to the vendor folder with metadata.\n    get      Like \"go get\" but copies dependencies into a \"vendor\" folder.\n    license  List discovered licenses for the given status or import paths.\n    shell    Run a \"shell\" to make multiple sub-commands more efficient for large\n                 projects.\n    go tool commands that are wrapped:\n      \"+status\" package selection may be used with them\n    fmt, build, install, clean, test, vet, generate, tool\nStatus Types\n    +local    (l) packages in your project\n    +external (e) referenced packages in GOPATH but not in current project\n    +vendor   (v) packages in the vendor folder\n    +std      (s) packages in the standard library\n    +excluded (x) external packages explicitly excluded from vendoring\n    +unused   (u) packages in the vendor folder, but unused\n    +missing  (m) referenced packages but not found\n    +program  (p) package is a main package\n    +outside  +external +missing\n    +all      +all packages\n    Status can be referenced by their initial letters.\nPackage specifier\n    <path>[::<origin>][{/...|/^}][@[<version-spec>]]\nIgnoring files with build tags, or excluding packages from being vendored:\n    The \"vendor.json\" file contains a string field named \"ignore\".\n    It may contain a space separated list of build tags to ignore when\n    listing and copying files.\n    This list may also contain package prefixes (containing a \"/\", possibly\n    as last character) to exclude when copying files in the vendor folder.\n    If \"foo/\" appears in this field, then package \"foo\" and all its sub-packages\n    (\"foo/bar\", …) will be excluded (but package \"bar/foo\" will not).\n    By default the init command adds the \"test\" tag to the ignore list.\nIf using go1.5, ensure GO15VENDOREXPERIMENT=1 is set.\n```\n\n## 4. vendor.json\n\n```json\n{\n    \"comment\": \"\",\n    \"ignore\": \"test\",\n    \"package\": [\n        {\n            \"checksumSHA1\": \"uGalSICR4r7354vvKuNnh7Y/R/4=\",\n            \"path\": \"github.com/urfave/cli\",\n            \"revision\": \"b99aa811b4c1dd84cc6bccb8499c82c72098085a\",\n            \"revisionTime\": \"2017-08-04T09:34:15Z\"\n        }\n    ],\n    \"rootPath\": \"waetool\"\n}\n```\n\n","slug":"Golang/govendor的使用","published":1,"updated":"2017-10-03T06:26:35.944Z","_id":"cj8b79uq800002cvuah6ya5o4","comments":1,"layout":"post","photos":[],"link":"","content":"<h2><span id=\"1-govendor简介\">1. govendor简介</span></h2>\n<p>golang工程的依赖包经常使用go get 的方式来获取，例如：go get <a href=\"http://github.com/kardianos/govendor\" target=\"_blank\" rel=\"external\">github.com/kardianos/govendor</a> ，会将依赖包下载到GOPATH的路径下。</p>\n<p>常用的依赖包管理工具有godep，govendor等，在Golang1.5之后，Go提供了 <code>GO15VENDOREXPERIMENT</code> 环境变量，用于将go build时的应用路径搜索调整成为 <code>当前项目目录/vendor</code> 目录方式。通过这种形式，我们可以实现类似于 <code>godep</code> 方式的项目依赖管理。</p>\n<h2><span id=\"2-安装与使用\">2. 安装与使用</span></h2>\n<h3><span id=\"21-安装\">2.1. 安装</span></h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">go</span> get -u -v github.com/kardianos/govendor</div></pre></td></tr></table></figure>\n<h3><span id=\"22-使用\">2.2. 使用</span></h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span>进入到项目目录</div><div class=\"line\">cd /home/gopath/src/waetool</div><div class=\"line\"><span class=\"meta\">#</span>初始化vendor目录</div><div class=\"line\">govendor init</div><div class=\"line\"><span class=\"meta\">#</span>查看vendor目录</div><div class=\"line\">[root@CC54425A waetool]# ls</div><div class=\"line\">commands  main.go  vendor  waetool_test.sh</div><div class=\"line\"><span class=\"meta\">#</span>进入vendor目录</div><div class=\"line\">cd vendor</div><div class=\"line\"><span class=\"meta\">#</span>将GOPATH中本工程使用到的依赖包自动移动到vendor目录中</div><div class=\"line\"><span class=\"meta\">#</span>说明：如果本地GOPATH没有依赖包，先go get相应的依赖包</div><div class=\"line\">govendor add +external</div><div class=\"line\"><span class=\"meta\">#</span>通过设置环境变量 GO15VENDOREXPERIMENT=1 使用vendor文件夹构建文件。</div><div class=\"line\"><span class=\"meta\">#</span>可以选择 export GO15VENDOREXPERIMENT=1 或 GO15VENDOREXPERIMENT=1 go build 执行编译</div><div class=\"line\">export GO15VENDOREXPERIMENT=1</div></pre></td></tr></table></figure>\n<h3><span id=\"23-说明\">2.3. 说明</span></h3>\n<p>govendor只是用来管理项目的依赖包，如果GOPATH中本身没有项目的依赖包，则需要通过go get先下载到GOPATH中，再通过govendor add +external 拷贝到vendor目录中。</p>\n<h2><span id=\"3-govendor使用命令\">3. govendor使用命令</span></h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@CC54425A waetool]# govendor</div><div class=\"line\">govendor (v1.0.8): record dependencies and copy into vendor folder</div><div class=\"line\">    -govendor-licenses    Show govendor's licenses.</div><div class=\"line\">    -version              Show govendor version</div><div class=\"line\">    -cpuprofile 'file'    Writes a CPU profile to 'file' for debugging.</div><div class=\"line\">    -memprofile 'file'    Writes a heap profile to 'file' for debugging.</div><div class=\"line\">Sub-Commands</div><div class=\"line\">    init     Create the \"vendor\" folder and the \"vendor.json\" file.</div><div class=\"line\">    list     List and filter existing dependencies and packages.</div><div class=\"line\">    add      Add packages from $GOPATH.</div><div class=\"line\">    update   Update packages from $GOPATH.</div><div class=\"line\">    remove   Remove packages from the vendor folder.</div><div class=\"line\">    status   Lists any packages missing, out-of-date, or modified locally.</div><div class=\"line\">    fetch    Add new or update vendor folder packages from remote repository.</div><div class=\"line\">    sync     Pull packages into vendor folder from remote repository with revisions</div><div class=\"line\">                 from vendor.json file.</div><div class=\"line\">    migrate  Move packages from a legacy tool to the vendor folder with metadata.</div><div class=\"line\">    get      Like \"go get\" but copies dependencies into a \"vendor\" folder.</div><div class=\"line\">    license  List discovered licenses for the given status or import paths.</div><div class=\"line\">    shell    Run a \"shell\" to make multiple sub-commands more efficient for large</div><div class=\"line\">                 projects.</div><div class=\"line\">    go tool commands that are wrapped:</div><div class=\"line\">      \"+status\" package selection may be used with them</div><div class=\"line\">    fmt, build, install, clean, test, vet, generate, tool</div><div class=\"line\">Status Types</div><div class=\"line\">    +local    (l) packages in your project</div><div class=\"line\">    +external (e) referenced packages in GOPATH but not in current project</div><div class=\"line\">    +vendor   (v) packages in the vendor folder</div><div class=\"line\">    +std      (s) packages in the standard library</div><div class=\"line\">    +excluded (x) external packages explicitly excluded from vendoring</div><div class=\"line\">    +unused   (u) packages in the vendor folder, but unused</div><div class=\"line\">    +missing  (m) referenced packages but not found</div><div class=\"line\">    +program  (p) package is a main package</div><div class=\"line\">    +outside  +external +missing</div><div class=\"line\">    +all      +all packages</div><div class=\"line\">    Status can be referenced by their initial letters.</div><div class=\"line\">Package specifier</div><div class=\"line\">    &lt;path&gt;[::&lt;origin&gt;][&#123;/...|/^&#125;][@[&lt;version-spec&gt;]]</div><div class=\"line\">Ignoring files with build tags, or excluding packages from being vendored:</div><div class=\"line\">    The \"vendor.json\" file contains a string field named \"ignore\".</div><div class=\"line\">    It may contain a space separated list of build tags to ignore when</div><div class=\"line\">    listing and copying files.</div><div class=\"line\">    This list may also contain package prefixes (containing a \"/\", possibly</div><div class=\"line\">    as last character) to exclude when copying files in the vendor folder.</div><div class=\"line\">    If \"foo/\" appears in this field, then package \"foo\" and all its sub-packages</div><div class=\"line\">    (\"foo/bar\", …) will be excluded (but package \"bar/foo\" will not).</div><div class=\"line\">    By default the init command adds the \"test\" tag to the ignore list.</div><div class=\"line\">If using go1.5, ensure GO15VENDOREXPERIMENT=1 is set.</div></pre></td></tr></table></figure>\n<h2><span id=\"4-vendorjson\">4. vendor.json</span></h2>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"comment\"</span>: <span class=\"string\">\"\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"ignore\"</span>: <span class=\"string\">\"test\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"package\"</span>: [</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"attr\">\"checksumSHA1\"</span>: <span class=\"string\">\"uGalSICR4r7354vvKuNnh7Y/R/4=\"</span>,</div><div class=\"line\">            <span class=\"attr\">\"path\"</span>: <span class=\"string\">\"github.com/urfave/cli\"</span>,</div><div class=\"line\">            <span class=\"attr\">\"revision\"</span>: <span class=\"string\">\"b99aa811b4c1dd84cc6bccb8499c82c72098085a\"</span>,</div><div class=\"line\">            <span class=\"attr\">\"revisionTime\"</span>: <span class=\"string\">\"2017-08-04T09:34:15Z\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    ],</div><div class=\"line\">    <span class=\"attr\">\"rootPath\"</span>: <span class=\"string\">\"waetool\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. govendor简介</h2>\n<p>golang工程的依赖包经常使用go get 的方式来获取，例如：go get <a href=\"http://github.com/kardianos/govendor\" target=\"_blank\" rel=\"external\">github.com/kardianos/govendor</a> ，会将依赖包下载到GOPATH的路径下。</p>\n<p>常用的依赖包管理工具有godep，govendor等，在Golang1.5之后，Go提供了 <code>GO15VENDOREXPERIMENT</code> 环境变量，用于将go build时的应用路径搜索调整成为 <code>当前项目目录/vendor</code> 目录方式。通过这种形式，我们可以实现类似于 <code>godep</code> 方式的项目依赖管理。</p>\n<h2>2. 安装与使用</h2>\n<h3>2.1. 安装</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">go</span> get -u -v github.com/kardianos/govendor</div></pre></td></tr></table></figure>\n<h3>2.2. 使用</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span>进入到项目目录</div><div class=\"line\">cd /home/gopath/src/waetool</div><div class=\"line\"><span class=\"meta\">#</span>初始化vendor目录</div><div class=\"line\">govendor init</div><div class=\"line\"><span class=\"meta\">#</span>查看vendor目录</div><div class=\"line\">[root@CC54425A waetool]# ls</div><div class=\"line\">commands  main.go  vendor  waetool_test.sh</div><div class=\"line\"><span class=\"meta\">#</span>进入vendor目录</div><div class=\"line\">cd vendor</div><div class=\"line\"><span class=\"meta\">#</span>将GOPATH中本工程使用到的依赖包自动移动到vendor目录中</div><div class=\"line\"><span class=\"meta\">#</span>说明：如果本地GOPATH没有依赖包，先go get相应的依赖包</div><div class=\"line\">govendor add +external</div><div class=\"line\"><span class=\"meta\">#</span>通过设置环境变量 GO15VENDOREXPERIMENT=1 使用vendor文件夹构建文件。</div><div class=\"line\"><span class=\"meta\">#</span>可以选择 export GO15VENDOREXPERIMENT=1 或 GO15VENDOREXPERIMENT=1 go build 执行编译</div><div class=\"line\">export GO15VENDOREXPERIMENT=1</div></pre></td></tr></table></figure>\n<h3>2.3. 说明</h3>\n<p>govendor只是用来管理项目的依赖包，如果GOPATH中本身没有项目的依赖包，则需要通过go get先下载到GOPATH中，再通过govendor add +external 拷贝到vendor目录中。</p>\n<h2>3. govendor使用命令</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@CC54425A waetool]# govendor</div><div class=\"line\">govendor (v1.0.8): record dependencies and copy into vendor folder</div><div class=\"line\">    -govendor-licenses    Show govendor's licenses.</div><div class=\"line\">    -version              Show govendor version</div><div class=\"line\">    -cpuprofile 'file'    Writes a CPU profile to 'file' for debugging.</div><div class=\"line\">    -memprofile 'file'    Writes a heap profile to 'file' for debugging.</div><div class=\"line\">Sub-Commands</div><div class=\"line\">    init     Create the \"vendor\" folder and the \"vendor.json\" file.</div><div class=\"line\">    list     List and filter existing dependencies and packages.</div><div class=\"line\">    add      Add packages from $GOPATH.</div><div class=\"line\">    update   Update packages from $GOPATH.</div><div class=\"line\">    remove   Remove packages from the vendor folder.</div><div class=\"line\">    status   Lists any packages missing, out-of-date, or modified locally.</div><div class=\"line\">    fetch    Add new or update vendor folder packages from remote repository.</div><div class=\"line\">    sync     Pull packages into vendor folder from remote repository with revisions</div><div class=\"line\">                 from vendor.json file.</div><div class=\"line\">    migrate  Move packages from a legacy tool to the vendor folder with metadata.</div><div class=\"line\">    get      Like \"go get\" but copies dependencies into a \"vendor\" folder.</div><div class=\"line\">    license  List discovered licenses for the given status or import paths.</div><div class=\"line\">    shell    Run a \"shell\" to make multiple sub-commands more efficient for large</div><div class=\"line\">                 projects.</div><div class=\"line\">    go tool commands that are wrapped:</div><div class=\"line\">      \"+status\" package selection may be used with them</div><div class=\"line\">    fmt, build, install, clean, test, vet, generate, tool</div><div class=\"line\">Status Types</div><div class=\"line\">    +local    (l) packages in your project</div><div class=\"line\">    +external (e) referenced packages in GOPATH but not in current project</div><div class=\"line\">    +vendor   (v) packages in the vendor folder</div><div class=\"line\">    +std      (s) packages in the standard library</div><div class=\"line\">    +excluded (x) external packages explicitly excluded from vendoring</div><div class=\"line\">    +unused   (u) packages in the vendor folder, but unused</div><div class=\"line\">    +missing  (m) referenced packages but not found</div><div class=\"line\">    +program  (p) package is a main package</div><div class=\"line\">    +outside  +external +missing</div><div class=\"line\">    +all      +all packages</div><div class=\"line\">    Status can be referenced by their initial letters.</div><div class=\"line\">Package specifier</div><div class=\"line\">    &lt;path&gt;[::&lt;origin&gt;][&#123;/...|/^&#125;][@[&lt;version-spec&gt;]]</div><div class=\"line\">Ignoring files with build tags, or excluding packages from being vendored:</div><div class=\"line\">    The \"vendor.json\" file contains a string field named \"ignore\".</div><div class=\"line\">    It may contain a space separated list of build tags to ignore when</div><div class=\"line\">    listing and copying files.</div><div class=\"line\">    This list may also contain package prefixes (containing a \"/\", possibly</div><div class=\"line\">    as last character) to exclude when copying files in the vendor folder.</div><div class=\"line\">    If \"foo/\" appears in this field, then package \"foo\" and all its sub-packages</div><div class=\"line\">    (\"foo/bar\", …) will be excluded (but package \"bar/foo\" will not).</div><div class=\"line\">    By default the init command adds the \"test\" tag to the ignore list.</div><div class=\"line\">If using go1.5, ensure GO15VENDOREXPERIMENT=1 is set.</div></pre></td></tr></table></figure>\n<h2>4. vendor.json</h2>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"comment\"</span>: <span class=\"string\">\"\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"ignore\"</span>: <span class=\"string\">\"test\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"package\"</span>: [</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"attr\">\"checksumSHA1\"</span>: <span class=\"string\">\"uGalSICR4r7354vvKuNnh7Y/R/4=\"</span>,</div><div class=\"line\">            <span class=\"attr\">\"path\"</span>: <span class=\"string\">\"github.com/urfave/cli\"</span>,</div><div class=\"line\">            <span class=\"attr\">\"revision\"</span>: <span class=\"string\">\"b99aa811b4c1dd84cc6bccb8499c82c72098085a\"</span>,</div><div class=\"line\">            <span class=\"attr\">\"revisionTime\"</span>: <span class=\"string\">\"2017-08-04T09:34:15Z\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    ],</div><div class=\"line\">    <span class=\"attr\">\"rootPath\"</span>: <span class=\"string\">\"waetool\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"[Golang] Golang系列（一）之基础篇","catalog":true,"date":"2017-09-16T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Golang"],"_content":"\n## 一、初识Go语言\n\n### （一）概述\n\n一个在语言层面实现了并发机制的类C通用型编程语言。\n\n### （二）Go关键字（25个）\n\n| 类别     | 关键字                                     | 说明                         |\n| ------ | --------------------------------------- | -------------------------- |\n| 程序声明   | package，import                          | 包的声明和导入                    |\n| 声明与定义  | var，const                               | 变量和常量的声明                   |\n|        | type                                    | 用于定义类型                     |\n| 复合数据类型 | struct                                  | 定义结构体，类似java中的class        |\n|        | interface                               | 定义接口                       |\n|        | map                                     | 定义键值对                      |\n|        | func                                    | 定义函数和方法                    |\n|        | chan                                    | 定义管道，并发中channel通信          |\n| 并发编程   | go                                      | 并发编程                       |\n|        | select                                  | 用于选择不同类型通信                 |\n| 流程控制   | for；if，else；switch，case                 | 循环语句；条件语句；选择语句             |\n|        | break，continue，fallthrough，default，goto | 跳转语句等                      |\n|        | return                                  | 函数返回值                      |\n|        | defer                                   | 延迟函数，用于return前释放资源         |\n|        | range                                   | 用于读取slice，map，channel容器类数据 |\n\n### （三）Go语言命令\n\n Usage：go command [arguments]\n\n| 分类   | 命令       | 说明                                       |\n| ---- | -------- | ---------------------------------------- |\n|      | build    | compile packages and dependencies        |\n|      | clean    | remove object files                      |\n|      | doc      | show documentation for package or symbol |\n|      | env      | print Go environment information         |\n|      | fix      | run go tool fix on packages              |\n|      | fmt      | run gofmt on package sources             |\n|      | generate | generate Go files by processing source   |\n|      | get      | download and install packages and dependencies |\n|      | install  | compile and install packages and dependencies |\n|      | list     | list packages                            |\n|      | run      | compile and run Go program               |\n|      | test     | test packages                            |\n|      | tool     | run specified go tool                    |\n|      | version  | print Go version                         |\n|      | vet      | run go tool vet on packages              |\n\n## 二、顺序编程\n\n### 1.变量\n\n#### 1.1变量声明\n\n```go\n//1、单变量声明,类型放在变量名之后，可以为任意类型\nvar 变量名 类型\nvar v1,v2,v3 string //多变量同类型声明\n//2、多变量声明\nvar {\n    v1 int\n    v2 []int\n}\n```\n\n#### 1.2变量初始化\n\n```go\n//1、使用关键字var，声明变量类型并赋值\nvar v1 int=10\n//2、使用关键字var，直接对变量赋值，go可以自动推导出变量类型\nvar v2=10\n//3、直接使用“：=”对变量赋值，不使用var，两者同时使用会语法冲突，推荐使用\nv3:=10\n```\n\n#### 1.3变量赋值\n\n```go\n//1、声明后再变量赋值\nvar v int\nv=10\n//2、多重赋值，经常使用在函数的多返回值中，err,v=func(arg)\ni，j=j,i  //两者互换，并不需要引入中间变量\n```\n\n#### 1.4匿名变量\n\n```go\n//Go中所有声明后的变量都需要调用到，当出现函数多返回值，并且部分返回值不需要使用时，可以使用匿名变量丢弃该返回值\nfunc GetName()(firstName,lastName,nickName string){\n  return \"May\",\"Chan\",\"Make\"\n}\n_,_,nickName:=GetName()  //使用匿名变量丢弃部分返回值\n```\n\n### 2.常量\n\n​\tGo语言中，常量是编译时期就已知且不可变的值，常量可以是数值类型（整型、浮点型、复数类型）、布尔类型、字符串类型。\n\n#### 2.1字面常量\n\n```go\n//字面常量(literal)指程序中硬编码的常量\n3.14\n“foo”\ntrue\n```\n\n#### 2.2常量定义\n\n```go\n//1、可以限定常量类型，但非必需\nconst Pi float64 = 3.14\n//2、无类型常量和字面常量一样\nconst zero=0.0\n//3、多常量赋值\nconst(\n  size int64=1024\n  eof=-1\n)\n//4、常量的多重赋值，类似变量的多重赋值\nconst u,v float32=0,3\nconst a,b,c=3,4,\"foo\"    //无类型常量的多重赋值\n//5、常量赋值是编译期行为，可以赋值为一个编译期运算的常量表达式\nconst mask=1<<3\n```\n\n#### 2.3预定义常量\n\n```go\n//预定义常量：true、false、iota\n//iota：可修改常量，在每次const出现时被重置为0，在下一个const出现前，每出现一次iota，其代表的值自动增1。\nconst(          //iota重置为0\n  c0=iota       //c0==0\n  c1=iota       //c1==1\n  c2=iota       //c2==2\n)\n//两个const赋值语句一样可以省略后一个\nconst(          //iota重置为0\n  c0=iota       //c0==0\n  c1            //c1==1\n  c2            //c2==2\n)\n```\n\n#### 2.4枚举\n\n枚举指一系列相关常量。\n\n```go\nconst(\n  Sunday=iota    //Sunday==0,以此类推\n  Monday\n  Tuesday\n  Wednesday\n  Thursday\n  Friday\n  Saturday       //大写字母开头表示包外可见\n  numberOfDays   //小写字母开头表示包内私有\n)\n```\n\n### 3.类型\n\n#### 3.1基础类型\n\n##### 3.1.1布尔类型\n\n```go\n//布尔类型的关键字为bool,值为true或false，不可写为0或1\nvar v1 bool\nv1=true\n//接受表达式判断赋值，不支持自动或强制类型转换\nv2:=(1==2)\n```\n\n##### 3.1.2整型\n\n ![整型](/img/article/golang/整型.png)\n\n```go\n//1、类型表示\n//int和int32为不同类型，不会自动类型转换需要强制类型转换\n//强制类型转换需注意精度损失（浮点数→整数），值溢出（大范围→小范围）\nvar v2 int32\nv1:=64\nv2=int32(v1)\n\n//2、数值运算,支持“+,-,*,/和%”\n5%3 //求余\n\n//3、比较运算,“<,>,==,>=,<=,!=”\n//不同类型不能进行比较例如int和int8，但可以与字面常量（literal）进行比较\nvar i int32\nvar j int64\ni,j=1,2\nif i==j  //编译错误，不同类型不能进行比较\nif i==1 || j==2  //编译通过，可以与字面常量（literal）进行比较\n\n//4、位运算\n//Go(^x)取反与C语言(~x)不同，其他类似，具体见下表\n```\n\n  ![位运算](/img/article/golang/位运算.png)\n\n##### 3.1.3浮点型\n\n```go\n//1、浮点型分为float32(类似C中的float)，float64(类似C中的double)\nvar f1 float32\nf1=12     //不加小数点，被推导为整型\nf2:=12.0  //加小数点，被推导为float64\nf1=float32(f2)  //需要执行强制转换\n//2、浮点数的比较\n//浮点数不是精确的表达方式，不能直接使用“==”来判断是否相等，可以借用math的包math.Fdim \n```\n\n##### 3.1.4复数类型\n\n```go\n//1、复数的表示\nvar v1 complex64\nv1=3.2+12i\n//v1 v2 v3 表示为同一个数\nv2:=3.2+12i\nv3:=complex(3.2,12)\n//2、实部与虚部\n//z=complex(x,y),通过内置函数实部x=real(z),虚部y=imag(z)\n```\n\n##### 3.1.5字符串\n\n```go\n//声明与赋值\nvar str string\nstr=\"hello world\"\n```\n\n ![字符串操作](/img/article/golang/字符串操作.png)\n\n##### 3.1.6字符类型\n\n```go\n//1、byte，即uint8的别名\n//2、rune，即Unicode\n```\n\n##### 3.1.7错误类型（error）\n\n#### 3.2复合类型\n\n##### 3.2.1数组(array)\n\n数组表示同一类型数据，数组长度定义后就不可更改，长度是数组内的一个内置常量，可通过len()来获取。\n\n```go\n//1、创建数组\nvar array1 [5]int    //声明：var 变量名 类型\nvar array2 [5]int=[5]int{1,2,3,4,5}   //初始化\narray3：=[5]int{1,2,3,4,5}    //直接用“：=”赋值\n[3][5]int  //二维数组\n[3]*float  //指针数组\n\n//2、元素访问\nfor i,v:=range array{\n  //第一个返回值为数组下标，第二个为元素的值\n}\n\n//3、值类型\n//数组在Go中作为一个值类型，值类型在赋值和函数参数传递时，只复制副本，因此在函数体中并不能改变数组的内容，需用指针来改变数组的值。\n```\n\n##### 3.2.2切片(slice)\n\n​\t数组在定义了长度后无法改变，且作为值类型在传递时产生副本，并不能改变数组元素的值。因此切片的功能弥补了这个不足，切片类似指向数组的一个指针。可以抽象为三个变量：指向数组的指针；切片中元素的个数(len函数)；已分配的存储空间(cap函数)。\n\n```go\n//1、创建切片\n//a)基于数组创建\nvar myArray [5]int=[5]{1,2,3,4,5}\nvar mySlice []int=myArray[first:last]\nslice1=myArray[:]   //基于数组所有元素创建\nslice2=myArray[:3]  //基于前三个元素创建\nslice3=myArray[3:]  //基于第3个元素开始后的所有元素创建\n//b)直接创建\nslice1:=make([]int,5)       //元素初始值为0，初始个数为5\nslice2:=make([]int,5,10)    //元素初始值为0，初始个数为5，预留个数为10\nslice3:=[]int{1,2,3,4,5}    //初始化赋值\n//c)基于切片创建\noldSlice:=[]int{1,2,3,4,5}\nnewSlice:=oldSlice[:3]   //基于切片创建，不能超过原切片的存储空间(cap函数的值)\n\n//2、元素遍历\nfor i,v:=range slice{\n  //与数组的方式一致，使用range来遍历\n  //第一个返回值(i)为索引，第二个为元素的值(v)\n}\n\n//3、动态增减元素\n//切片分存储空间(cap)和元素个数(len)，当存储空间小于实际的元素个数，会重新分配一块原空间2倍的内存块，并将原数据复制到该内存块中，合理的分配存储空间可以以空间换时间，降低系统开销。\n//添加元素\nnewSlice:=append(oldSlice,1,2,3)   //直接将元素加进去，若存储空间不够会按上述方式扩容。\nnewSlice1:=append(oldSlice1,oldSlice2...)  //将oldSlice2的元素打散后加到oldSlice1中，三个点不可省略。\n//删除元素则用delete函数替换append函数，用法一致。\n\n//4、内容复制\n//copy()函数可以复制切片，如果切片大小不一样，按较小的切片元素个数进行复制\nslice1:=[]int{1,2,3,4,5}\nslice2:=[]int{6,7,8}\ncopy(slice2,slice1)   //只会复制slice1的前三个元素到slice2中\ncopy(slice1,slice1)   //只会复制slice2的三个元素到slice1中的前三个位置\n```\n\n##### 3.2.3键值对(map)\n\nmap是一堆键值对的未排序集合。\n\n```go\n//1、声明\nvar map1 map[键类型] 值类型\n//创建\nmap1=make(map[键类型] 值类型)\nmap1=make(map[键类型] 值类型 存储空间)\n//赋值\nmap1[key]=value\n//创建并初始化\nmap1=map[key] value\n\n//2、元素删除\n//delete()函数删除对应key的键值对，如果key不存在，不会报错；如果value为nil，则会抛出异常(panic)。\ndelete(map1,key)  \n\n//3、元素查找\nvalue,ok:=myMap[key]\nif ok{//如果找到\n  //处理找到的value值\n}\n```\n\n##### 3.2.4指针(pointer)\n\n##### 3.2.5结构体(struct)\n\n##### 3.2.6接口(interface)\n\n##### 3.2.7通道(chan)\n\n### 4.流程语句\n\n#### 4.1条件语句\n\n```go\n//在if之后条件语句之前可以添加变量初始化语句，用;号隔离\nif <条件语句> {    //条件语句不需要用括号括起来，花括号必须存在\n  //语句体\n}else{\n  //语句体\n}\n\n//在有返回值的函数中，不允许将最后的return语句放在if...else...的结构中，否则会编译失败\n//例如以下为错误范例\nfunc example(x int) int{\n  if x==0{\n    return 5\n  }else{\n    return x  //最后的return语句放在if-else结构中，所以编译失败\n  }\n}\n```\n\n#### 4.2选择语句\n\n```go\n//1、根据条件不同，对应不同的执行体\nswitch i{\n  case 0:\n  \tfmt.Printf(\"0\")\n  case 1:                //满足条件就会退出，只有添加fallthrough才会继续执行下一个case语句\n  \tfmt.Prinntf(\"1\")\n  case 2,3,4:            //单个case可以出现多个选项\n  \tfmt.Printf(\"2,3,4\")\n  default:               //当都不满足以上条件时，执行default语句\n  \tfmt.Printf(\"Default\")\n}\n\n//2、该模式等价于多个if-else的功能\nswitch {\n  case <条件表达式1>:\n  \t语句体1\n  case <条件表达式2>:\n  \t语句体2\n}\n```\n\n#### 4.3循环语句\n\n```go\n//1、Go只支持for关键字，不支持while，do-while结构\nfor i,j:=0,1;i<10;i++{    //支持多个赋值\n  //语句体\n}\n\n//2、无限循环\nsum:=1\nfor{  //不接条件表达式表示无限循环\n  sum++\n  if sum > 100{\n    break   //满足条件跳出循环\n  }\n}\n\n//3、支持continue和break，break可以指定中断哪个循环，break JLoop(标签)\nfor j:=0;j<5;j++{\n  for i:=0;i<10;i++{\n    if i>5{\n      break JLoop   //终止JLoop标签处的外层循环\n  }\n  fmt.Println(i)\n}\nJLoop:    //标签处\n...\n```\n\n#### 4.4跳转语句\n\n```go\n//关键字goto支持跳转\nfunc myfunc(){\n  i:=0\n  HERE:           //定义标签处\n  fmt.Println(i)\n  i++\n  if i<10{\n    goto HERE     //跳转到标签处\n  }\n}\n```\n\n### 5.函数\n\n#### 5.1函数定义与调用\n\n```go\n//1、函数组成：关键字func ,函数名，参数列表，返回值，函数体，返回语句\n//先名称后类型\nfunc 函数名(参数列表)(返回值列表){  //参数列表和返回值列表以变量声明的形式，如果单返回值可以直接加类型\n  函数体\n  return    //返回语句\n}\n//例子\nfunc Add(a,b int)(ret int,err error){\n  //函数体 \n  return   //return语句\n}\n\n//2、函数调用\n//先导入函数所在的包，直接调用函数\nimport \"mymath\"\nsum,err:=mymath.Add(1,2)   //多返回值和错误处理机制\n//可见性，包括函数、类型、变量\n//本包内可见(private)：小写字母开头\n//包外可见(public)：大写字母开头\n```\n\n#### 5.2不定参数\n\n```go\n//1、不定参数的类型\nfunc myfunc(args ...int){   //...type不定参数的类型，必须是最后一个参数，本质是切片\n  for _,arg:=range args{\n    fmt.Println(arg)\n  }\n}\n//函数调用,传参可以选择多个，个数不定\nmyfunc(1,2,3)\nmyfunc(1,2,3,4,5)\n\n//2、不定参数的传递，假如有个变参函数myfunc2(args ...int)\nfunc myfunc1(args ...int){\n  //按原样传递\n  myfunc2(args...)\n  //传递切片\n  myfunc2(args[1:]...)\n}\n\n//3、任意类型的不定参数，使用interface{}作为指定类型\nfunc Printf(format string,args ...interface{}){   //此为标准库中fmt.Printf()函数的原型\n  //函数体\n}\n```\n\n#### 5.3多返回值\n\n```go\n//多返回值\nfunc (file *File) Read(b []byte) (n int,err error)\n//使用下划线\"_\"来丢弃返回值\nn,_:=f.Read(buf)\n```\n\n#### 5.4匿名函数与闭包\n\n```go\n//1、匿名函数：不带函数名的函数，可以像变量一样被传递\nfunc(a,b int,z float32) bool{  //没有函数名\n  return a*b<int(z)\n}\nf:=func(x,y int) int{\n  return x+y\n}\n\n//2、闭包\n```\n\n","source":"_posts/Golang/Golang系列（一）之基础篇.md","raw":"---\ntitle: \"[Golang] Golang系列（一）之基础篇\"\ncatalog: true\ndate: 2017-09-16 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Golang\ncatagories:\n- Golang\n---\n\n## 一、初识Go语言\n\n### （一）概述\n\n一个在语言层面实现了并发机制的类C通用型编程语言。\n\n### （二）Go关键字（25个）\n\n| 类别     | 关键字                                     | 说明                         |\n| ------ | --------------------------------------- | -------------------------- |\n| 程序声明   | package，import                          | 包的声明和导入                    |\n| 声明与定义  | var，const                               | 变量和常量的声明                   |\n|        | type                                    | 用于定义类型                     |\n| 复合数据类型 | struct                                  | 定义结构体，类似java中的class        |\n|        | interface                               | 定义接口                       |\n|        | map                                     | 定义键值对                      |\n|        | func                                    | 定义函数和方法                    |\n|        | chan                                    | 定义管道，并发中channel通信          |\n| 并发编程   | go                                      | 并发编程                       |\n|        | select                                  | 用于选择不同类型通信                 |\n| 流程控制   | for；if，else；switch，case                 | 循环语句；条件语句；选择语句             |\n|        | break，continue，fallthrough，default，goto | 跳转语句等                      |\n|        | return                                  | 函数返回值                      |\n|        | defer                                   | 延迟函数，用于return前释放资源         |\n|        | range                                   | 用于读取slice，map，channel容器类数据 |\n\n### （三）Go语言命令\n\n Usage：go command [arguments]\n\n| 分类   | 命令       | 说明                                       |\n| ---- | -------- | ---------------------------------------- |\n|      | build    | compile packages and dependencies        |\n|      | clean    | remove object files                      |\n|      | doc      | show documentation for package or symbol |\n|      | env      | print Go environment information         |\n|      | fix      | run go tool fix on packages              |\n|      | fmt      | run gofmt on package sources             |\n|      | generate | generate Go files by processing source   |\n|      | get      | download and install packages and dependencies |\n|      | install  | compile and install packages and dependencies |\n|      | list     | list packages                            |\n|      | run      | compile and run Go program               |\n|      | test     | test packages                            |\n|      | tool     | run specified go tool                    |\n|      | version  | print Go version                         |\n|      | vet      | run go tool vet on packages              |\n\n## 二、顺序编程\n\n### 1.变量\n\n#### 1.1变量声明\n\n```go\n//1、单变量声明,类型放在变量名之后，可以为任意类型\nvar 变量名 类型\nvar v1,v2,v3 string //多变量同类型声明\n//2、多变量声明\nvar {\n    v1 int\n    v2 []int\n}\n```\n\n#### 1.2变量初始化\n\n```go\n//1、使用关键字var，声明变量类型并赋值\nvar v1 int=10\n//2、使用关键字var，直接对变量赋值，go可以自动推导出变量类型\nvar v2=10\n//3、直接使用“：=”对变量赋值，不使用var，两者同时使用会语法冲突，推荐使用\nv3:=10\n```\n\n#### 1.3变量赋值\n\n```go\n//1、声明后再变量赋值\nvar v int\nv=10\n//2、多重赋值，经常使用在函数的多返回值中，err,v=func(arg)\ni，j=j,i  //两者互换，并不需要引入中间变量\n```\n\n#### 1.4匿名变量\n\n```go\n//Go中所有声明后的变量都需要调用到，当出现函数多返回值，并且部分返回值不需要使用时，可以使用匿名变量丢弃该返回值\nfunc GetName()(firstName,lastName,nickName string){\n  return \"May\",\"Chan\",\"Make\"\n}\n_,_,nickName:=GetName()  //使用匿名变量丢弃部分返回值\n```\n\n### 2.常量\n\n​\tGo语言中，常量是编译时期就已知且不可变的值，常量可以是数值类型（整型、浮点型、复数类型）、布尔类型、字符串类型。\n\n#### 2.1字面常量\n\n```go\n//字面常量(literal)指程序中硬编码的常量\n3.14\n“foo”\ntrue\n```\n\n#### 2.2常量定义\n\n```go\n//1、可以限定常量类型，但非必需\nconst Pi float64 = 3.14\n//2、无类型常量和字面常量一样\nconst zero=0.0\n//3、多常量赋值\nconst(\n  size int64=1024\n  eof=-1\n)\n//4、常量的多重赋值，类似变量的多重赋值\nconst u,v float32=0,3\nconst a,b,c=3,4,\"foo\"    //无类型常量的多重赋值\n//5、常量赋值是编译期行为，可以赋值为一个编译期运算的常量表达式\nconst mask=1<<3\n```\n\n#### 2.3预定义常量\n\n```go\n//预定义常量：true、false、iota\n//iota：可修改常量，在每次const出现时被重置为0，在下一个const出现前，每出现一次iota，其代表的值自动增1。\nconst(          //iota重置为0\n  c0=iota       //c0==0\n  c1=iota       //c1==1\n  c2=iota       //c2==2\n)\n//两个const赋值语句一样可以省略后一个\nconst(          //iota重置为0\n  c0=iota       //c0==0\n  c1            //c1==1\n  c2            //c2==2\n)\n```\n\n#### 2.4枚举\n\n枚举指一系列相关常量。\n\n```go\nconst(\n  Sunday=iota    //Sunday==0,以此类推\n  Monday\n  Tuesday\n  Wednesday\n  Thursday\n  Friday\n  Saturday       //大写字母开头表示包外可见\n  numberOfDays   //小写字母开头表示包内私有\n)\n```\n\n### 3.类型\n\n#### 3.1基础类型\n\n##### 3.1.1布尔类型\n\n```go\n//布尔类型的关键字为bool,值为true或false，不可写为0或1\nvar v1 bool\nv1=true\n//接受表达式判断赋值，不支持自动或强制类型转换\nv2:=(1==2)\n```\n\n##### 3.1.2整型\n\n ![整型](/img/article/golang/整型.png)\n\n```go\n//1、类型表示\n//int和int32为不同类型，不会自动类型转换需要强制类型转换\n//强制类型转换需注意精度损失（浮点数→整数），值溢出（大范围→小范围）\nvar v2 int32\nv1:=64\nv2=int32(v1)\n\n//2、数值运算,支持“+,-,*,/和%”\n5%3 //求余\n\n//3、比较运算,“<,>,==,>=,<=,!=”\n//不同类型不能进行比较例如int和int8，但可以与字面常量（literal）进行比较\nvar i int32\nvar j int64\ni,j=1,2\nif i==j  //编译错误，不同类型不能进行比较\nif i==1 || j==2  //编译通过，可以与字面常量（literal）进行比较\n\n//4、位运算\n//Go(^x)取反与C语言(~x)不同，其他类似，具体见下表\n```\n\n  ![位运算](/img/article/golang/位运算.png)\n\n##### 3.1.3浮点型\n\n```go\n//1、浮点型分为float32(类似C中的float)，float64(类似C中的double)\nvar f1 float32\nf1=12     //不加小数点，被推导为整型\nf2:=12.0  //加小数点，被推导为float64\nf1=float32(f2)  //需要执行强制转换\n//2、浮点数的比较\n//浮点数不是精确的表达方式，不能直接使用“==”来判断是否相等，可以借用math的包math.Fdim \n```\n\n##### 3.1.4复数类型\n\n```go\n//1、复数的表示\nvar v1 complex64\nv1=3.2+12i\n//v1 v2 v3 表示为同一个数\nv2:=3.2+12i\nv3:=complex(3.2,12)\n//2、实部与虚部\n//z=complex(x,y),通过内置函数实部x=real(z),虚部y=imag(z)\n```\n\n##### 3.1.5字符串\n\n```go\n//声明与赋值\nvar str string\nstr=\"hello world\"\n```\n\n ![字符串操作](/img/article/golang/字符串操作.png)\n\n##### 3.1.6字符类型\n\n```go\n//1、byte，即uint8的别名\n//2、rune，即Unicode\n```\n\n##### 3.1.7错误类型（error）\n\n#### 3.2复合类型\n\n##### 3.2.1数组(array)\n\n数组表示同一类型数据，数组长度定义后就不可更改，长度是数组内的一个内置常量，可通过len()来获取。\n\n```go\n//1、创建数组\nvar array1 [5]int    //声明：var 变量名 类型\nvar array2 [5]int=[5]int{1,2,3,4,5}   //初始化\narray3：=[5]int{1,2,3,4,5}    //直接用“：=”赋值\n[3][5]int  //二维数组\n[3]*float  //指针数组\n\n//2、元素访问\nfor i,v:=range array{\n  //第一个返回值为数组下标，第二个为元素的值\n}\n\n//3、值类型\n//数组在Go中作为一个值类型，值类型在赋值和函数参数传递时，只复制副本，因此在函数体中并不能改变数组的内容，需用指针来改变数组的值。\n```\n\n##### 3.2.2切片(slice)\n\n​\t数组在定义了长度后无法改变，且作为值类型在传递时产生副本，并不能改变数组元素的值。因此切片的功能弥补了这个不足，切片类似指向数组的一个指针。可以抽象为三个变量：指向数组的指针；切片中元素的个数(len函数)；已分配的存储空间(cap函数)。\n\n```go\n//1、创建切片\n//a)基于数组创建\nvar myArray [5]int=[5]{1,2,3,4,5}\nvar mySlice []int=myArray[first:last]\nslice1=myArray[:]   //基于数组所有元素创建\nslice2=myArray[:3]  //基于前三个元素创建\nslice3=myArray[3:]  //基于第3个元素开始后的所有元素创建\n//b)直接创建\nslice1:=make([]int,5)       //元素初始值为0，初始个数为5\nslice2:=make([]int,5,10)    //元素初始值为0，初始个数为5，预留个数为10\nslice3:=[]int{1,2,3,4,5}    //初始化赋值\n//c)基于切片创建\noldSlice:=[]int{1,2,3,4,5}\nnewSlice:=oldSlice[:3]   //基于切片创建，不能超过原切片的存储空间(cap函数的值)\n\n//2、元素遍历\nfor i,v:=range slice{\n  //与数组的方式一致，使用range来遍历\n  //第一个返回值(i)为索引，第二个为元素的值(v)\n}\n\n//3、动态增减元素\n//切片分存储空间(cap)和元素个数(len)，当存储空间小于实际的元素个数，会重新分配一块原空间2倍的内存块，并将原数据复制到该内存块中，合理的分配存储空间可以以空间换时间，降低系统开销。\n//添加元素\nnewSlice:=append(oldSlice,1,2,3)   //直接将元素加进去，若存储空间不够会按上述方式扩容。\nnewSlice1:=append(oldSlice1,oldSlice2...)  //将oldSlice2的元素打散后加到oldSlice1中，三个点不可省略。\n//删除元素则用delete函数替换append函数，用法一致。\n\n//4、内容复制\n//copy()函数可以复制切片，如果切片大小不一样，按较小的切片元素个数进行复制\nslice1:=[]int{1,2,3,4,5}\nslice2:=[]int{6,7,8}\ncopy(slice2,slice1)   //只会复制slice1的前三个元素到slice2中\ncopy(slice1,slice1)   //只会复制slice2的三个元素到slice1中的前三个位置\n```\n\n##### 3.2.3键值对(map)\n\nmap是一堆键值对的未排序集合。\n\n```go\n//1、声明\nvar map1 map[键类型] 值类型\n//创建\nmap1=make(map[键类型] 值类型)\nmap1=make(map[键类型] 值类型 存储空间)\n//赋值\nmap1[key]=value\n//创建并初始化\nmap1=map[key] value\n\n//2、元素删除\n//delete()函数删除对应key的键值对，如果key不存在，不会报错；如果value为nil，则会抛出异常(panic)。\ndelete(map1,key)  \n\n//3、元素查找\nvalue,ok:=myMap[key]\nif ok{//如果找到\n  //处理找到的value值\n}\n```\n\n##### 3.2.4指针(pointer)\n\n##### 3.2.5结构体(struct)\n\n##### 3.2.6接口(interface)\n\n##### 3.2.7通道(chan)\n\n### 4.流程语句\n\n#### 4.1条件语句\n\n```go\n//在if之后条件语句之前可以添加变量初始化语句，用;号隔离\nif <条件语句> {    //条件语句不需要用括号括起来，花括号必须存在\n  //语句体\n}else{\n  //语句体\n}\n\n//在有返回值的函数中，不允许将最后的return语句放在if...else...的结构中，否则会编译失败\n//例如以下为错误范例\nfunc example(x int) int{\n  if x==0{\n    return 5\n  }else{\n    return x  //最后的return语句放在if-else结构中，所以编译失败\n  }\n}\n```\n\n#### 4.2选择语句\n\n```go\n//1、根据条件不同，对应不同的执行体\nswitch i{\n  case 0:\n  \tfmt.Printf(\"0\")\n  case 1:                //满足条件就会退出，只有添加fallthrough才会继续执行下一个case语句\n  \tfmt.Prinntf(\"1\")\n  case 2,3,4:            //单个case可以出现多个选项\n  \tfmt.Printf(\"2,3,4\")\n  default:               //当都不满足以上条件时，执行default语句\n  \tfmt.Printf(\"Default\")\n}\n\n//2、该模式等价于多个if-else的功能\nswitch {\n  case <条件表达式1>:\n  \t语句体1\n  case <条件表达式2>:\n  \t语句体2\n}\n```\n\n#### 4.3循环语句\n\n```go\n//1、Go只支持for关键字，不支持while，do-while结构\nfor i,j:=0,1;i<10;i++{    //支持多个赋值\n  //语句体\n}\n\n//2、无限循环\nsum:=1\nfor{  //不接条件表达式表示无限循环\n  sum++\n  if sum > 100{\n    break   //满足条件跳出循环\n  }\n}\n\n//3、支持continue和break，break可以指定中断哪个循环，break JLoop(标签)\nfor j:=0;j<5;j++{\n  for i:=0;i<10;i++{\n    if i>5{\n      break JLoop   //终止JLoop标签处的外层循环\n  }\n  fmt.Println(i)\n}\nJLoop:    //标签处\n...\n```\n\n#### 4.4跳转语句\n\n```go\n//关键字goto支持跳转\nfunc myfunc(){\n  i:=0\n  HERE:           //定义标签处\n  fmt.Println(i)\n  i++\n  if i<10{\n    goto HERE     //跳转到标签处\n  }\n}\n```\n\n### 5.函数\n\n#### 5.1函数定义与调用\n\n```go\n//1、函数组成：关键字func ,函数名，参数列表，返回值，函数体，返回语句\n//先名称后类型\nfunc 函数名(参数列表)(返回值列表){  //参数列表和返回值列表以变量声明的形式，如果单返回值可以直接加类型\n  函数体\n  return    //返回语句\n}\n//例子\nfunc Add(a,b int)(ret int,err error){\n  //函数体 \n  return   //return语句\n}\n\n//2、函数调用\n//先导入函数所在的包，直接调用函数\nimport \"mymath\"\nsum,err:=mymath.Add(1,2)   //多返回值和错误处理机制\n//可见性，包括函数、类型、变量\n//本包内可见(private)：小写字母开头\n//包外可见(public)：大写字母开头\n```\n\n#### 5.2不定参数\n\n```go\n//1、不定参数的类型\nfunc myfunc(args ...int){   //...type不定参数的类型，必须是最后一个参数，本质是切片\n  for _,arg:=range args{\n    fmt.Println(arg)\n  }\n}\n//函数调用,传参可以选择多个，个数不定\nmyfunc(1,2,3)\nmyfunc(1,2,3,4,5)\n\n//2、不定参数的传递，假如有个变参函数myfunc2(args ...int)\nfunc myfunc1(args ...int){\n  //按原样传递\n  myfunc2(args...)\n  //传递切片\n  myfunc2(args[1:]...)\n}\n\n//3、任意类型的不定参数，使用interface{}作为指定类型\nfunc Printf(format string,args ...interface{}){   //此为标准库中fmt.Printf()函数的原型\n  //函数体\n}\n```\n\n#### 5.3多返回值\n\n```go\n//多返回值\nfunc (file *File) Read(b []byte) (n int,err error)\n//使用下划线\"_\"来丢弃返回值\nn,_:=f.Read(buf)\n```\n\n#### 5.4匿名函数与闭包\n\n```go\n//1、匿名函数：不带函数名的函数，可以像变量一样被传递\nfunc(a,b int,z float32) bool{  //没有函数名\n  return a*b<int(z)\n}\nf:=func(x,y int) int{\n  return x+y\n}\n\n//2、闭包\n```\n\n","slug":"Golang/Golang系列（一）之基础篇","published":1,"updated":"2017-10-02T12:55:22.618Z","_id":"cj8b7chee00042cvu9eng582l","comments":1,"layout":"post","photos":[],"link":"","content":"<h2><span id=\"一-初识go语言\">一、初识Go语言</span></h2>\n<h3><span id=\"一概述\">（一）概述</span></h3>\n<p>一个在语言层面实现了并发机制的类C通用型编程语言。</p>\n<h3><span id=\"二go关键字25个\">（二）Go关键字（25个）</span></h3>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>关键字</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>程序声明</td>\n<td>package，import</td>\n<td>包的声明和导入</td>\n</tr>\n<tr>\n<td>声明与定义</td>\n<td>var，const</td>\n<td>变量和常量的声明</td>\n</tr>\n<tr>\n<td></td>\n<td>type</td>\n<td>用于定义类型</td>\n</tr>\n<tr>\n<td>复合数据类型</td>\n<td>struct</td>\n<td>定义结构体，类似java中的class</td>\n</tr>\n<tr>\n<td></td>\n<td>interface</td>\n<td>定义接口</td>\n</tr>\n<tr>\n<td></td>\n<td>map</td>\n<td>定义键值对</td>\n</tr>\n<tr>\n<td></td>\n<td>func</td>\n<td>定义函数和方法</td>\n</tr>\n<tr>\n<td></td>\n<td>chan</td>\n<td>定义管道，并发中channel通信</td>\n</tr>\n<tr>\n<td>并发编程</td>\n<td>go</td>\n<td>并发编程</td>\n</tr>\n<tr>\n<td></td>\n<td>select</td>\n<td>用于选择不同类型通信</td>\n</tr>\n<tr>\n<td>流程控制</td>\n<td>for；if，else；switch，case</td>\n<td>循环语句；条件语句；选择语句</td>\n</tr>\n<tr>\n<td></td>\n<td>break，continue，fallthrough，default，goto</td>\n<td>跳转语句等</td>\n</tr>\n<tr>\n<td></td>\n<td>return</td>\n<td>函数返回值</td>\n</tr>\n<tr>\n<td></td>\n<td>defer</td>\n<td>延迟函数，用于return前释放资源</td>\n</tr>\n<tr>\n<td></td>\n<td>range</td>\n<td>用于读取slice，map，channel容器类数据</td>\n</tr>\n</tbody>\n</table>\n<h3><span id=\"三go语言命令\">（三）Go语言命令</span></h3>\n<p>Usage：go command [arguments]</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td>build</td>\n<td>compile packages and dependencies</td>\n</tr>\n<tr>\n<td></td>\n<td>clean</td>\n<td>remove object files</td>\n</tr>\n<tr>\n<td></td>\n<td>doc</td>\n<td>show documentation for package or symbol</td>\n</tr>\n<tr>\n<td></td>\n<td>env</td>\n<td>print Go environment information</td>\n</tr>\n<tr>\n<td></td>\n<td>fix</td>\n<td>run go tool fix on packages</td>\n</tr>\n<tr>\n<td></td>\n<td>fmt</td>\n<td>run gofmt on package sources</td>\n</tr>\n<tr>\n<td></td>\n<td>generate</td>\n<td>generate Go files by processing source</td>\n</tr>\n<tr>\n<td></td>\n<td>get</td>\n<td>download and install packages and dependencies</td>\n</tr>\n<tr>\n<td></td>\n<td>install</td>\n<td>compile and install packages and dependencies</td>\n</tr>\n<tr>\n<td></td>\n<td>list</td>\n<td>list packages</td>\n</tr>\n<tr>\n<td></td>\n<td>run</td>\n<td>compile and run Go program</td>\n</tr>\n<tr>\n<td></td>\n<td>test</td>\n<td>test packages</td>\n</tr>\n<tr>\n<td></td>\n<td>tool</td>\n<td>run specified go tool</td>\n</tr>\n<tr>\n<td></td>\n<td>version</td>\n<td>print Go version</td>\n</tr>\n<tr>\n<td></td>\n<td>vet</td>\n<td>run go tool vet on packages</td>\n</tr>\n</tbody>\n</table>\n<h2><span id=\"二-顺序编程\">二、顺序编程</span></h2>\n<h3><span id=\"1变量\">1.变量</span></h3>\n<h4><span id=\"11变量声明\">1.1变量声明</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、单变量声明,类型放在变量名之后，可以为任意类型</span></div><div class=\"line\"><span class=\"keyword\">var</span> 变量名 类型</div><div class=\"line\"><span class=\"keyword\">var</span> v1,v2,v3 <span class=\"keyword\">string</span> <span class=\"comment\">//多变量同类型声明</span></div><div class=\"line\"><span class=\"comment\">//2、多变量声明</span></div><div class=\"line\"><span class=\"keyword\">var</span> &#123;</div><div class=\"line\">    v1 <span class=\"keyword\">int</span></div><div class=\"line\">    v2 []<span class=\"keyword\">int</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4><span id=\"12变量初始化\">1.2变量初始化</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、使用关键字var，声明变量类型并赋值</span></div><div class=\"line\"><span class=\"keyword\">var</span> v1 <span class=\"keyword\">int</span>=<span class=\"number\">10</span></div><div class=\"line\"><span class=\"comment\">//2、使用关键字var，直接对变量赋值，go可以自动推导出变量类型</span></div><div class=\"line\"><span class=\"keyword\">var</span> v2=<span class=\"number\">10</span></div><div class=\"line\"><span class=\"comment\">//3、直接使用“：=”对变量赋值，不使用var，两者同时使用会语法冲突，推荐使用</span></div><div class=\"line\">v3:=<span class=\"number\">10</span></div></pre></td></tr></table></figure>\n<h4><span id=\"13变量赋值\">1.3变量赋值</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、声明后再变量赋值</span></div><div class=\"line\"><span class=\"keyword\">var</span> v <span class=\"keyword\">int</span></div><div class=\"line\">v=<span class=\"number\">10</span></div><div class=\"line\"><span class=\"comment\">//2、多重赋值，经常使用在函数的多返回值中，err,v=func(arg)</span></div><div class=\"line\">i，j=j,i  <span class=\"comment\">//两者互换，并不需要引入中间变量</span></div></pre></td></tr></table></figure>\n<h4><span id=\"14匿名变量\">1.4匿名变量</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Go中所有声明后的变量都需要调用到，当出现函数多返回值，并且部分返回值不需要使用时，可以使用匿名变量丢弃该返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GetName</span><span class=\"params\">()</span><span class=\"params\">(firstName,lastName,nickName <span class=\"keyword\">string</span>)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"May\"</span>,<span class=\"string\">\"Chan\"</span>,<span class=\"string\">\"Make\"</span></div><div class=\"line\">&#125;</div><div class=\"line\">_,_,nickName:=GetName()  <span class=\"comment\">//使用匿名变量丢弃部分返回值</span></div></pre></td></tr></table></figure>\n<h3><span id=\"2常量\">2.常量</span></h3>\n<p>​\tGo语言中，常量是编译时期就已知且不可变的值，常量可以是数值类型（整型、浮点型、复数类型）、布尔类型、字符串类型。</p>\n<h4><span id=\"21字面常量\">2.1字面常量</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//字面常量(literal)指程序中硬编码的常量</span></div><div class=\"line\"><span class=\"number\">3.14</span></div><div class=\"line\">“foo”</div><div class=\"line\"><span class=\"literal\">true</span></div></pre></td></tr></table></figure>\n<h4><span id=\"22常量定义\">2.2常量定义</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、可以限定常量类型，但非必需</span></div><div class=\"line\"><span class=\"keyword\">const</span> Pi <span class=\"keyword\">float64</span> = <span class=\"number\">3.14</span></div><div class=\"line\"><span class=\"comment\">//2、无类型常量和字面常量一样</span></div><div class=\"line\"><span class=\"keyword\">const</span> zero=<span class=\"number\">0.0</span></div><div class=\"line\"><span class=\"comment\">//3、多常量赋值</span></div><div class=\"line\"><span class=\"keyword\">const</span>(</div><div class=\"line\">  size <span class=\"keyword\">int64</span>=<span class=\"number\">1024</span></div><div class=\"line\">  eof=<span class=\"number\">-1</span></div><div class=\"line\">)</div><div class=\"line\"><span class=\"comment\">//4、常量的多重赋值，类似变量的多重赋值</span></div><div class=\"line\"><span class=\"keyword\">const</span> u,v <span class=\"keyword\">float32</span>=<span class=\"number\">0</span>,<span class=\"number\">3</span></div><div class=\"line\"><span class=\"keyword\">const</span> a,b,c=<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"string\">\"foo\"</span>    <span class=\"comment\">//无类型常量的多重赋值</span></div><div class=\"line\"><span class=\"comment\">//5、常量赋值是编译期行为，可以赋值为一个编译期运算的常量表达式</span></div><div class=\"line\"><span class=\"keyword\">const</span> mask=<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span></div></pre></td></tr></table></figure>\n<h4><span id=\"23预定义常量\">2.3预定义常量</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//预定义常量：true、false、iota</span></div><div class=\"line\"><span class=\"comment\">//iota：可修改常量，在每次const出现时被重置为0，在下一个const出现前，每出现一次iota，其代表的值自动增1。</span></div><div class=\"line\"><span class=\"keyword\">const</span>(          <span class=\"comment\">//iota重置为0</span></div><div class=\"line\">  c0=<span class=\"literal\">iota</span>       <span class=\"comment\">//c0==0</span></div><div class=\"line\">  c1=<span class=\"literal\">iota</span>       <span class=\"comment\">//c1==1</span></div><div class=\"line\">  c2=<span class=\"literal\">iota</span>       <span class=\"comment\">//c2==2</span></div><div class=\"line\">)</div><div class=\"line\"><span class=\"comment\">//两个const赋值语句一样可以省略后一个</span></div><div class=\"line\"><span class=\"keyword\">const</span>(          <span class=\"comment\">//iota重置为0</span></div><div class=\"line\">  c0=<span class=\"literal\">iota</span>       <span class=\"comment\">//c0==0</span></div><div class=\"line\">  c1            <span class=\"comment\">//c1==1</span></div><div class=\"line\">  c2            <span class=\"comment\">//c2==2</span></div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<h4><span id=\"24枚举\">2.4枚举</span></h4>\n<p>枚举指一系列相关常量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span>(</div><div class=\"line\">  Sunday=<span class=\"literal\">iota</span>    <span class=\"comment\">//Sunday==0,以此类推</span></div><div class=\"line\">  Monday</div><div class=\"line\">  Tuesday</div><div class=\"line\">  Wednesday</div><div class=\"line\">  Thursday</div><div class=\"line\">  Friday</div><div class=\"line\">  Saturday       <span class=\"comment\">//大写字母开头表示包外可见</span></div><div class=\"line\">  numberOfDays   <span class=\"comment\">//小写字母开头表示包内私有</span></div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<h3><span id=\"3类型\">3.类型</span></h3>\n<h4><span id=\"31基础类型\">3.1基础类型</span></h4>\n<h5><span id=\"311布尔类型\">3.1.1布尔类型</span></h5>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//布尔类型的关键字为bool,值为true或false，不可写为0或1</span></div><div class=\"line\"><span class=\"keyword\">var</span> v1 <span class=\"keyword\">bool</span></div><div class=\"line\">v1=<span class=\"literal\">true</span></div><div class=\"line\"><span class=\"comment\">//接受表达式判断赋值，不支持自动或强制类型转换</span></div><div class=\"line\">v2:=(<span class=\"number\">1</span>==<span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<h5><span id=\"312整型\">3.1.2整型</span></h5>\n<p><img src=\"/img/article/golang/%E6%95%B4%E5%9E%8B.png\" alt=\"整型\"></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、类型表示</span></div><div class=\"line\"><span class=\"comment\">//int和int32为不同类型，不会自动类型转换需要强制类型转换</span></div><div class=\"line\"><span class=\"comment\">//强制类型转换需注意精度损失（浮点数→整数），值溢出（大范围→小范围）</span></div><div class=\"line\"><span class=\"keyword\">var</span> v2 <span class=\"keyword\">int32</span></div><div class=\"line\">v1:=<span class=\"number\">64</span></div><div class=\"line\">v2=<span class=\"keyword\">int32</span>(v1)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、数值运算,支持“+,-,*,/和%”</span></div><div class=\"line\"><span class=\"number\">5</span>%<span class=\"number\">3</span> <span class=\"comment\">//求余</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//3、比较运算,“&lt;,&gt;,==,&gt;=,&lt;=,!=”</span></div><div class=\"line\"><span class=\"comment\">//不同类型不能进行比较例如int和int8，但可以与字面常量（literal）进行比较</span></div><div class=\"line\"><span class=\"keyword\">var</span> i <span class=\"keyword\">int32</span></div><div class=\"line\"><span class=\"keyword\">var</span> j <span class=\"keyword\">int64</span></div><div class=\"line\">i,j=<span class=\"number\">1</span>,<span class=\"number\">2</span></div><div class=\"line\"><span class=\"keyword\">if</span> i==j  <span class=\"comment\">//编译错误，不同类型不能进行比较</span></div><div class=\"line\"><span class=\"keyword\">if</span> i==<span class=\"number\">1</span> || j==<span class=\"number\">2</span>  <span class=\"comment\">//编译通过，可以与字面常量（literal）进行比较</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//4、位运算</span></div><div class=\"line\"><span class=\"comment\">//Go(^x)取反与C语言(~x)不同，其他类似，具体见下表</span></div></pre></td></tr></table></figure>\n<p><img src=\"/img/article/golang/%E4%BD%8D%E8%BF%90%E7%AE%97.png\" alt=\"位运算\"></p>\n<h5><span id=\"313浮点型\">3.1.3浮点型</span></h5>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、浮点型分为float32(类似C中的float)，float64(类似C中的double)</span></div><div class=\"line\"><span class=\"keyword\">var</span> f1 <span class=\"keyword\">float32</span></div><div class=\"line\">f1=<span class=\"number\">12</span>     <span class=\"comment\">//不加小数点，被推导为整型</span></div><div class=\"line\">f2:=<span class=\"number\">12.0</span>  <span class=\"comment\">//加小数点，被推导为float64</span></div><div class=\"line\">f1=<span class=\"keyword\">float32</span>(f2)  <span class=\"comment\">//需要执行强制转换</span></div><div class=\"line\"><span class=\"comment\">//2、浮点数的比较</span></div><div class=\"line\"><span class=\"comment\">//浮点数不是精确的表达方式，不能直接使用“==”来判断是否相等，可以借用math的包math.Fdim</span></div></pre></td></tr></table></figure>\n<h5><span id=\"314复数类型\">3.1.4复数类型</span></h5>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、复数的表示</span></div><div class=\"line\"><span class=\"keyword\">var</span> v1 <span class=\"keyword\">complex64</span></div><div class=\"line\">v1=<span class=\"number\">3.2</span>+<span class=\"number\">12i</span></div><div class=\"line\"><span class=\"comment\">//v1 v2 v3 表示为同一个数</span></div><div class=\"line\">v2:=<span class=\"number\">3.2</span>+<span class=\"number\">12i</span></div><div class=\"line\">v3:=<span class=\"built_in\">complex</span>(<span class=\"number\">3.2</span>,<span class=\"number\">12</span>)</div><div class=\"line\"><span class=\"comment\">//2、实部与虚部</span></div><div class=\"line\"><span class=\"comment\">//z=complex(x,y),通过内置函数实部x=real(z),虚部y=imag(z)</span></div></pre></td></tr></table></figure>\n<h5><span id=\"315字符串\">3.1.5字符串</span></h5>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//声明与赋值</span></div><div class=\"line\"><span class=\"keyword\">var</span> str <span class=\"keyword\">string</span></div><div class=\"line\">str=<span class=\"string\">\"hello world\"</span></div></pre></td></tr></table></figure>\n<p><img src=\"/img/article/golang/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C.png\" alt=\"字符串操作\"></p>\n<h5><span id=\"316字符类型\">3.1.6字符类型</span></h5>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、byte，即uint8的别名</span></div><div class=\"line\"><span class=\"comment\">//2、rune，即Unicode</span></div></pre></td></tr></table></figure>\n<h5><span id=\"317错误类型error\">3.1.7错误类型（error）</span></h5>\n<h4><span id=\"32复合类型\">3.2复合类型</span></h4>\n<h5><span id=\"321数组array\">3.2.1数组(array)</span></h5>\n<p>数组表示同一类型数据，数组长度定义后就不可更改，长度是数组内的一个内置常量，可通过len()来获取。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、创建数组</span></div><div class=\"line\"><span class=\"keyword\">var</span> array1 [<span class=\"number\">5</span>]<span class=\"keyword\">int</span>    <span class=\"comment\">//声明：var 变量名 类型</span></div><div class=\"line\"><span class=\"keyword\">var</span> array2 [<span class=\"number\">5</span>]<span class=\"keyword\">int</span>=[<span class=\"number\">5</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;   <span class=\"comment\">//初始化</span></div><div class=\"line\">array3：=[<span class=\"number\">5</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;    <span class=\"comment\">//直接用“：=”赋值</span></div><div class=\"line\">[<span class=\"number\">3</span>][<span class=\"number\">5</span>]<span class=\"keyword\">int</span>  <span class=\"comment\">//二维数组</span></div><div class=\"line\">[<span class=\"number\">3</span>]*float  <span class=\"comment\">//指针数组</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、元素访问</span></div><div class=\"line\"><span class=\"keyword\">for</span> i,v:=<span class=\"keyword\">range</span> array&#123;</div><div class=\"line\">  <span class=\"comment\">//第一个返回值为数组下标，第二个为元素的值</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//3、值类型</span></div><div class=\"line\"><span class=\"comment\">//数组在Go中作为一个值类型，值类型在赋值和函数参数传递时，只复制副本，因此在函数体中并不能改变数组的内容，需用指针来改变数组的值。</span></div></pre></td></tr></table></figure>\n<h5><span id=\"322切片slice\">3.2.2切片(slice)</span></h5>\n<p>​\t数组在定义了长度后无法改变，且作为值类型在传递时产生副本，并不能改变数组元素的值。因此切片的功能弥补了这个不足，切片类似指向数组的一个指针。可以抽象为三个变量：指向数组的指针；切片中元素的个数(len函数)；已分配的存储空间(cap函数)。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、创建切片</span></div><div class=\"line\"><span class=\"comment\">//a)基于数组创建</span></div><div class=\"line\"><span class=\"keyword\">var</span> myArray [<span class=\"number\">5</span>]<span class=\"keyword\">int</span>=[<span class=\"number\">5</span>]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> mySlice []<span class=\"keyword\">int</span>=myArray[first:last]</div><div class=\"line\">slice1=myArray[:]   <span class=\"comment\">//基于数组所有元素创建</span></div><div class=\"line\">slice2=myArray[:<span class=\"number\">3</span>]  <span class=\"comment\">//基于前三个元素创建</span></div><div class=\"line\">slice3=myArray[<span class=\"number\">3</span>:]  <span class=\"comment\">//基于第3个元素开始后的所有元素创建</span></div><div class=\"line\"><span class=\"comment\">//b)直接创建</span></div><div class=\"line\">slice1:=<span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>,<span class=\"number\">5</span>)       <span class=\"comment\">//元素初始值为0，初始个数为5</span></div><div class=\"line\">slice2:=<span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>,<span class=\"number\">5</span>,<span class=\"number\">10</span>)    <span class=\"comment\">//元素初始值为0，初始个数为5，预留个数为10</span></div><div class=\"line\">slice3:=[]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;    <span class=\"comment\">//初始化赋值</span></div><div class=\"line\"><span class=\"comment\">//c)基于切片创建</span></div><div class=\"line\">oldSlice:=[]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</div><div class=\"line\">newSlice:=oldSlice[:<span class=\"number\">3</span>]   <span class=\"comment\">//基于切片创建，不能超过原切片的存储空间(cap函数的值)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、元素遍历</span></div><div class=\"line\"><span class=\"keyword\">for</span> i,v:=<span class=\"keyword\">range</span> slice&#123;</div><div class=\"line\">  <span class=\"comment\">//与数组的方式一致，使用range来遍历</span></div><div class=\"line\">  <span class=\"comment\">//第一个返回值(i)为索引，第二个为元素的值(v)</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//3、动态增减元素</span></div><div class=\"line\"><span class=\"comment\">//切片分存储空间(cap)和元素个数(len)，当存储空间小于实际的元素个数，会重新分配一块原空间2倍的内存块，并将原数据复制到该内存块中，合理的分配存储空间可以以空间换时间，降低系统开销。</span></div><div class=\"line\"><span class=\"comment\">//添加元素</span></div><div class=\"line\">newSlice:=<span class=\"built_in\">append</span>(oldSlice,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)   <span class=\"comment\">//直接将元素加进去，若存储空间不够会按上述方式扩容。</span></div><div class=\"line\">newSlice1:=<span class=\"built_in\">append</span>(oldSlice1,oldSlice2...)  <span class=\"comment\">//将oldSlice2的元素打散后加到oldSlice1中，三个点不可省略。</span></div><div class=\"line\"><span class=\"comment\">//删除元素则用delete函数替换append函数，用法一致。</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//4、内容复制</span></div><div class=\"line\"><span class=\"comment\">//copy()函数可以复制切片，如果切片大小不一样，按较小的切片元素个数进行复制</span></div><div class=\"line\">slice1:=[]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</div><div class=\"line\">slice2:=[]<span class=\"keyword\">int</span>&#123;<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>&#125;</div><div class=\"line\"><span class=\"built_in\">copy</span>(slice2,slice1)   <span class=\"comment\">//只会复制slice1的前三个元素到slice2中</span></div><div class=\"line\"><span class=\"built_in\">copy</span>(slice1,slice1)   <span class=\"comment\">//只会复制slice2的三个元素到slice1中的前三个位置</span></div></pre></td></tr></table></figure>\n<h5><span id=\"323键值对map\">3.2.3键值对(map)</span></h5>\n<p>map是一堆键值对的未排序集合。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、声明</span></div><div class=\"line\"><span class=\"keyword\">var</span> map1 <span class=\"keyword\">map</span>[键类型] 值类型</div><div class=\"line\"><span class=\"comment\">//创建</span></div><div class=\"line\">map1=<span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[键类型] 值类型)</div><div class=\"line\">map1=<span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[键类型] 值类型 存储空间)</div><div class=\"line\"><span class=\"comment\">//赋值</span></div><div class=\"line\">map1[key]=value</div><div class=\"line\"><span class=\"comment\">//创建并初始化</span></div><div class=\"line\">map1=<span class=\"keyword\">map</span>[key] value</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、元素删除</span></div><div class=\"line\"><span class=\"comment\">//delete()函数删除对应key的键值对，如果key不存在，不会报错；如果value为nil，则会抛出异常(panic)。</span></div><div class=\"line\"><span class=\"built_in\">delete</span>(map1,key)  </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//3、元素查找</span></div><div class=\"line\">value,ok:=myMap[key]</div><div class=\"line\"><span class=\"keyword\">if</span> ok&#123;<span class=\"comment\">//如果找到</span></div><div class=\"line\">  <span class=\"comment\">//处理找到的value值</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5><span id=\"324指针pointer\">3.2.4指针(pointer)</span></h5>\n<h5><span id=\"325结构体struct\">3.2.5结构体(struct)</span></h5>\n<h5><span id=\"326接口interface\">3.2.6接口(interface)</span></h5>\n<h5><span id=\"327通道chan\">3.2.7通道(chan)</span></h5>\n<h3><span id=\"4流程语句\">4.流程语句</span></h3>\n<h4><span id=\"41条件语句\">4.1条件语句</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//在if之后条件语句之前可以添加变量初始化语句，用;号隔离</span></div><div class=\"line\"><span class=\"keyword\">if</span> &lt;条件语句&gt; &#123;    <span class=\"comment\">//条件语句不需要用括号括起来，花括号必须存在</span></div><div class=\"line\">  <span class=\"comment\">//语句体</span></div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//语句体</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//在有返回值的函数中，不允许将最后的return语句放在if...else...的结构中，否则会编译失败</span></div><div class=\"line\"><span class=\"comment\">//例如以下为错误范例</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">example</span><span class=\"params\">(x <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> x==<span class=\"number\">0</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">5</span></div><div class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x  <span class=\"comment\">//最后的return语句放在if-else结构中，所以编译失败</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4><span id=\"42选择语句\">4.2选择语句</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、根据条件不同，对应不同的执行体</span></div><div class=\"line\"><span class=\"keyword\">switch</span> i&#123;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</div><div class=\"line\">  \tfmt.Printf(<span class=\"string\">\"0\"</span>)</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">1</span>:                <span class=\"comment\">//满足条件就会退出，只有添加fallthrough才会继续执行下一个case语句</span></div><div class=\"line\">  \tfmt.Prinntf(<span class=\"string\">\"1\"</span>)</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>:            <span class=\"comment\">//单个case可以出现多个选项</span></div><div class=\"line\">  \tfmt.Printf(<span class=\"string\">\"2,3,4\"</span>)</div><div class=\"line\">  <span class=\"keyword\">default</span>:               <span class=\"comment\">//当都不满足以上条件时，执行default语句</span></div><div class=\"line\">  \tfmt.Printf(<span class=\"string\">\"Default\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、该模式等价于多个if-else的功能</span></div><div class=\"line\"><span class=\"keyword\">switch</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">case</span> &lt;条件表达式<span class=\"number\">1</span>&gt;:</div><div class=\"line\">  \t语句体<span class=\"number\">1</span></div><div class=\"line\">  <span class=\"keyword\">case</span> &lt;条件表达式<span class=\"number\">2</span>&gt;:</div><div class=\"line\">  \t语句体<span class=\"number\">2</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4><span id=\"43循环语句\">4.3循环语句</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、Go只支持for关键字，不支持while，do-while结构</span></div><div class=\"line\"><span class=\"keyword\">for</span> i,j:=<span class=\"number\">0</span>,<span class=\"number\">1</span>;i&lt;<span class=\"number\">10</span>;i++&#123;    <span class=\"comment\">//支持多个赋值</span></div><div class=\"line\">  <span class=\"comment\">//语句体</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、无限循环</span></div><div class=\"line\">sum:=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"keyword\">for</span>&#123;  <span class=\"comment\">//不接条件表达式表示无限循环</span></div><div class=\"line\">  sum++</div><div class=\"line\">  <span class=\"keyword\">if</span> sum &gt; <span class=\"number\">100</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">break</span>   <span class=\"comment\">//满足条件跳出循环</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//3、支持continue和break，break可以指定中断哪个循环，break JLoop(标签)</span></div><div class=\"line\"><span class=\"keyword\">for</span> j:=<span class=\"number\">0</span>;j&lt;<span class=\"number\">5</span>;j++&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> i&gt;<span class=\"number\">5</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">break</span> JLoop   <span class=\"comment\">//终止JLoop标签处的外层循环</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  fmt.Println(i)</div><div class=\"line\">&#125;</div><div class=\"line\">JLoop:    <span class=\"comment\">//标签处</span></div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<h4><span id=\"44跳转语句\">4.4跳转语句</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//关键字goto支持跳转</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myfunc</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">  i:=<span class=\"number\">0</span></div><div class=\"line\">  HERE:           <span class=\"comment\">//定义标签处</span></div><div class=\"line\">  fmt.Println(i)</div><div class=\"line\">  i++</div><div class=\"line\">  <span class=\"keyword\">if</span> i&lt;<span class=\"number\">10</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">goto</span> HERE     <span class=\"comment\">//跳转到标签处</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"5函数\">5.函数</span></h3>\n<h4><span id=\"51函数定义与调用\">5.1函数定义与调用</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、函数组成：关键字func ,函数名，参数列表，返回值，函数体，返回语句</span></div><div class=\"line\"><span class=\"comment\">//先名称后类型</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> 函数名<span class=\"params\">(参数列表)</span><span class=\"params\">(返回值列表)</span></span>&#123;  <span class=\"comment\">//参数列表和返回值列表以变量声明的形式，如果单返回值可以直接加类型</span></div><div class=\"line\">  函数体</div><div class=\"line\">  <span class=\"keyword\">return</span>    <span class=\"comment\">//返回语句</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//例子</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Add</span><span class=\"params\">(a,b <span class=\"keyword\">int</span>)</span><span class=\"params\">(ret <span class=\"keyword\">int</span>,err error)</span></span>&#123;</div><div class=\"line\">  <span class=\"comment\">//函数体 </span></div><div class=\"line\">  <span class=\"keyword\">return</span>   <span class=\"comment\">//return语句</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、函数调用</span></div><div class=\"line\"><span class=\"comment\">//先导入函数所在的包，直接调用函数</span></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"mymath\"</span></div><div class=\"line\">sum,err:=mymath.Add(<span class=\"number\">1</span>,<span class=\"number\">2</span>)   <span class=\"comment\">//多返回值和错误处理机制</span></div><div class=\"line\"><span class=\"comment\">//可见性，包括函数、类型、变量</span></div><div class=\"line\"><span class=\"comment\">//本包内可见(private)：小写字母开头</span></div><div class=\"line\"><span class=\"comment\">//包外可见(public)：大写字母开头</span></div></pre></td></tr></table></figure>\n<h4><span id=\"52不定参数\">5.2不定参数</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、不定参数的类型</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myfunc</span><span class=\"params\">(args ...<span class=\"keyword\">int</span>)</span></span>&#123;   <span class=\"comment\">//...type不定参数的类型，必须是最后一个参数，本质是切片</span></div><div class=\"line\">  <span class=\"keyword\">for</span> _,arg:=<span class=\"keyword\">range</span> args&#123;</div><div class=\"line\">    fmt.Println(arg)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//函数调用,传参可以选择多个，个数不定</span></div><div class=\"line\">myfunc(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</div><div class=\"line\">myfunc(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、不定参数的传递，假如有个变参函数myfunc2(args ...int)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myfunc1</span><span class=\"params\">(args ...<span class=\"keyword\">int</span>)</span></span>&#123;</div><div class=\"line\">  <span class=\"comment\">//按原样传递</span></div><div class=\"line\">  myfunc2(args...)</div><div class=\"line\">  <span class=\"comment\">//传递切片</span></div><div class=\"line\">  myfunc2(args[<span class=\"number\">1</span>:]...)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//3、任意类型的不定参数，使用interface&#123;&#125;作为指定类型</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Printf</span><span class=\"params\">(format <span class=\"keyword\">string</span>,args ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span>&#123;   <span class=\"comment\">//此为标准库中fmt.Printf()函数的原型</span></div><div class=\"line\">  <span class=\"comment\">//函数体</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4><span id=\"53多返回值\">5.3多返回值</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//多返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(file *File)</span> <span class=\"title\">Read</span><span class=\"params\">(b []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,err error)</span></span></div><div class=\"line\"><span class=\"function\">//使用下划线\"_\"来丢弃返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">n</span>,_:=<span class=\"title\">f</span>.<span class=\"title\">Read</span><span class=\"params\">(buf)</span></span></div></pre></td></tr></table></figure>\n<h4><span id=\"54匿名函数与闭包\">5.4匿名函数与闭包</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、匿名函数：不带函数名的函数，可以像变量一样被传递</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(a,b <span class=\"keyword\">int</span>,z <span class=\"keyword\">float32</span>)</span> <span class=\"title\">bool</span></span>&#123;  <span class=\"comment\">//没有函数名</span></div><div class=\"line\">  <span class=\"keyword\">return</span> a*b&lt;<span class=\"keyword\">int</span>(z)</div><div class=\"line\">&#125;</div><div class=\"line\">f:=<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x,y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> x+y</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、闭包</span></div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2>一、初识Go语言</h2>\n<h3>（一）概述</h3>\n<p>一个在语言层面实现了并发机制的类C通用型编程语言。</p>\n<h3>（二）Go关键字（25个）</h3>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>关键字</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>程序声明</td>\n<td>package，import</td>\n<td>包的声明和导入</td>\n</tr>\n<tr>\n<td>声明与定义</td>\n<td>var，const</td>\n<td>变量和常量的声明</td>\n</tr>\n<tr>\n<td></td>\n<td>type</td>\n<td>用于定义类型</td>\n</tr>\n<tr>\n<td>复合数据类型</td>\n<td>struct</td>\n<td>定义结构体，类似java中的class</td>\n</tr>\n<tr>\n<td></td>\n<td>interface</td>\n<td>定义接口</td>\n</tr>\n<tr>\n<td></td>\n<td>map</td>\n<td>定义键值对</td>\n</tr>\n<tr>\n<td></td>\n<td>func</td>\n<td>定义函数和方法</td>\n</tr>\n<tr>\n<td></td>\n<td>chan</td>\n<td>定义管道，并发中channel通信</td>\n</tr>\n<tr>\n<td>并发编程</td>\n<td>go</td>\n<td>并发编程</td>\n</tr>\n<tr>\n<td></td>\n<td>select</td>\n<td>用于选择不同类型通信</td>\n</tr>\n<tr>\n<td>流程控制</td>\n<td>for；if，else；switch，case</td>\n<td>循环语句；条件语句；选择语句</td>\n</tr>\n<tr>\n<td></td>\n<td>break，continue，fallthrough，default，goto</td>\n<td>跳转语句等</td>\n</tr>\n<tr>\n<td></td>\n<td>return</td>\n<td>函数返回值</td>\n</tr>\n<tr>\n<td></td>\n<td>defer</td>\n<td>延迟函数，用于return前释放资源</td>\n</tr>\n<tr>\n<td></td>\n<td>range</td>\n<td>用于读取slice，map，channel容器类数据</td>\n</tr>\n</tbody>\n</table>\n<h3>（三）Go语言命令</h3>\n<p>Usage：go command [arguments]</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td>build</td>\n<td>compile packages and dependencies</td>\n</tr>\n<tr>\n<td></td>\n<td>clean</td>\n<td>remove object files</td>\n</tr>\n<tr>\n<td></td>\n<td>doc</td>\n<td>show documentation for package or symbol</td>\n</tr>\n<tr>\n<td></td>\n<td>env</td>\n<td>print Go environment information</td>\n</tr>\n<tr>\n<td></td>\n<td>fix</td>\n<td>run go tool fix on packages</td>\n</tr>\n<tr>\n<td></td>\n<td>fmt</td>\n<td>run gofmt on package sources</td>\n</tr>\n<tr>\n<td></td>\n<td>generate</td>\n<td>generate Go files by processing source</td>\n</tr>\n<tr>\n<td></td>\n<td>get</td>\n<td>download and install packages and dependencies</td>\n</tr>\n<tr>\n<td></td>\n<td>install</td>\n<td>compile and install packages and dependencies</td>\n</tr>\n<tr>\n<td></td>\n<td>list</td>\n<td>list packages</td>\n</tr>\n<tr>\n<td></td>\n<td>run</td>\n<td>compile and run Go program</td>\n</tr>\n<tr>\n<td></td>\n<td>test</td>\n<td>test packages</td>\n</tr>\n<tr>\n<td></td>\n<td>tool</td>\n<td>run specified go tool</td>\n</tr>\n<tr>\n<td></td>\n<td>version</td>\n<td>print Go version</td>\n</tr>\n<tr>\n<td></td>\n<td>vet</td>\n<td>run go tool vet on packages</td>\n</tr>\n</tbody>\n</table>\n<h2>二、顺序编程</h2>\n<h3>1.变量</h3>\n<h4>1.1变量声明</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、单变量声明,类型放在变量名之后，可以为任意类型</span></div><div class=\"line\"><span class=\"keyword\">var</span> 变量名 类型</div><div class=\"line\"><span class=\"keyword\">var</span> v1,v2,v3 <span class=\"keyword\">string</span> <span class=\"comment\">//多变量同类型声明</span></div><div class=\"line\"><span class=\"comment\">//2、多变量声明</span></div><div class=\"line\"><span class=\"keyword\">var</span> &#123;</div><div class=\"line\">    v1 <span class=\"keyword\">int</span></div><div class=\"line\">    v2 []<span class=\"keyword\">int</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4>1.2变量初始化</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、使用关键字var，声明变量类型并赋值</span></div><div class=\"line\"><span class=\"keyword\">var</span> v1 <span class=\"keyword\">int</span>=<span class=\"number\">10</span></div><div class=\"line\"><span class=\"comment\">//2、使用关键字var，直接对变量赋值，go可以自动推导出变量类型</span></div><div class=\"line\"><span class=\"keyword\">var</span> v2=<span class=\"number\">10</span></div><div class=\"line\"><span class=\"comment\">//3、直接使用“：=”对变量赋值，不使用var，两者同时使用会语法冲突，推荐使用</span></div><div class=\"line\">v3:=<span class=\"number\">10</span></div></pre></td></tr></table></figure>\n<h4>1.3变量赋值</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、声明后再变量赋值</span></div><div class=\"line\"><span class=\"keyword\">var</span> v <span class=\"keyword\">int</span></div><div class=\"line\">v=<span class=\"number\">10</span></div><div class=\"line\"><span class=\"comment\">//2、多重赋值，经常使用在函数的多返回值中，err,v=func(arg)</span></div><div class=\"line\">i，j=j,i  <span class=\"comment\">//两者互换，并不需要引入中间变量</span></div></pre></td></tr></table></figure>\n<h4>1.4匿名变量</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Go中所有声明后的变量都需要调用到，当出现函数多返回值，并且部分返回值不需要使用时，可以使用匿名变量丢弃该返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GetName</span><span class=\"params\">()</span><span class=\"params\">(firstName,lastName,nickName <span class=\"keyword\">string</span>)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"May\"</span>,<span class=\"string\">\"Chan\"</span>,<span class=\"string\">\"Make\"</span></div><div class=\"line\">&#125;</div><div class=\"line\">_,_,nickName:=GetName()  <span class=\"comment\">//使用匿名变量丢弃部分返回值</span></div></pre></td></tr></table></figure>\n<h3>2.常量</h3>\n<p>​\tGo语言中，常量是编译时期就已知且不可变的值，常量可以是数值类型（整型、浮点型、复数类型）、布尔类型、字符串类型。</p>\n<h4>2.1字面常量</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//字面常量(literal)指程序中硬编码的常量</span></div><div class=\"line\"><span class=\"number\">3.14</span></div><div class=\"line\">“foo”</div><div class=\"line\"><span class=\"literal\">true</span></div></pre></td></tr></table></figure>\n<h4>2.2常量定义</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、可以限定常量类型，但非必需</span></div><div class=\"line\"><span class=\"keyword\">const</span> Pi <span class=\"keyword\">float64</span> = <span class=\"number\">3.14</span></div><div class=\"line\"><span class=\"comment\">//2、无类型常量和字面常量一样</span></div><div class=\"line\"><span class=\"keyword\">const</span> zero=<span class=\"number\">0.0</span></div><div class=\"line\"><span class=\"comment\">//3、多常量赋值</span></div><div class=\"line\"><span class=\"keyword\">const</span>(</div><div class=\"line\">  size <span class=\"keyword\">int64</span>=<span class=\"number\">1024</span></div><div class=\"line\">  eof=<span class=\"number\">-1</span></div><div class=\"line\">)</div><div class=\"line\"><span class=\"comment\">//4、常量的多重赋值，类似变量的多重赋值</span></div><div class=\"line\"><span class=\"keyword\">const</span> u,v <span class=\"keyword\">float32</span>=<span class=\"number\">0</span>,<span class=\"number\">3</span></div><div class=\"line\"><span class=\"keyword\">const</span> a,b,c=<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"string\">\"foo\"</span>    <span class=\"comment\">//无类型常量的多重赋值</span></div><div class=\"line\"><span class=\"comment\">//5、常量赋值是编译期行为，可以赋值为一个编译期运算的常量表达式</span></div><div class=\"line\"><span class=\"keyword\">const</span> mask=<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span></div></pre></td></tr></table></figure>\n<h4>2.3预定义常量</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//预定义常量：true、false、iota</span></div><div class=\"line\"><span class=\"comment\">//iota：可修改常量，在每次const出现时被重置为0，在下一个const出现前，每出现一次iota，其代表的值自动增1。</span></div><div class=\"line\"><span class=\"keyword\">const</span>(          <span class=\"comment\">//iota重置为0</span></div><div class=\"line\">  c0=<span class=\"literal\">iota</span>       <span class=\"comment\">//c0==0</span></div><div class=\"line\">  c1=<span class=\"literal\">iota</span>       <span class=\"comment\">//c1==1</span></div><div class=\"line\">  c2=<span class=\"literal\">iota</span>       <span class=\"comment\">//c2==2</span></div><div class=\"line\">)</div><div class=\"line\"><span class=\"comment\">//两个const赋值语句一样可以省略后一个</span></div><div class=\"line\"><span class=\"keyword\">const</span>(          <span class=\"comment\">//iota重置为0</span></div><div class=\"line\">  c0=<span class=\"literal\">iota</span>       <span class=\"comment\">//c0==0</span></div><div class=\"line\">  c1            <span class=\"comment\">//c1==1</span></div><div class=\"line\">  c2            <span class=\"comment\">//c2==2</span></div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<h4>2.4枚举</h4>\n<p>枚举指一系列相关常量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span>(</div><div class=\"line\">  Sunday=<span class=\"literal\">iota</span>    <span class=\"comment\">//Sunday==0,以此类推</span></div><div class=\"line\">  Monday</div><div class=\"line\">  Tuesday</div><div class=\"line\">  Wednesday</div><div class=\"line\">  Thursday</div><div class=\"line\">  Friday</div><div class=\"line\">  Saturday       <span class=\"comment\">//大写字母开头表示包外可见</span></div><div class=\"line\">  numberOfDays   <span class=\"comment\">//小写字母开头表示包内私有</span></div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<h3>3.类型</h3>\n<h4>3.1基础类型</h4>\n<h5>3.1.1布尔类型</h5>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//布尔类型的关键字为bool,值为true或false，不可写为0或1</span></div><div class=\"line\"><span class=\"keyword\">var</span> v1 <span class=\"keyword\">bool</span></div><div class=\"line\">v1=<span class=\"literal\">true</span></div><div class=\"line\"><span class=\"comment\">//接受表达式判断赋值，不支持自动或强制类型转换</span></div><div class=\"line\">v2:=(<span class=\"number\">1</span>==<span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<h5>3.1.2整型</h5>\n<p><img src=\"/img/article/golang/%E6%95%B4%E5%9E%8B.png\" alt=\"整型\"></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、类型表示</span></div><div class=\"line\"><span class=\"comment\">//int和int32为不同类型，不会自动类型转换需要强制类型转换</span></div><div class=\"line\"><span class=\"comment\">//强制类型转换需注意精度损失（浮点数→整数），值溢出（大范围→小范围）</span></div><div class=\"line\"><span class=\"keyword\">var</span> v2 <span class=\"keyword\">int32</span></div><div class=\"line\">v1:=<span class=\"number\">64</span></div><div class=\"line\">v2=<span class=\"keyword\">int32</span>(v1)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、数值运算,支持“+,-,*,/和%”</span></div><div class=\"line\"><span class=\"number\">5</span>%<span class=\"number\">3</span> <span class=\"comment\">//求余</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//3、比较运算,“&lt;,&gt;,==,&gt;=,&lt;=,!=”</span></div><div class=\"line\"><span class=\"comment\">//不同类型不能进行比较例如int和int8，但可以与字面常量（literal）进行比较</span></div><div class=\"line\"><span class=\"keyword\">var</span> i <span class=\"keyword\">int32</span></div><div class=\"line\"><span class=\"keyword\">var</span> j <span class=\"keyword\">int64</span></div><div class=\"line\">i,j=<span class=\"number\">1</span>,<span class=\"number\">2</span></div><div class=\"line\"><span class=\"keyword\">if</span> i==j  <span class=\"comment\">//编译错误，不同类型不能进行比较</span></div><div class=\"line\"><span class=\"keyword\">if</span> i==<span class=\"number\">1</span> || j==<span class=\"number\">2</span>  <span class=\"comment\">//编译通过，可以与字面常量（literal）进行比较</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//4、位运算</span></div><div class=\"line\"><span class=\"comment\">//Go(^x)取反与C语言(~x)不同，其他类似，具体见下表</span></div></pre></td></tr></table></figure>\n<p><img src=\"/img/article/golang/%E4%BD%8D%E8%BF%90%E7%AE%97.png\" alt=\"位运算\"></p>\n<h5>3.1.3浮点型</h5>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、浮点型分为float32(类似C中的float)，float64(类似C中的double)</span></div><div class=\"line\"><span class=\"keyword\">var</span> f1 <span class=\"keyword\">float32</span></div><div class=\"line\">f1=<span class=\"number\">12</span>     <span class=\"comment\">//不加小数点，被推导为整型</span></div><div class=\"line\">f2:=<span class=\"number\">12.0</span>  <span class=\"comment\">//加小数点，被推导为float64</span></div><div class=\"line\">f1=<span class=\"keyword\">float32</span>(f2)  <span class=\"comment\">//需要执行强制转换</span></div><div class=\"line\"><span class=\"comment\">//2、浮点数的比较</span></div><div class=\"line\"><span class=\"comment\">//浮点数不是精确的表达方式，不能直接使用“==”来判断是否相等，可以借用math的包math.Fdim</span></div></pre></td></tr></table></figure>\n<h5>3.1.4复数类型</h5>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、复数的表示</span></div><div class=\"line\"><span class=\"keyword\">var</span> v1 <span class=\"keyword\">complex64</span></div><div class=\"line\">v1=<span class=\"number\">3.2</span>+<span class=\"number\">12i</span></div><div class=\"line\"><span class=\"comment\">//v1 v2 v3 表示为同一个数</span></div><div class=\"line\">v2:=<span class=\"number\">3.2</span>+<span class=\"number\">12i</span></div><div class=\"line\">v3:=<span class=\"built_in\">complex</span>(<span class=\"number\">3.2</span>,<span class=\"number\">12</span>)</div><div class=\"line\"><span class=\"comment\">//2、实部与虚部</span></div><div class=\"line\"><span class=\"comment\">//z=complex(x,y),通过内置函数实部x=real(z),虚部y=imag(z)</span></div></pre></td></tr></table></figure>\n<h5>3.1.5字符串</h5>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//声明与赋值</span></div><div class=\"line\"><span class=\"keyword\">var</span> str <span class=\"keyword\">string</span></div><div class=\"line\">str=<span class=\"string\">\"hello world\"</span></div></pre></td></tr></table></figure>\n<p><img src=\"/img/article/golang/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C.png\" alt=\"字符串操作\"></p>\n<h5>3.1.6字符类型</h5>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、byte，即uint8的别名</span></div><div class=\"line\"><span class=\"comment\">//2、rune，即Unicode</span></div></pre></td></tr></table></figure>\n<h5>3.1.7错误类型（error）</h5>\n<h4>3.2复合类型</h4>\n<h5>3.2.1数组(array)</h5>\n<p>数组表示同一类型数据，数组长度定义后就不可更改，长度是数组内的一个内置常量，可通过len()来获取。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、创建数组</span></div><div class=\"line\"><span class=\"keyword\">var</span> array1 [<span class=\"number\">5</span>]<span class=\"keyword\">int</span>    <span class=\"comment\">//声明：var 变量名 类型</span></div><div class=\"line\"><span class=\"keyword\">var</span> array2 [<span class=\"number\">5</span>]<span class=\"keyword\">int</span>=[<span class=\"number\">5</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;   <span class=\"comment\">//初始化</span></div><div class=\"line\">array3：=[<span class=\"number\">5</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;    <span class=\"comment\">//直接用“：=”赋值</span></div><div class=\"line\">[<span class=\"number\">3</span>][<span class=\"number\">5</span>]<span class=\"keyword\">int</span>  <span class=\"comment\">//二维数组</span></div><div class=\"line\">[<span class=\"number\">3</span>]*float  <span class=\"comment\">//指针数组</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、元素访问</span></div><div class=\"line\"><span class=\"keyword\">for</span> i,v:=<span class=\"keyword\">range</span> array&#123;</div><div class=\"line\">  <span class=\"comment\">//第一个返回值为数组下标，第二个为元素的值</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//3、值类型</span></div><div class=\"line\"><span class=\"comment\">//数组在Go中作为一个值类型，值类型在赋值和函数参数传递时，只复制副本，因此在函数体中并不能改变数组的内容，需用指针来改变数组的值。</span></div></pre></td></tr></table></figure>\n<h5>3.2.2切片(slice)</h5>\n<p>​\t数组在定义了长度后无法改变，且作为值类型在传递时产生副本，并不能改变数组元素的值。因此切片的功能弥补了这个不足，切片类似指向数组的一个指针。可以抽象为三个变量：指向数组的指针；切片中元素的个数(len函数)；已分配的存储空间(cap函数)。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、创建切片</span></div><div class=\"line\"><span class=\"comment\">//a)基于数组创建</span></div><div class=\"line\"><span class=\"keyword\">var</span> myArray [<span class=\"number\">5</span>]<span class=\"keyword\">int</span>=[<span class=\"number\">5</span>]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> mySlice []<span class=\"keyword\">int</span>=myArray[first:last]</div><div class=\"line\">slice1=myArray[:]   <span class=\"comment\">//基于数组所有元素创建</span></div><div class=\"line\">slice2=myArray[:<span class=\"number\">3</span>]  <span class=\"comment\">//基于前三个元素创建</span></div><div class=\"line\">slice3=myArray[<span class=\"number\">3</span>:]  <span class=\"comment\">//基于第3个元素开始后的所有元素创建</span></div><div class=\"line\"><span class=\"comment\">//b)直接创建</span></div><div class=\"line\">slice1:=<span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>,<span class=\"number\">5</span>)       <span class=\"comment\">//元素初始值为0，初始个数为5</span></div><div class=\"line\">slice2:=<span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>,<span class=\"number\">5</span>,<span class=\"number\">10</span>)    <span class=\"comment\">//元素初始值为0，初始个数为5，预留个数为10</span></div><div class=\"line\">slice3:=[]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;    <span class=\"comment\">//初始化赋值</span></div><div class=\"line\"><span class=\"comment\">//c)基于切片创建</span></div><div class=\"line\">oldSlice:=[]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</div><div class=\"line\">newSlice:=oldSlice[:<span class=\"number\">3</span>]   <span class=\"comment\">//基于切片创建，不能超过原切片的存储空间(cap函数的值)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、元素遍历</span></div><div class=\"line\"><span class=\"keyword\">for</span> i,v:=<span class=\"keyword\">range</span> slice&#123;</div><div class=\"line\">  <span class=\"comment\">//与数组的方式一致，使用range来遍历</span></div><div class=\"line\">  <span class=\"comment\">//第一个返回值(i)为索引，第二个为元素的值(v)</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//3、动态增减元素</span></div><div class=\"line\"><span class=\"comment\">//切片分存储空间(cap)和元素个数(len)，当存储空间小于实际的元素个数，会重新分配一块原空间2倍的内存块，并将原数据复制到该内存块中，合理的分配存储空间可以以空间换时间，降低系统开销。</span></div><div class=\"line\"><span class=\"comment\">//添加元素</span></div><div class=\"line\">newSlice:=<span class=\"built_in\">append</span>(oldSlice,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)   <span class=\"comment\">//直接将元素加进去，若存储空间不够会按上述方式扩容。</span></div><div class=\"line\">newSlice1:=<span class=\"built_in\">append</span>(oldSlice1,oldSlice2...)  <span class=\"comment\">//将oldSlice2的元素打散后加到oldSlice1中，三个点不可省略。</span></div><div class=\"line\"><span class=\"comment\">//删除元素则用delete函数替换append函数，用法一致。</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//4、内容复制</span></div><div class=\"line\"><span class=\"comment\">//copy()函数可以复制切片，如果切片大小不一样，按较小的切片元素个数进行复制</span></div><div class=\"line\">slice1:=[]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;</div><div class=\"line\">slice2:=[]<span class=\"keyword\">int</span>&#123;<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>&#125;</div><div class=\"line\"><span class=\"built_in\">copy</span>(slice2,slice1)   <span class=\"comment\">//只会复制slice1的前三个元素到slice2中</span></div><div class=\"line\"><span class=\"built_in\">copy</span>(slice1,slice1)   <span class=\"comment\">//只会复制slice2的三个元素到slice1中的前三个位置</span></div></pre></td></tr></table></figure>\n<h5>3.2.3键值对(map)</h5>\n<p>map是一堆键值对的未排序集合。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、声明</span></div><div class=\"line\"><span class=\"keyword\">var</span> map1 <span class=\"keyword\">map</span>[键类型] 值类型</div><div class=\"line\"><span class=\"comment\">//创建</span></div><div class=\"line\">map1=<span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[键类型] 值类型)</div><div class=\"line\">map1=<span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[键类型] 值类型 存储空间)</div><div class=\"line\"><span class=\"comment\">//赋值</span></div><div class=\"line\">map1[key]=value</div><div class=\"line\"><span class=\"comment\">//创建并初始化</span></div><div class=\"line\">map1=<span class=\"keyword\">map</span>[key] value</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、元素删除</span></div><div class=\"line\"><span class=\"comment\">//delete()函数删除对应key的键值对，如果key不存在，不会报错；如果value为nil，则会抛出异常(panic)。</span></div><div class=\"line\"><span class=\"built_in\">delete</span>(map1,key)  </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//3、元素查找</span></div><div class=\"line\">value,ok:=myMap[key]</div><div class=\"line\"><span class=\"keyword\">if</span> ok&#123;<span class=\"comment\">//如果找到</span></div><div class=\"line\">  <span class=\"comment\">//处理找到的value值</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5>3.2.4指针(pointer)</h5>\n<h5>3.2.5结构体(struct)</h5>\n<h5>3.2.6接口(interface)</h5>\n<h5>3.2.7通道(chan)</h5>\n<h3>4.流程语句</h3>\n<h4>4.1条件语句</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//在if之后条件语句之前可以添加变量初始化语句，用;号隔离</span></div><div class=\"line\"><span class=\"keyword\">if</span> &lt;条件语句&gt; &#123;    <span class=\"comment\">//条件语句不需要用括号括起来，花括号必须存在</span></div><div class=\"line\">  <span class=\"comment\">//语句体</span></div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//语句体</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//在有返回值的函数中，不允许将最后的return语句放在if...else...的结构中，否则会编译失败</span></div><div class=\"line\"><span class=\"comment\">//例如以下为错误范例</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">example</span><span class=\"params\">(x <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> x==<span class=\"number\">0</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">5</span></div><div class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x  <span class=\"comment\">//最后的return语句放在if-else结构中，所以编译失败</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4>4.2选择语句</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、根据条件不同，对应不同的执行体</span></div><div class=\"line\"><span class=\"keyword\">switch</span> i&#123;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</div><div class=\"line\">  \tfmt.Printf(<span class=\"string\">\"0\"</span>)</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">1</span>:                <span class=\"comment\">//满足条件就会退出，只有添加fallthrough才会继续执行下一个case语句</span></div><div class=\"line\">  \tfmt.Prinntf(<span class=\"string\">\"1\"</span>)</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>:            <span class=\"comment\">//单个case可以出现多个选项</span></div><div class=\"line\">  \tfmt.Printf(<span class=\"string\">\"2,3,4\"</span>)</div><div class=\"line\">  <span class=\"keyword\">default</span>:               <span class=\"comment\">//当都不满足以上条件时，执行default语句</span></div><div class=\"line\">  \tfmt.Printf(<span class=\"string\">\"Default\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、该模式等价于多个if-else的功能</span></div><div class=\"line\"><span class=\"keyword\">switch</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">case</span> &lt;条件表达式<span class=\"number\">1</span>&gt;:</div><div class=\"line\">  \t语句体<span class=\"number\">1</span></div><div class=\"line\">  <span class=\"keyword\">case</span> &lt;条件表达式<span class=\"number\">2</span>&gt;:</div><div class=\"line\">  \t语句体<span class=\"number\">2</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4>4.3循环语句</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、Go只支持for关键字，不支持while，do-while结构</span></div><div class=\"line\"><span class=\"keyword\">for</span> i,j:=<span class=\"number\">0</span>,<span class=\"number\">1</span>;i&lt;<span class=\"number\">10</span>;i++&#123;    <span class=\"comment\">//支持多个赋值</span></div><div class=\"line\">  <span class=\"comment\">//语句体</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、无限循环</span></div><div class=\"line\">sum:=<span class=\"number\">1</span></div><div class=\"line\"><span class=\"keyword\">for</span>&#123;  <span class=\"comment\">//不接条件表达式表示无限循环</span></div><div class=\"line\">  sum++</div><div class=\"line\">  <span class=\"keyword\">if</span> sum &gt; <span class=\"number\">100</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">break</span>   <span class=\"comment\">//满足条件跳出循环</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//3、支持continue和break，break可以指定中断哪个循环，break JLoop(标签)</span></div><div class=\"line\"><span class=\"keyword\">for</span> j:=<span class=\"number\">0</span>;j&lt;<span class=\"number\">5</span>;j++&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> i&gt;<span class=\"number\">5</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">break</span> JLoop   <span class=\"comment\">//终止JLoop标签处的外层循环</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  fmt.Println(i)</div><div class=\"line\">&#125;</div><div class=\"line\">JLoop:    <span class=\"comment\">//标签处</span></div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<h4>4.4跳转语句</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//关键字goto支持跳转</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myfunc</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">  i:=<span class=\"number\">0</span></div><div class=\"line\">  HERE:           <span class=\"comment\">//定义标签处</span></div><div class=\"line\">  fmt.Println(i)</div><div class=\"line\">  i++</div><div class=\"line\">  <span class=\"keyword\">if</span> i&lt;<span class=\"number\">10</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">goto</span> HERE     <span class=\"comment\">//跳转到标签处</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>5.函数</h3>\n<h4>5.1函数定义与调用</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、函数组成：关键字func ,函数名，参数列表，返回值，函数体，返回语句</span></div><div class=\"line\"><span class=\"comment\">//先名称后类型</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> 函数名<span class=\"params\">(参数列表)</span><span class=\"params\">(返回值列表)</span></span>&#123;  <span class=\"comment\">//参数列表和返回值列表以变量声明的形式，如果单返回值可以直接加类型</span></div><div class=\"line\">  函数体</div><div class=\"line\">  <span class=\"keyword\">return</span>    <span class=\"comment\">//返回语句</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//例子</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Add</span><span class=\"params\">(a,b <span class=\"keyword\">int</span>)</span><span class=\"params\">(ret <span class=\"keyword\">int</span>,err error)</span></span>&#123;</div><div class=\"line\">  <span class=\"comment\">//函数体 </span></div><div class=\"line\">  <span class=\"keyword\">return</span>   <span class=\"comment\">//return语句</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、函数调用</span></div><div class=\"line\"><span class=\"comment\">//先导入函数所在的包，直接调用函数</span></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"mymath\"</span></div><div class=\"line\">sum,err:=mymath.Add(<span class=\"number\">1</span>,<span class=\"number\">2</span>)   <span class=\"comment\">//多返回值和错误处理机制</span></div><div class=\"line\"><span class=\"comment\">//可见性，包括函数、类型、变量</span></div><div class=\"line\"><span class=\"comment\">//本包内可见(private)：小写字母开头</span></div><div class=\"line\"><span class=\"comment\">//包外可见(public)：大写字母开头</span></div></pre></td></tr></table></figure>\n<h4>5.2不定参数</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、不定参数的类型</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myfunc</span><span class=\"params\">(args ...<span class=\"keyword\">int</span>)</span></span>&#123;   <span class=\"comment\">//...type不定参数的类型，必须是最后一个参数，本质是切片</span></div><div class=\"line\">  <span class=\"keyword\">for</span> _,arg:=<span class=\"keyword\">range</span> args&#123;</div><div class=\"line\">    fmt.Println(arg)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//函数调用,传参可以选择多个，个数不定</span></div><div class=\"line\">myfunc(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</div><div class=\"line\">myfunc(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、不定参数的传递，假如有个变参函数myfunc2(args ...int)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myfunc1</span><span class=\"params\">(args ...<span class=\"keyword\">int</span>)</span></span>&#123;</div><div class=\"line\">  <span class=\"comment\">//按原样传递</span></div><div class=\"line\">  myfunc2(args...)</div><div class=\"line\">  <span class=\"comment\">//传递切片</span></div><div class=\"line\">  myfunc2(args[<span class=\"number\">1</span>:]...)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//3、任意类型的不定参数，使用interface&#123;&#125;作为指定类型</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Printf</span><span class=\"params\">(format <span class=\"keyword\">string</span>,args ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span>&#123;   <span class=\"comment\">//此为标准库中fmt.Printf()函数的原型</span></div><div class=\"line\">  <span class=\"comment\">//函数体</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4>5.3多返回值</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//多返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(file *File)</span> <span class=\"title\">Read</span><span class=\"params\">(b []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,err error)</span></span></div><div class=\"line\"><span class=\"function\">//使用下划线\"_\"来丢弃返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">n</span>,_:=<span class=\"title\">f</span>.<span class=\"title\">Read</span><span class=\"params\">(buf)</span></span></div></pre></td></tr></table></figure>\n<h4>5.4匿名函数与闭包</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、匿名函数：不带函数名的函数，可以像变量一样被传递</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(a,b <span class=\"keyword\">int</span>,z <span class=\"keyword\">float32</span>)</span> <span class=\"title\">bool</span></span>&#123;  <span class=\"comment\">//没有函数名</span></div><div class=\"line\">  <span class=\"keyword\">return</span> a*b&lt;<span class=\"keyword\">int</span>(z)</div><div class=\"line\">&#125;</div><div class=\"line\">f:=<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x,y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> x+y</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、闭包</span></div></pre></td></tr></table></figure>\n"},{"title":"[Golang] Golang系列（二）之面向对象编程","catalog":true,"date":"2017-10-01T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Golang"],"_content":"\n- **面向对象编程**\n\n​       把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）[方法的重写，子类不同于父类的特性]／泛化（generalization）[共性，子类都拥有父类的特性]，通过多态（polymorphism）实现基于对象类型的动态分派（dynamic dispatch）。\n\n- **面对对象思想**\n\n​       面向对象思想是对现实世界事物的抽象，系统中一切事物皆为对象；对象是属性及其操作的封装体；对象可按其性质划分为类，对象成为类的实例；实例关系和继承关系是对象之间的静态关系；消息传递是对象之间动态联系的唯一形式，也是计算的唯一形式；方法是消息的序列。\n\n## （一）类型系统[类的声明]\n\n类型系统：\n\n- 一组基本类型构成的“基本类型集合”；\n- “基本类型集合”上定义的一系列组合、运算、转换方法。\n\n类型系统包括基础类型（byte、int、bool、float等）；复合类型（数组、结构体、指针等）；可以指向任何对象的类型（Any类型，类似Java的Object类型）；值语义和引用语义；面向对象类型；接口。Go大多数类型为值语义，可以给任何类型添加方法（包括内置类型，不包括指针类型）。Any类型是空接口即interface{}。\n\n### 1.方法\n\n1、为类型添加方法[类方法声明]，方法即为有接收者的函数\nfunc (对象名 对象类型) 函数名(参数列表) (返回值列表)\n可随时为某个对象添加方法即为某个方法添加归属对象（receiver），以方法为中心\n在Go语言中没有隐藏的this指针，即显示传递，形参即为this，例如以下的形参为a。\n\n```go\ntype Integer int\nfunc (a Integer) Less(b Integer) bool{  //表示a这个对象定义了Less这个方法，a可以为任意类型\n  return a<b                           \n}\n//类型基于值传递，如果要修改值需要传递指针\nfunc (a *Integer) Add(b Integer){\n  *a+=b    //通过指针传递来改变值\n}\n```\n\n### 2.值语义和引用语义\n\n值类型：b的修改并不会影响a的值\n\n引用类型：b的修改会影响a的值\n\nGo大多类型为值语义，包括基本类型：byte，int，string等；复合类型：数组，结构体(struct)，指针等\n\n```go\n//2、值语义和引用语义\nb=a\nb.Modify()\n \n//值类型\nvar a=[3]int{1,2,3}\nb:=a\nb[1]++\nfmt.Println(a,b)   //a=[1,2,3]  b=[1,3,3]\n//引用类型\na:=[3]int{1,2,3}\nb:=&a              //b指向a,即为a的地址，对b指向的值改变实际上就是对a的改变（数组本身就是一种地址指向）\nb[1]++\nfmt.Println(a,*b)  //a=[1,3,3]  b=[1,3,3]   //*b,取地址指向的值\n```\n\n### 3.结构体\n\n3、结构体[类属性的声明]\nstruct的功能类似Java的class，可实现嵌套组合(类似继承的功能)\nstruct实际上就是一种复合类型，只是对类中的属性进行定义赋值，并没有对方法进行定义，方法可以随时定义绑定到该类的对象上，更具灵活性。可利用嵌套组合来实现类似继承的功能避免代码重复。\n\n```go\ntype Rect struct{   //定义矩形类\n  x,y float64       //类型只包含属性，并没有方法\n  width,height float64\n}\nfunc (r *Rect) Area() float64{    //为Rect类型绑定Area的方法，*Rect为指针引用可以修改传入参数的值\n  return r.width*r.height         //方法归属于类型，不归属于具体的对象，声明该类型的对象即可调用该类型的方法\n}\n```\n\n## （二）初始化[实例化对象]\n\n 数据初始化的内建函数new()与make()，二者都是用来分配空间。区别如下:\n\n- **new()**\n\n1. func new(Type) *Type\n2. 内置函数 `new` 分配空间。传递给`new` 函数的是一个**类型**，不是一个值。返回值是指向这个新分配的零值的**指针**\n\n- **make()**\n\n1. func make(Type, size IntegerType) Type \n2. 内建函数 `make` 分配并且初始化 一个 slice, 或者 map 或者 chan 对象。 并且只能是这三种对象。 和 `new` 一样，第一个参数是 类型，不是一个值。 但是`make` 的返回值就是这个类型（即使一个引用类型），而不是指针。 具体的返回值，依赖具体传入的类型。\n\n```go\n//创建实例\nrect1:=new(Rect)   //new一个对象\nrect2:=&Rect{}     //为赋值默认值，bool默认值为false，int默认为零值0，string默认为空字符串\nrect3:=&Rect{0,0,100,200}     //取地址并赋值,按声明的变量顺序依次赋值\nrect4:=&Rect{width:100,height:200}    //按变量名赋值不按顺序赋值\n//构造函数：没有构造参数的概念，通常由全局的创建函数NewXXX来实现构造函数的功能\nfunc NewRect(x,y,width,height float64) *Rect{\n  return &Rect{x,y,width,height}     //利用指针来改变传入参数的值达到类似构造参数的效果\n}\n//方法的重载,Go不支持方法的重载（函数同名，参数不同）\n//v …interface{}表示参数不定的意思，其中v是slice类型，及声明不定参数，可以传入任意参数，实现类似方法的重载\nfunc (poem *Poem) recite(v ...interface{}) {\n    fmt.Println(v)\n}\n```\n\n## （三）匿名组合[继承]\n\n​       组合，即方法代理，例如A包含B，即A通过消息传递的形式代理了B的方法，而不需要重复写B的方法。\n\n​       继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。继承主要为了代码复用，继承也可以扩展已存在的代码模块（类）。\n\n​       严格来讲，继承是“a kind of ”，即子类是父类的一种，例如student是person的一种；组合是“a part of”，即父类是子类中的一部分，例如眼睛是头部的一部分。\n\n```go\n//1、匿名组合的方式实现了类似Java继承的功能，可以实现多继承\ntype Base struct{\n  Name string\n}\nfunc (base *Base) Foo(){...}    //Base的Foo()方法\nfunc (base *Base) Bar(){...}    //Base的Bar()方法\ntype Foo struct{  \n  Base                         //通过组合的方式声明了基类，即继承了基类\n  ...\n}\nfunc (foo *Foo) Bar(){\n  foo.Base.Bar()               //并改写了基类的方法，该方法实现时先调用基类的Bar()方法\n  ...                          //如果没有改写即为继承，调用foo.Foo()和调用foo.Base.Foo()的作用的一样的\n}\n//修改内存布局\ntype Foo struct{\n  ...   //其他成员信息\n  Base\n}\n//以指针方式组合\ntype Foo struct{\n  *Base   //以指针方式派生，创建Foo实例时，需要外部提供一个Base类实例的指针\n  ...\n}\n//名字冲突问题,组合内外如果出现名字重复问题，只会访问到最外层，内层会被隐藏，不会报错，即类似java中方法覆盖/重写。\ntype X struct{\n  Name string\n}\ntype Y struct{\n  X             //Y.X.Name会被隐藏，内层会被隐藏\n  Name string   //只会访问到Y.Name，只会调用外层属性\n}\n```\n\n## （四）可见性[封装]\n\n​       封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n​       **封装的本质或目的其实程序对信息(数据)的控制力。封装分为两部分：该隐藏的隐藏，该暴露的暴露。封装可以隐藏实现细节，使得代码模块化。**\n\n​       Go中用大写字母开头来表示public，可以包外访问；小写字母开头来表示private，只能包内访问；访问性是包级别非类型级别\n​       如果可访问性是类型一致的，可以加friend关键字表示朋友关系可互相访问彼此的私有成员(属性和方法)\n\n```go\ntype Rect struct{\n  X,Y float64\n  Width,Height float64           //字母大写开头表示该属性可以由包外访问到\n}\nfunc (r *Rect) area() float64{   //字母小写开头表示该方法只能包内调用\n  return r.Width*r.Height\n}\n```\n\n## （五）接口[多态]\n\n​       多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。\n\n​       简而言之，就是允许将子类类型的指针赋值给父类类型的指针。\n\n​       即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态分为编译时多态（静态多态）和运行时多态（动态多态），编译时多态一般通过方法重载实现，运行时多态一般通过方法重写实现。\n\n### 5.1接口概念\n\n​      接口即一组方法的集合，定义了对象的一组行为，方法包含实际的代码。换句话说，一个接口就是定义（规范或约束），而方法就是实现，接口的作用应该是将定义与实现分离，降低耦合度。习惯用“er”结尾来命名，例如“Reader”。接口与对象的关系是多对多，即一个对象可以实现多个接口，一个接口也可以被多个对象实现。\n\n​      接口是Go语言整个类型系统的基石，其他语言的接口是不同组件之间的契约的存在，对契约的实现是强制性的，必须显式声明实现了该接口，这类接口称之为“侵入式接口”。而Go语言的接口是隐式存在，只要实现了该接口的所有函数则代表已经实现了该接口，并不需要显式的接口声明。\n\n- **接口的比喻**\n\n​     你的电脑上只有一个USB接口。这个USB接口可以接MP3，数码相机，摄像头，鼠标，键盘等。。。所有的上述硬件都可以公用这个接口，有很好的扩展性，该USB接口定义了一种规范，只要实现了该规范，就可以将不同的设备接入电脑，而设备的改变并不会对电脑本身有什么影响（低耦合）。\n\n- **面向接口编程**\n\n​      接口表示调用者和设计者的一种约定，在多人合作开发同一个项目时，事先定义好相互调用的接口可以大大提高开发的效率。接口是用类来实现的，实现接口的类必须严格按照接口的声明来实现接口提供的所有功能。有了接口，就可以在不影响现有接口声明的情况下，修改接口的内部实现，从而使兼容性问题最小化。\n​      当其他设计者调用了接口后，就不能再随意更改接口的定义，否则项目开发者事先的约定就失去了意义。但是可以在类中修改相应的代码，完成需要改动的内容。\n\n### 5.2非侵入式接口\n\n非侵入式接口：一个类只需要实现了接口要求的所有函数就表示实现了该接口，并不需要显式声明\n\n```go\ntype File struct{\n  //类的属性\n}\n//File类的方法\nfunc (f *File) Read(buf []byte) (n int,err error)\nfunc (f *File) Write(buf []byte) (n int,err error)\nfunc (f *File) Seek(off int64,whence int) (pos int64,err error)\nfunc (f *File) Close() error\n//接口1：IFile\ntype IFile interface{\n  Read(buf []byte) (n int,err error)\n  Write(buf []byte) (n int,err error)\n  Seek(off int64,whence int) (pos int64,err error)\n  Close() error\n}\n//接口2：IReader\ntype IReader interface{\n  Read(buf []byte) (n int,err error)\n}\n//接口赋值,File类实现了IFile和IReader接口，即接口所包含的所有方法\nvar file1 IFile = new(File)\nvar file2 IReader = new(File)\n```\n\n### 5.3接口赋值\n\n只要类实现了该接口的所有方法，即可将该类赋值给这个接口，接口主要用于多态化方法。即对接口定义的方法，不同的实现方式。\n\n接口赋值：\n**1）将对象实例赋值给接口**\n\n```go\ntype IUSB interface{\n    //定义IUSB的接口方法\n}\n//方法定义在类外，绑定该类，以下为方便，备注写在类中\ntype MP3 struct{\n    //实现IUSB的接口，具体实现方式是MP3的方法\n}\ntype Mouse struct{\n    //实现IUSB的接口，具体实现方式是Mouse的方法\n}\n//接口赋值给具体的对象实例MP3\nvar usb IUSB =new(MP3)\nusb.Connect()\nusb.Close()\n//接口赋值给具体的对象实例Mouse\nvar usb IUSB =new(Mouse)\nusb.Connect()\nusb.Close()\n```\n\n**2）将接口赋值给另一个接口**\n\n1. 只要两个接口拥有相同的方法列表（与次序无关），即是两个相同的接口，可以相互赋值\n2. 接口赋值只需要接口A的方法列表是接口B的子集（即假设接口A中定义的所有方法，都在接口B中有定义），那么B接口的实例可以赋值给A的对象。反之不成立，即子接口B包含了父接口A，因此可以将子接口的实例赋值给父接口。\n3. 即子接口实例实现了子接口的所有方法，而父接口的方法列表是子接口的子集，则子接口实例自然实现了父接口的所有方法，因此可以将子接口实例赋值给父接口。\n\n```go\ntype Writer interface{    //父接口\n    Write(buf []byte) (n int,err error)\n}\ntype ReadWriter interface{    //子接口\n    Read(buf []byte) (n int,err error)\n    Write(buf []byte) (n int,err error)\n}\nvar file1 ReadWriter=new(File)   //子接口实例\nvar file2 Writer=file1           //子接口实例赋值给父接口\n```\n\n### 5.4接口查询\n\n若要在 switch 外判断一个接口类型是否实现了某个接口，可以使用“逗号 ok ”。\n\nvalue, ok := Interfacevariable.(implementType)\n\n其中 Interfacevariable 是接口变量（接口值），implementType 为实现此接口的类型，value 返回接口变量实际类型变量的值，如果该类型实现了此接口返回 true。\n\n```go\n//判断file1接口指向的对象实例是否是File类型\nvar file1 Writer=...\nif file5,ok:=file1.(File);ok{  \n  ...\n}\n```\n\n### 5.5接口类型查询\n\n在 Go 中，要判断传递给接口值的变量类型，可以在使用 type switch 得到。(type)只能在 switch 中使用。\n\n```go\n// 另一个实现了 I 接口的 R 类型\ntype R struct { i int }\nfunc (p *R) Get() int { return p.i }\nfunc (p *R) Put(v int) { p.i = v }\n \nfunc f(p I) {\n    switch t := p.(type) { // 判断传递给 p 的实际类型\n        case *S: // 指向 S 的指针类型\n        case *R: // 指向 R 的指针类型\n        case S:  // S 类型\n        case R:  // R 类型\n        default: //实现了 I 接口的其他类型\n    }\n}\n```\n\n### 5.6接口组合\n\n```go\n//接口组合类似类型组合，只不过只包含方法，不包含成员变量\ntype ReadWriter interface{  //接口组合，避免代码重复\n  Reader      //接口Reader\n  Writer      //接口Writer\n}\n```\n\n### 5.7Any类型[空接口]\n\n每种类型都能匹配到空接口：interface{}。空接口类型对方法没有任何约束（因为没有方法），它能包含任意类型，也可以实现到其他接口类型的转换。如果传递给该接口的类型变量实现了转换后的接口则可以正常运行，否则出现运行时错误。\n\n```go\n//interface{}即为可以指向任何对象的Any类型，类似Java中的Object类\nvar v1 interface{}=struct{X int}{1}\nvar v2 interface{}=\"abc\"\n \nfunc DoSomething(v interface{}) {   //该函数可以接收任何类型的参数，因为任何类型都实现了空接口\n   // ...\n}\n```\n\n### 5.8接口的代码示例\n\n```go\n//接口animal\ntype Animal interface {\n    Speak() string\n}\n//Dog类实现animal接口\ntype Dog struct {\n}\n \nfunc (d Dog) Speak() string {\n    return \"Woof!\"\n}\n//Cat类实现animal接口\ntype Cat struct {\n}\n \nfunc (c Cat) Speak() string {\n    return \"Meow!\"\n}\n//Llama实现animal接口\ntype Llama struct {\n}\n \nfunc (l Llama) Speak() string {\n    return \"?????\"\n}\n//JavaProgrammer实现animal接口\ntype JavaProgrammer struct {\n}\n \nfunc (j JavaProgrammer) Speak() string {\n    return \"Design patterns!\"\n}\n//主函数\nfunc main() {\n    animals := []Animal{Dog{}, Cat{}, Llama{}, JavaProgrammer{}}  //利用接口实现多态\n    for _, animal := range animals {\n        fmt.Println(animal.Speak())  //打印不同实现该接口的类的方法返回值\n    }\n}\n```","source":"_posts/Golang/Golang系列（二）之面向对象编程.md","raw":"---\ntitle: \"[Golang] Golang系列（二）之面向对象编程\"\ncatalog: true\ndate: 2017-10-01 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Golang\ncatagories:\n- Golang\n---\n\n- **面向对象编程**\n\n​       把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）[方法的重写，子类不同于父类的特性]／泛化（generalization）[共性，子类都拥有父类的特性]，通过多态（polymorphism）实现基于对象类型的动态分派（dynamic dispatch）。\n\n- **面对对象思想**\n\n​       面向对象思想是对现实世界事物的抽象，系统中一切事物皆为对象；对象是属性及其操作的封装体；对象可按其性质划分为类，对象成为类的实例；实例关系和继承关系是对象之间的静态关系；消息传递是对象之间动态联系的唯一形式，也是计算的唯一形式；方法是消息的序列。\n\n## （一）类型系统[类的声明]\n\n类型系统：\n\n- 一组基本类型构成的“基本类型集合”；\n- “基本类型集合”上定义的一系列组合、运算、转换方法。\n\n类型系统包括基础类型（byte、int、bool、float等）；复合类型（数组、结构体、指针等）；可以指向任何对象的类型（Any类型，类似Java的Object类型）；值语义和引用语义；面向对象类型；接口。Go大多数类型为值语义，可以给任何类型添加方法（包括内置类型，不包括指针类型）。Any类型是空接口即interface{}。\n\n### 1.方法\n\n1、为类型添加方法[类方法声明]，方法即为有接收者的函数\nfunc (对象名 对象类型) 函数名(参数列表) (返回值列表)\n可随时为某个对象添加方法即为某个方法添加归属对象（receiver），以方法为中心\n在Go语言中没有隐藏的this指针，即显示传递，形参即为this，例如以下的形参为a。\n\n```go\ntype Integer int\nfunc (a Integer) Less(b Integer) bool{  //表示a这个对象定义了Less这个方法，a可以为任意类型\n  return a<b                           \n}\n//类型基于值传递，如果要修改值需要传递指针\nfunc (a *Integer) Add(b Integer){\n  *a+=b    //通过指针传递来改变值\n}\n```\n\n### 2.值语义和引用语义\n\n值类型：b的修改并不会影响a的值\n\n引用类型：b的修改会影响a的值\n\nGo大多类型为值语义，包括基本类型：byte，int，string等；复合类型：数组，结构体(struct)，指针等\n\n```go\n//2、值语义和引用语义\nb=a\nb.Modify()\n \n//值类型\nvar a=[3]int{1,2,3}\nb:=a\nb[1]++\nfmt.Println(a,b)   //a=[1,2,3]  b=[1,3,3]\n//引用类型\na:=[3]int{1,2,3}\nb:=&a              //b指向a,即为a的地址，对b指向的值改变实际上就是对a的改变（数组本身就是一种地址指向）\nb[1]++\nfmt.Println(a,*b)  //a=[1,3,3]  b=[1,3,3]   //*b,取地址指向的值\n```\n\n### 3.结构体\n\n3、结构体[类属性的声明]\nstruct的功能类似Java的class，可实现嵌套组合(类似继承的功能)\nstruct实际上就是一种复合类型，只是对类中的属性进行定义赋值，并没有对方法进行定义，方法可以随时定义绑定到该类的对象上，更具灵活性。可利用嵌套组合来实现类似继承的功能避免代码重复。\n\n```go\ntype Rect struct{   //定义矩形类\n  x,y float64       //类型只包含属性，并没有方法\n  width,height float64\n}\nfunc (r *Rect) Area() float64{    //为Rect类型绑定Area的方法，*Rect为指针引用可以修改传入参数的值\n  return r.width*r.height         //方法归属于类型，不归属于具体的对象，声明该类型的对象即可调用该类型的方法\n}\n```\n\n## （二）初始化[实例化对象]\n\n 数据初始化的内建函数new()与make()，二者都是用来分配空间。区别如下:\n\n- **new()**\n\n1. func new(Type) *Type\n2. 内置函数 `new` 分配空间。传递给`new` 函数的是一个**类型**，不是一个值。返回值是指向这个新分配的零值的**指针**\n\n- **make()**\n\n1. func make(Type, size IntegerType) Type \n2. 内建函数 `make` 分配并且初始化 一个 slice, 或者 map 或者 chan 对象。 并且只能是这三种对象。 和 `new` 一样，第一个参数是 类型，不是一个值。 但是`make` 的返回值就是这个类型（即使一个引用类型），而不是指针。 具体的返回值，依赖具体传入的类型。\n\n```go\n//创建实例\nrect1:=new(Rect)   //new一个对象\nrect2:=&Rect{}     //为赋值默认值，bool默认值为false，int默认为零值0，string默认为空字符串\nrect3:=&Rect{0,0,100,200}     //取地址并赋值,按声明的变量顺序依次赋值\nrect4:=&Rect{width:100,height:200}    //按变量名赋值不按顺序赋值\n//构造函数：没有构造参数的概念，通常由全局的创建函数NewXXX来实现构造函数的功能\nfunc NewRect(x,y,width,height float64) *Rect{\n  return &Rect{x,y,width,height}     //利用指针来改变传入参数的值达到类似构造参数的效果\n}\n//方法的重载,Go不支持方法的重载（函数同名，参数不同）\n//v …interface{}表示参数不定的意思，其中v是slice类型，及声明不定参数，可以传入任意参数，实现类似方法的重载\nfunc (poem *Poem) recite(v ...interface{}) {\n    fmt.Println(v)\n}\n```\n\n## （三）匿名组合[继承]\n\n​       组合，即方法代理，例如A包含B，即A通过消息传递的形式代理了B的方法，而不需要重复写B的方法。\n\n​       继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。继承主要为了代码复用，继承也可以扩展已存在的代码模块（类）。\n\n​       严格来讲，继承是“a kind of ”，即子类是父类的一种，例如student是person的一种；组合是“a part of”，即父类是子类中的一部分，例如眼睛是头部的一部分。\n\n```go\n//1、匿名组合的方式实现了类似Java继承的功能，可以实现多继承\ntype Base struct{\n  Name string\n}\nfunc (base *Base) Foo(){...}    //Base的Foo()方法\nfunc (base *Base) Bar(){...}    //Base的Bar()方法\ntype Foo struct{  \n  Base                         //通过组合的方式声明了基类，即继承了基类\n  ...\n}\nfunc (foo *Foo) Bar(){\n  foo.Base.Bar()               //并改写了基类的方法，该方法实现时先调用基类的Bar()方法\n  ...                          //如果没有改写即为继承，调用foo.Foo()和调用foo.Base.Foo()的作用的一样的\n}\n//修改内存布局\ntype Foo struct{\n  ...   //其他成员信息\n  Base\n}\n//以指针方式组合\ntype Foo struct{\n  *Base   //以指针方式派生，创建Foo实例时，需要外部提供一个Base类实例的指针\n  ...\n}\n//名字冲突问题,组合内外如果出现名字重复问题，只会访问到最外层，内层会被隐藏，不会报错，即类似java中方法覆盖/重写。\ntype X struct{\n  Name string\n}\ntype Y struct{\n  X             //Y.X.Name会被隐藏，内层会被隐藏\n  Name string   //只会访问到Y.Name，只会调用外层属性\n}\n```\n\n## （四）可见性[封装]\n\n​       封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n​       **封装的本质或目的其实程序对信息(数据)的控制力。封装分为两部分：该隐藏的隐藏，该暴露的暴露。封装可以隐藏实现细节，使得代码模块化。**\n\n​       Go中用大写字母开头来表示public，可以包外访问；小写字母开头来表示private，只能包内访问；访问性是包级别非类型级别\n​       如果可访问性是类型一致的，可以加friend关键字表示朋友关系可互相访问彼此的私有成员(属性和方法)\n\n```go\ntype Rect struct{\n  X,Y float64\n  Width,Height float64           //字母大写开头表示该属性可以由包外访问到\n}\nfunc (r *Rect) area() float64{   //字母小写开头表示该方法只能包内调用\n  return r.Width*r.Height\n}\n```\n\n## （五）接口[多态]\n\n​       多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。\n\n​       简而言之，就是允许将子类类型的指针赋值给父类类型的指针。\n\n​       即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态分为编译时多态（静态多态）和运行时多态（动态多态），编译时多态一般通过方法重载实现，运行时多态一般通过方法重写实现。\n\n### 5.1接口概念\n\n​      接口即一组方法的集合，定义了对象的一组行为，方法包含实际的代码。换句话说，一个接口就是定义（规范或约束），而方法就是实现，接口的作用应该是将定义与实现分离，降低耦合度。习惯用“er”结尾来命名，例如“Reader”。接口与对象的关系是多对多，即一个对象可以实现多个接口，一个接口也可以被多个对象实现。\n\n​      接口是Go语言整个类型系统的基石，其他语言的接口是不同组件之间的契约的存在，对契约的实现是强制性的，必须显式声明实现了该接口，这类接口称之为“侵入式接口”。而Go语言的接口是隐式存在，只要实现了该接口的所有函数则代表已经实现了该接口，并不需要显式的接口声明。\n\n- **接口的比喻**\n\n​     你的电脑上只有一个USB接口。这个USB接口可以接MP3，数码相机，摄像头，鼠标，键盘等。。。所有的上述硬件都可以公用这个接口，有很好的扩展性，该USB接口定义了一种规范，只要实现了该规范，就可以将不同的设备接入电脑，而设备的改变并不会对电脑本身有什么影响（低耦合）。\n\n- **面向接口编程**\n\n​      接口表示调用者和设计者的一种约定，在多人合作开发同一个项目时，事先定义好相互调用的接口可以大大提高开发的效率。接口是用类来实现的，实现接口的类必须严格按照接口的声明来实现接口提供的所有功能。有了接口，就可以在不影响现有接口声明的情况下，修改接口的内部实现，从而使兼容性问题最小化。\n​      当其他设计者调用了接口后，就不能再随意更改接口的定义，否则项目开发者事先的约定就失去了意义。但是可以在类中修改相应的代码，完成需要改动的内容。\n\n### 5.2非侵入式接口\n\n非侵入式接口：一个类只需要实现了接口要求的所有函数就表示实现了该接口，并不需要显式声明\n\n```go\ntype File struct{\n  //类的属性\n}\n//File类的方法\nfunc (f *File) Read(buf []byte) (n int,err error)\nfunc (f *File) Write(buf []byte) (n int,err error)\nfunc (f *File) Seek(off int64,whence int) (pos int64,err error)\nfunc (f *File) Close() error\n//接口1：IFile\ntype IFile interface{\n  Read(buf []byte) (n int,err error)\n  Write(buf []byte) (n int,err error)\n  Seek(off int64,whence int) (pos int64,err error)\n  Close() error\n}\n//接口2：IReader\ntype IReader interface{\n  Read(buf []byte) (n int,err error)\n}\n//接口赋值,File类实现了IFile和IReader接口，即接口所包含的所有方法\nvar file1 IFile = new(File)\nvar file2 IReader = new(File)\n```\n\n### 5.3接口赋值\n\n只要类实现了该接口的所有方法，即可将该类赋值给这个接口，接口主要用于多态化方法。即对接口定义的方法，不同的实现方式。\n\n接口赋值：\n**1）将对象实例赋值给接口**\n\n```go\ntype IUSB interface{\n    //定义IUSB的接口方法\n}\n//方法定义在类外，绑定该类，以下为方便，备注写在类中\ntype MP3 struct{\n    //实现IUSB的接口，具体实现方式是MP3的方法\n}\ntype Mouse struct{\n    //实现IUSB的接口，具体实现方式是Mouse的方法\n}\n//接口赋值给具体的对象实例MP3\nvar usb IUSB =new(MP3)\nusb.Connect()\nusb.Close()\n//接口赋值给具体的对象实例Mouse\nvar usb IUSB =new(Mouse)\nusb.Connect()\nusb.Close()\n```\n\n**2）将接口赋值给另一个接口**\n\n1. 只要两个接口拥有相同的方法列表（与次序无关），即是两个相同的接口，可以相互赋值\n2. 接口赋值只需要接口A的方法列表是接口B的子集（即假设接口A中定义的所有方法，都在接口B中有定义），那么B接口的实例可以赋值给A的对象。反之不成立，即子接口B包含了父接口A，因此可以将子接口的实例赋值给父接口。\n3. 即子接口实例实现了子接口的所有方法，而父接口的方法列表是子接口的子集，则子接口实例自然实现了父接口的所有方法，因此可以将子接口实例赋值给父接口。\n\n```go\ntype Writer interface{    //父接口\n    Write(buf []byte) (n int,err error)\n}\ntype ReadWriter interface{    //子接口\n    Read(buf []byte) (n int,err error)\n    Write(buf []byte) (n int,err error)\n}\nvar file1 ReadWriter=new(File)   //子接口实例\nvar file2 Writer=file1           //子接口实例赋值给父接口\n```\n\n### 5.4接口查询\n\n若要在 switch 外判断一个接口类型是否实现了某个接口，可以使用“逗号 ok ”。\n\nvalue, ok := Interfacevariable.(implementType)\n\n其中 Interfacevariable 是接口变量（接口值），implementType 为实现此接口的类型，value 返回接口变量实际类型变量的值，如果该类型实现了此接口返回 true。\n\n```go\n//判断file1接口指向的对象实例是否是File类型\nvar file1 Writer=...\nif file5,ok:=file1.(File);ok{  \n  ...\n}\n```\n\n### 5.5接口类型查询\n\n在 Go 中，要判断传递给接口值的变量类型，可以在使用 type switch 得到。(type)只能在 switch 中使用。\n\n```go\n// 另一个实现了 I 接口的 R 类型\ntype R struct { i int }\nfunc (p *R) Get() int { return p.i }\nfunc (p *R) Put(v int) { p.i = v }\n \nfunc f(p I) {\n    switch t := p.(type) { // 判断传递给 p 的实际类型\n        case *S: // 指向 S 的指针类型\n        case *R: // 指向 R 的指针类型\n        case S:  // S 类型\n        case R:  // R 类型\n        default: //实现了 I 接口的其他类型\n    }\n}\n```\n\n### 5.6接口组合\n\n```go\n//接口组合类似类型组合，只不过只包含方法，不包含成员变量\ntype ReadWriter interface{  //接口组合，避免代码重复\n  Reader      //接口Reader\n  Writer      //接口Writer\n}\n```\n\n### 5.7Any类型[空接口]\n\n每种类型都能匹配到空接口：interface{}。空接口类型对方法没有任何约束（因为没有方法），它能包含任意类型，也可以实现到其他接口类型的转换。如果传递给该接口的类型变量实现了转换后的接口则可以正常运行，否则出现运行时错误。\n\n```go\n//interface{}即为可以指向任何对象的Any类型，类似Java中的Object类\nvar v1 interface{}=struct{X int}{1}\nvar v2 interface{}=\"abc\"\n \nfunc DoSomething(v interface{}) {   //该函数可以接收任何类型的参数，因为任何类型都实现了空接口\n   // ...\n}\n```\n\n### 5.8接口的代码示例\n\n```go\n//接口animal\ntype Animal interface {\n    Speak() string\n}\n//Dog类实现animal接口\ntype Dog struct {\n}\n \nfunc (d Dog) Speak() string {\n    return \"Woof!\"\n}\n//Cat类实现animal接口\ntype Cat struct {\n}\n \nfunc (c Cat) Speak() string {\n    return \"Meow!\"\n}\n//Llama实现animal接口\ntype Llama struct {\n}\n \nfunc (l Llama) Speak() string {\n    return \"?????\"\n}\n//JavaProgrammer实现animal接口\ntype JavaProgrammer struct {\n}\n \nfunc (j JavaProgrammer) Speak() string {\n    return \"Design patterns!\"\n}\n//主函数\nfunc main() {\n    animals := []Animal{Dog{}, Cat{}, Llama{}, JavaProgrammer{}}  //利用接口实现多态\n    for _, animal := range animals {\n        fmt.Println(animal.Speak())  //打印不同实现该接口的类的方法返回值\n    }\n}\n```","slug":"Golang/Golang系列（二）之面向对象编程","published":1,"updated":"2017-10-03T08:06:05.861Z","_id":"cj8b7dfg800062cvu492d7xjx","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li><strong>面向对象编程</strong></li>\n</ul>\n<p>​       把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）[方法的重写，子类不同于父类的特性]／泛化（generalization）[共性，子类都拥有父类的特性]，通过多态（polymorphism）实现基于对象类型的动态分派（dynamic dispatch）。</p>\n<ul>\n<li><strong>面对对象思想</strong></li>\n</ul>\n<p>​       面向对象思想是对现实世界事物的抽象，系统中一切事物皆为对象；对象是属性及其操作的封装体；对象可按其性质划分为类，对象成为类的实例；实例关系和继承关系是对象之间的静态关系；消息传递是对象之间动态联系的唯一形式，也是计算的唯一形式；方法是消息的序列。</p>\n<h2><span id=\"一类型系统类的声明\">（一）类型系统[类的声明]</span></h2>\n<p>类型系统：</p>\n<ul>\n<li>一组基本类型构成的“基本类型集合”；</li>\n<li>“基本类型集合”上定义的一系列组合、运算、转换方法。</li>\n</ul>\n<p>类型系统包括基础类型（byte、int、bool、float等）；复合类型（数组、结构体、指针等）；可以指向任何对象的类型（Any类型，类似Java的Object类型）；值语义和引用语义；面向对象类型；接口。Go大多数类型为值语义，可以给任何类型添加方法（包括内置类型，不包括指针类型）。Any类型是空接口即interface{}。</p>\n<h3><span id=\"1方法\">1.方法</span></h3>\n<p>1、为类型添加方法[类方法声明]，方法即为有接收者的函数<br>\nfunc (对象名 对象类型) 函数名(参数列表) (返回值列表)<br>\n可随时为某个对象添加方法即为某个方法添加归属对象（receiver），以方法为中心<br>\n在Go语言中没有隐藏的this指针，即显示传递，形参即为this，例如以下的形参为a。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Integer <span class=\"keyword\">int</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a Integer)</span> <span class=\"title\">Less</span><span class=\"params\">(b Integer)</span> <span class=\"title\">bool</span></span>&#123;  <span class=\"comment\">//表示a这个对象定义了Less这个方法，a可以为任意类型</span></div><div class=\"line\">  <span class=\"keyword\">return</span> a&lt;b                           </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//类型基于值传递，如果要修改值需要传递指针</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *Integer)</span> <span class=\"title\">Add</span><span class=\"params\">(b Integer)</span></span>&#123;</div><div class=\"line\">  *a+=b    <span class=\"comment\">//通过指针传递来改变值</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"2值语义和引用语义\">2.值语义和引用语义</span></h3>\n<p>值类型：b的修改并不会影响a的值</p>\n<p>引用类型：b的修改会影响a的值</p>\n<p>Go大多类型为值语义，包括基本类型：byte，int，string等；复合类型：数组，结构体(struct)，指针等</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//2、值语义和引用语义</span></div><div class=\"line\">b=a</div><div class=\"line\">b.Modify()</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">//值类型</span></div><div class=\"line\"><span class=\"keyword\">var</span> a=[<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</div><div class=\"line\">b:=a</div><div class=\"line\">b[<span class=\"number\">1</span>]++</div><div class=\"line\">fmt.Println(a,b)   <span class=\"comment\">//a=[1,2,3]  b=[1,3,3]</span></div><div class=\"line\"><span class=\"comment\">//引用类型</span></div><div class=\"line\">a:=[<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</div><div class=\"line\">b:=&amp;a              <span class=\"comment\">//b指向a,即为a的地址，对b指向的值改变实际上就是对a的改变（数组本身就是一种地址指向）</span></div><div class=\"line\">b[<span class=\"number\">1</span>]++</div><div class=\"line\">fmt.Println(a,*b)  <span class=\"comment\">//a=[1,3,3]  b=[1,3,3]   //*b,取地址指向的值</span></div></pre></td></tr></table></figure>\n<h3><span id=\"3结构体\">3.结构体</span></h3>\n<p>3、结构体[类属性的声明]<br>\nstruct的功能类似Java的class，可实现嵌套组合(类似继承的功能)<br>\nstruct实际上就是一种复合类型，只是对类中的属性进行定义赋值，并没有对方法进行定义，方法可以随时定义绑定到该类的对象上，更具灵活性。可利用嵌套组合来实现类似继承的功能避免代码重复。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Rect <span class=\"keyword\">struct</span>&#123;   <span class=\"comment\">//定义矩形类</span></div><div class=\"line\">  x,y <span class=\"keyword\">float64</span>       <span class=\"comment\">//类型只包含属性，并没有方法</span></div><div class=\"line\">  width,height <span class=\"keyword\">float64</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *Rect)</span> <span class=\"title\">Area</span><span class=\"params\">()</span> <span class=\"title\">float64</span></span>&#123;    <span class=\"comment\">//为Rect类型绑定Area的方法，*Rect为指针引用可以修改传入参数的值</span></div><div class=\"line\">  <span class=\"keyword\">return</span> r.width*r.height         <span class=\"comment\">//方法归属于类型，不归属于具体的对象，声明该类型的对象即可调用该类型的方法</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2><span id=\"二初始化实例化对象\">（二）初始化[实例化对象]</span></h2>\n<p>数据初始化的内建函数new()与make()，二者都是用来分配空间。区别如下:</p>\n<ul>\n<li><strong>new()</strong></li>\n</ul>\n<ol>\n<li>func new(Type) *Type</li>\n<li>内置函数 <code>new</code> 分配空间。传递给<code>new</code> 函数的是一个<strong>类型</strong>，不是一个值。返回值是指向这个新分配的零值的<strong>指针</strong></li>\n</ol>\n<ul>\n<li><strong>make()</strong></li>\n</ul>\n<ol>\n<li>func make(Type, size IntegerType) Type</li>\n<li>内建函数 <code>make</code> 分配并且初始化 一个 slice, 或者 map 或者 chan 对象。 并且只能是这三种对象。 和 <code>new</code> 一样，第一个参数是 类型，不是一个值。 但是<code>make</code> 的返回值就是这个类型（即使一个引用类型），而不是指针。 具体的返回值，依赖具体传入的类型。</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建实例</span></div><div class=\"line\">rect1:=<span class=\"built_in\">new</span>(Rect)   <span class=\"comment\">//new一个对象</span></div><div class=\"line\">rect2:=&amp;Rect&#123;&#125;     <span class=\"comment\">//为赋值默认值，bool默认值为false，int默认为零值0，string默认为空字符串</span></div><div class=\"line\">rect3:=&amp;Rect&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">100</span>,<span class=\"number\">200</span>&#125;     <span class=\"comment\">//取地址并赋值,按声明的变量顺序依次赋值</span></div><div class=\"line\">rect4:=&amp;Rect&#123;width:<span class=\"number\">100</span>,height:<span class=\"number\">200</span>&#125;    <span class=\"comment\">//按变量名赋值不按顺序赋值</span></div><div class=\"line\"><span class=\"comment\">//构造函数：没有构造参数的概念，通常由全局的创建函数NewXXX来实现构造函数的功能</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewRect</span><span class=\"params\">(x,y,width,height <span class=\"keyword\">float64</span>)</span> *<span class=\"title\">Rect</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &amp;Rect&#123;x,y,width,height&#125;     <span class=\"comment\">//利用指针来改变传入参数的值达到类似构造参数的效果</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//方法的重载,Go不支持方法的重载（函数同名，参数不同）</span></div><div class=\"line\"><span class=\"comment\">//v …interface&#123;&#125;表示参数不定的意思，其中v是slice类型，及声明不定参数，可以传入任意参数，实现类似方法的重载</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(poem *Poem)</span> <span class=\"title\">recite</span><span class=\"params\">(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</div><div class=\"line\">    fmt.Println(v)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2><span id=\"三匿名组合继承\">（三）匿名组合[继承]</span></h2>\n<p>​       组合，即方法代理，例如A包含B，即A通过消息传递的形式代理了B的方法，而不需要重复写B的方法。</p>\n<p>​       继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。继承主要为了代码复用，继承也可以扩展已存在的代码模块（类）。</p>\n<p>​       严格来讲，继承是“a kind of ”，即子类是父类的一种，例如student是person的一种；组合是“a part of”，即父类是子类中的一部分，例如眼睛是头部的一部分。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、匿名组合的方式实现了类似Java继承的功能，可以实现多继承</span></div><div class=\"line\"><span class=\"keyword\">type</span> Base <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">  Name <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(base *Base)</span> <span class=\"title\">Foo</span><span class=\"params\">()</span></span>&#123;...&#125;    <span class=\"comment\">//Base的Foo()方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(base *Base)</span> <span class=\"title\">Bar</span><span class=\"params\">()</span></span>&#123;...&#125;    <span class=\"comment\">//Base的Bar()方法</span></div><div class=\"line\"><span class=\"keyword\">type</span> Foo <span class=\"keyword\">struct</span>&#123;  </div><div class=\"line\">  Base                         <span class=\"comment\">//通过组合的方式声明了基类，即继承了基类</span></div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(foo *Foo)</span> <span class=\"title\">Bar</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">  foo.Base.Bar()               <span class=\"comment\">//并改写了基类的方法，该方法实现时先调用基类的Bar()方法</span></div><div class=\"line\">  ...                          <span class=\"comment\">//如果没有改写即为继承，调用foo.Foo()和调用foo.Base.Foo()的作用的一样的</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//修改内存布局</span></div><div class=\"line\"><span class=\"keyword\">type</span> Foo <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">  ...   <span class=\"comment\">//其他成员信息</span></div><div class=\"line\">  Base</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//以指针方式组合</span></div><div class=\"line\"><span class=\"keyword\">type</span> Foo <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">  *Base   <span class=\"comment\">//以指针方式派生，创建Foo实例时，需要外部提供一个Base类实例的指针</span></div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//名字冲突问题,组合内外如果出现名字重复问题，只会访问到最外层，内层会被隐藏，不会报错，即类似java中方法覆盖/重写。</span></div><div class=\"line\"><span class=\"keyword\">type</span> X <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">  Name <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">type</span> Y <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">  X             <span class=\"comment\">//Y.X.Name会被隐藏，内层会被隐藏</span></div><div class=\"line\">  Name <span class=\"keyword\">string</span>   <span class=\"comment\">//只会访问到Y.Name，只会调用外层属性</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2><span id=\"四可见性封装\">（四）可见性[封装]</span></h2>\n<p>​       封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p>\n<p>​       <strong>封装的本质或目的其实程序对信息(数据)的控制力。封装分为两部分：该隐藏的隐藏，该暴露的暴露。封装可以隐藏实现细节，使得代码模块化。</strong></p>\n<p>​       Go中用大写字母开头来表示public，可以包外访问；小写字母开头来表示private，只能包内访问；访问性是包级别非类型级别<br>\n​       如果可访问性是类型一致的，可以加friend关键字表示朋友关系可互相访问彼此的私有成员(属性和方法)</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Rect <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">  X,Y <span class=\"keyword\">float64</span></div><div class=\"line\">  Width,Height <span class=\"keyword\">float64</span>           <span class=\"comment\">//字母大写开头表示该属性可以由包外访问到</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *Rect)</span> <span class=\"title\">area</span><span class=\"params\">()</span> <span class=\"title\">float64</span></span>&#123;   <span class=\"comment\">//字母小写开头表示该方法只能包内调用</span></div><div class=\"line\">  <span class=\"keyword\">return</span> r.Width*r.Height</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2><span id=\"五接口多态\">（五）接口[多态]</span></h2>\n<p>​       多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。</p>\n<p>​       简而言之，就是允许将子类类型的指针赋值给父类类型的指针。</p>\n<p>​       即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态分为编译时多态（静态多态）和运行时多态（动态多态），编译时多态一般通过方法重载实现，运行时多态一般通过方法重写实现。</p>\n<h3><span id=\"51接口概念\">5.1接口概念</span></h3>\n<p>​      接口即一组方法的集合，定义了对象的一组行为，方法包含实际的代码。换句话说，一个接口就是定义（规范或约束），而方法就是实现，接口的作用应该是将定义与实现分离，降低耦合度。习惯用“er”结尾来命名，例如“Reader”。接口与对象的关系是多对多，即一个对象可以实现多个接口，一个接口也可以被多个对象实现。</p>\n<p>​      接口是Go语言整个类型系统的基石，其他语言的接口是不同组件之间的契约的存在，对契约的实现是强制性的，必须显式声明实现了该接口，这类接口称之为“侵入式接口”。而Go语言的接口是隐式存在，只要实现了该接口的所有函数则代表已经实现了该接口，并不需要显式的接口声明。</p>\n<ul>\n<li><strong>接口的比喻</strong></li>\n</ul>\n<p>​     你的电脑上只有一个USB接口。这个USB接口可以接MP3，数码相机，摄像头，鼠标，键盘等。。。所有的上述硬件都可以公用这个接口，有很好的扩展性，该USB接口定义了一种规范，只要实现了该规范，就可以将不同的设备接入电脑，而设备的改变并不会对电脑本身有什么影响（低耦合）。</p>\n<ul>\n<li><strong>面向接口编程</strong></li>\n</ul>\n<p>​      接口表示调用者和设计者的一种约定，在多人合作开发同一个项目时，事先定义好相互调用的接口可以大大提高开发的效率。接口是用类来实现的，实现接口的类必须严格按照接口的声明来实现接口提供的所有功能。有了接口，就可以在不影响现有接口声明的情况下，修改接口的内部实现，从而使兼容性问题最小化。<br>\n​      当其他设计者调用了接口后，就不能再随意更改接口的定义，否则项目开发者事先的约定就失去了意义。但是可以在类中修改相应的代码，完成需要改动的内容。</p>\n<h3><span id=\"52非侵入式接口\">5.2非侵入式接口</span></h3>\n<p>非侵入式接口：一个类只需要实现了接口要求的所有函数就表示实现了该接口，并不需要显式声明</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> File <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//类的属性</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//File类的方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Read</span><span class=\"params\">(buf []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,err error)</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Write</span><span class=\"params\">(buf []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,err error)</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Seek</span><span class=\"params\">(off <span class=\"keyword\">int64</span>,whence <span class=\"keyword\">int</span>)</span> <span class=\"params\">(pos <span class=\"keyword\">int64</span>,err error)</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Close</span><span class=\"params\">()</span> <span class=\"title\">error</span></span></div><div class=\"line\"><span class=\"function\">//接口1：<span class=\"title\">IFile</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">type</span> <span class=\"title\">IFile</span> <span class=\"title\">interface</span></span>&#123;</div><div class=\"line\">  Read(buf []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>,err error)</div><div class=\"line\">  Write(buf []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>,err error)</div><div class=\"line\">  Seek(off <span class=\"keyword\">int64</span>,whence <span class=\"keyword\">int</span>) (pos <span class=\"keyword\">int64</span>,err error)</div><div class=\"line\">  Close() error</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//接口2：IReader</span></div><div class=\"line\"><span class=\"keyword\">type</span> IReader <span class=\"keyword\">interface</span>&#123;</div><div class=\"line\">  Read(buf []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>,err error)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//接口赋值,File类实现了IFile和IReader接口，即接口所包含的所有方法</span></div><div class=\"line\"><span class=\"keyword\">var</span> file1 IFile = <span class=\"built_in\">new</span>(File)</div><div class=\"line\"><span class=\"keyword\">var</span> file2 IReader = <span class=\"built_in\">new</span>(File)</div></pre></td></tr></table></figure>\n<h3><span id=\"53接口赋值\">5.3接口赋值</span></h3>\n<p>只要类实现了该接口的所有方法，即可将该类赋值给这个接口，接口主要用于多态化方法。即对接口定义的方法，不同的实现方式。</p>\n<p>接口赋值：<br>\n<strong>1）将对象实例赋值给接口</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> IUSB <span class=\"keyword\">interface</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//定义IUSB的接口方法</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//方法定义在类外，绑定该类，以下为方便，备注写在类中</span></div><div class=\"line\"><span class=\"keyword\">type</span> MP3 <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//实现IUSB的接口，具体实现方式是MP3的方法</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">type</span> Mouse <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//实现IUSB的接口，具体实现方式是Mouse的方法</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//接口赋值给具体的对象实例MP3</span></div><div class=\"line\"><span class=\"keyword\">var</span> usb IUSB =<span class=\"built_in\">new</span>(MP3)</div><div class=\"line\">usb.Connect()</div><div class=\"line\">usb.Close()</div><div class=\"line\"><span class=\"comment\">//接口赋值给具体的对象实例Mouse</span></div><div class=\"line\"><span class=\"keyword\">var</span> usb IUSB =<span class=\"built_in\">new</span>(Mouse)</div><div class=\"line\">usb.Connect()</div><div class=\"line\">usb.Close()</div></pre></td></tr></table></figure>\n<p><strong>2）将接口赋值给另一个接口</strong></p>\n<ol>\n<li>只要两个接口拥有相同的方法列表（与次序无关），即是两个相同的接口，可以相互赋值</li>\n<li>接口赋值只需要接口A的方法列表是接口B的子集（即假设接口A中定义的所有方法，都在接口B中有定义），那么B接口的实例可以赋值给A的对象。反之不成立，即子接口B包含了父接口A，因此可以将子接口的实例赋值给父接口。</li>\n<li>即子接口实例实现了子接口的所有方法，而父接口的方法列表是子接口的子集，则子接口实例自然实现了父接口的所有方法，因此可以将子接口实例赋值给父接口。</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Writer <span class=\"keyword\">interface</span>&#123;    <span class=\"comment\">//父接口</span></div><div class=\"line\">    Write(buf []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>,err error)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">type</span> ReadWriter <span class=\"keyword\">interface</span>&#123;    <span class=\"comment\">//子接口</span></div><div class=\"line\">    Read(buf []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>,err error)</div><div class=\"line\">    Write(buf []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>,err error)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> file1 ReadWriter=<span class=\"built_in\">new</span>(File)   <span class=\"comment\">//子接口实例</span></div><div class=\"line\"><span class=\"keyword\">var</span> file2 Writer=file1           <span class=\"comment\">//子接口实例赋值给父接口</span></div></pre></td></tr></table></figure>\n<h3><span id=\"54接口查询\">5.4接口查询</span></h3>\n<p>若要在 switch 外判断一个接口类型是否实现了某个接口，可以使用“逗号 ok ”。</p>\n<p>value, ok := Interfacevariable.(implementType)</p>\n<p>其中 Interfacevariable 是接口变量（接口值），implementType 为实现此接口的类型，value 返回接口变量实际类型变量的值，如果该类型实现了此接口返回 true。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//判断file1接口指向的对象实例是否是File类型</span></div><div class=\"line\"><span class=\"keyword\">var</span> file1 Writer=...</div><div class=\"line\"><span class=\"keyword\">if</span> file5,ok:=file1.(File);ok&#123;  </div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"55接口类型查询\">5.5接口类型查询</span></h3>\n<p>在 Go 中，要判断传递给接口值的变量类型，可以在使用 type switch 得到。(type)只能在 switch 中使用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 另一个实现了 I 接口的 R 类型</span></div><div class=\"line\"><span class=\"keyword\">type</span> R <span class=\"keyword\">struct</span> &#123; i <span class=\"keyword\">int</span> &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *R)</span> <span class=\"title\">Get</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> p.i &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *R)</span> <span class=\"title\">Put</span><span class=\"params\">(v <span class=\"keyword\">int</span>)</span></span> &#123; p.i = v &#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">(p I)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span> t := p.(<span class=\"keyword\">type</span>) &#123; <span class=\"comment\">// 判断传递给 p 的实际类型</span></div><div class=\"line\">        <span class=\"keyword\">case</span> *S: <span class=\"comment\">// 指向 S 的指针类型</span></div><div class=\"line\">        <span class=\"keyword\">case</span> *R: <span class=\"comment\">// 指向 R 的指针类型</span></div><div class=\"line\">        <span class=\"keyword\">case</span> S:  <span class=\"comment\">// S 类型</span></div><div class=\"line\">        <span class=\"keyword\">case</span> R:  <span class=\"comment\">// R 类型</span></div><div class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"comment\">//实现了 I 接口的其他类型</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"56接口组合\">5.6接口组合</span></h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//接口组合类似类型组合，只不过只包含方法，不包含成员变量</span></div><div class=\"line\"><span class=\"keyword\">type</span> ReadWriter <span class=\"keyword\">interface</span>&#123;  <span class=\"comment\">//接口组合，避免代码重复</span></div><div class=\"line\">  Reader      <span class=\"comment\">//接口Reader</span></div><div class=\"line\">  Writer      <span class=\"comment\">//接口Writer</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"57any类型空接口\">5.7Any类型[空接口]</span></h3>\n<p>每种类型都能匹配到空接口：interface{}。空接口类型对方法没有任何约束（因为没有方法），它能包含任意类型，也可以实现到其他接口类型的转换。如果传递给该接口的类型变量实现了转换后的接口则可以正常运行，否则出现运行时错误。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//interface&#123;&#125;即为可以指向任何对象的Any类型，类似Java中的Object类</span></div><div class=\"line\"><span class=\"keyword\">var</span> v1 <span class=\"keyword\">interface</span>&#123;&#125;=<span class=\"keyword\">struct</span>&#123;X <span class=\"keyword\">int</span>&#125;&#123;<span class=\"number\">1</span>&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> v2 <span class=\"keyword\">interface</span>&#123;&#125;=<span class=\"string\">\"abc\"</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">DoSomething</span><span class=\"params\">(v <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;   <span class=\"comment\">//该函数可以接收任何类型的参数，因为任何类型都实现了空接口</span></div><div class=\"line\">   <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"58接口的代码示例\">5.8接口的代码示例</span></h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//接口animal</span></div><div class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">interface</span> &#123;</div><div class=\"line\">    Speak() <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Dog类实现animal接口</span></div><div class=\"line\"><span class=\"keyword\">type</span> Dog <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(d Dog)</span> <span class=\"title\">Speak</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Woof!\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Cat类实现animal接口</span></div><div class=\"line\"><span class=\"keyword\">type</span> Cat <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c Cat)</span> <span class=\"title\">Speak</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Meow!\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Llama实现animal接口</span></div><div class=\"line\"><span class=\"keyword\">type</span> Llama <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l Llama)</span> <span class=\"title\">Speak</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"?????\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//JavaProgrammer实现animal接口</span></div><div class=\"line\"><span class=\"keyword\">type</span> JavaProgrammer <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(j JavaProgrammer)</span> <span class=\"title\">Speak</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Design patterns!\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//主函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    animals := []Animal&#123;Dog&#123;&#125;, Cat&#123;&#125;, Llama&#123;&#125;, JavaProgrammer&#123;&#125;&#125;  <span class=\"comment\">//利用接口实现多态</span></div><div class=\"line\">    <span class=\"keyword\">for</span> _, animal := <span class=\"keyword\">range</span> animals &#123;</div><div class=\"line\">        fmt.Println(animal.Speak())  <span class=\"comment\">//打印不同实现该接口的类的方法返回值</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><strong>面向对象编程</strong></li>\n</ul>\n<p>​       把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）[方法的重写，子类不同于父类的特性]／泛化（generalization）[共性，子类都拥有父类的特性]，通过多态（polymorphism）实现基于对象类型的动态分派（dynamic dispatch）。</p>\n<ul>\n<li><strong>面对对象思想</strong></li>\n</ul>\n<p>​       面向对象思想是对现实世界事物的抽象，系统中一切事物皆为对象；对象是属性及其操作的封装体；对象可按其性质划分为类，对象成为类的实例；实例关系和继承关系是对象之间的静态关系；消息传递是对象之间动态联系的唯一形式，也是计算的唯一形式；方法是消息的序列。</p>\n<h2>（一）类型系统[类的声明]</h2>\n<p>类型系统：</p>\n<ul>\n<li>一组基本类型构成的“基本类型集合”；</li>\n<li>“基本类型集合”上定义的一系列组合、运算、转换方法。</li>\n</ul>\n<p>类型系统包括基础类型（byte、int、bool、float等）；复合类型（数组、结构体、指针等）；可以指向任何对象的类型（Any类型，类似Java的Object类型）；值语义和引用语义；面向对象类型；接口。Go大多数类型为值语义，可以给任何类型添加方法（包括内置类型，不包括指针类型）。Any类型是空接口即interface{}。</p>\n<h3>1.方法</h3>\n<p>1、为类型添加方法[类方法声明]，方法即为有接收者的函数<br>\nfunc (对象名 对象类型) 函数名(参数列表) (返回值列表)<br>\n可随时为某个对象添加方法即为某个方法添加归属对象（receiver），以方法为中心<br>\n在Go语言中没有隐藏的this指针，即显示传递，形参即为this，例如以下的形参为a。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Integer <span class=\"keyword\">int</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a Integer)</span> <span class=\"title\">Less</span><span class=\"params\">(b Integer)</span> <span class=\"title\">bool</span></span>&#123;  <span class=\"comment\">//表示a这个对象定义了Less这个方法，a可以为任意类型</span></div><div class=\"line\">  <span class=\"keyword\">return</span> a&lt;b                           </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//类型基于值传递，如果要修改值需要传递指针</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *Integer)</span> <span class=\"title\">Add</span><span class=\"params\">(b Integer)</span></span>&#123;</div><div class=\"line\">  *a+=b    <span class=\"comment\">//通过指针传递来改变值</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>2.值语义和引用语义</h3>\n<p>值类型：b的修改并不会影响a的值</p>\n<p>引用类型：b的修改会影响a的值</p>\n<p>Go大多类型为值语义，包括基本类型：byte，int，string等；复合类型：数组，结构体(struct)，指针等</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//2、值语义和引用语义</span></div><div class=\"line\">b=a</div><div class=\"line\">b.Modify()</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">//值类型</span></div><div class=\"line\"><span class=\"keyword\">var</span> a=[<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</div><div class=\"line\">b:=a</div><div class=\"line\">b[<span class=\"number\">1</span>]++</div><div class=\"line\">fmt.Println(a,b)   <span class=\"comment\">//a=[1,2,3]  b=[1,3,3]</span></div><div class=\"line\"><span class=\"comment\">//引用类型</span></div><div class=\"line\">a:=[<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</div><div class=\"line\">b:=&amp;a              <span class=\"comment\">//b指向a,即为a的地址，对b指向的值改变实际上就是对a的改变（数组本身就是一种地址指向）</span></div><div class=\"line\">b[<span class=\"number\">1</span>]++</div><div class=\"line\">fmt.Println(a,*b)  <span class=\"comment\">//a=[1,3,3]  b=[1,3,3]   //*b,取地址指向的值</span></div></pre></td></tr></table></figure>\n<h3>3.结构体</h3>\n<p>3、结构体[类属性的声明]<br>\nstruct的功能类似Java的class，可实现嵌套组合(类似继承的功能)<br>\nstruct实际上就是一种复合类型，只是对类中的属性进行定义赋值，并没有对方法进行定义，方法可以随时定义绑定到该类的对象上，更具灵活性。可利用嵌套组合来实现类似继承的功能避免代码重复。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Rect <span class=\"keyword\">struct</span>&#123;   <span class=\"comment\">//定义矩形类</span></div><div class=\"line\">  x,y <span class=\"keyword\">float64</span>       <span class=\"comment\">//类型只包含属性，并没有方法</span></div><div class=\"line\">  width,height <span class=\"keyword\">float64</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *Rect)</span> <span class=\"title\">Area</span><span class=\"params\">()</span> <span class=\"title\">float64</span></span>&#123;    <span class=\"comment\">//为Rect类型绑定Area的方法，*Rect为指针引用可以修改传入参数的值</span></div><div class=\"line\">  <span class=\"keyword\">return</span> r.width*r.height         <span class=\"comment\">//方法归属于类型，不归属于具体的对象，声明该类型的对象即可调用该类型的方法</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2>（二）初始化[实例化对象]</h2>\n<p>数据初始化的内建函数new()与make()，二者都是用来分配空间。区别如下:</p>\n<ul>\n<li><strong>new()</strong></li>\n</ul>\n<ol>\n<li>func new(Type) *Type</li>\n<li>内置函数 <code>new</code> 分配空间。传递给<code>new</code> 函数的是一个<strong>类型</strong>，不是一个值。返回值是指向这个新分配的零值的<strong>指针</strong></li>\n</ol>\n<ul>\n<li><strong>make()</strong></li>\n</ul>\n<ol>\n<li>func make(Type, size IntegerType) Type</li>\n<li>内建函数 <code>make</code> 分配并且初始化 一个 slice, 或者 map 或者 chan 对象。 并且只能是这三种对象。 和 <code>new</code> 一样，第一个参数是 类型，不是一个值。 但是<code>make</code> 的返回值就是这个类型（即使一个引用类型），而不是指针。 具体的返回值，依赖具体传入的类型。</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建实例</span></div><div class=\"line\">rect1:=<span class=\"built_in\">new</span>(Rect)   <span class=\"comment\">//new一个对象</span></div><div class=\"line\">rect2:=&amp;Rect&#123;&#125;     <span class=\"comment\">//为赋值默认值，bool默认值为false，int默认为零值0，string默认为空字符串</span></div><div class=\"line\">rect3:=&amp;Rect&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">100</span>,<span class=\"number\">200</span>&#125;     <span class=\"comment\">//取地址并赋值,按声明的变量顺序依次赋值</span></div><div class=\"line\">rect4:=&amp;Rect&#123;width:<span class=\"number\">100</span>,height:<span class=\"number\">200</span>&#125;    <span class=\"comment\">//按变量名赋值不按顺序赋值</span></div><div class=\"line\"><span class=\"comment\">//构造函数：没有构造参数的概念，通常由全局的创建函数NewXXX来实现构造函数的功能</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewRect</span><span class=\"params\">(x,y,width,height <span class=\"keyword\">float64</span>)</span> *<span class=\"title\">Rect</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &amp;Rect&#123;x,y,width,height&#125;     <span class=\"comment\">//利用指针来改变传入参数的值达到类似构造参数的效果</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//方法的重载,Go不支持方法的重载（函数同名，参数不同）</span></div><div class=\"line\"><span class=\"comment\">//v …interface&#123;&#125;表示参数不定的意思，其中v是slice类型，及声明不定参数，可以传入任意参数，实现类似方法的重载</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(poem *Poem)</span> <span class=\"title\">recite</span><span class=\"params\">(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</div><div class=\"line\">    fmt.Println(v)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2>（三）匿名组合[继承]</h2>\n<p>​       组合，即方法代理，例如A包含B，即A通过消息传递的形式代理了B的方法，而不需要重复写B的方法。</p>\n<p>​       继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。继承主要为了代码复用，继承也可以扩展已存在的代码模块（类）。</p>\n<p>​       严格来讲，继承是“a kind of ”，即子类是父类的一种，例如student是person的一种；组合是“a part of”，即父类是子类中的一部分，例如眼睛是头部的一部分。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、匿名组合的方式实现了类似Java继承的功能，可以实现多继承</span></div><div class=\"line\"><span class=\"keyword\">type</span> Base <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">  Name <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(base *Base)</span> <span class=\"title\">Foo</span><span class=\"params\">()</span></span>&#123;...&#125;    <span class=\"comment\">//Base的Foo()方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(base *Base)</span> <span class=\"title\">Bar</span><span class=\"params\">()</span></span>&#123;...&#125;    <span class=\"comment\">//Base的Bar()方法</span></div><div class=\"line\"><span class=\"keyword\">type</span> Foo <span class=\"keyword\">struct</span>&#123;  </div><div class=\"line\">  Base                         <span class=\"comment\">//通过组合的方式声明了基类，即继承了基类</span></div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(foo *Foo)</span> <span class=\"title\">Bar</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">  foo.Base.Bar()               <span class=\"comment\">//并改写了基类的方法，该方法实现时先调用基类的Bar()方法</span></div><div class=\"line\">  ...                          <span class=\"comment\">//如果没有改写即为继承，调用foo.Foo()和调用foo.Base.Foo()的作用的一样的</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//修改内存布局</span></div><div class=\"line\"><span class=\"keyword\">type</span> Foo <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">  ...   <span class=\"comment\">//其他成员信息</span></div><div class=\"line\">  Base</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//以指针方式组合</span></div><div class=\"line\"><span class=\"keyword\">type</span> Foo <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">  *Base   <span class=\"comment\">//以指针方式派生，创建Foo实例时，需要外部提供一个Base类实例的指针</span></div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//名字冲突问题,组合内外如果出现名字重复问题，只会访问到最外层，内层会被隐藏，不会报错，即类似java中方法覆盖/重写。</span></div><div class=\"line\"><span class=\"keyword\">type</span> X <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">  Name <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">type</span> Y <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">  X             <span class=\"comment\">//Y.X.Name会被隐藏，内层会被隐藏</span></div><div class=\"line\">  Name <span class=\"keyword\">string</span>   <span class=\"comment\">//只会访问到Y.Name，只会调用外层属性</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2>（四）可见性[封装]</h2>\n<p>​       封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p>\n<p>​       <strong>封装的本质或目的其实程序对信息(数据)的控制力。封装分为两部分：该隐藏的隐藏，该暴露的暴露。封装可以隐藏实现细节，使得代码模块化。</strong></p>\n<p>​       Go中用大写字母开头来表示public，可以包外访问；小写字母开头来表示private，只能包内访问；访问性是包级别非类型级别<br>\n​       如果可访问性是类型一致的，可以加friend关键字表示朋友关系可互相访问彼此的私有成员(属性和方法)</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Rect <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">  X,Y <span class=\"keyword\">float64</span></div><div class=\"line\">  Width,Height <span class=\"keyword\">float64</span>           <span class=\"comment\">//字母大写开头表示该属性可以由包外访问到</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *Rect)</span> <span class=\"title\">area</span><span class=\"params\">()</span> <span class=\"title\">float64</span></span>&#123;   <span class=\"comment\">//字母小写开头表示该方法只能包内调用</span></div><div class=\"line\">  <span class=\"keyword\">return</span> r.Width*r.Height</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2>（五）接口[多态]</h2>\n<p>​       多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。</p>\n<p>​       简而言之，就是允许将子类类型的指针赋值给父类类型的指针。</p>\n<p>​       即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态分为编译时多态（静态多态）和运行时多态（动态多态），编译时多态一般通过方法重载实现，运行时多态一般通过方法重写实现。</p>\n<h3>5.1接口概念</h3>\n<p>​      接口即一组方法的集合，定义了对象的一组行为，方法包含实际的代码。换句话说，一个接口就是定义（规范或约束），而方法就是实现，接口的作用应该是将定义与实现分离，降低耦合度。习惯用“er”结尾来命名，例如“Reader”。接口与对象的关系是多对多，即一个对象可以实现多个接口，一个接口也可以被多个对象实现。</p>\n<p>​      接口是Go语言整个类型系统的基石，其他语言的接口是不同组件之间的契约的存在，对契约的实现是强制性的，必须显式声明实现了该接口，这类接口称之为“侵入式接口”。而Go语言的接口是隐式存在，只要实现了该接口的所有函数则代表已经实现了该接口，并不需要显式的接口声明。</p>\n<ul>\n<li><strong>接口的比喻</strong></li>\n</ul>\n<p>​     你的电脑上只有一个USB接口。这个USB接口可以接MP3，数码相机，摄像头，鼠标，键盘等。。。所有的上述硬件都可以公用这个接口，有很好的扩展性，该USB接口定义了一种规范，只要实现了该规范，就可以将不同的设备接入电脑，而设备的改变并不会对电脑本身有什么影响（低耦合）。</p>\n<ul>\n<li><strong>面向接口编程</strong></li>\n</ul>\n<p>​      接口表示调用者和设计者的一种约定，在多人合作开发同一个项目时，事先定义好相互调用的接口可以大大提高开发的效率。接口是用类来实现的，实现接口的类必须严格按照接口的声明来实现接口提供的所有功能。有了接口，就可以在不影响现有接口声明的情况下，修改接口的内部实现，从而使兼容性问题最小化。<br>\n​      当其他设计者调用了接口后，就不能再随意更改接口的定义，否则项目开发者事先的约定就失去了意义。但是可以在类中修改相应的代码，完成需要改动的内容。</p>\n<h3>5.2非侵入式接口</h3>\n<p>非侵入式接口：一个类只需要实现了接口要求的所有函数就表示实现了该接口，并不需要显式声明</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> File <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//类的属性</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//File类的方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Read</span><span class=\"params\">(buf []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,err error)</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Write</span><span class=\"params\">(buf []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,err error)</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Seek</span><span class=\"params\">(off <span class=\"keyword\">int64</span>,whence <span class=\"keyword\">int</span>)</span> <span class=\"params\">(pos <span class=\"keyword\">int64</span>,err error)</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Close</span><span class=\"params\">()</span> <span class=\"title\">error</span></span></div><div class=\"line\"><span class=\"function\">//接口1：<span class=\"title\">IFile</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">type</span> <span class=\"title\">IFile</span> <span class=\"title\">interface</span></span>&#123;</div><div class=\"line\">  Read(buf []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>,err error)</div><div class=\"line\">  Write(buf []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>,err error)</div><div class=\"line\">  Seek(off <span class=\"keyword\">int64</span>,whence <span class=\"keyword\">int</span>) (pos <span class=\"keyword\">int64</span>,err error)</div><div class=\"line\">  Close() error</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//接口2：IReader</span></div><div class=\"line\"><span class=\"keyword\">type</span> IReader <span class=\"keyword\">interface</span>&#123;</div><div class=\"line\">  Read(buf []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>,err error)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//接口赋值,File类实现了IFile和IReader接口，即接口所包含的所有方法</span></div><div class=\"line\"><span class=\"keyword\">var</span> file1 IFile = <span class=\"built_in\">new</span>(File)</div><div class=\"line\"><span class=\"keyword\">var</span> file2 IReader = <span class=\"built_in\">new</span>(File)</div></pre></td></tr></table></figure>\n<h3>5.3接口赋值</h3>\n<p>只要类实现了该接口的所有方法，即可将该类赋值给这个接口，接口主要用于多态化方法。即对接口定义的方法，不同的实现方式。</p>\n<p>接口赋值：<br>\n<strong>1）将对象实例赋值给接口</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> IUSB <span class=\"keyword\">interface</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//定义IUSB的接口方法</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//方法定义在类外，绑定该类，以下为方便，备注写在类中</span></div><div class=\"line\"><span class=\"keyword\">type</span> MP3 <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//实现IUSB的接口，具体实现方式是MP3的方法</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">type</span> Mouse <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//实现IUSB的接口，具体实现方式是Mouse的方法</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//接口赋值给具体的对象实例MP3</span></div><div class=\"line\"><span class=\"keyword\">var</span> usb IUSB =<span class=\"built_in\">new</span>(MP3)</div><div class=\"line\">usb.Connect()</div><div class=\"line\">usb.Close()</div><div class=\"line\"><span class=\"comment\">//接口赋值给具体的对象实例Mouse</span></div><div class=\"line\"><span class=\"keyword\">var</span> usb IUSB =<span class=\"built_in\">new</span>(Mouse)</div><div class=\"line\">usb.Connect()</div><div class=\"line\">usb.Close()</div></pre></td></tr></table></figure>\n<p><strong>2）将接口赋值给另一个接口</strong></p>\n<ol>\n<li>只要两个接口拥有相同的方法列表（与次序无关），即是两个相同的接口，可以相互赋值</li>\n<li>接口赋值只需要接口A的方法列表是接口B的子集（即假设接口A中定义的所有方法，都在接口B中有定义），那么B接口的实例可以赋值给A的对象。反之不成立，即子接口B包含了父接口A，因此可以将子接口的实例赋值给父接口。</li>\n<li>即子接口实例实现了子接口的所有方法，而父接口的方法列表是子接口的子集，则子接口实例自然实现了父接口的所有方法，因此可以将子接口实例赋值给父接口。</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Writer <span class=\"keyword\">interface</span>&#123;    <span class=\"comment\">//父接口</span></div><div class=\"line\">    Write(buf []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>,err error)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">type</span> ReadWriter <span class=\"keyword\">interface</span>&#123;    <span class=\"comment\">//子接口</span></div><div class=\"line\">    Read(buf []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>,err error)</div><div class=\"line\">    Write(buf []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>,err error)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> file1 ReadWriter=<span class=\"built_in\">new</span>(File)   <span class=\"comment\">//子接口实例</span></div><div class=\"line\"><span class=\"keyword\">var</span> file2 Writer=file1           <span class=\"comment\">//子接口实例赋值给父接口</span></div></pre></td></tr></table></figure>\n<h3>5.4接口查询</h3>\n<p>若要在 switch 外判断一个接口类型是否实现了某个接口，可以使用“逗号 ok ”。</p>\n<p>value, ok := Interfacevariable.(implementType)</p>\n<p>其中 Interfacevariable 是接口变量（接口值），implementType 为实现此接口的类型，value 返回接口变量实际类型变量的值，如果该类型实现了此接口返回 true。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//判断file1接口指向的对象实例是否是File类型</span></div><div class=\"line\"><span class=\"keyword\">var</span> file1 Writer=...</div><div class=\"line\"><span class=\"keyword\">if</span> file5,ok:=file1.(File);ok&#123;  </div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>5.5接口类型查询</h3>\n<p>在 Go 中，要判断传递给接口值的变量类型，可以在使用 type switch 得到。(type)只能在 switch 中使用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 另一个实现了 I 接口的 R 类型</span></div><div class=\"line\"><span class=\"keyword\">type</span> R <span class=\"keyword\">struct</span> &#123; i <span class=\"keyword\">int</span> &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *R)</span> <span class=\"title\">Get</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> p.i &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *R)</span> <span class=\"title\">Put</span><span class=\"params\">(v <span class=\"keyword\">int</span>)</span></span> &#123; p.i = v &#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">(p I)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span> t := p.(<span class=\"keyword\">type</span>) &#123; <span class=\"comment\">// 判断传递给 p 的实际类型</span></div><div class=\"line\">        <span class=\"keyword\">case</span> *S: <span class=\"comment\">// 指向 S 的指针类型</span></div><div class=\"line\">        <span class=\"keyword\">case</span> *R: <span class=\"comment\">// 指向 R 的指针类型</span></div><div class=\"line\">        <span class=\"keyword\">case</span> S:  <span class=\"comment\">// S 类型</span></div><div class=\"line\">        <span class=\"keyword\">case</span> R:  <span class=\"comment\">// R 类型</span></div><div class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"comment\">//实现了 I 接口的其他类型</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>5.6接口组合</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//接口组合类似类型组合，只不过只包含方法，不包含成员变量</span></div><div class=\"line\"><span class=\"keyword\">type</span> ReadWriter <span class=\"keyword\">interface</span>&#123;  <span class=\"comment\">//接口组合，避免代码重复</span></div><div class=\"line\">  Reader      <span class=\"comment\">//接口Reader</span></div><div class=\"line\">  Writer      <span class=\"comment\">//接口Writer</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>5.7Any类型[空接口]</h3>\n<p>每种类型都能匹配到空接口：interface{}。空接口类型对方法没有任何约束（因为没有方法），它能包含任意类型，也可以实现到其他接口类型的转换。如果传递给该接口的类型变量实现了转换后的接口则可以正常运行，否则出现运行时错误。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//interface&#123;&#125;即为可以指向任何对象的Any类型，类似Java中的Object类</span></div><div class=\"line\"><span class=\"keyword\">var</span> v1 <span class=\"keyword\">interface</span>&#123;&#125;=<span class=\"keyword\">struct</span>&#123;X <span class=\"keyword\">int</span>&#125;&#123;<span class=\"number\">1</span>&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> v2 <span class=\"keyword\">interface</span>&#123;&#125;=<span class=\"string\">\"abc\"</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">DoSomething</span><span class=\"params\">(v <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;   <span class=\"comment\">//该函数可以接收任何类型的参数，因为任何类型都实现了空接口</span></div><div class=\"line\">   <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>5.8接口的代码示例</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//接口animal</span></div><div class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">interface</span> &#123;</div><div class=\"line\">    Speak() <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Dog类实现animal接口</span></div><div class=\"line\"><span class=\"keyword\">type</span> Dog <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(d Dog)</span> <span class=\"title\">Speak</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Woof!\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Cat类实现animal接口</span></div><div class=\"line\"><span class=\"keyword\">type</span> Cat <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c Cat)</span> <span class=\"title\">Speak</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Meow!\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Llama实现animal接口</span></div><div class=\"line\"><span class=\"keyword\">type</span> Llama <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l Llama)</span> <span class=\"title\">Speak</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"?????\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//JavaProgrammer实现animal接口</span></div><div class=\"line\"><span class=\"keyword\">type</span> JavaProgrammer <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(j JavaProgrammer)</span> <span class=\"title\">Speak</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Design patterns!\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//主函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    animals := []Animal&#123;Dog&#123;&#125;, Cat&#123;&#125;, Llama&#123;&#125;, JavaProgrammer&#123;&#125;&#125;  <span class=\"comment\">//利用接口实现多态</span></div><div class=\"line\">    <span class=\"keyword\">for</span> _, animal := <span class=\"keyword\">range</span> animals &#123;</div><div class=\"line\">        fmt.Println(animal.Speak())  <span class=\"comment\">//打印不同实现该接口的类的方法返回值</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"[Golang] Golang系列（三）之并发编程","catalog":true,"date":"2017-09-17T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Golang"],"_content":"\n## （一）并发基础\n\n### 1.概念\n\n并发意味着程序在运行时有多个执行上下文，对应多个调用栈。\n\n并发与并行的区别：\n\n并发的主流实现模型：\n\n| 实现模型          | 说明                       | 特点                      |\n| ------------- | ------------------------ | ----------------------- |\n| 多进程           | 操作系统层面的并发模式              | 处理简单，互不影响，但开销大          |\n| 多线程           | 系统层面的并发模式                | 有效，开销较大，高并发时影响效率        |\n| 基于回调的非阻塞/异步IO | 多用于高并发服务器开发中             | 编程复杂，开销小                |\n| 协程            | 用户态线程，不需要操作系统抢占调度，寄存于线程中 | 编程简单，结构简单，开销极小，但需要语言的支持 |\n\n共享内存系统：线程之间采用共享内存的方式通信，通过加锁来避免死锁或资源竞争。\n\n消息传递系统：将线程间共享状态封装在消息中，通过发送消息来共享内存，而非通过共享内存来通信。\n\n### 2.协程\n\n执行体是个抽象的概念，在操作系统中分为三个级别：进程（process），进程内的线程（thread），进程内的协程（coroutine，轻量级线程）。协程的数量级可达到上百万个，进程和线程的数量级最多不超过一万个。Go语言中的协程叫goroutine，Go标准库提供的调用操作，IO操作都会出让CPU给其他goroutine，让协程间的切换管理不依赖系统的线程和进程，不依赖CPU的核心数量。\n\n### 3.并发通信\n\n并发编程的难度在于协调，协调需要通过通信，并发通信模型分为共享数据和消息。共享数据即多个并发单元保持对同一个数据的引用，数据可以是内存数据块，磁盘文件，网络数据等。数据共享通过加锁的方式来避免死锁和资源竞争。Go语言则采取消息机制来通信，每个并发单元是独立的个体，有独立的变量，不同并发单元间这些变量不共享，每个并发单元的输入输出只通过消息的方式。\n\n## （二）goroutine\n\n```go\n//定义调用体\nfunc Add(x,y int){\n  z:=x+y\n  fmt.Println(z)\n}\n//go关键字执行调用，即会产生一个goroutine并发执行\n//当函数返回时，goroutine自动结束，如果有返回值,返回值会自动被丢弃\ngo Add(1,1)\n//并发执行\nfunc main(){\n  for i:=0;i<10;i++{//主函数启动了10个goroutine，然后返回，程序退出，并不会等待其他goroutine结束\n    go Add(i,i)     //所以需要通过channel通信来保证其他goroutine可以顺利执行\n  }\n}\n```\n\n## （三）channel\n\n​       channel就像管道的形式，是goroutine之间的通信方式，是进程内的通信方式，跨进程通信建议用分布式系统的方法来解决，例如Socket或http等通信协议。channel是类型相关，即一个channel只能传递一种类型的值，在声明时指定。\n\n### 1、基本语法\n\n#### 1）channel的声明\n\n```go\n//1、channel声明，声明一个管道chanName，该管道可以传递的类型是ElementType\n//管道是一种复合类型，[chan ElementType],表示可以传递ElementType类型的管道[类似定语从句的修饰方法]\nvar chanName chan ElementType\nvar ch chan int                  //声明一个可以传递int类型的管道\nvar m map[string] chan bool      //声明一个map，值的类型为可以传递bool类型的管道\n```\n\n#### 2）初始化\n\n```go\n//2、初始化ch:=make(chan int)   //make一般用来声明一个复合类型，参数为复合类型的属性\n```\n\n#### 3）管道读写\n\n```go\n//3、管道写入,把值想象成一个球，\"<-\"的方向，表示球的流向，ch即为管道\n//写入时，当管道已满（管道有缓冲长度）则会导致程序堵塞，直到有goroutine从中读取出值\nch <- value\n//管道读取，\"<-\"表示从管道把球倒出来赋值给一个变量\n//当管道为空，读取数据会导致程序阻塞，直到有goroutine写入值\nvalue:= <-ch \n```\n\n#### 4）select\n\n```go\n//4、每个case必须是一个IO操作，面向channel的操作，只执行其中的一个case操作，一旦满足则结束select过程\n//面向channel的操作无非三种情况：成功读出；成功写入；即没有读出也没有写入\nselect{\n  case <-chan1:\n  //如果chan1读到数据，则进行该case处理语句\n  case chan2<-1:\n  //如果成功向chan2写入数据，则进入该case处理语句\n  default:\n  //如果上面都没有成功，则进入default处理流程\n}\n```\n\n### 2、缓冲和超时机制\n\n#### 1）缓冲机制\n\n```go\n//1、缓冲机制：为管道指定空间长度，达到类似消息队列的效果\nc:=make(chan int,1024)  //第二个参数为缓冲区大小，与切片的空间大小类似\n//通过range关键字来实现依次读取管道的数据，与数组或切片的range使用方法类似\nfor i :=range c{\n  fmt.Println(\"Received:\",i)\n}\n```\n\n#### 2）超时机制\n\n```go\n//2、超时机制：利用select只要一个case满足，程序就继续执行而不考虑其他case的情况的特性实现超时机制\ntimeout:=make(chan bool,1)    //设置一个超时管道\ngo func(){\n  time.Sleep(1e9)      //设置超时时间，等待一分钟\n  timeout<-true        //一分钟后往管道放一个true的值\n}()\n//\nselect {\n  case <-ch:           //如果读到数据，则会结束select过程\n  //从ch中读取数据\n  case <-timeout:      //如果前面的case没有调用到，必定会读到true值，结束select，避免永久等待\n  //一直没有从ch中读取到数据，但从timeout中读取到了数据\n}\n```\n\n### 3、channel的传递\n\n```go\n//1、channel的传递，来实现Linux系统中管道的功能，以插件的方式增加数据处理的流程\ntype PipeData struct{\n  value int\n  handler func(int) int   //handler是属性？\n  next chan int   //可以把[chan int]看成一个整体，表示放int类型的管道\n}\nfunc handler(queue chan *PipeData){ //queue是一个存放*PipeDate类型的管道，可改变管道里的数据块内容\n  for data:=range queue{     //data的类型就是管道存放定义的类型，即PipeData\n    data.next <- data.handler(data.value)    //该方法实现将PipeData的value值存放到next的管道中\n  }\n}\n```\n\n### 4、单向channel\n\n```go\n//2、单向channel：只能用于接收或发送数据，是对channel的一种使用限制\n//单向channel的声明\nvar ch1 chan int    //正常channel，可读写\nvar ch2 chan<- int  //单向只写channel  [chan<- int]看成一个整体，表示流入管道\nvar ch3 <-chan int  //单向只读channel  [<-chan int]看成一个整体，表示流出管道\n//管道类型强制转换\nch4:=make(chan int)     //ch4为双向管道\nch5:=<-chan int(ch4)    //把[<-chan int]看成单向只读管道类型，对ch4进行强制类型转换\nch6:=chan<- int(ch4)    //把[chan<- int]看成单向只写管道类型，对ch4进行强制类型转换\nfunc Parse(ch <-chan int){    //最小权限原则\n  for value:=range ch{\n    fmt.Println(\"Parsing value\",value)\n  }\n}\n```\n\n### 5、关闭channel\n\n```go\n//3、关闭channel，使用内置函数close()函数即可\nclose(ch)\n//判断channel是否关闭\nx,ok:=<-ch //ok==false表示channel已经关闭\nif !ok {   //如果channel关闭，ok==false，!ok==true\n  //执行体\n}\n```\n\n## （四）多核并行化与同步锁\n\n### 1、多核并行化\n\n```go\n//多核并行化\nruntime.GOMAXPROCS(16) //设置环境变量GOMAXPROCS的值来控制使用多少个CPU核心\nruntime.NumCPU() //来获取核心数\n//出让时间片\nruntime.Gosched() //在每个goroutine中控制何时出让时间片给其他goroutine\n```\n\n### 2、同步锁\n\n```go\n//同步锁\nsync.Mutex //单读单写：占用Mutex后，其他goroutine只能等到其释放该Mutex\nsync.RWMutex //单写多读：会阻止写，不会阻止读\nRLock() //读锁\nLock() //写锁\nRUnlock() //解锁（读锁）\nUnlock() //解锁（写锁）\n//全局唯一性操作\n//once的Do方法保证全局只调用指定函数(setup)一次，其他goroutine在调用到此函数是会阻塞，直到once调用结束才继续\nonce.Do(setup)\n```","source":"_posts/Golang/Golang系列（三）之并发编程.md","raw":"---\ntitle: \"[Golang] Golang系列（三）之并发编程\"\ncatalog: true\ndate: 2017-09-17 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Golang\ncatagories:\n- Golang\n---\n\n## （一）并发基础\n\n### 1.概念\n\n并发意味着程序在运行时有多个执行上下文，对应多个调用栈。\n\n并发与并行的区别：\n\n并发的主流实现模型：\n\n| 实现模型          | 说明                       | 特点                      |\n| ------------- | ------------------------ | ----------------------- |\n| 多进程           | 操作系统层面的并发模式              | 处理简单，互不影响，但开销大          |\n| 多线程           | 系统层面的并发模式                | 有效，开销较大，高并发时影响效率        |\n| 基于回调的非阻塞/异步IO | 多用于高并发服务器开发中             | 编程复杂，开销小                |\n| 协程            | 用户态线程，不需要操作系统抢占调度，寄存于线程中 | 编程简单，结构简单，开销极小，但需要语言的支持 |\n\n共享内存系统：线程之间采用共享内存的方式通信，通过加锁来避免死锁或资源竞争。\n\n消息传递系统：将线程间共享状态封装在消息中，通过发送消息来共享内存，而非通过共享内存来通信。\n\n### 2.协程\n\n执行体是个抽象的概念，在操作系统中分为三个级别：进程（process），进程内的线程（thread），进程内的协程（coroutine，轻量级线程）。协程的数量级可达到上百万个，进程和线程的数量级最多不超过一万个。Go语言中的协程叫goroutine，Go标准库提供的调用操作，IO操作都会出让CPU给其他goroutine，让协程间的切换管理不依赖系统的线程和进程，不依赖CPU的核心数量。\n\n### 3.并发通信\n\n并发编程的难度在于协调，协调需要通过通信，并发通信模型分为共享数据和消息。共享数据即多个并发单元保持对同一个数据的引用，数据可以是内存数据块，磁盘文件，网络数据等。数据共享通过加锁的方式来避免死锁和资源竞争。Go语言则采取消息机制来通信，每个并发单元是独立的个体，有独立的变量，不同并发单元间这些变量不共享，每个并发单元的输入输出只通过消息的方式。\n\n## （二）goroutine\n\n```go\n//定义调用体\nfunc Add(x,y int){\n  z:=x+y\n  fmt.Println(z)\n}\n//go关键字执行调用，即会产生一个goroutine并发执行\n//当函数返回时，goroutine自动结束，如果有返回值,返回值会自动被丢弃\ngo Add(1,1)\n//并发执行\nfunc main(){\n  for i:=0;i<10;i++{//主函数启动了10个goroutine，然后返回，程序退出，并不会等待其他goroutine结束\n    go Add(i,i)     //所以需要通过channel通信来保证其他goroutine可以顺利执行\n  }\n}\n```\n\n## （三）channel\n\n​       channel就像管道的形式，是goroutine之间的通信方式，是进程内的通信方式，跨进程通信建议用分布式系统的方法来解决，例如Socket或http等通信协议。channel是类型相关，即一个channel只能传递一种类型的值，在声明时指定。\n\n### 1、基本语法\n\n#### 1）channel的声明\n\n```go\n//1、channel声明，声明一个管道chanName，该管道可以传递的类型是ElementType\n//管道是一种复合类型，[chan ElementType],表示可以传递ElementType类型的管道[类似定语从句的修饰方法]\nvar chanName chan ElementType\nvar ch chan int                  //声明一个可以传递int类型的管道\nvar m map[string] chan bool      //声明一个map，值的类型为可以传递bool类型的管道\n```\n\n#### 2）初始化\n\n```go\n//2、初始化ch:=make(chan int)   //make一般用来声明一个复合类型，参数为复合类型的属性\n```\n\n#### 3）管道读写\n\n```go\n//3、管道写入,把值想象成一个球，\"<-\"的方向，表示球的流向，ch即为管道\n//写入时，当管道已满（管道有缓冲长度）则会导致程序堵塞，直到有goroutine从中读取出值\nch <- value\n//管道读取，\"<-\"表示从管道把球倒出来赋值给一个变量\n//当管道为空，读取数据会导致程序阻塞，直到有goroutine写入值\nvalue:= <-ch \n```\n\n#### 4）select\n\n```go\n//4、每个case必须是一个IO操作，面向channel的操作，只执行其中的一个case操作，一旦满足则结束select过程\n//面向channel的操作无非三种情况：成功读出；成功写入；即没有读出也没有写入\nselect{\n  case <-chan1:\n  //如果chan1读到数据，则进行该case处理语句\n  case chan2<-1:\n  //如果成功向chan2写入数据，则进入该case处理语句\n  default:\n  //如果上面都没有成功，则进入default处理流程\n}\n```\n\n### 2、缓冲和超时机制\n\n#### 1）缓冲机制\n\n```go\n//1、缓冲机制：为管道指定空间长度，达到类似消息队列的效果\nc:=make(chan int,1024)  //第二个参数为缓冲区大小，与切片的空间大小类似\n//通过range关键字来实现依次读取管道的数据，与数组或切片的range使用方法类似\nfor i :=range c{\n  fmt.Println(\"Received:\",i)\n}\n```\n\n#### 2）超时机制\n\n```go\n//2、超时机制：利用select只要一个case满足，程序就继续执行而不考虑其他case的情况的特性实现超时机制\ntimeout:=make(chan bool,1)    //设置一个超时管道\ngo func(){\n  time.Sleep(1e9)      //设置超时时间，等待一分钟\n  timeout<-true        //一分钟后往管道放一个true的值\n}()\n//\nselect {\n  case <-ch:           //如果读到数据，则会结束select过程\n  //从ch中读取数据\n  case <-timeout:      //如果前面的case没有调用到，必定会读到true值，结束select，避免永久等待\n  //一直没有从ch中读取到数据，但从timeout中读取到了数据\n}\n```\n\n### 3、channel的传递\n\n```go\n//1、channel的传递，来实现Linux系统中管道的功能，以插件的方式增加数据处理的流程\ntype PipeData struct{\n  value int\n  handler func(int) int   //handler是属性？\n  next chan int   //可以把[chan int]看成一个整体，表示放int类型的管道\n}\nfunc handler(queue chan *PipeData){ //queue是一个存放*PipeDate类型的管道，可改变管道里的数据块内容\n  for data:=range queue{     //data的类型就是管道存放定义的类型，即PipeData\n    data.next <- data.handler(data.value)    //该方法实现将PipeData的value值存放到next的管道中\n  }\n}\n```\n\n### 4、单向channel\n\n```go\n//2、单向channel：只能用于接收或发送数据，是对channel的一种使用限制\n//单向channel的声明\nvar ch1 chan int    //正常channel，可读写\nvar ch2 chan<- int  //单向只写channel  [chan<- int]看成一个整体，表示流入管道\nvar ch3 <-chan int  //单向只读channel  [<-chan int]看成一个整体，表示流出管道\n//管道类型强制转换\nch4:=make(chan int)     //ch4为双向管道\nch5:=<-chan int(ch4)    //把[<-chan int]看成单向只读管道类型，对ch4进行强制类型转换\nch6:=chan<- int(ch4)    //把[chan<- int]看成单向只写管道类型，对ch4进行强制类型转换\nfunc Parse(ch <-chan int){    //最小权限原则\n  for value:=range ch{\n    fmt.Println(\"Parsing value\",value)\n  }\n}\n```\n\n### 5、关闭channel\n\n```go\n//3、关闭channel，使用内置函数close()函数即可\nclose(ch)\n//判断channel是否关闭\nx,ok:=<-ch //ok==false表示channel已经关闭\nif !ok {   //如果channel关闭，ok==false，!ok==true\n  //执行体\n}\n```\n\n## （四）多核并行化与同步锁\n\n### 1、多核并行化\n\n```go\n//多核并行化\nruntime.GOMAXPROCS(16) //设置环境变量GOMAXPROCS的值来控制使用多少个CPU核心\nruntime.NumCPU() //来获取核心数\n//出让时间片\nruntime.Gosched() //在每个goroutine中控制何时出让时间片给其他goroutine\n```\n\n### 2、同步锁\n\n```go\n//同步锁\nsync.Mutex //单读单写：占用Mutex后，其他goroutine只能等到其释放该Mutex\nsync.RWMutex //单写多读：会阻止写，不会阻止读\nRLock() //读锁\nLock() //写锁\nRUnlock() //解锁（读锁）\nUnlock() //解锁（写锁）\n//全局唯一性操作\n//once的Do方法保证全局只调用指定函数(setup)一次，其他goroutine在调用到此函数是会阻塞，直到once调用结束才继续\nonce.Do(setup)\n```","slug":"Golang/Golang系列（三）之并发编程","published":1,"updated":"2017-10-02T13:05:04.451Z","_id":"cj8b7dfgo00082cvub0lu6984","comments":1,"layout":"post","photos":[],"link":"","content":"<h2><span id=\"一并发基础\">（一）并发基础</span></h2>\n<h3><span id=\"1概念\">1.概念</span></h3>\n<p>并发意味着程序在运行时有多个执行上下文，对应多个调用栈。</p>\n<p>并发与并行的区别：</p>\n<p>并发的主流实现模型：</p>\n<table>\n<thead>\n<tr>\n<th>实现模型</th>\n<th>说明</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>多进程</td>\n<td>操作系统层面的并发模式</td>\n<td>处理简单，互不影响，但开销大</td>\n</tr>\n<tr>\n<td>多线程</td>\n<td>系统层面的并发模式</td>\n<td>有效，开销较大，高并发时影响效率</td>\n</tr>\n<tr>\n<td>基于回调的非阻塞/异步IO</td>\n<td>多用于高并发服务器开发中</td>\n<td>编程复杂，开销小</td>\n</tr>\n<tr>\n<td>协程</td>\n<td>用户态线程，不需要操作系统抢占调度，寄存于线程中</td>\n<td>编程简单，结构简单，开销极小，但需要语言的支持</td>\n</tr>\n</tbody>\n</table>\n<p>共享内存系统：线程之间采用共享内存的方式通信，通过加锁来避免死锁或资源竞争。</p>\n<p>消息传递系统：将线程间共享状态封装在消息中，通过发送消息来共享内存，而非通过共享内存来通信。</p>\n<h3><span id=\"2协程\">2.协程</span></h3>\n<p>执行体是个抽象的概念，在操作系统中分为三个级别：进程（process），进程内的线程（thread），进程内的协程（coroutine，轻量级线程）。协程的数量级可达到上百万个，进程和线程的数量级最多不超过一万个。Go语言中的协程叫goroutine，Go标准库提供的调用操作，IO操作都会出让CPU给其他goroutine，让协程间的切换管理不依赖系统的线程和进程，不依赖CPU的核心数量。</p>\n<h3><span id=\"3并发通信\">3.并发通信</span></h3>\n<p>并发编程的难度在于协调，协调需要通过通信，并发通信模型分为共享数据和消息。共享数据即多个并发单元保持对同一个数据的引用，数据可以是内存数据块，磁盘文件，网络数据等。数据共享通过加锁的方式来避免死锁和资源竞争。Go语言则采取消息机制来通信，每个并发单元是独立的个体，有独立的变量，不同并发单元间这些变量不共享，每个并发单元的输入输出只通过消息的方式。</p>\n<h2><span id=\"二goroutine\">（二）goroutine</span></h2>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义调用体</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Add</span><span class=\"params\">(x,y <span class=\"keyword\">int</span>)</span></span>&#123;</div><div class=\"line\">  z:=x+y</div><div class=\"line\">  fmt.Println(z)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//go关键字执行调用，即会产生一个goroutine并发执行</span></div><div class=\"line\"><span class=\"comment\">//当函数返回时，goroutine自动结束，如果有返回值,返回值会自动被丢弃</span></div><div class=\"line\"><span class=\"keyword\">go</span> Add(<span class=\"number\">1</span>,<span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"comment\">//并发执行</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++&#123;<span class=\"comment\">//主函数启动了10个goroutine，然后返回，程序退出，并不会等待其他goroutine结束</span></div><div class=\"line\">    <span class=\"keyword\">go</span> Add(i,i)     <span class=\"comment\">//所以需要通过channel通信来保证其他goroutine可以顺利执行</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2><span id=\"三channel\">（三）channel</span></h2>\n<p>​       channel就像管道的形式，是goroutine之间的通信方式，是进程内的通信方式，跨进程通信建议用分布式系统的方法来解决，例如Socket或http等通信协议。channel是类型相关，即一个channel只能传递一种类型的值，在声明时指定。</p>\n<h3><span id=\"1-基本语法\">1、基本语法</span></h3>\n<h4><span id=\"1channel的声明\">1）channel的声明</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、channel声明，声明一个管道chanName，该管道可以传递的类型是ElementType</span></div><div class=\"line\"><span class=\"comment\">//管道是一种复合类型，[chan ElementType],表示可以传递ElementType类型的管道[类似定语从句的修饰方法]</span></div><div class=\"line\"><span class=\"keyword\">var</span> chanName <span class=\"keyword\">chan</span> ElementType</div><div class=\"line\"><span class=\"keyword\">var</span> ch <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>                  <span class=\"comment\">//声明一个可以传递int类型的管道</span></div><div class=\"line\"><span class=\"keyword\">var</span> m <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>] <span class=\"keyword\">chan</span> <span class=\"keyword\">bool</span>      <span class=\"comment\">//声明一个map，值的类型为可以传递bool类型的管道</span></div></pre></td></tr></table></figure>\n<h4><span id=\"2初始化\">2）初始化</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//2、初始化ch:=make(chan int)   //make一般用来声明一个复合类型，参数为复合类型的属性</span></div></pre></td></tr></table></figure>\n<h4><span id=\"3管道读写\">3）管道读写</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//3、管道写入,把值想象成一个球，\"&lt;-\"的方向，表示球的流向，ch即为管道</span></div><div class=\"line\"><span class=\"comment\">//写入时，当管道已满（管道有缓冲长度）则会导致程序堵塞，直到有goroutine从中读取出值</span></div><div class=\"line\">ch &lt;- value</div><div class=\"line\"><span class=\"comment\">//管道读取，\"&lt;-\"表示从管道把球倒出来赋值给一个变量</span></div><div class=\"line\"><span class=\"comment\">//当管道为空，读取数据会导致程序阻塞，直到有goroutine写入值</span></div><div class=\"line\">value:= &lt;-ch</div></pre></td></tr></table></figure>\n<h4><span id=\"4select\">4）select</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//4、每个case必须是一个IO操作，面向channel的操作，只执行其中的一个case操作，一旦满足则结束select过程</span></div><div class=\"line\"><span class=\"comment\">//面向channel的操作无非三种情况：成功读出；成功写入；即没有读出也没有写入</span></div><div class=\"line\"><span class=\"keyword\">select</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">case</span> &lt;-chan1:</div><div class=\"line\">  <span class=\"comment\">//如果chan1读到数据，则进行该case处理语句</span></div><div class=\"line\">  <span class=\"keyword\">case</span> chan2&lt;<span class=\"number\">-1</span>:</div><div class=\"line\">  <span class=\"comment\">//如果成功向chan2写入数据，则进入该case处理语句</span></div><div class=\"line\">  <span class=\"keyword\">default</span>:</div><div class=\"line\">  <span class=\"comment\">//如果上面都没有成功，则进入default处理流程</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"2-缓冲和超时机制\">2、缓冲和超时机制</span></h3>\n<h4><span id=\"1缓冲机制\">1）缓冲机制</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、缓冲机制：为管道指定空间长度，达到类似消息队列的效果</span></div><div class=\"line\">c:=<span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>,<span class=\"number\">1024</span>)  <span class=\"comment\">//第二个参数为缓冲区大小，与切片的空间大小类似</span></div><div class=\"line\"><span class=\"comment\">//通过range关键字来实现依次读取管道的数据，与数组或切片的range使用方法类似</span></div><div class=\"line\"><span class=\"keyword\">for</span> i :=<span class=\"keyword\">range</span> c&#123;</div><div class=\"line\">  fmt.Println(<span class=\"string\">\"Received:\"</span>,i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4><span id=\"2超时机制\">2）超时机制</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//2、超时机制：利用select只要一个case满足，程序就继续执行而不考虑其他case的情况的特性实现超时机制</span></div><div class=\"line\">timeout:=<span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">bool</span>,<span class=\"number\">1</span>)    <span class=\"comment\">//设置一个超时管道</span></div><div class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">  time.Sleep(<span class=\"number\">1e9</span>)      <span class=\"comment\">//设置超时时间，等待一分钟</span></div><div class=\"line\">  timeout&lt;-<span class=\"literal\">true</span>        <span class=\"comment\">//一分钟后往管道放一个true的值</span></div><div class=\"line\">&#125;()</div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"keyword\">select</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">case</span> &lt;-ch:           <span class=\"comment\">//如果读到数据，则会结束select过程</span></div><div class=\"line\">  <span class=\"comment\">//从ch中读取数据</span></div><div class=\"line\">  <span class=\"keyword\">case</span> &lt;-timeout:      <span class=\"comment\">//如果前面的case没有调用到，必定会读到true值，结束select，避免永久等待</span></div><div class=\"line\">  <span class=\"comment\">//一直没有从ch中读取到数据，但从timeout中读取到了数据</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"3-channel的传递\">3、channel的传递</span></h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、channel的传递，来实现Linux系统中管道的功能，以插件的方式增加数据处理的流程</span></div><div class=\"line\"><span class=\"keyword\">type</span> PipeData <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">  value <span class=\"keyword\">int</span></div><div class=\"line\">  handler <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span>   //<span class=\"title\">handler</span>是属性？</span></div><div class=\"line\"><span class=\"function\">  <span class=\"title\">next</span> <span class=\"title\">chan</span> <span class=\"title\">int</span>   //可以把[<span class=\"title\">chan</span> <span class=\"title\">int</span>]看成一个整体，表示放<span class=\"title\">int</span>类型的管道</span></div><div class=\"line\"><span class=\"function\">&#125;</span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">handler</span><span class=\"params\">(queue <span class=\"keyword\">chan</span> *PipeData)</span></span>&#123; <span class=\"comment\">//queue是一个存放*PipeDate类型的管道，可改变管道里的数据块内容</span></div><div class=\"line\">  <span class=\"keyword\">for</span> data:=<span class=\"keyword\">range</span> queue&#123;     <span class=\"comment\">//data的类型就是管道存放定义的类型，即PipeData</span></div><div class=\"line\">    data.next &lt;- data.handler(data.value)    <span class=\"comment\">//该方法实现将PipeData的value值存放到next的管道中</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"4-单向channel\">4、单向channel</span></h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//2、单向channel：只能用于接收或发送数据，是对channel的一种使用限制</span></div><div class=\"line\"><span class=\"comment\">//单向channel的声明</span></div><div class=\"line\"><span class=\"keyword\">var</span> ch1 <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>    <span class=\"comment\">//正常channel，可读写</span></div><div class=\"line\"><span class=\"keyword\">var</span> ch2 <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>  <span class=\"comment\">//单向只写channel  [chan&lt;- int]看成一个整体，表示流入管道</span></div><div class=\"line\"><span class=\"keyword\">var</span> ch3 &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>  <span class=\"comment\">//单向只读channel  [&lt;-chan int]看成一个整体，表示流出管道</span></div><div class=\"line\"><span class=\"comment\">//管道类型强制转换</span></div><div class=\"line\">ch4:=<span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)     <span class=\"comment\">//ch4为双向管道</span></div><div class=\"line\">ch5:=&lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>(ch4)    <span class=\"comment\">//把[&lt;-chan int]看成单向只读管道类型，对ch4进行强制类型转换</span></div><div class=\"line\">ch6:=<span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>(ch4)    <span class=\"comment\">//把[chan&lt;- int]看成单向只写管道类型，对ch4进行强制类型转换</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Parse</span><span class=\"params\">(ch &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span>&#123;    <span class=\"comment\">//最小权限原则</span></div><div class=\"line\">  <span class=\"keyword\">for</span> value:=<span class=\"keyword\">range</span> ch&#123;</div><div class=\"line\">    fmt.Println(<span class=\"string\">\"Parsing value\"</span>,value)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"5-关闭channel\">5、关闭channel</span></h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//3、关闭channel，使用内置函数close()函数即可</span></div><div class=\"line\"><span class=\"built_in\">close</span>(ch)</div><div class=\"line\"><span class=\"comment\">//判断channel是否关闭</span></div><div class=\"line\">x,ok:=&lt;-ch <span class=\"comment\">//ok==false表示channel已经关闭</span></div><div class=\"line\"><span class=\"keyword\">if</span> !ok &#123;   <span class=\"comment\">//如果channel关闭，ok==false，!ok==true</span></div><div class=\"line\">  <span class=\"comment\">//执行体</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2><span id=\"四多核并行化与同步锁\">（四）多核并行化与同步锁</span></h2>\n<h3><span id=\"1-多核并行化\">1、多核并行化</span></h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//多核并行化</span></div><div class=\"line\">runtime.GOMAXPROCS(<span class=\"number\">16</span>) <span class=\"comment\">//设置环境变量GOMAXPROCS的值来控制使用多少个CPU核心</span></div><div class=\"line\">runtime.NumCPU() <span class=\"comment\">//来获取核心数</span></div><div class=\"line\"><span class=\"comment\">//出让时间片</span></div><div class=\"line\">runtime.Gosched() <span class=\"comment\">//在每个goroutine中控制何时出让时间片给其他goroutine</span></div></pre></td></tr></table></figure>\n<h3><span id=\"2-同步锁\">2、同步锁</span></h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//同步锁</span></div><div class=\"line\">sync.Mutex <span class=\"comment\">//单读单写：占用Mutex后，其他goroutine只能等到其释放该Mutex</span></div><div class=\"line\">sync.RWMutex <span class=\"comment\">//单写多读：会阻止写，不会阻止读</span></div><div class=\"line\">RLock() <span class=\"comment\">//读锁</span></div><div class=\"line\">Lock() <span class=\"comment\">//写锁</span></div><div class=\"line\">RUnlock() <span class=\"comment\">//解锁（读锁）</span></div><div class=\"line\">Unlock() <span class=\"comment\">//解锁（写锁）</span></div><div class=\"line\"><span class=\"comment\">//全局唯一性操作</span></div><div class=\"line\"><span class=\"comment\">//once的Do方法保证全局只调用指定函数(setup)一次，其他goroutine在调用到此函数是会阻塞，直到once调用结束才继续</span></div><div class=\"line\">once.Do(setup)</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2>（一）并发基础</h2>\n<h3>1.概念</h3>\n<p>并发意味着程序在运行时有多个执行上下文，对应多个调用栈。</p>\n<p>并发与并行的区别：</p>\n<p>并发的主流实现模型：</p>\n<table>\n<thead>\n<tr>\n<th>实现模型</th>\n<th>说明</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>多进程</td>\n<td>操作系统层面的并发模式</td>\n<td>处理简单，互不影响，但开销大</td>\n</tr>\n<tr>\n<td>多线程</td>\n<td>系统层面的并发模式</td>\n<td>有效，开销较大，高并发时影响效率</td>\n</tr>\n<tr>\n<td>基于回调的非阻塞/异步IO</td>\n<td>多用于高并发服务器开发中</td>\n<td>编程复杂，开销小</td>\n</tr>\n<tr>\n<td>协程</td>\n<td>用户态线程，不需要操作系统抢占调度，寄存于线程中</td>\n<td>编程简单，结构简单，开销极小，但需要语言的支持</td>\n</tr>\n</tbody>\n</table>\n<p>共享内存系统：线程之间采用共享内存的方式通信，通过加锁来避免死锁或资源竞争。</p>\n<p>消息传递系统：将线程间共享状态封装在消息中，通过发送消息来共享内存，而非通过共享内存来通信。</p>\n<h3>2.协程</h3>\n<p>执行体是个抽象的概念，在操作系统中分为三个级别：进程（process），进程内的线程（thread），进程内的协程（coroutine，轻量级线程）。协程的数量级可达到上百万个，进程和线程的数量级最多不超过一万个。Go语言中的协程叫goroutine，Go标准库提供的调用操作，IO操作都会出让CPU给其他goroutine，让协程间的切换管理不依赖系统的线程和进程，不依赖CPU的核心数量。</p>\n<h3>3.并发通信</h3>\n<p>并发编程的难度在于协调，协调需要通过通信，并发通信模型分为共享数据和消息。共享数据即多个并发单元保持对同一个数据的引用，数据可以是内存数据块，磁盘文件，网络数据等。数据共享通过加锁的方式来避免死锁和资源竞争。Go语言则采取消息机制来通信，每个并发单元是独立的个体，有独立的变量，不同并发单元间这些变量不共享，每个并发单元的输入输出只通过消息的方式。</p>\n<h2>（二）goroutine</h2>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义调用体</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Add</span><span class=\"params\">(x,y <span class=\"keyword\">int</span>)</span></span>&#123;</div><div class=\"line\">  z:=x+y</div><div class=\"line\">  fmt.Println(z)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//go关键字执行调用，即会产生一个goroutine并发执行</span></div><div class=\"line\"><span class=\"comment\">//当函数返回时，goroutine自动结束，如果有返回值,返回值会自动被丢弃</span></div><div class=\"line\"><span class=\"keyword\">go</span> Add(<span class=\"number\">1</span>,<span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"comment\">//并发执行</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++&#123;<span class=\"comment\">//主函数启动了10个goroutine，然后返回，程序退出，并不会等待其他goroutine结束</span></div><div class=\"line\">    <span class=\"keyword\">go</span> Add(i,i)     <span class=\"comment\">//所以需要通过channel通信来保证其他goroutine可以顺利执行</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2>（三）channel</h2>\n<p>​       channel就像管道的形式，是goroutine之间的通信方式，是进程内的通信方式，跨进程通信建议用分布式系统的方法来解决，例如Socket或http等通信协议。channel是类型相关，即一个channel只能传递一种类型的值，在声明时指定。</p>\n<h3>1、基本语法</h3>\n<h4>1）channel的声明</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、channel声明，声明一个管道chanName，该管道可以传递的类型是ElementType</span></div><div class=\"line\"><span class=\"comment\">//管道是一种复合类型，[chan ElementType],表示可以传递ElementType类型的管道[类似定语从句的修饰方法]</span></div><div class=\"line\"><span class=\"keyword\">var</span> chanName <span class=\"keyword\">chan</span> ElementType</div><div class=\"line\"><span class=\"keyword\">var</span> ch <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>                  <span class=\"comment\">//声明一个可以传递int类型的管道</span></div><div class=\"line\"><span class=\"keyword\">var</span> m <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>] <span class=\"keyword\">chan</span> <span class=\"keyword\">bool</span>      <span class=\"comment\">//声明一个map，值的类型为可以传递bool类型的管道</span></div></pre></td></tr></table></figure>\n<h4>2）初始化</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//2、初始化ch:=make(chan int)   //make一般用来声明一个复合类型，参数为复合类型的属性</span></div></pre></td></tr></table></figure>\n<h4>3）管道读写</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//3、管道写入,把值想象成一个球，\"&lt;-\"的方向，表示球的流向，ch即为管道</span></div><div class=\"line\"><span class=\"comment\">//写入时，当管道已满（管道有缓冲长度）则会导致程序堵塞，直到有goroutine从中读取出值</span></div><div class=\"line\">ch &lt;- value</div><div class=\"line\"><span class=\"comment\">//管道读取，\"&lt;-\"表示从管道把球倒出来赋值给一个变量</span></div><div class=\"line\"><span class=\"comment\">//当管道为空，读取数据会导致程序阻塞，直到有goroutine写入值</span></div><div class=\"line\">value:= &lt;-ch</div></pre></td></tr></table></figure>\n<h4>4）select</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//4、每个case必须是一个IO操作，面向channel的操作，只执行其中的一个case操作，一旦满足则结束select过程</span></div><div class=\"line\"><span class=\"comment\">//面向channel的操作无非三种情况：成功读出；成功写入；即没有读出也没有写入</span></div><div class=\"line\"><span class=\"keyword\">select</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">case</span> &lt;-chan1:</div><div class=\"line\">  <span class=\"comment\">//如果chan1读到数据，则进行该case处理语句</span></div><div class=\"line\">  <span class=\"keyword\">case</span> chan2&lt;<span class=\"number\">-1</span>:</div><div class=\"line\">  <span class=\"comment\">//如果成功向chan2写入数据，则进入该case处理语句</span></div><div class=\"line\">  <span class=\"keyword\">default</span>:</div><div class=\"line\">  <span class=\"comment\">//如果上面都没有成功，则进入default处理流程</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>2、缓冲和超时机制</h3>\n<h4>1）缓冲机制</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、缓冲机制：为管道指定空间长度，达到类似消息队列的效果</span></div><div class=\"line\">c:=<span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>,<span class=\"number\">1024</span>)  <span class=\"comment\">//第二个参数为缓冲区大小，与切片的空间大小类似</span></div><div class=\"line\"><span class=\"comment\">//通过range关键字来实现依次读取管道的数据，与数组或切片的range使用方法类似</span></div><div class=\"line\"><span class=\"keyword\">for</span> i :=<span class=\"keyword\">range</span> c&#123;</div><div class=\"line\">  fmt.Println(<span class=\"string\">\"Received:\"</span>,i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4>2）超时机制</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//2、超时机制：利用select只要一个case满足，程序就继续执行而不考虑其他case的情况的特性实现超时机制</span></div><div class=\"line\">timeout:=<span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">bool</span>,<span class=\"number\">1</span>)    <span class=\"comment\">//设置一个超时管道</span></div><div class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">  time.Sleep(<span class=\"number\">1e9</span>)      <span class=\"comment\">//设置超时时间，等待一分钟</span></div><div class=\"line\">  timeout&lt;-<span class=\"literal\">true</span>        <span class=\"comment\">//一分钟后往管道放一个true的值</span></div><div class=\"line\">&#125;()</div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"keyword\">select</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">case</span> &lt;-ch:           <span class=\"comment\">//如果读到数据，则会结束select过程</span></div><div class=\"line\">  <span class=\"comment\">//从ch中读取数据</span></div><div class=\"line\">  <span class=\"keyword\">case</span> &lt;-timeout:      <span class=\"comment\">//如果前面的case没有调用到，必定会读到true值，结束select，避免永久等待</span></div><div class=\"line\">  <span class=\"comment\">//一直没有从ch中读取到数据，但从timeout中读取到了数据</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>3、channel的传递</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1、channel的传递，来实现Linux系统中管道的功能，以插件的方式增加数据处理的流程</span></div><div class=\"line\"><span class=\"keyword\">type</span> PipeData <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">  value <span class=\"keyword\">int</span></div><div class=\"line\">  handler <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span>   //<span class=\"title\">handler</span>是属性？</span></div><div class=\"line\"><span class=\"function\">  <span class=\"title\">next</span> <span class=\"title\">chan</span> <span class=\"title\">int</span>   //可以把[<span class=\"title\">chan</span> <span class=\"title\">int</span>]看成一个整体，表示放<span class=\"title\">int</span>类型的管道</span></div><div class=\"line\"><span class=\"function\">&#125;</span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">handler</span><span class=\"params\">(queue <span class=\"keyword\">chan</span> *PipeData)</span></span>&#123; <span class=\"comment\">//queue是一个存放*PipeDate类型的管道，可改变管道里的数据块内容</span></div><div class=\"line\">  <span class=\"keyword\">for</span> data:=<span class=\"keyword\">range</span> queue&#123;     <span class=\"comment\">//data的类型就是管道存放定义的类型，即PipeData</span></div><div class=\"line\">    data.next &lt;- data.handler(data.value)    <span class=\"comment\">//该方法实现将PipeData的value值存放到next的管道中</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>4、单向channel</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//2、单向channel：只能用于接收或发送数据，是对channel的一种使用限制</span></div><div class=\"line\"><span class=\"comment\">//单向channel的声明</span></div><div class=\"line\"><span class=\"keyword\">var</span> ch1 <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>    <span class=\"comment\">//正常channel，可读写</span></div><div class=\"line\"><span class=\"keyword\">var</span> ch2 <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>  <span class=\"comment\">//单向只写channel  [chan&lt;- int]看成一个整体，表示流入管道</span></div><div class=\"line\"><span class=\"keyword\">var</span> ch3 &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>  <span class=\"comment\">//单向只读channel  [&lt;-chan int]看成一个整体，表示流出管道</span></div><div class=\"line\"><span class=\"comment\">//管道类型强制转换</span></div><div class=\"line\">ch4:=<span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)     <span class=\"comment\">//ch4为双向管道</span></div><div class=\"line\">ch5:=&lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>(ch4)    <span class=\"comment\">//把[&lt;-chan int]看成单向只读管道类型，对ch4进行强制类型转换</span></div><div class=\"line\">ch6:=<span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>(ch4)    <span class=\"comment\">//把[chan&lt;- int]看成单向只写管道类型，对ch4进行强制类型转换</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Parse</span><span class=\"params\">(ch &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span>&#123;    <span class=\"comment\">//最小权限原则</span></div><div class=\"line\">  <span class=\"keyword\">for</span> value:=<span class=\"keyword\">range</span> ch&#123;</div><div class=\"line\">    fmt.Println(<span class=\"string\">\"Parsing value\"</span>,value)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>5、关闭channel</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//3、关闭channel，使用内置函数close()函数即可</span></div><div class=\"line\"><span class=\"built_in\">close</span>(ch)</div><div class=\"line\"><span class=\"comment\">//判断channel是否关闭</span></div><div class=\"line\">x,ok:=&lt;-ch <span class=\"comment\">//ok==false表示channel已经关闭</span></div><div class=\"line\"><span class=\"keyword\">if</span> !ok &#123;   <span class=\"comment\">//如果channel关闭，ok==false，!ok==true</span></div><div class=\"line\">  <span class=\"comment\">//执行体</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2>（四）多核并行化与同步锁</h2>\n<h3>1、多核并行化</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//多核并行化</span></div><div class=\"line\">runtime.GOMAXPROCS(<span class=\"number\">16</span>) <span class=\"comment\">//设置环境变量GOMAXPROCS的值来控制使用多少个CPU核心</span></div><div class=\"line\">runtime.NumCPU() <span class=\"comment\">//来获取核心数</span></div><div class=\"line\"><span class=\"comment\">//出让时间片</span></div><div class=\"line\">runtime.Gosched() <span class=\"comment\">//在每个goroutine中控制何时出让时间片给其他goroutine</span></div></pre></td></tr></table></figure>\n<h3>2、同步锁</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//同步锁</span></div><div class=\"line\">sync.Mutex <span class=\"comment\">//单读单写：占用Mutex后，其他goroutine只能等到其释放该Mutex</span></div><div class=\"line\">sync.RWMutex <span class=\"comment\">//单写多读：会阻止写，不会阻止读</span></div><div class=\"line\">RLock() <span class=\"comment\">//读锁</span></div><div class=\"line\">Lock() <span class=\"comment\">//写锁</span></div><div class=\"line\">RUnlock() <span class=\"comment\">//解锁（读锁）</span></div><div class=\"line\">Unlock() <span class=\"comment\">//解锁（写锁）</span></div><div class=\"line\"><span class=\"comment\">//全局唯一性操作</span></div><div class=\"line\"><span class=\"comment\">//once的Do方法保证全局只调用指定函数(setup)一次，其他goroutine在调用到此函数是会阻塞，直到once调用结束才继续</span></div><div class=\"line\">once.Do(setup)</div></pre></td></tr></table></figure>"},{"title":"[Golang] beego介绍","catalog":true,"date":"2017-09-01T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Golang"],"_content":"\n## 1. beego的使用\n\n### 1.1. beego的安装\n\n```go\ngo get github.com/astaxie/beego\n```\n\n### 1.2. beego的升级\n\n1、直接升级\n\n```go\ngo get -u github.com/astaxie/beego\n```\n\n2、源码下载升级\n\n用户访问 `https://github.com/astaxie/beego` ,下载源码，然后覆盖到 `$GOPATH/src/github.com/astaxie/beego` 目录，然后通过本地执行安装就可以升级了：\n\n```go\ngo install  github.com/astaxie/beego\n```\n\n### 1.3. bee工具\n\nbee工具用来进行beego项目的创建、热编译、开发、测试、和部署。\n\n安装:\n\n```go\ngo get github.com/beego/bee\n```\n\n配置：\n\n安装完之后，`bee`可执行文件默认存放在`$GOPATH/bin`里面，所以要把`$GOPATH/bin`添加到环境变量中。\n\n### 1.4. bee命令\n\n```shell\nBee is a tool for managing beego framework.\n \nUsage:\n \n    bee command [arguments]\n \nThe commands are:\n \n    new         create an application base on beego framework\n    run         run the app which can hot compile\n    pack        compress an beego project\n    api         create an api application base on beego framework\n    bale        packs non-Go files to Go source files\n    version     show the bee & beego version\n    generate    source code generator\n    migrate     run database migrations\n```\n\n说明：\n\n#### 1.4.1. new\n\n在 `$GOPATH/src`的目录下执行`bee new <appname>`，会在当前目录下生成以下文件：\n\n```go\nmyproject\n├── conf\n│   └── app.conf\n├── controllers\n│   └── default.go\n├── main.go\n├── models\n├── routers\n│   └── router.go\n├── static\n│   ├── css\n│   ├── img\n│   └── js\n├── tests\n│   └── default_test.go\n└── views\n    └── index.tpl\n```\n\n#### 1.4.2. run\n\n必须在`$GOPATH/src/appname`下执行bee run，默认监听8080端口：`http://localhost:8080/。`\n\n#### 1.4.3. api\n\n`api` 命令就是用来创建 API 应用，生成以下文件：和 Web 项目相比，少了 static 和 views 目录，多了一个 test 模块，用来做单元测试。\n\n```\napiproject\n├── conf\n│   └── app.conf\n├── controllers\n│   └── object.go\n│   └── user.go\n├── docs\n│   └── doc.go\n├── main.go\n├── models\n│   └── object.go\n│   └── user.go\n├── routers\n│   └── router.go\n└── tests\n    └── default_test.go\n```\n\n#### 1.4.4. pack\n\n`pack` 目录用来发布应用的时候打包，会把项目打包成 zip 包(`apiproject.tar.gz`)，这样我们部署的时候直接把打包之后的项目上传，解压就可以部署了：\n\n#### 1.4.5. generate\n\n用来自动化的生成代码的，包含了从数据库一键生成model，还包含了scaffold。\n\n#### 1.4.6. migrate\n\n这个命令是应用的数据库迁移命令，主要是用来每次应用升级，降级的SQL管理。\n\n## 2. beego的架构\n\nbeego 是一个快速开发 Go 应用的 HTTP 框架，他可以用来快速开发 API、Web 及后端服务等各种应用，是一个 RESTful 的框架。\n\n### 2.1. beego架构图\n\n![architecture](/img/article/golang/beego/architecture.png)\n\nbeego 是基于八大独立的模块构建的，是一个高度解耦的框架。\n\n可以使用 cache 模块来做你的缓存逻辑；使用日志模块来记录你的操作信息；使用 config 模块来解析你各种格式的文件。\n\n### 2.2. beego执行逻辑\n\n![flow](/img/article/golang/beego/flow.png)\n\n文件结构见第一部分：[new]。\n\n## 3. beego项目逻辑\n\n### 3.1. 路由设置\n\n#### 3.1.1. beego.Router\n\n入口文件main.go\n\n```go\npackage main\n \nimport (\n    _ \"quickstart/routers\"\n    \"github.com/astaxie/beego\"\n)\n \nfunc main() {\n    beego.Run()\n}\n```\n\ngo中导入包中init函数的执行逻辑\n\n![init](/img/article/golang/beego/init.png)\n\n`_ \"quickstart/routers\"`,包只引入执行了里面的init函数\n\n```go\npackage routers\n \nimport (\n    \"quickstart/controllers\"\n    \"github.com/astaxie/beego\"\n)\n \nfunc init() {\n    beego.Router(\"/\", &controllers.MainController{})\n}\n```\n\n路由包里执行了路由注册`beego.Router`, 这个函数的功能是映射URL到controller，第一个参数是URL(用户请求的地址)，这里是 `/`，也就是访问的不带任何参数的URL，第二个参数是对应的 Controller，就是把请求分发到那个控制器来执行相应的逻辑。\n\n#### 3.1.2. beego.Run\n\n- 解析配置文件\n\n  beego 会自动解析在 conf 目录下面的配置文件 `app.conf`，通过修改配置文件相关的属性，我们可以定义：开启的端口，是否开启 session，应用名称等信息。\n\n- 执行用户的hookfunc\n\n  beego会执行用户注册的hookfunc，默认的已经存在了注册mime，用户可以通过函数`AddAPPStartHook`注册自己的启动函数。\n\n- 是否开启 session\n\n  会根据上面配置文件的分析之后判断是否开启 session，如果开启的话就初始化全局的 session。\n\n- 是否编译模板\n\n  beego 会在启动的时候根据配置把 views 目录下的所有模板进行预编译，然后存在 map 里面，这样可以有效的提高模板运行的效率，无需进行多次编译。\n\n- 是否开启文档功能\n\n  根据EnableDocs配置判断是否开启内置的文档路由功能\n\n- 是否启动管理模块\n\n  beego 目前做了一个很酷的模块，应用内监控模块，会在 8088 端口做一个内部监听，我们可以通过这个端口查询到 QPS、CPU、内存、GC、goroutine、thread 等统计信息。\n\n- 监听服务端口\n\n  这是最后一步也就是我们看到的访问 8080 看到的网页端口，内部其实调用了 `ListenAndServe`，充分利用了 goroutine 的优势，一旦 run 起来之后，我们的服务就监听在两个端口了，一个服务端口 8080 作为对外服务，另一个 8088 端口实行对内监控。\n\n### 3.2. controller 逻辑\n\n```go\npackage controllers\n \nimport (\n        \"github.com/astaxie/beego\"\n)\n \ntype MainController struct {\n        beego.Controller\n}\n \nfunc (this *MainController) Get() {\n        this.Data[\"Website\"] = \"beego.me\"\n        this.Data[\"Email\"] = \"astaxie@gmail.com\"\n        this.TplName = \"index.tpl\"\n}\n```\n\n1、声明了一个控制器 `MainController`，这个控制器里面内嵌了 `beego.Controller`，即Go 的嵌入方式，也就是 `MainController` 自动拥有了所有 `beego.Controller` 的方法。而 `beego.Controller` 拥有很多方法，其中包括 `Init`、`Prepare`、`Post`、`Get`、`Delete`、`Head`等方法。可以通过重写的方式来实现这些方法，以上例子重写了 `Get` 方法。\n\n2、beego 是一个 RESTful 的框架，请求默认是执行对应 `req.Method` 的方法。例如浏览器的是 `GET` 请求，那么默认就会执行 `MainController` 下的 `Get` 方法。（用户可以改变这个行为，通过注册自定义的函数名）。\n\n3、获取数据，赋值到 `this.Data` 中，这是一个用来存储输出数据的 map。\n\n4、渲染模板，`this.TplName` 就是需要渲染的模板，这里指定了 `index.tpl`，如果用户不设置该参数，那么默认会去到模板目录的 `Controller/<方法名>.tpl` 查找，例如上面的方法会去 `maincontroller/get.tpl`(文件、文件夹必须小写)。用户设置了模板之后系统会自动的调用 `Render` 函数（这个函数是在 beego.Controller 中实现的），所以无需用户自己来调用渲染。\n\n5、如果不使用模板可以直接输出：\n\n```go\nfunc (this *MainController) Get() {\n        this.Ctx.WriteString(\"hello\")\n}\n```\n\n### 3.3. model逻辑\n\nmodel一般用来处理数据库操作，如果逻辑中存在可以复用的部分就可以抽象成一个model。\n\n```go\npackage models\n \nimport (\n    \"loggo/utils\"\n    \"path/filepath\"\n    \"strconv\"\n    \"strings\"\n)\n \nvar (\n    NotPV []string = []string{\"css\", \"js\", \"class\", \"gif\", \"jpg\", \"jpeg\", \"png\", \"bmp\", \"ico\", \"rss\", \"xml\", \"swf\"}\n)\n \nconst big = 0xFFFFFF\n \nfunc LogPV(urls string) bool {\n    ext := filepath.Ext(urls)\n    if ext == \"\" {\n        return true\n    }\n    for _, v := range NotPV {\n        if v == strings.ToLower(ext) {\n            return false\n        }\n    }\n    return true\n}\n```\n\n### 3.4. view逻辑\n\n`Controller中的this.TplName = \"index.tpl\"`，设置显示的模板文件，默认支持 `tpl` 和 `html` 的后缀名，如果想设置其他后缀你可以调用 `beego.AddTemplateExt` 接口设置。beego 采用了 Go 语言默认的模板引擎，和 Go 的模板语法一样。\n\n```html\n<!DOCTYPE html>\n \n<html>\n    <head>\n        <title>Beego</title>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n    </head>\n     \n    <body>\n        <header class=\"hero-unit\" style=\"background-color:#A9F16C\">\n            <div class=\"container\">\n            <div class=\"row\">\n              <div class=\"hero-text\">\n                <h1>Welcome to Beego!</h1>\n                <p class=\"description\">\n                    Beego is a simple & powerful Go web framework which is inspired by tornado and sinatra.\n                <br />\n                    Official website: <a href=\"http://{{.Website}}\">{{.Website}}</a>\n                <br />\n                    Contact me: {{.Email}}\n                </p>\n              </div>\n            </div>\n            </div>\n        </header>\n    </body>\n</html>\n```\n\nController 里面把数据赋值给了 data（map 类型），然后在模板中就直接通过 key 访问 `.Website` 和 `.Email` 。这样就做到了数据的输出。\n\n### 3.5. 静态文件\n\n网页往往包含了很多的静态文件，包括图片、JS、CSS 等\n\n```shell\n├── static\n    │   ├── css\n    │   ├── img\n    │   └── js\n```\n\nbeego 默认注册了 static 目录为静态处理的目录，注册样式：URL 前缀和映射的目录（在/main.go文件中beego.Run()之前加入）：\n\n```go\nStaticDir[\"/static\"] = \"static\"\n```\n\n用户可以设置多个静态文件处理目录，例如你有多个文件下载目录 download1、download2，你可以这样映射（在/main.go文件中beego.Run()之前加入）：\n\n```go\nbeego.SetStaticPath(\"/down1\", \"download1\") beego.SetStaticPath(\"/down2\", \"download2\")\n```\n\n这样用户访问 URL `http://localhost:8080/down1/123.txt` 则会请求 download1 目录下的 123.txt 文件。\n\n \n\n参考：\n\n[https://beego.me/docs/intro/](https://beego.me/docs/intro/)\n\n ","source":"_posts/Golang/beego/beego介绍.md","raw":"---\ntitle: \"[Golang] beego介绍\"\ncatalog: true\ndate: 2017-09-01 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Golang\n- Beego\ncatagories:\n- Golang\n---\n\n## 1. beego的使用\n\n### 1.1. beego的安装\n\n```go\ngo get github.com/astaxie/beego\n```\n\n### 1.2. beego的升级\n\n1、直接升级\n\n```go\ngo get -u github.com/astaxie/beego\n```\n\n2、源码下载升级\n\n用户访问 `https://github.com/astaxie/beego` ,下载源码，然后覆盖到 `$GOPATH/src/github.com/astaxie/beego` 目录，然后通过本地执行安装就可以升级了：\n\n```go\ngo install  github.com/astaxie/beego\n```\n\n### 1.3. bee工具\n\nbee工具用来进行beego项目的创建、热编译、开发、测试、和部署。\n\n安装:\n\n```go\ngo get github.com/beego/bee\n```\n\n配置：\n\n安装完之后，`bee`可执行文件默认存放在`$GOPATH/bin`里面，所以要把`$GOPATH/bin`添加到环境变量中。\n\n### 1.4. bee命令\n\n```shell\nBee is a tool for managing beego framework.\n \nUsage:\n \n    bee command [arguments]\n \nThe commands are:\n \n    new         create an application base on beego framework\n    run         run the app which can hot compile\n    pack        compress an beego project\n    api         create an api application base on beego framework\n    bale        packs non-Go files to Go source files\n    version     show the bee & beego version\n    generate    source code generator\n    migrate     run database migrations\n```\n\n说明：\n\n#### 1.4.1. new\n\n在 `$GOPATH/src`的目录下执行`bee new <appname>`，会在当前目录下生成以下文件：\n\n```go\nmyproject\n├── conf\n│   └── app.conf\n├── controllers\n│   └── default.go\n├── main.go\n├── models\n├── routers\n│   └── router.go\n├── static\n│   ├── css\n│   ├── img\n│   └── js\n├── tests\n│   └── default_test.go\n└── views\n    └── index.tpl\n```\n\n#### 1.4.2. run\n\n必须在`$GOPATH/src/appname`下执行bee run，默认监听8080端口：`http://localhost:8080/。`\n\n#### 1.4.3. api\n\n`api` 命令就是用来创建 API 应用，生成以下文件：和 Web 项目相比，少了 static 和 views 目录，多了一个 test 模块，用来做单元测试。\n\n```\napiproject\n├── conf\n│   └── app.conf\n├── controllers\n│   └── object.go\n│   └── user.go\n├── docs\n│   └── doc.go\n├── main.go\n├── models\n│   └── object.go\n│   └── user.go\n├── routers\n│   └── router.go\n└── tests\n    └── default_test.go\n```\n\n#### 1.4.4. pack\n\n`pack` 目录用来发布应用的时候打包，会把项目打包成 zip 包(`apiproject.tar.gz`)，这样我们部署的时候直接把打包之后的项目上传，解压就可以部署了：\n\n#### 1.4.5. generate\n\n用来自动化的生成代码的，包含了从数据库一键生成model，还包含了scaffold。\n\n#### 1.4.6. migrate\n\n这个命令是应用的数据库迁移命令，主要是用来每次应用升级，降级的SQL管理。\n\n## 2. beego的架构\n\nbeego 是一个快速开发 Go 应用的 HTTP 框架，他可以用来快速开发 API、Web 及后端服务等各种应用，是一个 RESTful 的框架。\n\n### 2.1. beego架构图\n\n![architecture](/img/article/golang/beego/architecture.png)\n\nbeego 是基于八大独立的模块构建的，是一个高度解耦的框架。\n\n可以使用 cache 模块来做你的缓存逻辑；使用日志模块来记录你的操作信息；使用 config 模块来解析你各种格式的文件。\n\n### 2.2. beego执行逻辑\n\n![flow](/img/article/golang/beego/flow.png)\n\n文件结构见第一部分：[new]。\n\n## 3. beego项目逻辑\n\n### 3.1. 路由设置\n\n#### 3.1.1. beego.Router\n\n入口文件main.go\n\n```go\npackage main\n \nimport (\n    _ \"quickstart/routers\"\n    \"github.com/astaxie/beego\"\n)\n \nfunc main() {\n    beego.Run()\n}\n```\n\ngo中导入包中init函数的执行逻辑\n\n![init](/img/article/golang/beego/init.png)\n\n`_ \"quickstart/routers\"`,包只引入执行了里面的init函数\n\n```go\npackage routers\n \nimport (\n    \"quickstart/controllers\"\n    \"github.com/astaxie/beego\"\n)\n \nfunc init() {\n    beego.Router(\"/\", &controllers.MainController{})\n}\n```\n\n路由包里执行了路由注册`beego.Router`, 这个函数的功能是映射URL到controller，第一个参数是URL(用户请求的地址)，这里是 `/`，也就是访问的不带任何参数的URL，第二个参数是对应的 Controller，就是把请求分发到那个控制器来执行相应的逻辑。\n\n#### 3.1.2. beego.Run\n\n- 解析配置文件\n\n  beego 会自动解析在 conf 目录下面的配置文件 `app.conf`，通过修改配置文件相关的属性，我们可以定义：开启的端口，是否开启 session，应用名称等信息。\n\n- 执行用户的hookfunc\n\n  beego会执行用户注册的hookfunc，默认的已经存在了注册mime，用户可以通过函数`AddAPPStartHook`注册自己的启动函数。\n\n- 是否开启 session\n\n  会根据上面配置文件的分析之后判断是否开启 session，如果开启的话就初始化全局的 session。\n\n- 是否编译模板\n\n  beego 会在启动的时候根据配置把 views 目录下的所有模板进行预编译，然后存在 map 里面，这样可以有效的提高模板运行的效率，无需进行多次编译。\n\n- 是否开启文档功能\n\n  根据EnableDocs配置判断是否开启内置的文档路由功能\n\n- 是否启动管理模块\n\n  beego 目前做了一个很酷的模块，应用内监控模块，会在 8088 端口做一个内部监听，我们可以通过这个端口查询到 QPS、CPU、内存、GC、goroutine、thread 等统计信息。\n\n- 监听服务端口\n\n  这是最后一步也就是我们看到的访问 8080 看到的网页端口，内部其实调用了 `ListenAndServe`，充分利用了 goroutine 的优势，一旦 run 起来之后，我们的服务就监听在两个端口了，一个服务端口 8080 作为对外服务，另一个 8088 端口实行对内监控。\n\n### 3.2. controller 逻辑\n\n```go\npackage controllers\n \nimport (\n        \"github.com/astaxie/beego\"\n)\n \ntype MainController struct {\n        beego.Controller\n}\n \nfunc (this *MainController) Get() {\n        this.Data[\"Website\"] = \"beego.me\"\n        this.Data[\"Email\"] = \"astaxie@gmail.com\"\n        this.TplName = \"index.tpl\"\n}\n```\n\n1、声明了一个控制器 `MainController`，这个控制器里面内嵌了 `beego.Controller`，即Go 的嵌入方式，也就是 `MainController` 自动拥有了所有 `beego.Controller` 的方法。而 `beego.Controller` 拥有很多方法，其中包括 `Init`、`Prepare`、`Post`、`Get`、`Delete`、`Head`等方法。可以通过重写的方式来实现这些方法，以上例子重写了 `Get` 方法。\n\n2、beego 是一个 RESTful 的框架，请求默认是执行对应 `req.Method` 的方法。例如浏览器的是 `GET` 请求，那么默认就会执行 `MainController` 下的 `Get` 方法。（用户可以改变这个行为，通过注册自定义的函数名）。\n\n3、获取数据，赋值到 `this.Data` 中，这是一个用来存储输出数据的 map。\n\n4、渲染模板，`this.TplName` 就是需要渲染的模板，这里指定了 `index.tpl`，如果用户不设置该参数，那么默认会去到模板目录的 `Controller/<方法名>.tpl` 查找，例如上面的方法会去 `maincontroller/get.tpl`(文件、文件夹必须小写)。用户设置了模板之后系统会自动的调用 `Render` 函数（这个函数是在 beego.Controller 中实现的），所以无需用户自己来调用渲染。\n\n5、如果不使用模板可以直接输出：\n\n```go\nfunc (this *MainController) Get() {\n        this.Ctx.WriteString(\"hello\")\n}\n```\n\n### 3.3. model逻辑\n\nmodel一般用来处理数据库操作，如果逻辑中存在可以复用的部分就可以抽象成一个model。\n\n```go\npackage models\n \nimport (\n    \"loggo/utils\"\n    \"path/filepath\"\n    \"strconv\"\n    \"strings\"\n)\n \nvar (\n    NotPV []string = []string{\"css\", \"js\", \"class\", \"gif\", \"jpg\", \"jpeg\", \"png\", \"bmp\", \"ico\", \"rss\", \"xml\", \"swf\"}\n)\n \nconst big = 0xFFFFFF\n \nfunc LogPV(urls string) bool {\n    ext := filepath.Ext(urls)\n    if ext == \"\" {\n        return true\n    }\n    for _, v := range NotPV {\n        if v == strings.ToLower(ext) {\n            return false\n        }\n    }\n    return true\n}\n```\n\n### 3.4. view逻辑\n\n`Controller中的this.TplName = \"index.tpl\"`，设置显示的模板文件，默认支持 `tpl` 和 `html` 的后缀名，如果想设置其他后缀你可以调用 `beego.AddTemplateExt` 接口设置。beego 采用了 Go 语言默认的模板引擎，和 Go 的模板语法一样。\n\n```html\n<!DOCTYPE html>\n \n<html>\n    <head>\n        <title>Beego</title>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n    </head>\n     \n    <body>\n        <header class=\"hero-unit\" style=\"background-color:#A9F16C\">\n            <div class=\"container\">\n            <div class=\"row\">\n              <div class=\"hero-text\">\n                <h1>Welcome to Beego!</h1>\n                <p class=\"description\">\n                    Beego is a simple & powerful Go web framework which is inspired by tornado and sinatra.\n                <br />\n                    Official website: <a href=\"http://{{.Website}}\">{{.Website}}</a>\n                <br />\n                    Contact me: {{.Email}}\n                </p>\n              </div>\n            </div>\n            </div>\n        </header>\n    </body>\n</html>\n```\n\nController 里面把数据赋值给了 data（map 类型），然后在模板中就直接通过 key 访问 `.Website` 和 `.Email` 。这样就做到了数据的输出。\n\n### 3.5. 静态文件\n\n网页往往包含了很多的静态文件，包括图片、JS、CSS 等\n\n```shell\n├── static\n    │   ├── css\n    │   ├── img\n    │   └── js\n```\n\nbeego 默认注册了 static 目录为静态处理的目录，注册样式：URL 前缀和映射的目录（在/main.go文件中beego.Run()之前加入）：\n\n```go\nStaticDir[\"/static\"] = \"static\"\n```\n\n用户可以设置多个静态文件处理目录，例如你有多个文件下载目录 download1、download2，你可以这样映射（在/main.go文件中beego.Run()之前加入）：\n\n```go\nbeego.SetStaticPath(\"/down1\", \"download1\") beego.SetStaticPath(\"/down2\", \"download2\")\n```\n\n这样用户访问 URL `http://localhost:8080/down1/123.txt` 则会请求 download1 目录下的 123.txt 文件。\n\n \n\n参考：\n\n[https://beego.me/docs/intro/](https://beego.me/docs/intro/)\n\n ","slug":"Golang/beego/beego介绍","published":1,"updated":"2017-10-03T06:12:35.829Z","_id":"cj8b7jgj2000a2cvue872b4nf","comments":1,"layout":"post","photos":[],"link":"","content":"<h2><span id=\"1-beego的使用\">1. beego的使用</span></h2>\n<h3><span id=\"11-beego的安装\">1.1. beego的安装</span></h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">go</span> get github.com/astaxie/beego</div></pre></td></tr></table></figure>\n<h3><span id=\"12-beego的升级\">1.2. beego的升级</span></h3>\n<p>1、直接升级</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">go</span> get -u github.com/astaxie/beego</div></pre></td></tr></table></figure>\n<p>2、源码下载升级</p>\n<p>用户访问 <code>https://github.com/astaxie/beego</code> ,下载源码，然后覆盖到 <code>$GOPATH/src/github.com/astaxie/beego</code> 目录，然后通过本地执行安装就可以升级了：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">go</span> install  github.com/astaxie/beego</div></pre></td></tr></table></figure>\n<h3><span id=\"13-bee工具\">1.3. bee工具</span></h3>\n<p>bee工具用来进行beego项目的创建、热编译、开发、测试、和部署。</p>\n<p>安装:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">go</span> get github.com/beego/bee</div></pre></td></tr></table></figure>\n<p>配置：</p>\n<p>安装完之后，<code>bee</code>可执行文件默认存放在<code>$GOPATH/bin</code>里面，所以要把<code>$GOPATH/bin</code>添加到环境变量中。</p>\n<h3><span id=\"14-bee命令\">1.4. bee命令</span></h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">Bee is a tool for managing beego framework.</div><div class=\"line\"> </div><div class=\"line\">Usage:</div><div class=\"line\"> </div><div class=\"line\">    bee command [arguments]</div><div class=\"line\"> </div><div class=\"line\">The commands are:</div><div class=\"line\"> </div><div class=\"line\">    new         create an application base on beego framework</div><div class=\"line\">    run         run the app which can hot compile</div><div class=\"line\">    pack        compress an beego project</div><div class=\"line\">    api         create an api application base on beego framework</div><div class=\"line\">    bale        packs non-Go files to Go source files</div><div class=\"line\">    version     show the bee &amp; beego version</div><div class=\"line\">    generate    source code generator</div><div class=\"line\">    migrate     run database migrations</div></pre></td></tr></table></figure>\n<p>说明：</p>\n<h4><span id=\"141-new\">1.4.1. new</span></h4>\n<p>在 <code>$GOPATH/src</code>的目录下执行<code>bee new &lt;appname&gt;</code>，会在当前目录下生成以下文件：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">myproject</div><div class=\"line\">├── conf</div><div class=\"line\">│   └── app.conf</div><div class=\"line\">├── controllers</div><div class=\"line\">│   └── <span class=\"keyword\">default</span>.<span class=\"keyword\">go</span></div><div class=\"line\">├── main.<span class=\"keyword\">go</span></div><div class=\"line\">├── models</div><div class=\"line\">├── routers</div><div class=\"line\">│   └── router.<span class=\"keyword\">go</span></div><div class=\"line\">├── static</div><div class=\"line\">│   ├── css</div><div class=\"line\">│   ├── img</div><div class=\"line\">│   └── js</div><div class=\"line\">├── tests</div><div class=\"line\">│   └── default_test.<span class=\"keyword\">go</span></div><div class=\"line\">└── views</div><div class=\"line\">    └── index.tpl</div></pre></td></tr></table></figure>\n<h4><span id=\"142-run\">1.4.2. run</span></h4>\n<p>必须在<code>$GOPATH/src/appname</code>下执行bee run，默认监听8080端口：<code>http://localhost:8080/。</code></p>\n<h4><span id=\"143-api\">1.4.3. api</span></h4>\n<p><code>api</code> 命令就是用来创建 API 应用，生成以下文件：和 Web 项目相比，少了 static 和 views 目录，多了一个 test 模块，用来做单元测试。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">apiproject</div><div class=\"line\">├── conf</div><div class=\"line\">│   └── app.conf</div><div class=\"line\">├── controllers</div><div class=\"line\">│   └── <span class=\"selector-tag\">object</span>.go</div><div class=\"line\">│   └── user.go</div><div class=\"line\">├── docs</div><div class=\"line\">│   └── doc.go</div><div class=\"line\">├── main.go</div><div class=\"line\">├── models</div><div class=\"line\">│   └── <span class=\"selector-tag\">object</span>.go</div><div class=\"line\">│   └── user.go</div><div class=\"line\">├── routers</div><div class=\"line\">│   └── router.go</div><div class=\"line\">└── tests</div><div class=\"line\">    └── default_test.go</div></pre></td></tr></table></figure>\n<h4><span id=\"144-pack\">1.4.4. pack</span></h4>\n<p><code>pack</code> 目录用来发布应用的时候打包，会把项目打包成 zip 包(<code>apiproject.tar.gz</code>)，这样我们部署的时候直接把打包之后的项目上传，解压就可以部署了：</p>\n<h4><span id=\"145-generate\">1.4.5. generate</span></h4>\n<p>用来自动化的生成代码的，包含了从数据库一键生成model，还包含了scaffold。</p>\n<h4><span id=\"146-migrate\">1.4.6. migrate</span></h4>\n<p>这个命令是应用的数据库迁移命令，主要是用来每次应用升级，降级的SQL管理。</p>\n<h2><span id=\"2-beego的架构\">2. beego的架构</span></h2>\n<p>beego 是一个快速开发 Go 应用的 HTTP 框架，他可以用来快速开发 API、Web 及后端服务等各种应用，是一个 RESTful 的框架。</p>\n<h3><span id=\"21-beego架构图\">2.1. beego架构图</span></h3>\n<p><img src=\"/img/article/golang/beego/architecture.png\" alt=\"architecture\"></p>\n<p>beego 是基于八大独立的模块构建的，是一个高度解耦的框架。</p>\n<p>可以使用 cache 模块来做你的缓存逻辑；使用日志模块来记录你的操作信息；使用 config 模块来解析你各种格式的文件。</p>\n<h3><span id=\"22-beego执行逻辑\">2.2. beego执行逻辑</span></h3>\n<p><img src=\"/img/article/golang/beego/flow.png\" alt=\"flow\"></p>\n<p>文件结构见第一部分：[new]。</p>\n<h2><span id=\"3-beego项目逻辑\">3. beego项目逻辑</span></h2>\n<h3><span id=\"31-路由设置\">3.1. 路由设置</span></h3>\n<h4><span id=\"311-beegorouter\">3.1.1. beego.Router</span></h4>\n<p>入口文件main.go</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    _ <span class=\"string\">\"quickstart/routers\"</span></div><div class=\"line\">    <span class=\"string\">\"github.com/astaxie/beego\"</span></div><div class=\"line\">)</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    beego.Run()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>go中导入包中init函数的执行逻辑</p>\n<p><img src=\"/img/article/golang/beego/init.png\" alt=\"init\"></p>\n<p><code>_ &quot;quickstart/routers&quot;</code>,包只引入执行了里面的init函数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> routers</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"quickstart/controllers\"</span></div><div class=\"line\">    <span class=\"string\">\"github.com/astaxie/beego\"</span></div><div class=\"line\">)</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    beego.Router(<span class=\"string\">\"/\"</span>, &amp;controllers.MainController&#123;&#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>路由包里执行了路由注册<code>beego.Router</code>, 这个函数的功能是映射URL到controller，第一个参数是URL(用户请求的地址)，这里是 <code>/</code>，也就是访问的不带任何参数的URL，第二个参数是对应的 Controller，就是把请求分发到那个控制器来执行相应的逻辑。</p>\n<h4><span id=\"312-beegorun\">3.1.2. beego.Run</span></h4>\n<ul>\n<li>\n<p>解析配置文件</p>\n<p>beego 会自动解析在 conf 目录下面的配置文件 <code>app.conf</code>，通过修改配置文件相关的属性，我们可以定义：开启的端口，是否开启 session，应用名称等信息。</p>\n</li>\n<li>\n<p>执行用户的hookfunc</p>\n<p>beego会执行用户注册的hookfunc，默认的已经存在了注册mime，用户可以通过函数<code>AddAPPStartHook</code>注册自己的启动函数。</p>\n</li>\n<li>\n<p>是否开启 session</p>\n<p>会根据上面配置文件的分析之后判断是否开启 session，如果开启的话就初始化全局的 session。</p>\n</li>\n<li>\n<p>是否编译模板</p>\n<p>beego 会在启动的时候根据配置把 views 目录下的所有模板进行预编译，然后存在 map 里面，这样可以有效的提高模板运行的效率，无需进行多次编译。</p>\n</li>\n<li>\n<p>是否开启文档功能</p>\n<p>根据EnableDocs配置判断是否开启内置的文档路由功能</p>\n</li>\n<li>\n<p>是否启动管理模块</p>\n<p>beego 目前做了一个很酷的模块，应用内监控模块，会在 8088 端口做一个内部监听，我们可以通过这个端口查询到 QPS、CPU、内存、GC、goroutine、thread 等统计信息。</p>\n</li>\n<li>\n<p>监听服务端口</p>\n<p>这是最后一步也就是我们看到的访问 8080 看到的网页端口，内部其实调用了 <code>ListenAndServe</code>，充分利用了 goroutine 的优势，一旦 run 起来之后，我们的服务就监听在两个端口了，一个服务端口 8080 作为对外服务，另一个 8088 端口实行对内监控。</p>\n</li>\n</ul>\n<h3><span id=\"32-controller-逻辑\">3.2. controller 逻辑</span></h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> controllers</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">        <span class=\"string\">\"github.com/astaxie/beego\"</span></div><div class=\"line\">)</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">type</span> MainController <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">        beego.Controller</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MainController)</span> <span class=\"title\">Get</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        this.Data[<span class=\"string\">\"Website\"</span>] = <span class=\"string\">\"beego.me\"</span></div><div class=\"line\">        this.Data[<span class=\"string\">\"Email\"</span>] = <span class=\"string\">\"astaxie@gmail.com\"</span></div><div class=\"line\">        this.TplName = <span class=\"string\">\"index.tpl\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>1、声明了一个控制器 <code>MainController</code>，这个控制器里面内嵌了 <code>beego.Controller</code>，即Go 的嵌入方式，也就是 <code>MainController</code> 自动拥有了所有 <code>beego.Controller</code> 的方法。而 <code>beego.Controller</code> 拥有很多方法，其中包括 <code>Init</code>、<code>Prepare</code>、<code>Post</code>、<code>Get</code>、<code>Delete</code>、<code>Head</code>等方法。可以通过重写的方式来实现这些方法，以上例子重写了 <code>Get</code> 方法。</p>\n<p>2、beego 是一个 RESTful 的框架，请求默认是执行对应 <code>req.Method</code> 的方法。例如浏览器的是 <code>GET</code> 请求，那么默认就会执行 <code>MainController</code> 下的 <code>Get</code> 方法。（用户可以改变这个行为，通过注册自定义的函数名）。</p>\n<p>3、获取数据，赋值到 <code>this.Data</code> 中，这是一个用来存储输出数据的 map。</p>\n<p>4、渲染模板，<code>this.TplName</code> 就是需要渲染的模板，这里指定了 <code>index.tpl</code>，如果用户不设置该参数，那么默认会去到模板目录的 <code>Controller/&lt;方法名&gt;.tpl</code> 查找，例如上面的方法会去 <code>maincontroller/get.tpl</code>(文件、文件夹必须小写)。用户设置了模板之后系统会自动的调用 <code>Render</code> 函数（这个函数是在 beego.Controller 中实现的），所以无需用户自己来调用渲染。</p>\n<p>5、如果不使用模板可以直接输出：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MainController)</span> <span class=\"title\">Get</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        this.Ctx.WriteString(<span class=\"string\">\"hello\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"33-model逻辑\">3.3. model逻辑</span></h3>\n<p>model一般用来处理数据库操作，如果逻辑中存在可以复用的部分就可以抽象成一个model。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> models</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"loggo/utils\"</span></div><div class=\"line\">    <span class=\"string\">\"path/filepath\"</span></div><div class=\"line\">    <span class=\"string\">\"strconv\"</span></div><div class=\"line\">    <span class=\"string\">\"strings\"</span></div><div class=\"line\">)</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">var</span> (</div><div class=\"line\">    NotPV []<span class=\"keyword\">string</span> = []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"css\"</span>, <span class=\"string\">\"js\"</span>, <span class=\"string\">\"class\"</span>, <span class=\"string\">\"gif\"</span>, <span class=\"string\">\"jpg\"</span>, <span class=\"string\">\"jpeg\"</span>, <span class=\"string\">\"png\"</span>, <span class=\"string\">\"bmp\"</span>, <span class=\"string\">\"ico\"</span>, <span class=\"string\">\"rss\"</span>, <span class=\"string\">\"xml\"</span>, <span class=\"string\">\"swf\"</span>&#125;</div><div class=\"line\">)</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">const</span> big = <span class=\"number\">0xFFFFFF</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LogPV</span><span class=\"params\">(urls <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</div><div class=\"line\">    ext := filepath.Ext(urls)</div><div class=\"line\">    <span class=\"keyword\">if</span> ext == <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> NotPV &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> v == strings.ToLower(ext) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"34-view逻辑\">3.4. view逻辑</span></h3>\n<p><code>Controller中的this.TplName = &quot;index.tpl&quot;</code>，设置显示的模板文件，默认支持 <code>tpl</code> 和 <code>html</code> 的后缀名，如果想设置其他后缀你可以调用 <code>beego.AddTemplateExt</code> 接口设置。beego 采用了 Go 语言默认的模板引擎，和 Go 的模板语法一样。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Beego<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Content-Type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"text/html; charset=utf-8\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">     </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">header</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hero-unit\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background-color:#A9F16C\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></div><div class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hero-text\"</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome to Beego!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"description\"</span>&gt;</span></div><div class=\"line\">                    Beego is a simple &amp; powerful Go web framework which is inspired by tornado and sinatra.</div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></div><div class=\"line\">                    Official website: <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://&#123;&#123;.Website&#125;&#125;\"</span>&gt;</span>&#123;&#123;.Website&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></div><div class=\"line\">                    Contact me: &#123;&#123;.Email&#125;&#125;</div><div class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Controller 里面把数据赋值给了 data（map 类型），然后在模板中就直接通过 key 访问 <code>.Website</code> 和 <code>.Email</code> 。这样就做到了数据的输出。</p>\n<h3><span id=\"35-静态文件\">3.5. 静态文件</span></h3>\n<p>网页往往包含了很多的静态文件，包括图片、JS、CSS 等</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── static</div><div class=\"line\">    │   ├── css</div><div class=\"line\">    │   ├── img</div><div class=\"line\">    │   └── js</div></pre></td></tr></table></figure>\n<p>beego 默认注册了 static 目录为静态处理的目录，注册样式：URL 前缀和映射的目录（在/main.go文件中beego.Run()之前加入）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">StaticDir[<span class=\"string\">\"/static\"</span>] = <span class=\"string\">\"static\"</span></div></pre></td></tr></table></figure>\n<p>用户可以设置多个静态文件处理目录，例如你有多个文件下载目录 download1、download2，你可以这样映射（在/main.go文件中beego.Run()之前加入）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">beego.SetStaticPath(<span class=\"string\">\"/down1\"</span>, <span class=\"string\">\"download1\"</span>) beego.SetStaticPath(<span class=\"string\">\"/down2\"</span>, <span class=\"string\">\"download2\"</span>)</div></pre></td></tr></table></figure>\n<p>这样用户访问 URL <code>http://localhost:8080/down1/123.txt</code> 则会请求 download1 目录下的 123.txt 文件。</p>\n<p>参考：</p>\n<p><a href=\"https://beego.me/docs/intro/\" target=\"_blank\" rel=\"external\">https://beego.me/docs/intro/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. beego的使用</h2>\n<h3>1.1. beego的安装</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">go</span> get github.com/astaxie/beego</div></pre></td></tr></table></figure>\n<h3>1.2. beego的升级</h3>\n<p>1、直接升级</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">go</span> get -u github.com/astaxie/beego</div></pre></td></tr></table></figure>\n<p>2、源码下载升级</p>\n<p>用户访问 <code>https://github.com/astaxie/beego</code> ,下载源码，然后覆盖到 <code>$GOPATH/src/github.com/astaxie/beego</code> 目录，然后通过本地执行安装就可以升级了：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">go</span> install  github.com/astaxie/beego</div></pre></td></tr></table></figure>\n<h3>1.3. bee工具</h3>\n<p>bee工具用来进行beego项目的创建、热编译、开发、测试、和部署。</p>\n<p>安装:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">go</span> get github.com/beego/bee</div></pre></td></tr></table></figure>\n<p>配置：</p>\n<p>安装完之后，<code>bee</code>可执行文件默认存放在<code>$GOPATH/bin</code>里面，所以要把<code>$GOPATH/bin</code>添加到环境变量中。</p>\n<h3>1.4. bee命令</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">Bee is a tool for managing beego framework.</div><div class=\"line\"> </div><div class=\"line\">Usage:</div><div class=\"line\"> </div><div class=\"line\">    bee command [arguments]</div><div class=\"line\"> </div><div class=\"line\">The commands are:</div><div class=\"line\"> </div><div class=\"line\">    new         create an application base on beego framework</div><div class=\"line\">    run         run the app which can hot compile</div><div class=\"line\">    pack        compress an beego project</div><div class=\"line\">    api         create an api application base on beego framework</div><div class=\"line\">    bale        packs non-Go files to Go source files</div><div class=\"line\">    version     show the bee &amp; beego version</div><div class=\"line\">    generate    source code generator</div><div class=\"line\">    migrate     run database migrations</div></pre></td></tr></table></figure>\n<p>说明：</p>\n<h4>1.4.1. new</h4>\n<p>在 <code>$GOPATH/src</code>的目录下执行<code>bee new &lt;appname&gt;</code>，会在当前目录下生成以下文件：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">myproject</div><div class=\"line\">├── conf</div><div class=\"line\">│   └── app.conf</div><div class=\"line\">├── controllers</div><div class=\"line\">│   └── <span class=\"keyword\">default</span>.<span class=\"keyword\">go</span></div><div class=\"line\">├── main.<span class=\"keyword\">go</span></div><div class=\"line\">├── models</div><div class=\"line\">├── routers</div><div class=\"line\">│   └── router.<span class=\"keyword\">go</span></div><div class=\"line\">├── static</div><div class=\"line\">│   ├── css</div><div class=\"line\">│   ├── img</div><div class=\"line\">│   └── js</div><div class=\"line\">├── tests</div><div class=\"line\">│   └── default_test.<span class=\"keyword\">go</span></div><div class=\"line\">└── views</div><div class=\"line\">    └── index.tpl</div></pre></td></tr></table></figure>\n<h4>1.4.2. run</h4>\n<p>必须在<code>$GOPATH/src/appname</code>下执行bee run，默认监听8080端口：<code>http://localhost:8080/。</code></p>\n<h4>1.4.3. api</h4>\n<p><code>api</code> 命令就是用来创建 API 应用，生成以下文件：和 Web 项目相比，少了 static 和 views 目录，多了一个 test 模块，用来做单元测试。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">apiproject</div><div class=\"line\">├── conf</div><div class=\"line\">│   └── app.conf</div><div class=\"line\">├── controllers</div><div class=\"line\">│   └── <span class=\"selector-tag\">object</span>.go</div><div class=\"line\">│   └── user.go</div><div class=\"line\">├── docs</div><div class=\"line\">│   └── doc.go</div><div class=\"line\">├── main.go</div><div class=\"line\">├── models</div><div class=\"line\">│   └── <span class=\"selector-tag\">object</span>.go</div><div class=\"line\">│   └── user.go</div><div class=\"line\">├── routers</div><div class=\"line\">│   └── router.go</div><div class=\"line\">└── tests</div><div class=\"line\">    └── default_test.go</div></pre></td></tr></table></figure>\n<h4>1.4.4. pack</h4>\n<p><code>pack</code> 目录用来发布应用的时候打包，会把项目打包成 zip 包(<code>apiproject.tar.gz</code>)，这样我们部署的时候直接把打包之后的项目上传，解压就可以部署了：</p>\n<h4>1.4.5. generate</h4>\n<p>用来自动化的生成代码的，包含了从数据库一键生成model，还包含了scaffold。</p>\n<h4>1.4.6. migrate</h4>\n<p>这个命令是应用的数据库迁移命令，主要是用来每次应用升级，降级的SQL管理。</p>\n<h2>2. beego的架构</h2>\n<p>beego 是一个快速开发 Go 应用的 HTTP 框架，他可以用来快速开发 API、Web 及后端服务等各种应用，是一个 RESTful 的框架。</p>\n<h3>2.1. beego架构图</h3>\n<p><img src=\"/img/article/golang/beego/architecture.png\" alt=\"architecture\"></p>\n<p>beego 是基于八大独立的模块构建的，是一个高度解耦的框架。</p>\n<p>可以使用 cache 模块来做你的缓存逻辑；使用日志模块来记录你的操作信息；使用 config 模块来解析你各种格式的文件。</p>\n<h3>2.2. beego执行逻辑</h3>\n<p><img src=\"/img/article/golang/beego/flow.png\" alt=\"flow\"></p>\n<p>文件结构见第一部分：[new]。</p>\n<h2>3. beego项目逻辑</h2>\n<h3>3.1. 路由设置</h3>\n<h4>3.1.1. beego.Router</h4>\n<p>入口文件main.go</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    _ <span class=\"string\">\"quickstart/routers\"</span></div><div class=\"line\">    <span class=\"string\">\"github.com/astaxie/beego\"</span></div><div class=\"line\">)</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    beego.Run()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>go中导入包中init函数的执行逻辑</p>\n<p><img src=\"/img/article/golang/beego/init.png\" alt=\"init\"></p>\n<p><code>_ &quot;quickstart/routers&quot;</code>,包只引入执行了里面的init函数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> routers</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"quickstart/controllers\"</span></div><div class=\"line\">    <span class=\"string\">\"github.com/astaxie/beego\"</span></div><div class=\"line\">)</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    beego.Router(<span class=\"string\">\"/\"</span>, &amp;controllers.MainController&#123;&#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>路由包里执行了路由注册<code>beego.Router</code>, 这个函数的功能是映射URL到controller，第一个参数是URL(用户请求的地址)，这里是 <code>/</code>，也就是访问的不带任何参数的URL，第二个参数是对应的 Controller，就是把请求分发到那个控制器来执行相应的逻辑。</p>\n<h4>3.1.2. beego.Run</h4>\n<ul>\n<li>\n<p>解析配置文件</p>\n<p>beego 会自动解析在 conf 目录下面的配置文件 <code>app.conf</code>，通过修改配置文件相关的属性，我们可以定义：开启的端口，是否开启 session，应用名称等信息。</p>\n</li>\n<li>\n<p>执行用户的hookfunc</p>\n<p>beego会执行用户注册的hookfunc，默认的已经存在了注册mime，用户可以通过函数<code>AddAPPStartHook</code>注册自己的启动函数。</p>\n</li>\n<li>\n<p>是否开启 session</p>\n<p>会根据上面配置文件的分析之后判断是否开启 session，如果开启的话就初始化全局的 session。</p>\n</li>\n<li>\n<p>是否编译模板</p>\n<p>beego 会在启动的时候根据配置把 views 目录下的所有模板进行预编译，然后存在 map 里面，这样可以有效的提高模板运行的效率，无需进行多次编译。</p>\n</li>\n<li>\n<p>是否开启文档功能</p>\n<p>根据EnableDocs配置判断是否开启内置的文档路由功能</p>\n</li>\n<li>\n<p>是否启动管理模块</p>\n<p>beego 目前做了一个很酷的模块，应用内监控模块，会在 8088 端口做一个内部监听，我们可以通过这个端口查询到 QPS、CPU、内存、GC、goroutine、thread 等统计信息。</p>\n</li>\n<li>\n<p>监听服务端口</p>\n<p>这是最后一步也就是我们看到的访问 8080 看到的网页端口，内部其实调用了 <code>ListenAndServe</code>，充分利用了 goroutine 的优势，一旦 run 起来之后，我们的服务就监听在两个端口了，一个服务端口 8080 作为对外服务，另一个 8088 端口实行对内监控。</p>\n</li>\n</ul>\n<h3>3.2. controller 逻辑</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> controllers</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">        <span class=\"string\">\"github.com/astaxie/beego\"</span></div><div class=\"line\">)</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">type</span> MainController <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">        beego.Controller</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MainController)</span> <span class=\"title\">Get</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        this.Data[<span class=\"string\">\"Website\"</span>] = <span class=\"string\">\"beego.me\"</span></div><div class=\"line\">        this.Data[<span class=\"string\">\"Email\"</span>] = <span class=\"string\">\"astaxie@gmail.com\"</span></div><div class=\"line\">        this.TplName = <span class=\"string\">\"index.tpl\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>1、声明了一个控制器 <code>MainController</code>，这个控制器里面内嵌了 <code>beego.Controller</code>，即Go 的嵌入方式，也就是 <code>MainController</code> 自动拥有了所有 <code>beego.Controller</code> 的方法。而 <code>beego.Controller</code> 拥有很多方法，其中包括 <code>Init</code>、<code>Prepare</code>、<code>Post</code>、<code>Get</code>、<code>Delete</code>、<code>Head</code>等方法。可以通过重写的方式来实现这些方法，以上例子重写了 <code>Get</code> 方法。</p>\n<p>2、beego 是一个 RESTful 的框架，请求默认是执行对应 <code>req.Method</code> 的方法。例如浏览器的是 <code>GET</code> 请求，那么默认就会执行 <code>MainController</code> 下的 <code>Get</code> 方法。（用户可以改变这个行为，通过注册自定义的函数名）。</p>\n<p>3、获取数据，赋值到 <code>this.Data</code> 中，这是一个用来存储输出数据的 map。</p>\n<p>4、渲染模板，<code>this.TplName</code> 就是需要渲染的模板，这里指定了 <code>index.tpl</code>，如果用户不设置该参数，那么默认会去到模板目录的 <code>Controller/&lt;方法名&gt;.tpl</code> 查找，例如上面的方法会去 <code>maincontroller/get.tpl</code>(文件、文件夹必须小写)。用户设置了模板之后系统会自动的调用 <code>Render</code> 函数（这个函数是在 beego.Controller 中实现的），所以无需用户自己来调用渲染。</p>\n<p>5、如果不使用模板可以直接输出：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MainController)</span> <span class=\"title\">Get</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        this.Ctx.WriteString(<span class=\"string\">\"hello\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>3.3. model逻辑</h3>\n<p>model一般用来处理数据库操作，如果逻辑中存在可以复用的部分就可以抽象成一个model。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> models</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"loggo/utils\"</span></div><div class=\"line\">    <span class=\"string\">\"path/filepath\"</span></div><div class=\"line\">    <span class=\"string\">\"strconv\"</span></div><div class=\"line\">    <span class=\"string\">\"strings\"</span></div><div class=\"line\">)</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">var</span> (</div><div class=\"line\">    NotPV []<span class=\"keyword\">string</span> = []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"css\"</span>, <span class=\"string\">\"js\"</span>, <span class=\"string\">\"class\"</span>, <span class=\"string\">\"gif\"</span>, <span class=\"string\">\"jpg\"</span>, <span class=\"string\">\"jpeg\"</span>, <span class=\"string\">\"png\"</span>, <span class=\"string\">\"bmp\"</span>, <span class=\"string\">\"ico\"</span>, <span class=\"string\">\"rss\"</span>, <span class=\"string\">\"xml\"</span>, <span class=\"string\">\"swf\"</span>&#125;</div><div class=\"line\">)</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">const</span> big = <span class=\"number\">0xFFFFFF</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LogPV</span><span class=\"params\">(urls <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</div><div class=\"line\">    ext := filepath.Ext(urls)</div><div class=\"line\">    <span class=\"keyword\">if</span> ext == <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> NotPV &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> v == strings.ToLower(ext) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>3.4. view逻辑</h3>\n<p><code>Controller中的this.TplName = &quot;index.tpl&quot;</code>，设置显示的模板文件，默认支持 <code>tpl</code> 和 <code>html</code> 的后缀名，如果想设置其他后缀你可以调用 <code>beego.AddTemplateExt</code> 接口设置。beego 采用了 Go 语言默认的模板引擎，和 Go 的模板语法一样。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Beego<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Content-Type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"text/html; charset=utf-8\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">     </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">header</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hero-unit\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"background-color:#A9F16C\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></div><div class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hero-text\"</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome to Beego!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"description\"</span>&gt;</span></div><div class=\"line\">                    Beego is a simple &amp; powerful Go web framework which is inspired by tornado and sinatra.</div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></div><div class=\"line\">                    Official website: <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://&#123;&#123;.Website&#125;&#125;\"</span>&gt;</span>&#123;&#123;.Website&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></div><div class=\"line\">                    Contact me: &#123;&#123;.Email&#125;&#125;</div><div class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Controller 里面把数据赋值给了 data（map 类型），然后在模板中就直接通过 key 访问 <code>.Website</code> 和 <code>.Email</code> 。这样就做到了数据的输出。</p>\n<h3>3.5. 静态文件</h3>\n<p>网页往往包含了很多的静态文件，包括图片、JS、CSS 等</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── static</div><div class=\"line\">    │   ├── css</div><div class=\"line\">    │   ├── img</div><div class=\"line\">    │   └── js</div></pre></td></tr></table></figure>\n<p>beego 默认注册了 static 目录为静态处理的目录，注册样式：URL 前缀和映射的目录（在/main.go文件中beego.Run()之前加入）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">StaticDir[<span class=\"string\">\"/static\"</span>] = <span class=\"string\">\"static\"</span></div></pre></td></tr></table></figure>\n<p>用户可以设置多个静态文件处理目录，例如你有多个文件下载目录 download1、download2，你可以这样映射（在/main.go文件中beego.Run()之前加入）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">beego.SetStaticPath(<span class=\"string\">\"/down1\"</span>, <span class=\"string\">\"download1\"</span>) beego.SetStaticPath(<span class=\"string\">\"/down2\"</span>, <span class=\"string\">\"download2\"</span>)</div></pre></td></tr></table></figure>\n<p>这样用户访问 URL <code>http://localhost:8080/down1/123.txt</code> 则会请求 download1 目录下的 123.txt 文件。</p>\n<p>参考：</p>\n<p><a href=\"https://beego.me/docs/intro/\" target=\"_blank\" rel=\"external\">https://beego.me/docs/intro/</a></p>\n"},{"title":"[Golang] Golang常用包","catalog":true,"date":"2017-09-10T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Golang"],"_content":"\n## 一、常用包\n\n| 常用包           | 说明                                       | 常用函数 |\n| ------------- | ---------------------------------------- | ---- |\n| fmt           | 实现格式化的输入输出操作，其中的fmt.Printf()和fmt.Println()是开发者使用最为频繁的函数。 |      |\n| io            | 实现了一系列非平台相关的IO相关接口和实现，比如提供了对os中系统相关的IO功能的封装。我们在进行流式读写（比如读写文件）时，通常会用到该包。 |      |\n| bufio         | 它在io的基础上提供了缓存功能。在具备了缓存功能后， bufio可以比较方便地提供ReadLine之类的操作。 |      |\n| strconv       | 提供字符串与基本数据类型互转的能力。                       |      |\n| os            | 本包提供了对操作系统功能的非平台相关访问接口。接口为Unix风格。提供的功能包括文件操作、进程管理、信号和用户账号等。 |      |\n| sync          | 它提供了基本的同步原语。在多个goroutine访问共享资源的时候，需要使用sync中提供的锁机制。 |      |\n| flag          | 它提供命令行参数的规则定义和传入参数解析的功能。绝大部分的命令行程序都需要用到这个包。 |      |\n| encoding/json | JSON目前广泛用做网络程序中的通信格式。本包提供了对JSON的基本支持，比如从一个对象序列化为JSON字符串，或者从JSON字符串反序列化出一个具体的对象等。 |      |\n| http          | 通过http包，只需要数行代码，即可实现一个爬虫或者一个Web服务器，这在传统语言中是无法想象的。 |      |\n\n## 二、完整包列表\n\n| 目录             | 包                                        | 说明                                       |\n| -------------- | ---------------------------------------- | ---------------------------------------- |\n| 目录             | 包                                        | 说明                                       |\n|                | bufio                                    | 实现缓冲的I/O                                 |\n| bytes          | 提供了对字节切片操作的函数                            |                                          |\n| crypto         | 收集了常见的加密常数                               |                                          |\n| errors         | 实现了操作错误的函数                               |                                          |\n| Expvar         | 为公共变量提供了一个标准的接口，如服务器中的运算计数器              |                                          |\n| flag           | 实现了命令行标记解析                               |                                          |\n| fmt            | 实现了格式化输入输出                               |                                          |\n| hash           | 提供了哈希函数接口                                |                                          |\n| html           | 实现了一个HTML5兼容的分词器和解析器                     |                                          |\n| image          | 实现了一个基本的二维图像库                            |                                          |\n| io             | 提供了对I/O原语的基本接口                           |                                          |\n| log            | 它是一个简单的记录包，提供最基本的日志功能                    |                                          |\n| math           | 提供了一些基本的常量和数学函数                          |                                          |\n| mine           | 实现了部分的MIME规范                             |                                          |\n| net            | 提供了一个对UNIX网络套接字的可移植接口，包括TCP/IP、 UDP域名解析和UNIX域套接字 |                                          |\n| os             | 为操作系统功能实现了一个平台无关的接口                      |                                          |\n| path           | 实现了对斜线分割的文件名路径的操作                        |                                          |\n| reflect        | 实现了运行时反射，允许一个程序以任意类型操作对象                 |                                          |\n| regexp         | 实现了一个简单的正则表达式库                           |                                          |\n| runtime        | 包含与Go运行时系统交互的操作，如控制goroutine的函数          |                                          |\n| sort           | 提供对集合排序的基础函数集                            |                                          |\n| strconv        | 实现了在基本数据类型和字符串之间的转换                      |                                          |\n| strings        | 实现了操作字符串的简单函数                            |                                          |\n| sync           | 提供了基本的同步机制，如互斥锁                          |                                          |\n| syscall        | 包含一个低级的操作系统原语的接口                         |                                          |\n| testing        | 提供对自动测试Go包的支持                            |                                          |\n| time           | 提供测量和显示时间的功能                             |                                          |\n| unicode        | Unicode编码相关的基础函数                         |                                          |\n| archive        | tar                                      | 实现对tar压缩文档的访问                            |\n| zip            | 提供对ZIP压缩文档的读和写支持                         |                                          |\n| compress       | bzip2                                    | 实现了bzip2解压缩                              |\n| flate          | 实现了RFC 1951中所定义的DEFLATE压缩数据格式            |                                          |\n| gzip           | 实现了RFC 1951中所定义的gzip格式压缩文件的读和写           |                                          |\n| lzw            | 实现了 Lempel-Ziv-Welch编码格式的压缩的数据格式         |                                          |\n| zlib           | 实现了RFC 1950中所定义的zlib格式压缩数据的读和写           |                                          |\n| container      | heap                                     | 提供了实现heap.Interface接口的任何类型的堆操作           |\n| lsit           | 实现了一个双链表                                 |                                          |\n| ring           | 实现了对循环链表的操作                              |                                          |\n| crypto         | aes                                      | 实现了AES加密（以前的Rijndael）                    |\n| cipher         | 实现了标准的密码块模式，该模式可包装进低级的块加密实现中             |                                          |\n| des            | 实现了数据加密标准（ Data Encryption Standard，DES）和三重数据加密算法（ TripleData Encryption Algorithm， TDEA） |                                          |\n| dsa            | 实现了FIPS 186-3所定义的数据签名算法（ Digital Signature Algorithm） |                                          |\n| ecdsa          | 实现了FIPS 186-3所定义的椭圆曲线数据签名算法（ Elliptic Curve Digital SignatureAlgorithm） |                                          |\n| elliptic       | 实现了素数域上几个标准的椭圆曲线                         |                                          |\n| hmac           | 实现了键控哈希消息身份验证码（ Keyed-Hash Message Authentication Code，HMAC） |                                          |\n| md5            | 实现了RFC 1321中所定义的MD5哈希算法                  |                                          |\n| rand           | 实现了一个加密安全的伪随机数生成器                        |                                          |\n| rc4            | 实现了RC4加密，其定义见Bruce Schneier的应用密码学（ Applied Cryptography） |                                          |\n| rsa            | 实现了PKCS#1中所定义的RSA加密                      |                                          |\n| sha1           | 实现了RFC 3174中所定义的SHA1哈希算法                 |                                          |\n| sha256         | 实现了FIPS 180-2中所定义的SHA224和SHA256哈希算法      |                                          |\n| sha512         | 实现了FIPS 180-2中所定义的SHA384和SHA512哈希算法      |                                          |\n| subtle         | 实现了一些有用的加密函数，但需要仔细考虑以便正确应用它们             |                                          |\n| tls            | 部分实现了RFC 4346所定义的TLS 1.1协议               |                                          |\n| x509           | 可解析X.509编码的键值和证书                         |                                          |\n| x509/pkix      | 包含用于对X.509证书、 CRL和OCSP的ASN.1解析和序列化的共享的、低级的结构 |                                          |\n| database       | sql                                      | 围绕SQL提供了一个通用的接口                          |\n| sql/driver     | 定义了数据库驱动所需实现的接口，同sql包的使用方式               |                                          |\n| debug          | dwarf                                    | 提供了对从可执行文件加载的DWARF调试信息的访问，这个包对于实现Go语言的调试器非常有价值 |\n| elf            | 实现了对ELF对象文件的访问。 ELF是一种常见的二进制可执行文件和共享库的文件格式。 Linux采用了ELF格式 |                                          |\n| gosym          | 访问Go语言二进制程序中的调试信息。对于可视化调试很有价值            |                                          |\n| macho          | 实现了对[http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/](http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/)MachORuntime/Reference/reference.html 所定义的Mach-O对象文件的访问 |                                          |\n| pe             | 实现了对PE（ Microsoft Windows Portable Executable）文件的访问 |                                          |\n| encoding       | ascii85                                  | 实现了ascii85数据编码，用于btoa工具和Adobe’s PostScript以及PDF文档格式 |\n| asn1           | 实现了解析DER编码的ASN.1数据结构，其定义见ITU-T Rec X.690 |                                          |\n| base32         | 实现了RFC 4648中所定义的base32编码                 |                                          |\n| base64         | 实现了RFC 4648中所定义的base64编码                 |                                          |\n| binary         | 实现了在无符号整数值和字节串之间的转化，以及对固定尺寸值的读和写         |                                          |\n| csv            | 可读和写由逗号分割的数值（ csv）文件                     |                                          |\n| gob            | 管理gob流——在编码器（发送者）和解码器（接收者）之间进行二进制值交换     |                                          |\n| hex            | 实现了十六进制的编码和解码                            |                                          |\n| json           | 实现了定义于RFC 4627中的JSON对象的编码和解码             |                                          |\n| pem            | 实现了PEM（ Privacy Enhanced Mail）数据编码       |                                          |\n| xml            | 实现了一个简单的可理解XML名字空间的XML 1.0解析器            |                                          |\n| go             | ast                                      | 声明了用于展示Go包中的语法树类型                        |\n| build          | 提供了构建Go包的工具                              |                                          |\n| doc            | 从一个Go AST（抽象语法树）中提取源代码文档                 |                                          |\n| parser         | 实现了一个Go源文件解析器                            |                                          |\n| printer        | 实现了对AST（抽象语法树）的打印                        |                                          |\n| scanner        | 实现了一个Go源代码文本的扫描器                         |                                          |\n| token          | 定义了代表Go编程语言中词法标记以及基本操作标记（ printing、 predicates）的常量 |                                          |\n| hash           | adler32                                  | 实现了Adler-32校验和                           |\n| crc32          | 实现了32位的循环冗余校验或CRC-32校验和                  |                                          |\n| crc64          | 实现了64位的循环冗余校验或CRC-64校验和                  |                                          |\n| fnv            | 实现了Glenn Fowler、 Landon Curt Noll和Phong Vo所创建的FNV-1和FNV-1a未加密哈希函数 |                                          |\n| html           | template                                 | 它自动构建HTML输出，并可防止代码注入                     |\n| image          | color                                    | 实现了一个基本的颜色库                              |\n| draw           | 提供一些做图函数                                 |                                          |\n| gif            | 实现了一个GIF图像解码器                            |                                          |\n| jpeg           | 实现了一个JPEG图像解码器和编码器                       |                                          |\n| png            | 实现了一个PNG图像解码器和编码器                        |                                          |\n| index          | suffixarray                              | 通过构建内存索引实现的高速字符串匹配查找算法                   |\n| io             | ioutil                                   | 实现了一些实用的I/O函数                            |\n| log            | syslog                                   | 提供了对系统日志服务的简单接口                          |\n| math           | big                                      | 实现了多精度的算术运算（大数）                          |\n| cmplx          | 为复数提供了基本的常量和数学函数                         |                                          |\n| rand           | 实现了伪随机数生成器                               |                                          |\n| mime           | multipart                                | 实现了在RFC 2046中定义的MIME多个部分的解析              |\n| net            | http                                     | 提供了HTTP客户端和服务器的实现                        |\n| mail           | 实现了对邮件消息的解析                              |                                          |\n| rpc            | 提供了对一个来自网络或其他I/O连接的对象可导出的方法的访问           |                                          |\n| smtp           | 实现了定义于RFC 5321中的简单邮件传输协议（ Simple Mail Transfer Protocol) |                                          |\n| textproto      | 实现了在HTTP、 NNTP和SMTP中基于文本的通用的请求/响应协议      |                                          |\n| url            | 解析URL并实现查询转义                             |                                          |\n| http/cgi       | 实现了定义于RFC 3875中的CGI（通用网关接口）              |                                          |\n| http/fcgi      | 实现了FastCGI协议                             |                                          |\n| http/httptest  | 提供了一些HTTP测试应用                            |                                          |\n| http/httputil  | 提供了一些HTTP应用函数，这些是对net/http包中的东西的补充，只不过相对不太常用 |                                          |\n| http/pprof     | 通过其HTTP服务器运行时提供性能测试数据，该数据的格式正是pprof可视化工具需要的 |                                          |\n| rpc/jsonrpc    | 为rpc包实现了一个JSON-RPC ClientCodec和ServerCodec |                                          |\n| os             | exec                                     | 可运行外部命令                                  |\n| user           | 通过名称和id进行用户账户检查                          |                                          |\n| path           | filepath                                 | 实现了以与目标操作系统定义文件路径相兼容的方式处理文件名路径           |\n| regexp         | syntax                                   | 将正则表达式解析为语法树                             |\n| runtime        | debug                                    | 包含当程序在运行时调试其自身的功能                        |\n| pprof          | 以pprof可视化工具需要的格式写运行时性能测试数据               |                                          |\n| sync           | atomic                                   | 提供了低级的用于实现同步算法的原子级的内存机制                  |\n| testing        | iotest                                   | 提供一系列测试目的的类型，实现了Reader和Writer标准接口        |\n| quick          | 实现了用于黑箱测试的实用函数                           |                                          |\n| script         | 帮助测试使用通道的代码                              |                                          |\n| text           | scanner                                  | 为UTF-8文本提供了一个扫描器和分词器                     |\n| tabwriter      | 实现了一个写筛选器（ tabwriter.Writer），它可将一个输入的tab分割的列翻译为适当对齐的文本 |                                          |\n| template       | 数据驱动的模板引擎，用于生成类似HTML的文本输出格式              |                                          |\n| template/parse | 为template构建解析树                           |                                          |\n| unicode/utf16  | 实现了UTF-16序列的的编码和解码                       |                                          |\n| unicode/utf8   | 实现了支持以UTF-8编码的文本的函数和常数                   |                                          |","source":"_posts/Golang/Golang常用包.md","raw":"---\ntitle: \"[Golang] Golang常用包\"\ncatalog: true\ndate: 2017-09-10 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Golang\ncatagories:\n- Golang\n---\n\n## 一、常用包\n\n| 常用包           | 说明                                       | 常用函数 |\n| ------------- | ---------------------------------------- | ---- |\n| fmt           | 实现格式化的输入输出操作，其中的fmt.Printf()和fmt.Println()是开发者使用最为频繁的函数。 |      |\n| io            | 实现了一系列非平台相关的IO相关接口和实现，比如提供了对os中系统相关的IO功能的封装。我们在进行流式读写（比如读写文件）时，通常会用到该包。 |      |\n| bufio         | 它在io的基础上提供了缓存功能。在具备了缓存功能后， bufio可以比较方便地提供ReadLine之类的操作。 |      |\n| strconv       | 提供字符串与基本数据类型互转的能力。                       |      |\n| os            | 本包提供了对操作系统功能的非平台相关访问接口。接口为Unix风格。提供的功能包括文件操作、进程管理、信号和用户账号等。 |      |\n| sync          | 它提供了基本的同步原语。在多个goroutine访问共享资源的时候，需要使用sync中提供的锁机制。 |      |\n| flag          | 它提供命令行参数的规则定义和传入参数解析的功能。绝大部分的命令行程序都需要用到这个包。 |      |\n| encoding/json | JSON目前广泛用做网络程序中的通信格式。本包提供了对JSON的基本支持，比如从一个对象序列化为JSON字符串，或者从JSON字符串反序列化出一个具体的对象等。 |      |\n| http          | 通过http包，只需要数行代码，即可实现一个爬虫或者一个Web服务器，这在传统语言中是无法想象的。 |      |\n\n## 二、完整包列表\n\n| 目录             | 包                                        | 说明                                       |\n| -------------- | ---------------------------------------- | ---------------------------------------- |\n| 目录             | 包                                        | 说明                                       |\n|                | bufio                                    | 实现缓冲的I/O                                 |\n| bytes          | 提供了对字节切片操作的函数                            |                                          |\n| crypto         | 收集了常见的加密常数                               |                                          |\n| errors         | 实现了操作错误的函数                               |                                          |\n| Expvar         | 为公共变量提供了一个标准的接口，如服务器中的运算计数器              |                                          |\n| flag           | 实现了命令行标记解析                               |                                          |\n| fmt            | 实现了格式化输入输出                               |                                          |\n| hash           | 提供了哈希函数接口                                |                                          |\n| html           | 实现了一个HTML5兼容的分词器和解析器                     |                                          |\n| image          | 实现了一个基本的二维图像库                            |                                          |\n| io             | 提供了对I/O原语的基本接口                           |                                          |\n| log            | 它是一个简单的记录包，提供最基本的日志功能                    |                                          |\n| math           | 提供了一些基本的常量和数学函数                          |                                          |\n| mine           | 实现了部分的MIME规范                             |                                          |\n| net            | 提供了一个对UNIX网络套接字的可移植接口，包括TCP/IP、 UDP域名解析和UNIX域套接字 |                                          |\n| os             | 为操作系统功能实现了一个平台无关的接口                      |                                          |\n| path           | 实现了对斜线分割的文件名路径的操作                        |                                          |\n| reflect        | 实现了运行时反射，允许一个程序以任意类型操作对象                 |                                          |\n| regexp         | 实现了一个简单的正则表达式库                           |                                          |\n| runtime        | 包含与Go运行时系统交互的操作，如控制goroutine的函数          |                                          |\n| sort           | 提供对集合排序的基础函数集                            |                                          |\n| strconv        | 实现了在基本数据类型和字符串之间的转换                      |                                          |\n| strings        | 实现了操作字符串的简单函数                            |                                          |\n| sync           | 提供了基本的同步机制，如互斥锁                          |                                          |\n| syscall        | 包含一个低级的操作系统原语的接口                         |                                          |\n| testing        | 提供对自动测试Go包的支持                            |                                          |\n| time           | 提供测量和显示时间的功能                             |                                          |\n| unicode        | Unicode编码相关的基础函数                         |                                          |\n| archive        | tar                                      | 实现对tar压缩文档的访问                            |\n| zip            | 提供对ZIP压缩文档的读和写支持                         |                                          |\n| compress       | bzip2                                    | 实现了bzip2解压缩                              |\n| flate          | 实现了RFC 1951中所定义的DEFLATE压缩数据格式            |                                          |\n| gzip           | 实现了RFC 1951中所定义的gzip格式压缩文件的读和写           |                                          |\n| lzw            | 实现了 Lempel-Ziv-Welch编码格式的压缩的数据格式         |                                          |\n| zlib           | 实现了RFC 1950中所定义的zlib格式压缩数据的读和写           |                                          |\n| container      | heap                                     | 提供了实现heap.Interface接口的任何类型的堆操作           |\n| lsit           | 实现了一个双链表                                 |                                          |\n| ring           | 实现了对循环链表的操作                              |                                          |\n| crypto         | aes                                      | 实现了AES加密（以前的Rijndael）                    |\n| cipher         | 实现了标准的密码块模式，该模式可包装进低级的块加密实现中             |                                          |\n| des            | 实现了数据加密标准（ Data Encryption Standard，DES）和三重数据加密算法（ TripleData Encryption Algorithm， TDEA） |                                          |\n| dsa            | 实现了FIPS 186-3所定义的数据签名算法（ Digital Signature Algorithm） |                                          |\n| ecdsa          | 实现了FIPS 186-3所定义的椭圆曲线数据签名算法（ Elliptic Curve Digital SignatureAlgorithm） |                                          |\n| elliptic       | 实现了素数域上几个标准的椭圆曲线                         |                                          |\n| hmac           | 实现了键控哈希消息身份验证码（ Keyed-Hash Message Authentication Code，HMAC） |                                          |\n| md5            | 实现了RFC 1321中所定义的MD5哈希算法                  |                                          |\n| rand           | 实现了一个加密安全的伪随机数生成器                        |                                          |\n| rc4            | 实现了RC4加密，其定义见Bruce Schneier的应用密码学（ Applied Cryptography） |                                          |\n| rsa            | 实现了PKCS#1中所定义的RSA加密                      |                                          |\n| sha1           | 实现了RFC 3174中所定义的SHA1哈希算法                 |                                          |\n| sha256         | 实现了FIPS 180-2中所定义的SHA224和SHA256哈希算法      |                                          |\n| sha512         | 实现了FIPS 180-2中所定义的SHA384和SHA512哈希算法      |                                          |\n| subtle         | 实现了一些有用的加密函数，但需要仔细考虑以便正确应用它们             |                                          |\n| tls            | 部分实现了RFC 4346所定义的TLS 1.1协议               |                                          |\n| x509           | 可解析X.509编码的键值和证书                         |                                          |\n| x509/pkix      | 包含用于对X.509证书、 CRL和OCSP的ASN.1解析和序列化的共享的、低级的结构 |                                          |\n| database       | sql                                      | 围绕SQL提供了一个通用的接口                          |\n| sql/driver     | 定义了数据库驱动所需实现的接口，同sql包的使用方式               |                                          |\n| debug          | dwarf                                    | 提供了对从可执行文件加载的DWARF调试信息的访问，这个包对于实现Go语言的调试器非常有价值 |\n| elf            | 实现了对ELF对象文件的访问。 ELF是一种常见的二进制可执行文件和共享库的文件格式。 Linux采用了ELF格式 |                                          |\n| gosym          | 访问Go语言二进制程序中的调试信息。对于可视化调试很有价值            |                                          |\n| macho          | 实现了对[http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/](http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/)MachORuntime/Reference/reference.html 所定义的Mach-O对象文件的访问 |                                          |\n| pe             | 实现了对PE（ Microsoft Windows Portable Executable）文件的访问 |                                          |\n| encoding       | ascii85                                  | 实现了ascii85数据编码，用于btoa工具和Adobe’s PostScript以及PDF文档格式 |\n| asn1           | 实现了解析DER编码的ASN.1数据结构，其定义见ITU-T Rec X.690 |                                          |\n| base32         | 实现了RFC 4648中所定义的base32编码                 |                                          |\n| base64         | 实现了RFC 4648中所定义的base64编码                 |                                          |\n| binary         | 实现了在无符号整数值和字节串之间的转化，以及对固定尺寸值的读和写         |                                          |\n| csv            | 可读和写由逗号分割的数值（ csv）文件                     |                                          |\n| gob            | 管理gob流——在编码器（发送者）和解码器（接收者）之间进行二进制值交换     |                                          |\n| hex            | 实现了十六进制的编码和解码                            |                                          |\n| json           | 实现了定义于RFC 4627中的JSON对象的编码和解码             |                                          |\n| pem            | 实现了PEM（ Privacy Enhanced Mail）数据编码       |                                          |\n| xml            | 实现了一个简单的可理解XML名字空间的XML 1.0解析器            |                                          |\n| go             | ast                                      | 声明了用于展示Go包中的语法树类型                        |\n| build          | 提供了构建Go包的工具                              |                                          |\n| doc            | 从一个Go AST（抽象语法树）中提取源代码文档                 |                                          |\n| parser         | 实现了一个Go源文件解析器                            |                                          |\n| printer        | 实现了对AST（抽象语法树）的打印                        |                                          |\n| scanner        | 实现了一个Go源代码文本的扫描器                         |                                          |\n| token          | 定义了代表Go编程语言中词法标记以及基本操作标记（ printing、 predicates）的常量 |                                          |\n| hash           | adler32                                  | 实现了Adler-32校验和                           |\n| crc32          | 实现了32位的循环冗余校验或CRC-32校验和                  |                                          |\n| crc64          | 实现了64位的循环冗余校验或CRC-64校验和                  |                                          |\n| fnv            | 实现了Glenn Fowler、 Landon Curt Noll和Phong Vo所创建的FNV-1和FNV-1a未加密哈希函数 |                                          |\n| html           | template                                 | 它自动构建HTML输出，并可防止代码注入                     |\n| image          | color                                    | 实现了一个基本的颜色库                              |\n| draw           | 提供一些做图函数                                 |                                          |\n| gif            | 实现了一个GIF图像解码器                            |                                          |\n| jpeg           | 实现了一个JPEG图像解码器和编码器                       |                                          |\n| png            | 实现了一个PNG图像解码器和编码器                        |                                          |\n| index          | suffixarray                              | 通过构建内存索引实现的高速字符串匹配查找算法                   |\n| io             | ioutil                                   | 实现了一些实用的I/O函数                            |\n| log            | syslog                                   | 提供了对系统日志服务的简单接口                          |\n| math           | big                                      | 实现了多精度的算术运算（大数）                          |\n| cmplx          | 为复数提供了基本的常量和数学函数                         |                                          |\n| rand           | 实现了伪随机数生成器                               |                                          |\n| mime           | multipart                                | 实现了在RFC 2046中定义的MIME多个部分的解析              |\n| net            | http                                     | 提供了HTTP客户端和服务器的实现                        |\n| mail           | 实现了对邮件消息的解析                              |                                          |\n| rpc            | 提供了对一个来自网络或其他I/O连接的对象可导出的方法的访问           |                                          |\n| smtp           | 实现了定义于RFC 5321中的简单邮件传输协议（ Simple Mail Transfer Protocol) |                                          |\n| textproto      | 实现了在HTTP、 NNTP和SMTP中基于文本的通用的请求/响应协议      |                                          |\n| url            | 解析URL并实现查询转义                             |                                          |\n| http/cgi       | 实现了定义于RFC 3875中的CGI（通用网关接口）              |                                          |\n| http/fcgi      | 实现了FastCGI协议                             |                                          |\n| http/httptest  | 提供了一些HTTP测试应用                            |                                          |\n| http/httputil  | 提供了一些HTTP应用函数，这些是对net/http包中的东西的补充，只不过相对不太常用 |                                          |\n| http/pprof     | 通过其HTTP服务器运行时提供性能测试数据，该数据的格式正是pprof可视化工具需要的 |                                          |\n| rpc/jsonrpc    | 为rpc包实现了一个JSON-RPC ClientCodec和ServerCodec |                                          |\n| os             | exec                                     | 可运行外部命令                                  |\n| user           | 通过名称和id进行用户账户检查                          |                                          |\n| path           | filepath                                 | 实现了以与目标操作系统定义文件路径相兼容的方式处理文件名路径           |\n| regexp         | syntax                                   | 将正则表达式解析为语法树                             |\n| runtime        | debug                                    | 包含当程序在运行时调试其自身的功能                        |\n| pprof          | 以pprof可视化工具需要的格式写运行时性能测试数据               |                                          |\n| sync           | atomic                                   | 提供了低级的用于实现同步算法的原子级的内存机制                  |\n| testing        | iotest                                   | 提供一系列测试目的的类型，实现了Reader和Writer标准接口        |\n| quick          | 实现了用于黑箱测试的实用函数                           |                                          |\n| script         | 帮助测试使用通道的代码                              |                                          |\n| text           | scanner                                  | 为UTF-8文本提供了一个扫描器和分词器                     |\n| tabwriter      | 实现了一个写筛选器（ tabwriter.Writer），它可将一个输入的tab分割的列翻译为适当对齐的文本 |                                          |\n| template       | 数据驱动的模板引擎，用于生成类似HTML的文本输出格式              |                                          |\n| template/parse | 为template构建解析树                           |                                          |\n| unicode/utf16  | 实现了UTF-16序列的的编码和解码                       |                                          |\n| unicode/utf8   | 实现了支持以UTF-8编码的文本的函数和常数                   |                                          |","slug":"Golang/Golang常用包","published":1,"updated":"2017-10-03T06:15:37.155Z","_id":"cj8b7n8ow000e2cvuhb3idmfp","comments":1,"layout":"post","photos":[],"link":"","content":"<h2><span id=\"一-常用包\">一、常用包</span></h2>\n<table>\n<thead>\n<tr>\n<th>常用包</th>\n<th>说明</th>\n<th>常用函数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>fmt</td>\n<td>实现格式化的输入输出操作，其中的fmt.Printf()和fmt.Println()是开发者使用最为频繁的函数。</td>\n<td></td>\n</tr>\n<tr>\n<td>io</td>\n<td>实现了一系列非平台相关的IO相关接口和实现，比如提供了对os中系统相关的IO功能的封装。我们在进行流式读写（比如读写文件）时，通常会用到该包。</td>\n<td></td>\n</tr>\n<tr>\n<td>bufio</td>\n<td>它在io的基础上提供了缓存功能。在具备了缓存功能后， bufio可以比较方便地提供ReadLine之类的操作。</td>\n<td></td>\n</tr>\n<tr>\n<td>strconv</td>\n<td>提供字符串与基本数据类型互转的能力。</td>\n<td></td>\n</tr>\n<tr>\n<td>os</td>\n<td>本包提供了对操作系统功能的非平台相关访问接口。接口为Unix风格。提供的功能包括文件操作、进程管理、信号和用户账号等。</td>\n<td></td>\n</tr>\n<tr>\n<td>sync</td>\n<td>它提供了基本的同步原语。在多个goroutine访问共享资源的时候，需要使用sync中提供的锁机制。</td>\n<td></td>\n</tr>\n<tr>\n<td>flag</td>\n<td>它提供命令行参数的规则定义和传入参数解析的功能。绝大部分的命令行程序都需要用到这个包。</td>\n<td></td>\n</tr>\n<tr>\n<td>encoding/json</td>\n<td>JSON目前广泛用做网络程序中的通信格式。本包提供了对JSON的基本支持，比如从一个对象序列化为JSON字符串，或者从JSON字符串反序列化出一个具体的对象等。</td>\n<td></td>\n</tr>\n<tr>\n<td>http</td>\n<td>通过http包，只需要数行代码，即可实现一个爬虫或者一个Web服务器，这在传统语言中是无法想象的。</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2><span id=\"二-完整包列表\">二、完整包列表</span></h2>\n<table>\n<thead>\n<tr>\n<th>目录</th>\n<th>包</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>目录</td>\n<td>包</td>\n<td>说明</td>\n</tr>\n<tr>\n<td></td>\n<td>bufio</td>\n<td>实现缓冲的I/O</td>\n</tr>\n<tr>\n<td>bytes</td>\n<td>提供了对字节切片操作的函数</td>\n<td></td>\n</tr>\n<tr>\n<td>crypto</td>\n<td>收集了常见的加密常数</td>\n<td></td>\n</tr>\n<tr>\n<td>errors</td>\n<td>实现了操作错误的函数</td>\n<td></td>\n</tr>\n<tr>\n<td>Expvar</td>\n<td>为公共变量提供了一个标准的接口，如服务器中的运算计数器</td>\n<td></td>\n</tr>\n<tr>\n<td>flag</td>\n<td>实现了命令行标记解析</td>\n<td></td>\n</tr>\n<tr>\n<td>fmt</td>\n<td>实现了格式化输入输出</td>\n<td></td>\n</tr>\n<tr>\n<td>hash</td>\n<td>提供了哈希函数接口</td>\n<td></td>\n</tr>\n<tr>\n<td>html</td>\n<td>实现了一个HTML5兼容的分词器和解析器</td>\n<td></td>\n</tr>\n<tr>\n<td>image</td>\n<td>实现了一个基本的二维图像库</td>\n<td></td>\n</tr>\n<tr>\n<td>io</td>\n<td>提供了对I/O原语的基本接口</td>\n<td></td>\n</tr>\n<tr>\n<td>log</td>\n<td>它是一个简单的记录包，提供最基本的日志功能</td>\n<td></td>\n</tr>\n<tr>\n<td>math</td>\n<td>提供了一些基本的常量和数学函数</td>\n<td></td>\n</tr>\n<tr>\n<td>mine</td>\n<td>实现了部分的MIME规范</td>\n<td></td>\n</tr>\n<tr>\n<td>net</td>\n<td>提供了一个对UNIX网络套接字的可移植接口，包括TCP/IP、 UDP域名解析和UNIX域套接字</td>\n<td></td>\n</tr>\n<tr>\n<td>os</td>\n<td>为操作系统功能实现了一个平台无关的接口</td>\n<td></td>\n</tr>\n<tr>\n<td>path</td>\n<td>实现了对斜线分割的文件名路径的操作</td>\n<td></td>\n</tr>\n<tr>\n<td>reflect</td>\n<td>实现了运行时反射，允许一个程序以任意类型操作对象</td>\n<td></td>\n</tr>\n<tr>\n<td>regexp</td>\n<td>实现了一个简单的正则表达式库</td>\n<td></td>\n</tr>\n<tr>\n<td>runtime</td>\n<td>包含与Go运行时系统交互的操作，如控制goroutine的函数</td>\n<td></td>\n</tr>\n<tr>\n<td>sort</td>\n<td>提供对集合排序的基础函数集</td>\n<td></td>\n</tr>\n<tr>\n<td>strconv</td>\n<td>实现了在基本数据类型和字符串之间的转换</td>\n<td></td>\n</tr>\n<tr>\n<td>strings</td>\n<td>实现了操作字符串的简单函数</td>\n<td></td>\n</tr>\n<tr>\n<td>sync</td>\n<td>提供了基本的同步机制，如互斥锁</td>\n<td></td>\n</tr>\n<tr>\n<td>syscall</td>\n<td>包含一个低级的操作系统原语的接口</td>\n<td></td>\n</tr>\n<tr>\n<td>testing</td>\n<td>提供对自动测试Go包的支持</td>\n<td></td>\n</tr>\n<tr>\n<td>time</td>\n<td>提供测量和显示时间的功能</td>\n<td></td>\n</tr>\n<tr>\n<td>unicode</td>\n<td>Unicode编码相关的基础函数</td>\n<td></td>\n</tr>\n<tr>\n<td>archive</td>\n<td>tar</td>\n<td>实现对tar压缩文档的访问</td>\n</tr>\n<tr>\n<td>zip</td>\n<td>提供对ZIP压缩文档的读和写支持</td>\n<td></td>\n</tr>\n<tr>\n<td>compress</td>\n<td>bzip2</td>\n<td>实现了bzip2解压缩</td>\n</tr>\n<tr>\n<td>flate</td>\n<td>实现了RFC 1951中所定义的DEFLATE压缩数据格式</td>\n<td></td>\n</tr>\n<tr>\n<td>gzip</td>\n<td>实现了RFC 1951中所定义的gzip格式压缩文件的读和写</td>\n<td></td>\n</tr>\n<tr>\n<td>lzw</td>\n<td>实现了 Lempel-Ziv-Welch编码格式的压缩的数据格式</td>\n<td></td>\n</tr>\n<tr>\n<td>zlib</td>\n<td>实现了RFC 1950中所定义的zlib格式压缩数据的读和写</td>\n<td></td>\n</tr>\n<tr>\n<td>container</td>\n<td>heap</td>\n<td>提供了实现heap.Interface接口的任何类型的堆操作</td>\n</tr>\n<tr>\n<td>lsit</td>\n<td>实现了一个双链表</td>\n<td></td>\n</tr>\n<tr>\n<td>ring</td>\n<td>实现了对循环链表的操作</td>\n<td></td>\n</tr>\n<tr>\n<td>crypto</td>\n<td>aes</td>\n<td>实现了AES加密（以前的Rijndael）</td>\n</tr>\n<tr>\n<td>cipher</td>\n<td>实现了标准的密码块模式，该模式可包装进低级的块加密实现中</td>\n<td></td>\n</tr>\n<tr>\n<td>des</td>\n<td>实现了数据加密标准（ Data Encryption Standard，DES）和三重数据加密算法（ TripleData Encryption Algorithm， TDEA）</td>\n<td></td>\n</tr>\n<tr>\n<td>dsa</td>\n<td>实现了FIPS 186-3所定义的数据签名算法（ Digital Signature Algorithm）</td>\n<td></td>\n</tr>\n<tr>\n<td>ecdsa</td>\n<td>实现了FIPS 186-3所定义的椭圆曲线数据签名算法（ Elliptic Curve Digital SignatureAlgorithm）</td>\n<td></td>\n</tr>\n<tr>\n<td>elliptic</td>\n<td>实现了素数域上几个标准的椭圆曲线</td>\n<td></td>\n</tr>\n<tr>\n<td>hmac</td>\n<td>实现了键控哈希消息身份验证码（ Keyed-Hash Message Authentication Code，HMAC）</td>\n<td></td>\n</tr>\n<tr>\n<td>md5</td>\n<td>实现了RFC 1321中所定义的MD5哈希算法</td>\n<td></td>\n</tr>\n<tr>\n<td>rand</td>\n<td>实现了一个加密安全的伪随机数生成器</td>\n<td></td>\n</tr>\n<tr>\n<td>rc4</td>\n<td>实现了RC4加密，其定义见Bruce Schneier的应用密码学（ Applied Cryptography）</td>\n<td></td>\n</tr>\n<tr>\n<td>rsa</td>\n<td>实现了PKCS#1中所定义的RSA加密</td>\n<td></td>\n</tr>\n<tr>\n<td>sha1</td>\n<td>实现了RFC 3174中所定义的SHA1哈希算法</td>\n<td></td>\n</tr>\n<tr>\n<td>sha256</td>\n<td>实现了FIPS 180-2中所定义的SHA224和SHA256哈希算法</td>\n<td></td>\n</tr>\n<tr>\n<td>sha512</td>\n<td>实现了FIPS 180-2中所定义的SHA384和SHA512哈希算法</td>\n<td></td>\n</tr>\n<tr>\n<td>subtle</td>\n<td>实现了一些有用的加密函数，但需要仔细考虑以便正确应用它们</td>\n<td></td>\n</tr>\n<tr>\n<td>tls</td>\n<td>部分实现了RFC 4346所定义的TLS 1.1协议</td>\n<td></td>\n</tr>\n<tr>\n<td>x509</td>\n<td>可解析X.509编码的键值和证书</td>\n<td></td>\n</tr>\n<tr>\n<td>x509/pkix</td>\n<td>包含用于对X.509证书、 CRL和OCSP的ASN.1解析和序列化的共享的、低级的结构</td>\n<td></td>\n</tr>\n<tr>\n<td>database</td>\n<td>sql</td>\n<td>围绕SQL提供了一个通用的接口</td>\n</tr>\n<tr>\n<td>sql/driver</td>\n<td>定义了数据库驱动所需实现的接口，同sql包的使用方式</td>\n<td></td>\n</tr>\n<tr>\n<td>debug</td>\n<td>dwarf</td>\n<td>提供了对从可执行文件加载的DWARF调试信息的访问，这个包对于实现Go语言的调试器非常有价值</td>\n</tr>\n<tr>\n<td>elf</td>\n<td>实现了对ELF对象文件的访问。 ELF是一种常见的二进制可执行文件和共享库的文件格式。 Linux采用了ELF格式</td>\n<td></td>\n</tr>\n<tr>\n<td>gosym</td>\n<td>访问Go语言二进制程序中的调试信息。对于可视化调试很有价值</td>\n<td></td>\n</tr>\n<tr>\n<td>macho</td>\n<td>实现了对<a href=\"http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/\" target=\"_blank\" rel=\"external\">http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/</a>MachORuntime/Reference/reference.html 所定义的Mach-O对象文件的访问</td>\n<td></td>\n</tr>\n<tr>\n<td>pe</td>\n<td>实现了对PE（ Microsoft Windows Portable Executable）文件的访问</td>\n<td></td>\n</tr>\n<tr>\n<td>encoding</td>\n<td>ascii85</td>\n<td>实现了ascii85数据编码，用于btoa工具和Adobe’s PostScript以及PDF文档格式</td>\n</tr>\n<tr>\n<td>asn1</td>\n<td>实现了解析DER编码的ASN.1数据结构，其定义见ITU-T Rec X.690</td>\n<td></td>\n</tr>\n<tr>\n<td>base32</td>\n<td>实现了RFC 4648中所定义的base32编码</td>\n<td></td>\n</tr>\n<tr>\n<td>base64</td>\n<td>实现了RFC 4648中所定义的base64编码</td>\n<td></td>\n</tr>\n<tr>\n<td>binary</td>\n<td>实现了在无符号整数值和字节串之间的转化，以及对固定尺寸值的读和写</td>\n<td></td>\n</tr>\n<tr>\n<td>csv</td>\n<td>可读和写由逗号分割的数值（ csv）文件</td>\n<td></td>\n</tr>\n<tr>\n<td>gob</td>\n<td>管理gob流——在编码器（发送者）和解码器（接收者）之间进行二进制值交换</td>\n<td></td>\n</tr>\n<tr>\n<td>hex</td>\n<td>实现了十六进制的编码和解码</td>\n<td></td>\n</tr>\n<tr>\n<td>json</td>\n<td>实现了定义于RFC 4627中的JSON对象的编码和解码</td>\n<td></td>\n</tr>\n<tr>\n<td>pem</td>\n<td>实现了PEM（ Privacy Enhanced Mail）数据编码</td>\n<td></td>\n</tr>\n<tr>\n<td>xml</td>\n<td>实现了一个简单的可理解XML名字空间的XML 1.0解析器</td>\n<td></td>\n</tr>\n<tr>\n<td>go</td>\n<td>ast</td>\n<td>声明了用于展示Go包中的语法树类型</td>\n</tr>\n<tr>\n<td>build</td>\n<td>提供了构建Go包的工具</td>\n<td></td>\n</tr>\n<tr>\n<td>doc</td>\n<td>从一个Go AST（抽象语法树）中提取源代码文档</td>\n<td></td>\n</tr>\n<tr>\n<td>parser</td>\n<td>实现了一个Go源文件解析器</td>\n<td></td>\n</tr>\n<tr>\n<td>printer</td>\n<td>实现了对AST（抽象语法树）的打印</td>\n<td></td>\n</tr>\n<tr>\n<td>scanner</td>\n<td>实现了一个Go源代码文本的扫描器</td>\n<td></td>\n</tr>\n<tr>\n<td>token</td>\n<td>定义了代表Go编程语言中词法标记以及基本操作标记（ printing、 predicates）的常量</td>\n<td></td>\n</tr>\n<tr>\n<td>hash</td>\n<td>adler32</td>\n<td>实现了Adler-32校验和</td>\n</tr>\n<tr>\n<td>crc32</td>\n<td>实现了32位的循环冗余校验或CRC-32校验和</td>\n<td></td>\n</tr>\n<tr>\n<td>crc64</td>\n<td>实现了64位的循环冗余校验或CRC-64校验和</td>\n<td></td>\n</tr>\n<tr>\n<td>fnv</td>\n<td>实现了Glenn Fowler、 Landon Curt Noll和Phong Vo所创建的FNV-1和FNV-1a未加密哈希函数</td>\n<td></td>\n</tr>\n<tr>\n<td>html</td>\n<td>template</td>\n<td>它自动构建HTML输出，并可防止代码注入</td>\n</tr>\n<tr>\n<td>image</td>\n<td>color</td>\n<td>实现了一个基本的颜色库</td>\n</tr>\n<tr>\n<td>draw</td>\n<td>提供一些做图函数</td>\n<td></td>\n</tr>\n<tr>\n<td>gif</td>\n<td>实现了一个GIF图像解码器</td>\n<td></td>\n</tr>\n<tr>\n<td>jpeg</td>\n<td>实现了一个JPEG图像解码器和编码器</td>\n<td></td>\n</tr>\n<tr>\n<td>png</td>\n<td>实现了一个PNG图像解码器和编码器</td>\n<td></td>\n</tr>\n<tr>\n<td>index</td>\n<td>suffixarray</td>\n<td>通过构建内存索引实现的高速字符串匹配查找算法</td>\n</tr>\n<tr>\n<td>io</td>\n<td>ioutil</td>\n<td>实现了一些实用的I/O函数</td>\n</tr>\n<tr>\n<td>log</td>\n<td>syslog</td>\n<td>提供了对系统日志服务的简单接口</td>\n</tr>\n<tr>\n<td>math</td>\n<td>big</td>\n<td>实现了多精度的算术运算（大数）</td>\n</tr>\n<tr>\n<td>cmplx</td>\n<td>为复数提供了基本的常量和数学函数</td>\n<td></td>\n</tr>\n<tr>\n<td>rand</td>\n<td>实现了伪随机数生成器</td>\n<td></td>\n</tr>\n<tr>\n<td>mime</td>\n<td>multipart</td>\n<td>实现了在RFC 2046中定义的MIME多个部分的解析</td>\n</tr>\n<tr>\n<td>net</td>\n<td>http</td>\n<td>提供了HTTP客户端和服务器的实现</td>\n</tr>\n<tr>\n<td>mail</td>\n<td>实现了对邮件消息的解析</td>\n<td></td>\n</tr>\n<tr>\n<td>rpc</td>\n<td>提供了对一个来自网络或其他I/O连接的对象可导出的方法的访问</td>\n<td></td>\n</tr>\n<tr>\n<td>smtp</td>\n<td>实现了定义于RFC 5321中的简单邮件传输协议（ Simple Mail Transfer Protocol)</td>\n<td></td>\n</tr>\n<tr>\n<td>textproto</td>\n<td>实现了在HTTP、 NNTP和SMTP中基于文本的通用的请求/响应协议</td>\n<td></td>\n</tr>\n<tr>\n<td>url</td>\n<td>解析URL并实现查询转义</td>\n<td></td>\n</tr>\n<tr>\n<td>http/cgi</td>\n<td>实现了定义于RFC 3875中的CGI（通用网关接口）</td>\n<td></td>\n</tr>\n<tr>\n<td>http/fcgi</td>\n<td>实现了FastCGI协议</td>\n<td></td>\n</tr>\n<tr>\n<td>http/httptest</td>\n<td>提供了一些HTTP测试应用</td>\n<td></td>\n</tr>\n<tr>\n<td>http/httputil</td>\n<td>提供了一些HTTP应用函数，这些是对net/http包中的东西的补充，只不过相对不太常用</td>\n<td></td>\n</tr>\n<tr>\n<td>http/pprof</td>\n<td>通过其HTTP服务器运行时提供性能测试数据，该数据的格式正是pprof可视化工具需要的</td>\n<td></td>\n</tr>\n<tr>\n<td>rpc/jsonrpc</td>\n<td>为rpc包实现了一个JSON-RPC ClientCodec和ServerCodec</td>\n<td></td>\n</tr>\n<tr>\n<td>os</td>\n<td>exec</td>\n<td>可运行外部命令</td>\n</tr>\n<tr>\n<td>user</td>\n<td>通过名称和id进行用户账户检查</td>\n<td></td>\n</tr>\n<tr>\n<td>path</td>\n<td>filepath</td>\n<td>实现了以与目标操作系统定义文件路径相兼容的方式处理文件名路径</td>\n</tr>\n<tr>\n<td>regexp</td>\n<td>syntax</td>\n<td>将正则表达式解析为语法树</td>\n</tr>\n<tr>\n<td>runtime</td>\n<td>debug</td>\n<td>包含当程序在运行时调试其自身的功能</td>\n</tr>\n<tr>\n<td>pprof</td>\n<td>以pprof可视化工具需要的格式写运行时性能测试数据</td>\n<td></td>\n</tr>\n<tr>\n<td>sync</td>\n<td>atomic</td>\n<td>提供了低级的用于实现同步算法的原子级的内存机制</td>\n</tr>\n<tr>\n<td>testing</td>\n<td>iotest</td>\n<td>提供一系列测试目的的类型，实现了Reader和Writer标准接口</td>\n</tr>\n<tr>\n<td>quick</td>\n<td>实现了用于黑箱测试的实用函数</td>\n<td></td>\n</tr>\n<tr>\n<td>script</td>\n<td>帮助测试使用通道的代码</td>\n<td></td>\n</tr>\n<tr>\n<td>text</td>\n<td>scanner</td>\n<td>为UTF-8文本提供了一个扫描器和分词器</td>\n</tr>\n<tr>\n<td>tabwriter</td>\n<td>实现了一个写筛选器（ tabwriter.Writer），它可将一个输入的tab分割的列翻译为适当对齐的文本</td>\n<td></td>\n</tr>\n<tr>\n<td>template</td>\n<td>数据驱动的模板引擎，用于生成类似HTML的文本输出格式</td>\n<td></td>\n</tr>\n<tr>\n<td>template/parse</td>\n<td>为template构建解析树</td>\n<td></td>\n</tr>\n<tr>\n<td>unicode/utf16</td>\n<td>实现了UTF-16序列的的编码和解码</td>\n<td></td>\n</tr>\n<tr>\n<td>unicode/utf8</td>\n<td>实现了支持以UTF-8编码的文本的函数和常数</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h2>一、常用包</h2>\n<table>\n<thead>\n<tr>\n<th>常用包</th>\n<th>说明</th>\n<th>常用函数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>fmt</td>\n<td>实现格式化的输入输出操作，其中的fmt.Printf()和fmt.Println()是开发者使用最为频繁的函数。</td>\n<td></td>\n</tr>\n<tr>\n<td>io</td>\n<td>实现了一系列非平台相关的IO相关接口和实现，比如提供了对os中系统相关的IO功能的封装。我们在进行流式读写（比如读写文件）时，通常会用到该包。</td>\n<td></td>\n</tr>\n<tr>\n<td>bufio</td>\n<td>它在io的基础上提供了缓存功能。在具备了缓存功能后， bufio可以比较方便地提供ReadLine之类的操作。</td>\n<td></td>\n</tr>\n<tr>\n<td>strconv</td>\n<td>提供字符串与基本数据类型互转的能力。</td>\n<td></td>\n</tr>\n<tr>\n<td>os</td>\n<td>本包提供了对操作系统功能的非平台相关访问接口。接口为Unix风格。提供的功能包括文件操作、进程管理、信号和用户账号等。</td>\n<td></td>\n</tr>\n<tr>\n<td>sync</td>\n<td>它提供了基本的同步原语。在多个goroutine访问共享资源的时候，需要使用sync中提供的锁机制。</td>\n<td></td>\n</tr>\n<tr>\n<td>flag</td>\n<td>它提供命令行参数的规则定义和传入参数解析的功能。绝大部分的命令行程序都需要用到这个包。</td>\n<td></td>\n</tr>\n<tr>\n<td>encoding/json</td>\n<td>JSON目前广泛用做网络程序中的通信格式。本包提供了对JSON的基本支持，比如从一个对象序列化为JSON字符串，或者从JSON字符串反序列化出一个具体的对象等。</td>\n<td></td>\n</tr>\n<tr>\n<td>http</td>\n<td>通过http包，只需要数行代码，即可实现一个爬虫或者一个Web服务器，这在传统语言中是无法想象的。</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2>二、完整包列表</h2>\n<table>\n<thead>\n<tr>\n<th>目录</th>\n<th>包</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>目录</td>\n<td>包</td>\n<td>说明</td>\n</tr>\n<tr>\n<td></td>\n<td>bufio</td>\n<td>实现缓冲的I/O</td>\n</tr>\n<tr>\n<td>bytes</td>\n<td>提供了对字节切片操作的函数</td>\n<td></td>\n</tr>\n<tr>\n<td>crypto</td>\n<td>收集了常见的加密常数</td>\n<td></td>\n</tr>\n<tr>\n<td>errors</td>\n<td>实现了操作错误的函数</td>\n<td></td>\n</tr>\n<tr>\n<td>Expvar</td>\n<td>为公共变量提供了一个标准的接口，如服务器中的运算计数器</td>\n<td></td>\n</tr>\n<tr>\n<td>flag</td>\n<td>实现了命令行标记解析</td>\n<td></td>\n</tr>\n<tr>\n<td>fmt</td>\n<td>实现了格式化输入输出</td>\n<td></td>\n</tr>\n<tr>\n<td>hash</td>\n<td>提供了哈希函数接口</td>\n<td></td>\n</tr>\n<tr>\n<td>html</td>\n<td>实现了一个HTML5兼容的分词器和解析器</td>\n<td></td>\n</tr>\n<tr>\n<td>image</td>\n<td>实现了一个基本的二维图像库</td>\n<td></td>\n</tr>\n<tr>\n<td>io</td>\n<td>提供了对I/O原语的基本接口</td>\n<td></td>\n</tr>\n<tr>\n<td>log</td>\n<td>它是一个简单的记录包，提供最基本的日志功能</td>\n<td></td>\n</tr>\n<tr>\n<td>math</td>\n<td>提供了一些基本的常量和数学函数</td>\n<td></td>\n</tr>\n<tr>\n<td>mine</td>\n<td>实现了部分的MIME规范</td>\n<td></td>\n</tr>\n<tr>\n<td>net</td>\n<td>提供了一个对UNIX网络套接字的可移植接口，包括TCP/IP、 UDP域名解析和UNIX域套接字</td>\n<td></td>\n</tr>\n<tr>\n<td>os</td>\n<td>为操作系统功能实现了一个平台无关的接口</td>\n<td></td>\n</tr>\n<tr>\n<td>path</td>\n<td>实现了对斜线分割的文件名路径的操作</td>\n<td></td>\n</tr>\n<tr>\n<td>reflect</td>\n<td>实现了运行时反射，允许一个程序以任意类型操作对象</td>\n<td></td>\n</tr>\n<tr>\n<td>regexp</td>\n<td>实现了一个简单的正则表达式库</td>\n<td></td>\n</tr>\n<tr>\n<td>runtime</td>\n<td>包含与Go运行时系统交互的操作，如控制goroutine的函数</td>\n<td></td>\n</tr>\n<tr>\n<td>sort</td>\n<td>提供对集合排序的基础函数集</td>\n<td></td>\n</tr>\n<tr>\n<td>strconv</td>\n<td>实现了在基本数据类型和字符串之间的转换</td>\n<td></td>\n</tr>\n<tr>\n<td>strings</td>\n<td>实现了操作字符串的简单函数</td>\n<td></td>\n</tr>\n<tr>\n<td>sync</td>\n<td>提供了基本的同步机制，如互斥锁</td>\n<td></td>\n</tr>\n<tr>\n<td>syscall</td>\n<td>包含一个低级的操作系统原语的接口</td>\n<td></td>\n</tr>\n<tr>\n<td>testing</td>\n<td>提供对自动测试Go包的支持</td>\n<td></td>\n</tr>\n<tr>\n<td>time</td>\n<td>提供测量和显示时间的功能</td>\n<td></td>\n</tr>\n<tr>\n<td>unicode</td>\n<td>Unicode编码相关的基础函数</td>\n<td></td>\n</tr>\n<tr>\n<td>archive</td>\n<td>tar</td>\n<td>实现对tar压缩文档的访问</td>\n</tr>\n<tr>\n<td>zip</td>\n<td>提供对ZIP压缩文档的读和写支持</td>\n<td></td>\n</tr>\n<tr>\n<td>compress</td>\n<td>bzip2</td>\n<td>实现了bzip2解压缩</td>\n</tr>\n<tr>\n<td>flate</td>\n<td>实现了RFC 1951中所定义的DEFLATE压缩数据格式</td>\n<td></td>\n</tr>\n<tr>\n<td>gzip</td>\n<td>实现了RFC 1951中所定义的gzip格式压缩文件的读和写</td>\n<td></td>\n</tr>\n<tr>\n<td>lzw</td>\n<td>实现了 Lempel-Ziv-Welch编码格式的压缩的数据格式</td>\n<td></td>\n</tr>\n<tr>\n<td>zlib</td>\n<td>实现了RFC 1950中所定义的zlib格式压缩数据的读和写</td>\n<td></td>\n</tr>\n<tr>\n<td>container</td>\n<td>heap</td>\n<td>提供了实现heap.Interface接口的任何类型的堆操作</td>\n</tr>\n<tr>\n<td>lsit</td>\n<td>实现了一个双链表</td>\n<td></td>\n</tr>\n<tr>\n<td>ring</td>\n<td>实现了对循环链表的操作</td>\n<td></td>\n</tr>\n<tr>\n<td>crypto</td>\n<td>aes</td>\n<td>实现了AES加密（以前的Rijndael）</td>\n</tr>\n<tr>\n<td>cipher</td>\n<td>实现了标准的密码块模式，该模式可包装进低级的块加密实现中</td>\n<td></td>\n</tr>\n<tr>\n<td>des</td>\n<td>实现了数据加密标准（ Data Encryption Standard，DES）和三重数据加密算法（ TripleData Encryption Algorithm， TDEA）</td>\n<td></td>\n</tr>\n<tr>\n<td>dsa</td>\n<td>实现了FIPS 186-3所定义的数据签名算法（ Digital Signature Algorithm）</td>\n<td></td>\n</tr>\n<tr>\n<td>ecdsa</td>\n<td>实现了FIPS 186-3所定义的椭圆曲线数据签名算法（ Elliptic Curve Digital SignatureAlgorithm）</td>\n<td></td>\n</tr>\n<tr>\n<td>elliptic</td>\n<td>实现了素数域上几个标准的椭圆曲线</td>\n<td></td>\n</tr>\n<tr>\n<td>hmac</td>\n<td>实现了键控哈希消息身份验证码（ Keyed-Hash Message Authentication Code，HMAC）</td>\n<td></td>\n</tr>\n<tr>\n<td>md5</td>\n<td>实现了RFC 1321中所定义的MD5哈希算法</td>\n<td></td>\n</tr>\n<tr>\n<td>rand</td>\n<td>实现了一个加密安全的伪随机数生成器</td>\n<td></td>\n</tr>\n<tr>\n<td>rc4</td>\n<td>实现了RC4加密，其定义见Bruce Schneier的应用密码学（ Applied Cryptography）</td>\n<td></td>\n</tr>\n<tr>\n<td>rsa</td>\n<td>实现了PKCS#1中所定义的RSA加密</td>\n<td></td>\n</tr>\n<tr>\n<td>sha1</td>\n<td>实现了RFC 3174中所定义的SHA1哈希算法</td>\n<td></td>\n</tr>\n<tr>\n<td>sha256</td>\n<td>实现了FIPS 180-2中所定义的SHA224和SHA256哈希算法</td>\n<td></td>\n</tr>\n<tr>\n<td>sha512</td>\n<td>实现了FIPS 180-2中所定义的SHA384和SHA512哈希算法</td>\n<td></td>\n</tr>\n<tr>\n<td>subtle</td>\n<td>实现了一些有用的加密函数，但需要仔细考虑以便正确应用它们</td>\n<td></td>\n</tr>\n<tr>\n<td>tls</td>\n<td>部分实现了RFC 4346所定义的TLS 1.1协议</td>\n<td></td>\n</tr>\n<tr>\n<td>x509</td>\n<td>可解析X.509编码的键值和证书</td>\n<td></td>\n</tr>\n<tr>\n<td>x509/pkix</td>\n<td>包含用于对X.509证书、 CRL和OCSP的ASN.1解析和序列化的共享的、低级的结构</td>\n<td></td>\n</tr>\n<tr>\n<td>database</td>\n<td>sql</td>\n<td>围绕SQL提供了一个通用的接口</td>\n</tr>\n<tr>\n<td>sql/driver</td>\n<td>定义了数据库驱动所需实现的接口，同sql包的使用方式</td>\n<td></td>\n</tr>\n<tr>\n<td>debug</td>\n<td>dwarf</td>\n<td>提供了对从可执行文件加载的DWARF调试信息的访问，这个包对于实现Go语言的调试器非常有价值</td>\n</tr>\n<tr>\n<td>elf</td>\n<td>实现了对ELF对象文件的访问。 ELF是一种常见的二进制可执行文件和共享库的文件格式。 Linux采用了ELF格式</td>\n<td></td>\n</tr>\n<tr>\n<td>gosym</td>\n<td>访问Go语言二进制程序中的调试信息。对于可视化调试很有价值</td>\n<td></td>\n</tr>\n<tr>\n<td>macho</td>\n<td>实现了对<a href=\"http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/\" target=\"_blank\" rel=\"external\">http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/</a>MachORuntime/Reference/reference.html 所定义的Mach-O对象文件的访问</td>\n<td></td>\n</tr>\n<tr>\n<td>pe</td>\n<td>实现了对PE（ Microsoft Windows Portable Executable）文件的访问</td>\n<td></td>\n</tr>\n<tr>\n<td>encoding</td>\n<td>ascii85</td>\n<td>实现了ascii85数据编码，用于btoa工具和Adobe’s PostScript以及PDF文档格式</td>\n</tr>\n<tr>\n<td>asn1</td>\n<td>实现了解析DER编码的ASN.1数据结构，其定义见ITU-T Rec X.690</td>\n<td></td>\n</tr>\n<tr>\n<td>base32</td>\n<td>实现了RFC 4648中所定义的base32编码</td>\n<td></td>\n</tr>\n<tr>\n<td>base64</td>\n<td>实现了RFC 4648中所定义的base64编码</td>\n<td></td>\n</tr>\n<tr>\n<td>binary</td>\n<td>实现了在无符号整数值和字节串之间的转化，以及对固定尺寸值的读和写</td>\n<td></td>\n</tr>\n<tr>\n<td>csv</td>\n<td>可读和写由逗号分割的数值（ csv）文件</td>\n<td></td>\n</tr>\n<tr>\n<td>gob</td>\n<td>管理gob流——在编码器（发送者）和解码器（接收者）之间进行二进制值交换</td>\n<td></td>\n</tr>\n<tr>\n<td>hex</td>\n<td>实现了十六进制的编码和解码</td>\n<td></td>\n</tr>\n<tr>\n<td>json</td>\n<td>实现了定义于RFC 4627中的JSON对象的编码和解码</td>\n<td></td>\n</tr>\n<tr>\n<td>pem</td>\n<td>实现了PEM（ Privacy Enhanced Mail）数据编码</td>\n<td></td>\n</tr>\n<tr>\n<td>xml</td>\n<td>实现了一个简单的可理解XML名字空间的XML 1.0解析器</td>\n<td></td>\n</tr>\n<tr>\n<td>go</td>\n<td>ast</td>\n<td>声明了用于展示Go包中的语法树类型</td>\n</tr>\n<tr>\n<td>build</td>\n<td>提供了构建Go包的工具</td>\n<td></td>\n</tr>\n<tr>\n<td>doc</td>\n<td>从一个Go AST（抽象语法树）中提取源代码文档</td>\n<td></td>\n</tr>\n<tr>\n<td>parser</td>\n<td>实现了一个Go源文件解析器</td>\n<td></td>\n</tr>\n<tr>\n<td>printer</td>\n<td>实现了对AST（抽象语法树）的打印</td>\n<td></td>\n</tr>\n<tr>\n<td>scanner</td>\n<td>实现了一个Go源代码文本的扫描器</td>\n<td></td>\n</tr>\n<tr>\n<td>token</td>\n<td>定义了代表Go编程语言中词法标记以及基本操作标记（ printing、 predicates）的常量</td>\n<td></td>\n</tr>\n<tr>\n<td>hash</td>\n<td>adler32</td>\n<td>实现了Adler-32校验和</td>\n</tr>\n<tr>\n<td>crc32</td>\n<td>实现了32位的循环冗余校验或CRC-32校验和</td>\n<td></td>\n</tr>\n<tr>\n<td>crc64</td>\n<td>实现了64位的循环冗余校验或CRC-64校验和</td>\n<td></td>\n</tr>\n<tr>\n<td>fnv</td>\n<td>实现了Glenn Fowler、 Landon Curt Noll和Phong Vo所创建的FNV-1和FNV-1a未加密哈希函数</td>\n<td></td>\n</tr>\n<tr>\n<td>html</td>\n<td>template</td>\n<td>它自动构建HTML输出，并可防止代码注入</td>\n</tr>\n<tr>\n<td>image</td>\n<td>color</td>\n<td>实现了一个基本的颜色库</td>\n</tr>\n<tr>\n<td>draw</td>\n<td>提供一些做图函数</td>\n<td></td>\n</tr>\n<tr>\n<td>gif</td>\n<td>实现了一个GIF图像解码器</td>\n<td></td>\n</tr>\n<tr>\n<td>jpeg</td>\n<td>实现了一个JPEG图像解码器和编码器</td>\n<td></td>\n</tr>\n<tr>\n<td>png</td>\n<td>实现了一个PNG图像解码器和编码器</td>\n<td></td>\n</tr>\n<tr>\n<td>index</td>\n<td>suffixarray</td>\n<td>通过构建内存索引实现的高速字符串匹配查找算法</td>\n</tr>\n<tr>\n<td>io</td>\n<td>ioutil</td>\n<td>实现了一些实用的I/O函数</td>\n</tr>\n<tr>\n<td>log</td>\n<td>syslog</td>\n<td>提供了对系统日志服务的简单接口</td>\n</tr>\n<tr>\n<td>math</td>\n<td>big</td>\n<td>实现了多精度的算术运算（大数）</td>\n</tr>\n<tr>\n<td>cmplx</td>\n<td>为复数提供了基本的常量和数学函数</td>\n<td></td>\n</tr>\n<tr>\n<td>rand</td>\n<td>实现了伪随机数生成器</td>\n<td></td>\n</tr>\n<tr>\n<td>mime</td>\n<td>multipart</td>\n<td>实现了在RFC 2046中定义的MIME多个部分的解析</td>\n</tr>\n<tr>\n<td>net</td>\n<td>http</td>\n<td>提供了HTTP客户端和服务器的实现</td>\n</tr>\n<tr>\n<td>mail</td>\n<td>实现了对邮件消息的解析</td>\n<td></td>\n</tr>\n<tr>\n<td>rpc</td>\n<td>提供了对一个来自网络或其他I/O连接的对象可导出的方法的访问</td>\n<td></td>\n</tr>\n<tr>\n<td>smtp</td>\n<td>实现了定义于RFC 5321中的简单邮件传输协议（ Simple Mail Transfer Protocol)</td>\n<td></td>\n</tr>\n<tr>\n<td>textproto</td>\n<td>实现了在HTTP、 NNTP和SMTP中基于文本的通用的请求/响应协议</td>\n<td></td>\n</tr>\n<tr>\n<td>url</td>\n<td>解析URL并实现查询转义</td>\n<td></td>\n</tr>\n<tr>\n<td>http/cgi</td>\n<td>实现了定义于RFC 3875中的CGI（通用网关接口）</td>\n<td></td>\n</tr>\n<tr>\n<td>http/fcgi</td>\n<td>实现了FastCGI协议</td>\n<td></td>\n</tr>\n<tr>\n<td>http/httptest</td>\n<td>提供了一些HTTP测试应用</td>\n<td></td>\n</tr>\n<tr>\n<td>http/httputil</td>\n<td>提供了一些HTTP应用函数，这些是对net/http包中的东西的补充，只不过相对不太常用</td>\n<td></td>\n</tr>\n<tr>\n<td>http/pprof</td>\n<td>通过其HTTP服务器运行时提供性能测试数据，该数据的格式正是pprof可视化工具需要的</td>\n<td></td>\n</tr>\n<tr>\n<td>rpc/jsonrpc</td>\n<td>为rpc包实现了一个JSON-RPC ClientCodec和ServerCodec</td>\n<td></td>\n</tr>\n<tr>\n<td>os</td>\n<td>exec</td>\n<td>可运行外部命令</td>\n</tr>\n<tr>\n<td>user</td>\n<td>通过名称和id进行用户账户检查</td>\n<td></td>\n</tr>\n<tr>\n<td>path</td>\n<td>filepath</td>\n<td>实现了以与目标操作系统定义文件路径相兼容的方式处理文件名路径</td>\n</tr>\n<tr>\n<td>regexp</td>\n<td>syntax</td>\n<td>将正则表达式解析为语法树</td>\n</tr>\n<tr>\n<td>runtime</td>\n<td>debug</td>\n<td>包含当程序在运行时调试其自身的功能</td>\n</tr>\n<tr>\n<td>pprof</td>\n<td>以pprof可视化工具需要的格式写运行时性能测试数据</td>\n<td></td>\n</tr>\n<tr>\n<td>sync</td>\n<td>atomic</td>\n<td>提供了低级的用于实现同步算法的原子级的内存机制</td>\n</tr>\n<tr>\n<td>testing</td>\n<td>iotest</td>\n<td>提供一系列测试目的的类型，实现了Reader和Writer标准接口</td>\n</tr>\n<tr>\n<td>quick</td>\n<td>实现了用于黑箱测试的实用函数</td>\n<td></td>\n</tr>\n<tr>\n<td>script</td>\n<td>帮助测试使用通道的代码</td>\n<td></td>\n</tr>\n<tr>\n<td>text</td>\n<td>scanner</td>\n<td>为UTF-8文本提供了一个扫描器和分词器</td>\n</tr>\n<tr>\n<td>tabwriter</td>\n<td>实现了一个写筛选器（ tabwriter.Writer），它可将一个输入的tab分割的列翻译为适当对齐的文本</td>\n<td></td>\n</tr>\n<tr>\n<td>template</td>\n<td>数据驱动的模板引擎，用于生成类似HTML的文本输出格式</td>\n<td></td>\n</tr>\n<tr>\n<td>template/parse</td>\n<td>为template构建解析树</td>\n<td></td>\n</tr>\n<tr>\n<td>unicode/utf16</td>\n<td>实现了UTF-16序列的的编码和解码</td>\n<td></td>\n</tr>\n<tr>\n<td>unicode/utf8</td>\n<td>实现了支持以UTF-8编码的文本的函数和常数</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n"},{"title":"[Golang] Go语言指针详解","catalog":true,"date":"2017-10-01T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Golang"],"_content":"\n## 1. 指针的概念\n\n| 概念   | 说明                                |\n| ---- | --------------------------------- |\n| 变量   | 是一种占位符，用于引用计算机的内存地址。可理解为内存地址的标签   |\n| 指针   | 表示内存地址，表示地址的指向。指针是一个指向另一个变量内存地址的值 |\n| &    | 取地址符，例如：{指针}:=&{变量}               |\n| *    | 取值符，例如：{变量}:=*{指针}                |\n\n## 2. 内存地址说明\n\n### 2.1. 内存定义\n计算机的内存 RAM 可以把它想象成一些有序的盒子，一个接一个的排成一排，每一个盒子或者单元格都被一个唯一的数字标记依次递增，这个数字就是该单元格的地址，也就是内存的地址。\n![这里写图片描述](http://img.blog.csdn.net/20170907125622072?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**硬件角度**：内存是CPU沟通的桥梁，程序运行在内存中。\n\n**逻辑角度**：内存是一块具备随机访问能力，支持读写操作，用来存放程序及程序运行中产生的数据的区域。\n\n| 概念   | 比喻                            |\n| ---- | ----------------------------- |\n| 内存   | 一层楼层                          |\n| 内存块  | 楼层中的一个房间                      |\n| 变量名  | 房间的标签，例如：总经理室                 |\n| 指针   | 房间的具体地址（门牌号），例如：总经理室地址是2楼201室 |\n| 变量值  | 房间里的具体存储物                     |\n| 指针地址 | 指针的地址：存储指针内存块的地址              |\n\n### 2.2. 内存单位和编址\n\n#### 2.2.1. 内存单位\n\n| 单位       | 说明                                |\n| -------- | --------------------------------- |\n| 位（bit）   | 计算机中最小的数据单位，每一位的状态只能是0或1          |\n| 字节（Byte） | 1Byte=8bit，是内存基本的计量单位             |\n| 字        | “字”由若干个字节构成，字的位数叫字长，不同档次的机器有不同的字长 |\n| KB       | 1KB=1024Byte，即1024个字节             |\n| MB       | 1MB=1024KB                        |\n| GB       | 1GB=1024MB                        |\n\n#### 2.2.2. 内存编址\n\n计算机中的内存按字节编址，每个地址的存储单元可以存放一个字节的数据，CPU通过内存地址获取指令和数据，并不关心这个地址所代表的空间在什么位置，内存地址和地址指向的空间共同构成了一个内存单元。\n\n#### 2.2.3. 内存地址\n\n内存地址通常用16进制的数据表示，例如0x0ffc1。\n## 3.变量与指针运算理解\n编写一段程序，检索出值并存储在地址为 200 的一个块内存中，将其乘以 3，并将结果存储在地址为 201 的另一块内存中\n### 3.1.本质\n1. 检索出内存地址为 200 的值，并将其存储在 CPU 中\n2. 将存储在 CPU 中的值乘以 3\n3. 将 CPU 中存储的结果，写入地址为 201 的内存块中\n\n![这里写图片描述](http://img.blog.csdn.net/20170907130852225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n### 3.2.基于变量的理解\n1. 获取变量 a 中存储的值，并将其存储在 CPU 中\n2. 将其乘以 3\n3. 将结果保存在变量 b 中\n\n![这里写图片描述](http://img.blog.csdn.net/20170907131045953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n```\nvar a = 6 \nvar b = a * 3\n```\n### 3.3.基于指针的理解\n```go\nfunc main() {\n    a := 200\n    b := &a\n    *b++\n    fmt.Println(a)\n}\n```\n以上函数对a进行+1操作，具体理解如下：\n\n**1.a:=200**\n\n![这里写图片描述](http://img.blog.csdn.net/20170907131917257?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**2.  b := &a**\n\n![这里写图片描述](http://img.blog.csdn.net/20170907132113460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**3. *b++**\n\n![这里写图片描述](http://img.blog.csdn.net/20170907132146682?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![这里写图片描述](http://img.blog.csdn.net/20170907132200014?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 4. 指针的使用\n\n### 4.1. 方法中的指针\n\n方法即为有接受者的函数，接受者可以是类型的实例变量或者是类型的实例指针变量。但两种效果不同。\n\n**1、类型的实例变量**\n\n```go\nfunc main(){\n    person := Person{\"vanyar\", 21}\n    fmt.Printf(\"person<%s:%d>\\n\", person.name, person.age)\n    person.sayHi()\n    person.ModifyAge(210)\n    person.sayHi()\n}\ntype Person struct {\n    name string\n    age int\n}\nfunc (p Person) sayHi() {\n    fmt.Printf(\"SayHi -- This is %s, my age is %d\\n\",p.name, p.age)\n}\nfunc (p Person) ModifyAge(age int) {\n    fmt.Printf(\"ModifyAge\")\n    p.age = age\n}\n \n \n//输出结果\nperson<vanyar:21>\nSayHi -- This is vanyar, my age is 21\nModifyAgeSayHi -- This is vanyar, my age is 21\n```\n\n尽管 ModifyAge 方法修改了其age字段，可是方法里的p是person变量的一个副本，修改的只是副本的值。下一次调用sayHi方法的时候，还是person的副本，因此修改方法并不会生效。\n\n即实例变量的方式并不会改变接受者本身的值。\n\n**2、类型的实例指针变量**\n\n```go\nfunc (p *Person) ChangeAge(age int)  {\n    fmt.Printf(\"ModifyAge\")\n    p.age = age\n}\n```\n\nGo会根据Person的示例类型，转换成指针类型再拷贝，即 person.ChangeAge会变成 (&person).ChangeAge。\n\n指针类型的接受者，如果实例对象是值，那么go会转换成指针，然后再拷贝，如果本身就是指针对象，那么就直接拷贝指针实例。因为指针都指向一处值，就能修改对象了。\n\n## 5. 零值与nil(空指针)\n\n变量声明而没有赋值，默认为零值，不同类型零值不同，例如字符串零值为空字符串；\n\n指针声明而没有赋值，默认为nil，即该指针没有任何指向。当指针没有指向的时候，不能对(*point)进行操作包括读取，否则会报空指针异常。\n\n```go\nfunc main(){\n    // 声明一个指针变量 aPot 其类型也是 string\n    var aPot *string\n    fmt.Printf(\"aPot: %p %#v\\n\", &aPot, aPot) // 输出 aPot: 0xc42000c030 (*string)(nil)\n    *aPot = \"This is a Pointer\"  // 报错： panic: runtime error: invalid memory address or nil pointer dereference\n}\n```\n\n解决方法即给该指针分配一个指向,即初始化一个内存，并把该内存地址赋予指针变量，例如：\n\n```go\n// 声明一个指针变量 aPot 其类型也是 string\n    var aPot *string\n    fmt.Printf(\"aPot: %p %#v\\n\", &aPot, aPot) // 输出 aPot: 0xc42000c030 (*string)(nil)\n \n    aPot = &aVar\n    *aPot = \"This is a Pointer\"\n    fmt.Printf(\"aVar: %p %#v \\n\", &aVar, aVar) // 输出 aVar: 0xc42000e240 \"This is a Pointer\"\n    fmt.Printf(\"aPot: %p %#v %#v \\n\", &aPot, aPot, *aPot) // 输出 aPot: 0xc42000c030 (*string)(0xc42000e240) \"This is a Pointer\"\n```\n\n或者通过new开辟一个内存，并返回这个内存的地址。\n\n```go\nvar aNewPot *int\n \naNewPot = new(int)\n*aNewPot = 217\nfmt.Printf(\"aNewPot: %p %#v %#v \\n\", &aNewPot, aNewPot, *aNewPot) // 输出 aNewPot: 0xc42007a028 (*int)(0xc42006e1f0) 217\n```\n\n## 6. 总结\n\n- Golang提供了指针用于操作数据内存，并通过引用来修改变量。\n- 只声明未赋值的变量，golang都会自动为其初始化为零值，基础数据类型的零值比较简单，引用类型和指针的零值都为nil，nil类型不能直接赋值，因此需要通过new开辟一个内存，或者通过make初始化数据类型，或者两者配合，然后才能赋值。\n- 指针也是一种类型，不同于一般类型，指针的值是地址，这个地址指向其他的内存，通过指针可以读取其所指向的地址所存储的值。\n- 函数方法的接受者，也可以是指针变量。无论普通接受者还是指针接受者都会被拷贝传入方法中，不同在于拷贝的指针，其指向的地方都一样，只是其自身的地址不一样。\n\n\n\n参考：\n[http://www.jianshu.com/p/d23f78a3922b](http://www.jianshu.com/p/d23f78a3922b)\n[http://www.jianshu.com/p/44b9429d7bef](http://www.jianshu.com/p/44b9429d7bef)","source":"_posts/Golang/Go语言指针.md","raw":"---\ntitle: \"[Golang] Go语言指针详解\"\ncatalog: true\ndate: 2017-10-01 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Golang\ncatagories:\n- Golang\n---\n\n## 1. 指针的概念\n\n| 概念   | 说明                                |\n| ---- | --------------------------------- |\n| 变量   | 是一种占位符，用于引用计算机的内存地址。可理解为内存地址的标签   |\n| 指针   | 表示内存地址，表示地址的指向。指针是一个指向另一个变量内存地址的值 |\n| &    | 取地址符，例如：{指针}:=&{变量}               |\n| *    | 取值符，例如：{变量}:=*{指针}                |\n\n## 2. 内存地址说明\n\n### 2.1. 内存定义\n计算机的内存 RAM 可以把它想象成一些有序的盒子，一个接一个的排成一排，每一个盒子或者单元格都被一个唯一的数字标记依次递增，这个数字就是该单元格的地址，也就是内存的地址。\n![这里写图片描述](http://img.blog.csdn.net/20170907125622072?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**硬件角度**：内存是CPU沟通的桥梁，程序运行在内存中。\n\n**逻辑角度**：内存是一块具备随机访问能力，支持读写操作，用来存放程序及程序运行中产生的数据的区域。\n\n| 概念   | 比喻                            |\n| ---- | ----------------------------- |\n| 内存   | 一层楼层                          |\n| 内存块  | 楼层中的一个房间                      |\n| 变量名  | 房间的标签，例如：总经理室                 |\n| 指针   | 房间的具体地址（门牌号），例如：总经理室地址是2楼201室 |\n| 变量值  | 房间里的具体存储物                     |\n| 指针地址 | 指针的地址：存储指针内存块的地址              |\n\n### 2.2. 内存单位和编址\n\n#### 2.2.1. 内存单位\n\n| 单位       | 说明                                |\n| -------- | --------------------------------- |\n| 位（bit）   | 计算机中最小的数据单位，每一位的状态只能是0或1          |\n| 字节（Byte） | 1Byte=8bit，是内存基本的计量单位             |\n| 字        | “字”由若干个字节构成，字的位数叫字长，不同档次的机器有不同的字长 |\n| KB       | 1KB=1024Byte，即1024个字节             |\n| MB       | 1MB=1024KB                        |\n| GB       | 1GB=1024MB                        |\n\n#### 2.2.2. 内存编址\n\n计算机中的内存按字节编址，每个地址的存储单元可以存放一个字节的数据，CPU通过内存地址获取指令和数据，并不关心这个地址所代表的空间在什么位置，内存地址和地址指向的空间共同构成了一个内存单元。\n\n#### 2.2.3. 内存地址\n\n内存地址通常用16进制的数据表示，例如0x0ffc1。\n## 3.变量与指针运算理解\n编写一段程序，检索出值并存储在地址为 200 的一个块内存中，将其乘以 3，并将结果存储在地址为 201 的另一块内存中\n### 3.1.本质\n1. 检索出内存地址为 200 的值，并将其存储在 CPU 中\n2. 将存储在 CPU 中的值乘以 3\n3. 将 CPU 中存储的结果，写入地址为 201 的内存块中\n\n![这里写图片描述](http://img.blog.csdn.net/20170907130852225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n### 3.2.基于变量的理解\n1. 获取变量 a 中存储的值，并将其存储在 CPU 中\n2. 将其乘以 3\n3. 将结果保存在变量 b 中\n\n![这里写图片描述](http://img.blog.csdn.net/20170907131045953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n```\nvar a = 6 \nvar b = a * 3\n```\n### 3.3.基于指针的理解\n```go\nfunc main() {\n    a := 200\n    b := &a\n    *b++\n    fmt.Println(a)\n}\n```\n以上函数对a进行+1操作，具体理解如下：\n\n**1.a:=200**\n\n![这里写图片描述](http://img.blog.csdn.net/20170907131917257?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**2.  b := &a**\n\n![这里写图片描述](http://img.blog.csdn.net/20170907132113460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**3. *b++**\n\n![这里写图片描述](http://img.blog.csdn.net/20170907132146682?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![这里写图片描述](http://img.blog.csdn.net/20170907132200014?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 4. 指针的使用\n\n### 4.1. 方法中的指针\n\n方法即为有接受者的函数，接受者可以是类型的实例变量或者是类型的实例指针变量。但两种效果不同。\n\n**1、类型的实例变量**\n\n```go\nfunc main(){\n    person := Person{\"vanyar\", 21}\n    fmt.Printf(\"person<%s:%d>\\n\", person.name, person.age)\n    person.sayHi()\n    person.ModifyAge(210)\n    person.sayHi()\n}\ntype Person struct {\n    name string\n    age int\n}\nfunc (p Person) sayHi() {\n    fmt.Printf(\"SayHi -- This is %s, my age is %d\\n\",p.name, p.age)\n}\nfunc (p Person) ModifyAge(age int) {\n    fmt.Printf(\"ModifyAge\")\n    p.age = age\n}\n \n \n//输出结果\nperson<vanyar:21>\nSayHi -- This is vanyar, my age is 21\nModifyAgeSayHi -- This is vanyar, my age is 21\n```\n\n尽管 ModifyAge 方法修改了其age字段，可是方法里的p是person变量的一个副本，修改的只是副本的值。下一次调用sayHi方法的时候，还是person的副本，因此修改方法并不会生效。\n\n即实例变量的方式并不会改变接受者本身的值。\n\n**2、类型的实例指针变量**\n\n```go\nfunc (p *Person) ChangeAge(age int)  {\n    fmt.Printf(\"ModifyAge\")\n    p.age = age\n}\n```\n\nGo会根据Person的示例类型，转换成指针类型再拷贝，即 person.ChangeAge会变成 (&person).ChangeAge。\n\n指针类型的接受者，如果实例对象是值，那么go会转换成指针，然后再拷贝，如果本身就是指针对象，那么就直接拷贝指针实例。因为指针都指向一处值，就能修改对象了。\n\n## 5. 零值与nil(空指针)\n\n变量声明而没有赋值，默认为零值，不同类型零值不同，例如字符串零值为空字符串；\n\n指针声明而没有赋值，默认为nil，即该指针没有任何指向。当指针没有指向的时候，不能对(*point)进行操作包括读取，否则会报空指针异常。\n\n```go\nfunc main(){\n    // 声明一个指针变量 aPot 其类型也是 string\n    var aPot *string\n    fmt.Printf(\"aPot: %p %#v\\n\", &aPot, aPot) // 输出 aPot: 0xc42000c030 (*string)(nil)\n    *aPot = \"This is a Pointer\"  // 报错： panic: runtime error: invalid memory address or nil pointer dereference\n}\n```\n\n解决方法即给该指针分配一个指向,即初始化一个内存，并把该内存地址赋予指针变量，例如：\n\n```go\n// 声明一个指针变量 aPot 其类型也是 string\n    var aPot *string\n    fmt.Printf(\"aPot: %p %#v\\n\", &aPot, aPot) // 输出 aPot: 0xc42000c030 (*string)(nil)\n \n    aPot = &aVar\n    *aPot = \"This is a Pointer\"\n    fmt.Printf(\"aVar: %p %#v \\n\", &aVar, aVar) // 输出 aVar: 0xc42000e240 \"This is a Pointer\"\n    fmt.Printf(\"aPot: %p %#v %#v \\n\", &aPot, aPot, *aPot) // 输出 aPot: 0xc42000c030 (*string)(0xc42000e240) \"This is a Pointer\"\n```\n\n或者通过new开辟一个内存，并返回这个内存的地址。\n\n```go\nvar aNewPot *int\n \naNewPot = new(int)\n*aNewPot = 217\nfmt.Printf(\"aNewPot: %p %#v %#v \\n\", &aNewPot, aNewPot, *aNewPot) // 输出 aNewPot: 0xc42007a028 (*int)(0xc42006e1f0) 217\n```\n\n## 6. 总结\n\n- Golang提供了指针用于操作数据内存，并通过引用来修改变量。\n- 只声明未赋值的变量，golang都会自动为其初始化为零值，基础数据类型的零值比较简单，引用类型和指针的零值都为nil，nil类型不能直接赋值，因此需要通过new开辟一个内存，或者通过make初始化数据类型，或者两者配合，然后才能赋值。\n- 指针也是一种类型，不同于一般类型，指针的值是地址，这个地址指向其他的内存，通过指针可以读取其所指向的地址所存储的值。\n- 函数方法的接受者，也可以是指针变量。无论普通接受者还是指针接受者都会被拷贝传入方法中，不同在于拷贝的指针，其指向的地方都一样，只是其自身的地址不一样。\n\n\n\n参考：\n[http://www.jianshu.com/p/d23f78a3922b](http://www.jianshu.com/p/d23f78a3922b)\n[http://www.jianshu.com/p/44b9429d7bef](http://www.jianshu.com/p/44b9429d7bef)","slug":"Golang/Go语言指针","published":1,"updated":"2017-10-03T06:16:58.702Z","_id":"cj8b7p04e000g2cvurnu7m2rv","comments":1,"layout":"post","photos":[],"link":"","content":"<h2><span id=\"1-指针的概念\">1. 指针的概念</span></h2>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>变量</td>\n<td>是一种占位符，用于引用计算机的内存地址。可理解为内存地址的标签</td>\n</tr>\n<tr>\n<td>指针</td>\n<td>表示内存地址，表示地址的指向。指针是一个指向另一个变量内存地址的值</td>\n</tr>\n<tr>\n<td>&amp;</td>\n<td>取地址符，例如：{指针}:=&amp;{变量}</td>\n</tr>\n<tr>\n<td>*</td>\n<td>取值符，例如：{变量}:=*{指针}</td>\n</tr>\n</tbody>\n</table>\n<h2><span id=\"2-内存地址说明\">2. 内存地址说明</span></h2>\n<h3><span id=\"21-内存定义\">2.1. 内存定义</span></h3>\n<p>计算机的内存 RAM 可以把它想象成一些有序的盒子，一个接一个的排成一排，每一个盒子或者单元格都被一个唯一的数字标记依次递增，这个数字就是该单元格的地址，也就是内存的地址。<br>\n<img src=\"http://img.blog.csdn.net/20170907125622072?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><strong>硬件角度</strong>：内存是CPU沟通的桥梁，程序运行在内存中。</p>\n<p><strong>逻辑角度</strong>：内存是一块具备随机访问能力，支持读写操作，用来存放程序及程序运行中产生的数据的区域。</p>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>内存</td>\n<td>一层楼层</td>\n</tr>\n<tr>\n<td>内存块</td>\n<td>楼层中的一个房间</td>\n</tr>\n<tr>\n<td>变量名</td>\n<td>房间的标签，例如：总经理室</td>\n</tr>\n<tr>\n<td>指针</td>\n<td>房间的具体地址（门牌号），例如：总经理室地址是2楼201室</td>\n</tr>\n<tr>\n<td>变量值</td>\n<td>房间里的具体存储物</td>\n</tr>\n<tr>\n<td>指针地址</td>\n<td>指针的地址：存储指针内存块的地址</td>\n</tr>\n</tbody>\n</table>\n<h3><span id=\"22-内存单位和编址\">2.2. 内存单位和编址</span></h3>\n<h4><span id=\"221-内存单位\">2.2.1. 内存单位</span></h4>\n<table>\n<thead>\n<tr>\n<th>单位</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>位（bit）</td>\n<td>计算机中最小的数据单位，每一位的状态只能是0或1</td>\n</tr>\n<tr>\n<td>字节（Byte）</td>\n<td>1Byte=8bit，是内存基本的计量单位</td>\n</tr>\n<tr>\n<td>字</td>\n<td>“字”由若干个字节构成，字的位数叫字长，不同档次的机器有不同的字长</td>\n</tr>\n<tr>\n<td>KB</td>\n<td>1KB=1024Byte，即1024个字节</td>\n</tr>\n<tr>\n<td>MB</td>\n<td>1MB=1024KB</td>\n</tr>\n<tr>\n<td>GB</td>\n<td>1GB=1024MB</td>\n</tr>\n</tbody>\n</table>\n<h4><span id=\"222-内存编址\">2.2.2. 内存编址</span></h4>\n<p>计算机中的内存按字节编址，每个地址的存储单元可以存放一个字节的数据，CPU通过内存地址获取指令和数据，并不关心这个地址所代表的空间在什么位置，内存地址和地址指向的空间共同构成了一个内存单元。</p>\n<h4><span id=\"223-内存地址\">2.2.3. 内存地址</span></h4>\n<p>内存地址通常用16进制的数据表示，例如0x0ffc1。</p>\n<h2><span id=\"3变量与指针运算理解\">3.变量与指针运算理解</span></h2>\n<p>编写一段程序，检索出值并存储在地址为 200 的一个块内存中，将其乘以 3，并将结果存储在地址为 201 的另一块内存中</p>\n<h3><span id=\"31本质\">3.1.本质</span></h3>\n<ol>\n<li>检索出内存地址为 200 的值，并将其存储在 CPU 中</li>\n<li>将存储在 CPU 中的值乘以 3</li>\n<li>将 CPU 中存储的结果，写入地址为 201 的内存块中</li>\n</ol>\n<p><img src=\"http://img.blog.csdn.net/20170907130852225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h3><span id=\"32基于变量的理解\">3.2.基于变量的理解</span></h3>\n<ol>\n<li>获取变量 a 中存储的值，并将其存储在 CPU 中</li>\n<li>将其乘以 3</li>\n<li>将结果保存在变量 b 中</li>\n</ol>\n<p><img src=\"http://img.blog.csdn.net/20170907131045953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">6</span> </div><div class=\"line\"><span class=\"keyword\">var</span> b = a * <span class=\"number\">3</span></div></pre></td></tr></table></figure>\n<h3><span id=\"33基于指针的理解\">3.3.基于指针的理解</span></h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    a := <span class=\"number\">200</span></div><div class=\"line\">    b := &amp;a</div><div class=\"line\">    *b++</div><div class=\"line\">    fmt.Println(a)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上函数对a进行+1操作，具体理解如下：</p>\n<p><strong>1.a:=200</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20170907131917257?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><strong>2.  b := &amp;a</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20170907132113460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>*<em>3. <em>b++</em></em></p>\n<p><img src=\"http://img.blog.csdn.net/20170907132146682?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20170907132200014?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2><span id=\"4-指针的使用\">4. 指针的使用</span></h2>\n<h3><span id=\"41-方法中的指针\">4.1. 方法中的指针</span></h3>\n<p>方法即为有接受者的函数，接受者可以是类型的实例变量或者是类型的实例指针变量。但两种效果不同。</p>\n<p><strong>1、类型的实例变量</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    person := Person&#123;<span class=\"string\">\"vanyar\"</span>, <span class=\"number\">21</span>&#125;</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"person&lt;%s:%d&gt;\\n\"</span>, person.name, person.age)</div><div class=\"line\">    person.sayHi()</div><div class=\"line\">    person.ModifyAge(<span class=\"number\">210</span>)</div><div class=\"line\">    person.sayHi()</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">type</span> Person <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    name <span class=\"keyword\">string</span></div><div class=\"line\">    age <span class=\"keyword\">int</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Person)</span> <span class=\"title\">sayHi</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"SayHi -- This is %s, my age is %d\\n\"</span>,p.name, p.age)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Person)</span> <span class=\"title\">ModifyAge</span><span class=\"params\">(age <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"ModifyAge\"</span>)</div><div class=\"line\">    p.age = age</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">//输出结果</span></div><div class=\"line\">person&lt;vanyar:<span class=\"number\">21</span>&gt;</div><div class=\"line\">SayHi -- This is vanyar, my age is <span class=\"number\">21</span></div><div class=\"line\">ModifyAgeSayHi -- This is vanyar, my age is <span class=\"number\">21</span></div></pre></td></tr></table></figure>\n<p>尽管 ModifyAge 方法修改了其age字段，可是方法里的p是person变量的一个副本，修改的只是副本的值。下一次调用sayHi方法的时候，还是person的副本，因此修改方法并不会生效。</p>\n<p>即实例变量的方式并不会改变接受者本身的值。</p>\n<p><strong>2、类型的实例指针变量</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Person)</span> <span class=\"title\">ChangeAge</span><span class=\"params\">(age <span class=\"keyword\">int</span>)</span></span>  &#123;</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"ModifyAge\"</span>)</div><div class=\"line\">    p.age = age</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Go会根据Person的示例类型，转换成指针类型再拷贝，即 person.ChangeAge会变成 (&amp;person).ChangeAge。</p>\n<p>指针类型的接受者，如果实例对象是值，那么go会转换成指针，然后再拷贝，如果本身就是指针对象，那么就直接拷贝指针实例。因为指针都指向一处值，就能修改对象了。</p>\n<h2><span id=\"5-零值与nil空指针\">5. 零值与nil(空指针)</span></h2>\n<p>变量声明而没有赋值，默认为零值，不同类型零值不同，例如字符串零值为空字符串；</p>\n<p>指针声明而没有赋值，默认为nil，即该指针没有任何指向。当指针没有指向的时候，不能对(*point)进行操作包括读取，否则会报空指针异常。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 声明一个指针变量 aPot 其类型也是 string</span></div><div class=\"line\">    <span class=\"keyword\">var</span> aPot *<span class=\"keyword\">string</span></div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"aPot: %p %#v\\n\"</span>, &amp;aPot, aPot) <span class=\"comment\">// 输出 aPot: 0xc42000c030 (*string)(nil)</span></div><div class=\"line\">    *aPot = <span class=\"string\">\"This is a Pointer\"</span>  <span class=\"comment\">// 报错： panic: runtime error: invalid memory address or nil pointer dereference</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解决方法即给该指针分配一个指向,即初始化一个内存，并把该内存地址赋予指针变量，例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 声明一个指针变量 aPot 其类型也是 string</span></div><div class=\"line\">    <span class=\"keyword\">var</span> aPot *<span class=\"keyword\">string</span></div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"aPot: %p %#v\\n\"</span>, &amp;aPot, aPot) <span class=\"comment\">// 输出 aPot: 0xc42000c030 (*string)(nil)</span></div><div class=\"line\"> </div><div class=\"line\">    aPot = &amp;aVar</div><div class=\"line\">    *aPot = <span class=\"string\">\"This is a Pointer\"</span></div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"aVar: %p %#v \\n\"</span>, &amp;aVar, aVar) <span class=\"comment\">// 输出 aVar: 0xc42000e240 \"This is a Pointer\"</span></div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"aPot: %p %#v %#v \\n\"</span>, &amp;aPot, aPot, *aPot) <span class=\"comment\">// 输出 aPot: 0xc42000c030 (*string)(0xc42000e240) \"This is a Pointer\"</span></div></pre></td></tr></table></figure>\n<p>或者通过new开辟一个内存，并返回这个内存的地址。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> aNewPot *<span class=\"keyword\">int</span></div><div class=\"line\"> </div><div class=\"line\">aNewPot = <span class=\"built_in\">new</span>(<span class=\"keyword\">int</span>)</div><div class=\"line\">*aNewPot = <span class=\"number\">217</span></div><div class=\"line\">fmt.Printf(<span class=\"string\">\"aNewPot: %p %#v %#v \\n\"</span>, &amp;aNewPot, aNewPot, *aNewPot) <span class=\"comment\">// 输出 aNewPot: 0xc42007a028 (*int)(0xc42006e1f0) 217</span></div></pre></td></tr></table></figure>\n<h2><span id=\"6-总结\">6. 总结</span></h2>\n<ul>\n<li>Golang提供了指针用于操作数据内存，并通过引用来修改变量。</li>\n<li>只声明未赋值的变量，golang都会自动为其初始化为零值，基础数据类型的零值比较简单，引用类型和指针的零值都为nil，nil类型不能直接赋值，因此需要通过new开辟一个内存，或者通过make初始化数据类型，或者两者配合，然后才能赋值。</li>\n<li>指针也是一种类型，不同于一般类型，指针的值是地址，这个地址指向其他的内存，通过指针可以读取其所指向的地址所存储的值。</li>\n<li>函数方法的接受者，也可以是指针变量。无论普通接受者还是指针接受者都会被拷贝传入方法中，不同在于拷贝的指针，其指向的地方都一样，只是其自身的地址不一样。</li>\n</ul>\n<p>参考：<br>\n<a href=\"http://www.jianshu.com/p/d23f78a3922b\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/d23f78a3922b</a><br>\n<a href=\"http://www.jianshu.com/p/44b9429d7bef\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/44b9429d7bef</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 指针的概念</h2>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>变量</td>\n<td>是一种占位符，用于引用计算机的内存地址。可理解为内存地址的标签</td>\n</tr>\n<tr>\n<td>指针</td>\n<td>表示内存地址，表示地址的指向。指针是一个指向另一个变量内存地址的值</td>\n</tr>\n<tr>\n<td>&amp;</td>\n<td>取地址符，例如：{指针}:=&amp;{变量}</td>\n</tr>\n<tr>\n<td>*</td>\n<td>取值符，例如：{变量}:=*{指针}</td>\n</tr>\n</tbody>\n</table>\n<h2>2. 内存地址说明</h2>\n<h3>2.1. 内存定义</h3>\n<p>计算机的内存 RAM 可以把它想象成一些有序的盒子，一个接一个的排成一排，每一个盒子或者单元格都被一个唯一的数字标记依次递增，这个数字就是该单元格的地址，也就是内存的地址。<br>\n<img src=\"http://img.blog.csdn.net/20170907125622072?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><strong>硬件角度</strong>：内存是CPU沟通的桥梁，程序运行在内存中。</p>\n<p><strong>逻辑角度</strong>：内存是一块具备随机访问能力，支持读写操作，用来存放程序及程序运行中产生的数据的区域。</p>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>内存</td>\n<td>一层楼层</td>\n</tr>\n<tr>\n<td>内存块</td>\n<td>楼层中的一个房间</td>\n</tr>\n<tr>\n<td>变量名</td>\n<td>房间的标签，例如：总经理室</td>\n</tr>\n<tr>\n<td>指针</td>\n<td>房间的具体地址（门牌号），例如：总经理室地址是2楼201室</td>\n</tr>\n<tr>\n<td>变量值</td>\n<td>房间里的具体存储物</td>\n</tr>\n<tr>\n<td>指针地址</td>\n<td>指针的地址：存储指针内存块的地址</td>\n</tr>\n</tbody>\n</table>\n<h3>2.2. 内存单位和编址</h3>\n<h4>2.2.1. 内存单位</h4>\n<table>\n<thead>\n<tr>\n<th>单位</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>位（bit）</td>\n<td>计算机中最小的数据单位，每一位的状态只能是0或1</td>\n</tr>\n<tr>\n<td>字节（Byte）</td>\n<td>1Byte=8bit，是内存基本的计量单位</td>\n</tr>\n<tr>\n<td>字</td>\n<td>“字”由若干个字节构成，字的位数叫字长，不同档次的机器有不同的字长</td>\n</tr>\n<tr>\n<td>KB</td>\n<td>1KB=1024Byte，即1024个字节</td>\n</tr>\n<tr>\n<td>MB</td>\n<td>1MB=1024KB</td>\n</tr>\n<tr>\n<td>GB</td>\n<td>1GB=1024MB</td>\n</tr>\n</tbody>\n</table>\n<h4>2.2.2. 内存编址</h4>\n<p>计算机中的内存按字节编址，每个地址的存储单元可以存放一个字节的数据，CPU通过内存地址获取指令和数据，并不关心这个地址所代表的空间在什么位置，内存地址和地址指向的空间共同构成了一个内存单元。</p>\n<h4>2.2.3. 内存地址</h4>\n<p>内存地址通常用16进制的数据表示，例如0x0ffc1。</p>\n<h2>3.变量与指针运算理解</h2>\n<p>编写一段程序，检索出值并存储在地址为 200 的一个块内存中，将其乘以 3，并将结果存储在地址为 201 的另一块内存中</p>\n<h3>3.1.本质</h3>\n<ol>\n<li>检索出内存地址为 200 的值，并将其存储在 CPU 中</li>\n<li>将存储在 CPU 中的值乘以 3</li>\n<li>将 CPU 中存储的结果，写入地址为 201 的内存块中</li>\n</ol>\n<p><img src=\"http://img.blog.csdn.net/20170907130852225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h3>3.2.基于变量的理解</h3>\n<ol>\n<li>获取变量 a 中存储的值，并将其存储在 CPU 中</li>\n<li>将其乘以 3</li>\n<li>将结果保存在变量 b 中</li>\n</ol>\n<p><img src=\"http://img.blog.csdn.net/20170907131045953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">6</span> </div><div class=\"line\"><span class=\"keyword\">var</span> b = a * <span class=\"number\">3</span></div></pre></td></tr></table></figure>\n<h3>3.3.基于指针的理解</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    a := <span class=\"number\">200</span></div><div class=\"line\">    b := &amp;a</div><div class=\"line\">    *b++</div><div class=\"line\">    fmt.Println(a)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上函数对a进行+1操作，具体理解如下：</p>\n<p><strong>1.a:=200</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20170907131917257?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><strong>2.  b := &amp;a</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20170907132113460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>*<em>3. <em>b++</em></em></p>\n<p><img src=\"http://img.blog.csdn.net/20170907132146682?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><img src=\"http://img.blog.csdn.net/20170907132200014?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2>4. 指针的使用</h2>\n<h3>4.1. 方法中的指针</h3>\n<p>方法即为有接受者的函数，接受者可以是类型的实例变量或者是类型的实例指针变量。但两种效果不同。</p>\n<p><strong>1、类型的实例变量</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    person := Person&#123;<span class=\"string\">\"vanyar\"</span>, <span class=\"number\">21</span>&#125;</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"person&lt;%s:%d&gt;\\n\"</span>, person.name, person.age)</div><div class=\"line\">    person.sayHi()</div><div class=\"line\">    person.ModifyAge(<span class=\"number\">210</span>)</div><div class=\"line\">    person.sayHi()</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">type</span> Person <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    name <span class=\"keyword\">string</span></div><div class=\"line\">    age <span class=\"keyword\">int</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Person)</span> <span class=\"title\">sayHi</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"SayHi -- This is %s, my age is %d\\n\"</span>,p.name, p.age)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Person)</span> <span class=\"title\">ModifyAge</span><span class=\"params\">(age <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"ModifyAge\"</span>)</div><div class=\"line\">    p.age = age</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">//输出结果</span></div><div class=\"line\">person&lt;vanyar:<span class=\"number\">21</span>&gt;</div><div class=\"line\">SayHi -- This is vanyar, my age is <span class=\"number\">21</span></div><div class=\"line\">ModifyAgeSayHi -- This is vanyar, my age is <span class=\"number\">21</span></div></pre></td></tr></table></figure>\n<p>尽管 ModifyAge 方法修改了其age字段，可是方法里的p是person变量的一个副本，修改的只是副本的值。下一次调用sayHi方法的时候，还是person的副本，因此修改方法并不会生效。</p>\n<p>即实例变量的方式并不会改变接受者本身的值。</p>\n<p><strong>2、类型的实例指针变量</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Person)</span> <span class=\"title\">ChangeAge</span><span class=\"params\">(age <span class=\"keyword\">int</span>)</span></span>  &#123;</div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"ModifyAge\"</span>)</div><div class=\"line\">    p.age = age</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Go会根据Person的示例类型，转换成指针类型再拷贝，即 person.ChangeAge会变成 (&amp;person).ChangeAge。</p>\n<p>指针类型的接受者，如果实例对象是值，那么go会转换成指针，然后再拷贝，如果本身就是指针对象，那么就直接拷贝指针实例。因为指针都指向一处值，就能修改对象了。</p>\n<h2>5. 零值与nil(空指针)</h2>\n<p>变量声明而没有赋值，默认为零值，不同类型零值不同，例如字符串零值为空字符串；</p>\n<p>指针声明而没有赋值，默认为nil，即该指针没有任何指向。当指针没有指向的时候，不能对(*point)进行操作包括读取，否则会报空指针异常。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 声明一个指针变量 aPot 其类型也是 string</span></div><div class=\"line\">    <span class=\"keyword\">var</span> aPot *<span class=\"keyword\">string</span></div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"aPot: %p %#v\\n\"</span>, &amp;aPot, aPot) <span class=\"comment\">// 输出 aPot: 0xc42000c030 (*string)(nil)</span></div><div class=\"line\">    *aPot = <span class=\"string\">\"This is a Pointer\"</span>  <span class=\"comment\">// 报错： panic: runtime error: invalid memory address or nil pointer dereference</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解决方法即给该指针分配一个指向,即初始化一个内存，并把该内存地址赋予指针变量，例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 声明一个指针变量 aPot 其类型也是 string</span></div><div class=\"line\">    <span class=\"keyword\">var</span> aPot *<span class=\"keyword\">string</span></div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"aPot: %p %#v\\n\"</span>, &amp;aPot, aPot) <span class=\"comment\">// 输出 aPot: 0xc42000c030 (*string)(nil)</span></div><div class=\"line\"> </div><div class=\"line\">    aPot = &amp;aVar</div><div class=\"line\">    *aPot = <span class=\"string\">\"This is a Pointer\"</span></div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"aVar: %p %#v \\n\"</span>, &amp;aVar, aVar) <span class=\"comment\">// 输出 aVar: 0xc42000e240 \"This is a Pointer\"</span></div><div class=\"line\">    fmt.Printf(<span class=\"string\">\"aPot: %p %#v %#v \\n\"</span>, &amp;aPot, aPot, *aPot) <span class=\"comment\">// 输出 aPot: 0xc42000c030 (*string)(0xc42000e240) \"This is a Pointer\"</span></div></pre></td></tr></table></figure>\n<p>或者通过new开辟一个内存，并返回这个内存的地址。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> aNewPot *<span class=\"keyword\">int</span></div><div class=\"line\"> </div><div class=\"line\">aNewPot = <span class=\"built_in\">new</span>(<span class=\"keyword\">int</span>)</div><div class=\"line\">*aNewPot = <span class=\"number\">217</span></div><div class=\"line\">fmt.Printf(<span class=\"string\">\"aNewPot: %p %#v %#v \\n\"</span>, &amp;aNewPot, aNewPot, *aNewPot) <span class=\"comment\">// 输出 aNewPot: 0xc42007a028 (*int)(0xc42006e1f0) 217</span></div></pre></td></tr></table></figure>\n<h2>6. 总结</h2>\n<ul>\n<li>Golang提供了指针用于操作数据内存，并通过引用来修改变量。</li>\n<li>只声明未赋值的变量，golang都会自动为其初始化为零值，基础数据类型的零值比较简单，引用类型和指针的零值都为nil，nil类型不能直接赋值，因此需要通过new开辟一个内存，或者通过make初始化数据类型，或者两者配合，然后才能赋值。</li>\n<li>指针也是一种类型，不同于一般类型，指针的值是地址，这个地址指向其他的内存，通过指针可以读取其所指向的地址所存储的值。</li>\n<li>函数方法的接受者，也可以是指针变量。无论普通接受者还是指针接受者都会被拷贝传入方法中，不同在于拷贝的指针，其指向的地方都一样，只是其自身的地址不一样。</li>\n</ul>\n<p>参考：<br>\n<a href=\"http://www.jianshu.com/p/d23f78a3922b\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/d23f78a3922b</a><br>\n<a href=\"http://www.jianshu.com/p/44b9429d7bef\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/44b9429d7bef</a></p>\n"},{"title":"[Golang] GO HTTP执行流程","catalog":true,"date":"2017-09-01T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Golang"],"_content":"\n## 1. http包建立web服务器\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"strings\"\n)\nfunc sayhelloName(w http.ResponseWriter, r *http.Request) {\n    r.ParseForm()\n    fmt.Println(r.Form)\n    fmt.Println(\"path\", r.URL.Path)\n    fmt.Println(\"scheme\", r.URL.Scheme)\n    fmt.Println(r.Form[\"url_long\"])\n    for k, v := range r.Form {\n        fmt.Println(\"key:\", k)\n        fmt.Println(\"val:\", strings.Join((v), \"\"))\n    }\n    fmt.Println(w, \"hello world\")\n}\nfunc main() {\n    http.HandleFunc(\"/\", sayhelloName)\n    err := http.ListenAndServe(\":9090\", nil)\n    if err != nil {\n        log.Fatal(\"ListenAndServe:\", err)\n    }\n}\n```\n\n## 2. http包的运行机制\n\n相关源码位于：/src/net/http/server.go\n\n**服务端的几个概念**\n\n- Request：用户请求的信息，用来解析用户的请求信息，包括post，get，Cookie，url等信息。\n- Response:服务器需要反馈给客户端的信息。\n- Conn：用户的每次请求链接。\n- Handle:处理请求和生成返回信息的处理逻辑。\n\n**Go实现web服务的流程**\n\n1. 创建Listen Socket，监听指定的端口，等待客户端请求到来。\n2. Listen Socket接受客户端的请求，得到Client Socket，接下来通过Client Socket与客户端通信。\n3. 处理客户端请求，首先从Client Socket读取HTTP请求的协议头，如果是POST方法，还可能要读取客户端提交的数据，然后交给相应的handler处理请求，handler处理完，将数据通过Client Socket返回给客户端。\n\n### 2.1. http包执行流程图\n\n![image2017-3-5 22-46-35](/img/article/golang/http执行流程/http包执行流程图.png)\n\n### 2.2. 注册路由[HandleFunc]\n\nhttp.HandlerFunc类型默认实现了ServeHTTP的接口。\n\n```go\n// The HandlerFunc type is an adapter to allow the use of\n// ordinary functions as HTTP handlers.  If f is a function\n// with the appropriate signature, HandlerFunc(f) is a\n// Handler that calls f.\ntype HandlerFunc func(ResponseWriter, *Request)\n// ServeHTTP calls f(w, r).\nfunc (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {\n    f(w, r)\n}\n```\n\n```go\n// HandleFunc registers the handler function for the given pattern\n// in the DefaultServeMux.\n// The documentation for ServeMux explains how patterns are matched.\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    DefaultServeMux.HandleFunc(pattern, handler)\n}\n...\n// HandleFunc registers the handler function for the given pattern.\nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    mux.Handle(pattern, HandlerFunc(handler))\n}\n```\n\n\n\n**Handle**\n\n```go\n// Handle registers the handler for the given pattern.\n// If a handler already exists for pattern, Handle panics.\nfunc (mux *ServeMux) Handle(pattern string, handler Handler) {\n    mux.mu.Lock()\n    defer mux.mu.Unlock()\n \n    if pattern == \"\" {\n        panic(\"http: invalid pattern \" + pattern)\n    }\n    if handler == nil {\n        panic(\"http: nil handler\")\n    }\n    if mux.m[pattern].explicit {\n        panic(\"http: multiple registrations for \" + pattern)\n    }\n \n    mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern}\n \n    if pattern[0] != '/' {\n        mux.hosts = true\n    }\n \n    // Helpful behavior:\n    // If pattern is /tree/, insert an implicit permanent redirect for /tree.\n    // It can be overridden by an explicit registration.\n    n := len(pattern)\n    if n > 0 && pattern[n-1] == '/' && !mux.m[pattern[0:n-1]].explicit {\n        // If pattern contains a host name, strip it and use remaining\n        // path for redirect.\n        path := pattern\n        if pattern[0] != '/' {\n            // In pattern, at least the last character is a '/', so\n            // strings.Index can't be -1.\n            path = pattern[strings.Index(pattern, \"/\"):]\n        }\n        url := &url.URL{Path: path}\n        mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern}\n    }\n}\n```\n\n### 2.3. 如何监听端口\n\n通过ListenAndServe来监听，底层实现：初始化一个server对象，调用net.Listen(\"tcp\",addr)，也就是底层用TCP协议搭建了一个服务，监听设置的端口。然后调用srv.Serve(net.Listener)函数，这个函数处理接收客户端的请求信息。这个函数里起了一个for循环，通过Listener接收请求，创建conn，开一个goroutine，把请求的数据当作参数给conn去服务：go c.serve()，即每次请求都是在新的goroutine中去服务，利于高并发。\n\n**src/net/http/server.go**\n\n```go\n// ListenAndServe always returns a non-nil error.\nfunc ListenAndServe(addr string, handler Handler) error {\n    server := &Server{Addr: addr, Handler: handler}\n    return server.ListenAndServe()\n}\n...\n// ListenAndServe listens on the TCP network address srv.Addr and then\n// calls Serve to handle requests on incoming connections.\n// Accepted connections are configured to enable TCP keep-alives.\n// If srv.Addr is blank, \":http\" is used.\n// ListenAndServe always returns a non-nil error.\nfunc (srv *Server) ListenAndServe() error {\n    addr := srv.Addr\n    if addr == \"\" {\n        addr = \":http\"\n    }\n    ln, err := net.Listen(\"tcp\", addr)\n    if err != nil {\n        return err\n    }\n    return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})\n}\n```\n\n### 2.4. 如何接收客户端的请求\n\nsrv.Serve\n\n```go\n// Serve accepts incoming connections on the Listener l, creating a\n// new service goroutine for each. The service goroutines read requests and\n// then call srv.Handler to reply to them.\n// Serve always returns a non-nil error.\nfunc (srv *Server) Serve(l net.Listener) error {\n    defer l.Close()\n    if fn := testHookServerServe; fn != nil {\n        fn(srv, l)\n    }\n    var tempDelay time.Duration // how long to sleep on accept failure\n    if err := srv.setupHTTP2(); err != nil {\n        return err\n    }\n    for {\n        rw, e := l.Accept()\n        if e != nil {\n            if ne, ok := e.(net.Error); ok && ne.Temporary() {\n                if tempDelay == 0 {\n                    tempDelay = 5 * time.Millisecond\n                } else {\n                    tempDelay *= 2\n                }\n                if max := 1 * time.Second; tempDelay > max {\n                    tempDelay = max\n                }\n                srv.logf(\"http: Accept error: %v; retrying in %v\", e, tempDelay)\n                time.Sleep(tempDelay)\n                continue\n            }\n            return e\n        }\n        tempDelay = 0\n        c := srv.newConn(rw)\n        c.setState(c.rwc, StateNew) // before Serve can return\n        go c.serve()\n    }\n}\n```\n\n关键代码：\n\n```go\nc := srv.newConn(rw)\nc.setState(c.rwc, StateNew) // before Serve can return\ngo c.serve()\n```\n\n**newConn**\n\n```go\n// Create new connection from rwc.\nfunc (srv *Server) newConn(rwc net.Conn) *conn {\n    c := &conn{\n        server: srv,\n        rwc:    rwc,\n    }\n    if debugServerConnections {\n        c.rwc = newLoggingConn(\"server\", c.rwc)\n    }\n    return c\n}\n```\n\n### 2.5. 如何分配handler\n\nconn先解析request：c.readRequest()，获取相应的handler:handler:=c.server.Handler，即ListenAndServe的第二个参数，因为值为nil，所以默认handler=DefaultServeMux。该变量是一个路由器，用来匹配url跳转到其相应的handle函数。其中http.HandleFunc(\"/\",sayhelloName)即注册了请求“/”的路由规则，当uri为“/”时，路由跳转到函数sayhelloName。DefaultServeMux会调用ServeHTTP方法，这个方法内部调用sayhelloName本身，最后写入response的信息反馈给客户端。\n\n#### 2.5.1. c.serve()\n\n```go\n// Serve a new connection.\nfunc (c *conn) serve() {\n    ...\n    for {\n        w, err := c.readRequest()\n        ...\n        serverHandler{c.server}.ServeHTTP(w, w.req)\n        ..\n    }\n}\n```\n\n#### 2.5.2. c.readRequest()\n\n```go\n// Read next request from connection.\nfunc (c *conn) readRequest() (w *response, err error) {\n    if c.hijacked() {\n        return nil, ErrHijacked\n    }\n \n    if d := c.server.ReadTimeout; d != 0 {\n        c.rwc.SetReadDeadline(time.Now().Add(d))\n    }\n    if d := c.server.WriteTimeout; d != 0 {\n        defer func() {\n            c.rwc.SetWriteDeadline(time.Now().Add(d))\n        }()\n    }\n \n    c.r.setReadLimit(c.server.initialReadLimitSize())\n    c.mu.Lock() // while using bufr\n    if c.lastMethod == \"POST\" {\n        // RFC 2616 section 4.1 tolerance for old buggy clients.\n        peek, _ := c.bufr.Peek(4) // ReadRequest will get err below\n        c.bufr.Discard(numLeadingCRorLF(peek))\n    }\n    req, err := readRequest(c.bufr, keepHostHeader)\n    c.mu.Unlock()\n    if err != nil {\n        if c.r.hitReadLimit() {\n            return nil, errTooLarge\n        }\n        return nil, err\n    }\n    c.lastMethod = req.Method\n    c.r.setInfiniteReadLimit()\n \n    hosts, haveHost := req.Header[\"Host\"]\n    if req.ProtoAtLeast(1, 1) && (!haveHost || len(hosts) == 0) {\n        return nil, badRequestError(\"missing required Host header\")\n    }\n    if len(hosts) > 1 {\n        return nil, badRequestError(\"too many Host headers\")\n    }\n    if len(hosts) == 1 && !validHostHeader(hosts[0]) {\n        return nil, badRequestError(\"malformed Host header\")\n    }\n    for k, vv := range req.Header {\n        if !validHeaderName(k) {\n            return nil, badRequestError(\"invalid header name\")\n        }\n        for _, v := range vv {\n            if !validHeaderValue(v) {\n                return nil, badRequestError(\"invalid header value\")\n            }\n        }\n    }\n    delete(req.Header, \"Host\")\n \n    req.RemoteAddr = c.remoteAddr\n    req.TLS = c.tlsState\n    if body, ok := req.Body.(*body); ok {\n        body.doEarlyClose = true\n    }\n \n    w = &response{\n        conn:          c,\n        req:           req,\n        reqBody:       req.Body,\n        handlerHeader: make(Header),\n        contentLength: -1,\n    }\n    w.cw.res = w\n    w.w = newBufioWriterSize(&w.cw, bufferBeforeChunkingSize)\n    return w, nil\n}\n```\n\n#### 2.5.3. ServeHTTP(w, w.req)\n\n```go\nfunc (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {\n    handler := sh.srv.Handler\n    if handler == nil {\n        handler = DefaultServeMux\n    }\n    if req.RequestURI == \"*\" && req.Method == \"OPTIONS\" {\n        handler = globalOptionsHandler{}\n    }\n    handler.ServeHTTP(rw, req)\n}\n```\n\n#### 2.5.4. DefaultServeMux\n\n```go\ntype ServeMux struct {\n    mu    sync.RWMutex\n    m     map[string]muxEntry\n    hosts bool // whether any patterns contain hostnames\n}\ntype muxEntry struct {\n    explicit bool\n    h        Handler\n    pattern  string\n}\n// NewServeMux allocates and returns a new ServeMux.\nfunc NewServeMux() *ServeMux { return &ServeMux{m: make(map[string]muxEntry)} }\n// DefaultServeMux is the default ServeMux used by Serve.\nvar DefaultServeMux = NewServeMux()\n```\n\n**handler接口的定义**\n\n```go\ntype Handler interface {\n    ServeHTTP(ResponseWriter, *Request)\n}\n```\n\n#### 2.5.5. ServeMux.ServeHTTP\n\n```go\n// ServeHTTP dispatches the request to the handler whose\n// pattern most closely matches the request URL.\nfunc (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n    if r.RequestURI == \"*\" {\n        if r.ProtoAtLeast(1, 1) {\n            w.Header().Set(\"Connection\", \"close\")\n        }\n        w.WriteHeader(StatusBadRequest)\n        return\n    }\n    h, _ := mux.Handler(r)\n    h.ServeHTTP(w, r)\n}\n```\n\n**mux.Handler(r)**\n\n```go\n// Handler returns the handler to use for the given request,\n// consulting r.Method, r.Host, and r.URL.Path. It always returns\n// a non-nil handler. If the path is not in its canonical form, the\n// handler will be an internally-generated handler that redirects\n// to the canonical path.\n//\n// Handler also returns the registered pattern that matches the\n// request or, in the case of internally-generated redirects,\n// the pattern that will match after following the redirect.\n//\n// If there is no registered handler that applies to the request,\n// Handler returns a ``page not found'' handler and an empty pattern.\nfunc (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {\n    if r.Method != \"CONNECT\" {\n        if p := cleanPath(r.URL.Path); p != r.URL.Path {\n            _, pattern = mux.handler(r.Host, p)\n            url := *r.URL\n            url.Path = p\n            return RedirectHandler(url.String(), StatusMovedPermanently), pattern\n        }\n    }\n \n    return mux.handler(r.Host, r.URL.Path)\n}\n \n// handler is the main implementation of Handler.\n// The path is known to be in canonical form, except for CONNECT methods.\nfunc (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {\n    mux.mu.RLock()\n    defer mux.mu.RUnlock()\n \n    // Host-specific pattern takes precedence over generic ones\n    if mux.hosts {\n        h, pattern = mux.match(host + path)\n    }\n    if h == nil {\n        h, pattern = mux.match(path)\n    }\n    if h == nil {\n        h, pattern = NotFoundHandler(), \"\"\n    }\n    return\n}\n```\n\n### 2.6. http连接处理流程图\n\n![image2017-3-5 23-50-6](/img/article/golang/http执行流程/http连接处理流程图.png)\n\n## 3. http的执行流程总结\n\n1、首先调用Http.HandleFunc，按如下顺序执行：\n\n1. 调用了DefaultServerMux的HandleFunc。\n2. 调用了DefaultServerMux的Handle。\n3. 往DefaultServerMux的map[string] muxEntry中增加对应的handler和路由规则。\n\n2、调用http.ListenAndServe(\":9090\",nil)，按如下顺序执行：\n\n1. 实例化Server。\n2. 调用Server的ListenAndServe()。\n3. 调用net.Listen(\"tcp\",addr)监听端口。\n4. 启动一个for循环，在循环体中Accept请求。\n5. 对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve()。\n6. 读取每个请求的内容w,err:=c.readRequest()。\n7. 判断handler是否为空，如果没有设置handler，handler默认设置为DefaultServeMux。\n8. 调用handler的ServeHttp。\n9. 根据request选择handler，并且进入到这个handler的ServeHTTP,\n   mux.handler(r).ServeHTTP(w,r)\n10. 选择handler\n\n- 判断是否有路由能满足这个request（循环遍历ServeMux的muxEntry）。\n- 如果有路由满足，调用这个路由handler的ServeHttp。\n- 如果没有路由满足，调用NotFoundHandler的ServeHttp。\n\n## 4. 自定义路由\n\nGo支持外部实现路由器，ListenAndServe的第二个参数就是配置外部路由器，它是一个Handler接口。即外部路由器实现Hanlder接口。\n\nHandler接口：\n\n```go\ntype Handler interface {\n    ServeHTTP(ResponseWriter, *Request)\n}\n```\n\n自定义路由\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\n)\ntype MyMux struct{\n}\nfunc (p *MyMux) ServeHTTP(w http.ResponseWriter,r *http.Request){\n    if r.URL.Path==\"/\"{\n        sayhelloName(w,r)\n        return\n    }\n    http.NotFound(w,r)\n    return\n}\nfunc sayhelloName(w http.ResponseWriter,r *http.Request){\n    fmt.Fprintln(w,\"Hello myroute\")\n}\nfunc main() {\n    mux:=&MyMux{}\n    http.ListenAndServe(\":9090\",mux)\n     \n}\n```\n\n文章参考：\n\n《Go web编程》","source":"_posts/Golang/网络编程/Go http执行流程.md","raw":"---\ntitle: \"[Golang] GO HTTP执行流程\"\ncatalog: true\ndate: 2017-09-01 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Golang\ncatagories:\n- Golang\n---\n\n## 1. http包建立web服务器\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"strings\"\n)\nfunc sayhelloName(w http.ResponseWriter, r *http.Request) {\n    r.ParseForm()\n    fmt.Println(r.Form)\n    fmt.Println(\"path\", r.URL.Path)\n    fmt.Println(\"scheme\", r.URL.Scheme)\n    fmt.Println(r.Form[\"url_long\"])\n    for k, v := range r.Form {\n        fmt.Println(\"key:\", k)\n        fmt.Println(\"val:\", strings.Join((v), \"\"))\n    }\n    fmt.Println(w, \"hello world\")\n}\nfunc main() {\n    http.HandleFunc(\"/\", sayhelloName)\n    err := http.ListenAndServe(\":9090\", nil)\n    if err != nil {\n        log.Fatal(\"ListenAndServe:\", err)\n    }\n}\n```\n\n## 2. http包的运行机制\n\n相关源码位于：/src/net/http/server.go\n\n**服务端的几个概念**\n\n- Request：用户请求的信息，用来解析用户的请求信息，包括post，get，Cookie，url等信息。\n- Response:服务器需要反馈给客户端的信息。\n- Conn：用户的每次请求链接。\n- Handle:处理请求和生成返回信息的处理逻辑。\n\n**Go实现web服务的流程**\n\n1. 创建Listen Socket，监听指定的端口，等待客户端请求到来。\n2. Listen Socket接受客户端的请求，得到Client Socket，接下来通过Client Socket与客户端通信。\n3. 处理客户端请求，首先从Client Socket读取HTTP请求的协议头，如果是POST方法，还可能要读取客户端提交的数据，然后交给相应的handler处理请求，handler处理完，将数据通过Client Socket返回给客户端。\n\n### 2.1. http包执行流程图\n\n![image2017-3-5 22-46-35](/img/article/golang/http执行流程/http包执行流程图.png)\n\n### 2.2. 注册路由[HandleFunc]\n\nhttp.HandlerFunc类型默认实现了ServeHTTP的接口。\n\n```go\n// The HandlerFunc type is an adapter to allow the use of\n// ordinary functions as HTTP handlers.  If f is a function\n// with the appropriate signature, HandlerFunc(f) is a\n// Handler that calls f.\ntype HandlerFunc func(ResponseWriter, *Request)\n// ServeHTTP calls f(w, r).\nfunc (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {\n    f(w, r)\n}\n```\n\n```go\n// HandleFunc registers the handler function for the given pattern\n// in the DefaultServeMux.\n// The documentation for ServeMux explains how patterns are matched.\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    DefaultServeMux.HandleFunc(pattern, handler)\n}\n...\n// HandleFunc registers the handler function for the given pattern.\nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    mux.Handle(pattern, HandlerFunc(handler))\n}\n```\n\n\n\n**Handle**\n\n```go\n// Handle registers the handler for the given pattern.\n// If a handler already exists for pattern, Handle panics.\nfunc (mux *ServeMux) Handle(pattern string, handler Handler) {\n    mux.mu.Lock()\n    defer mux.mu.Unlock()\n \n    if pattern == \"\" {\n        panic(\"http: invalid pattern \" + pattern)\n    }\n    if handler == nil {\n        panic(\"http: nil handler\")\n    }\n    if mux.m[pattern].explicit {\n        panic(\"http: multiple registrations for \" + pattern)\n    }\n \n    mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern}\n \n    if pattern[0] != '/' {\n        mux.hosts = true\n    }\n \n    // Helpful behavior:\n    // If pattern is /tree/, insert an implicit permanent redirect for /tree.\n    // It can be overridden by an explicit registration.\n    n := len(pattern)\n    if n > 0 && pattern[n-1] == '/' && !mux.m[pattern[0:n-1]].explicit {\n        // If pattern contains a host name, strip it and use remaining\n        // path for redirect.\n        path := pattern\n        if pattern[0] != '/' {\n            // In pattern, at least the last character is a '/', so\n            // strings.Index can't be -1.\n            path = pattern[strings.Index(pattern, \"/\"):]\n        }\n        url := &url.URL{Path: path}\n        mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern}\n    }\n}\n```\n\n### 2.3. 如何监听端口\n\n通过ListenAndServe来监听，底层实现：初始化一个server对象，调用net.Listen(\"tcp\",addr)，也就是底层用TCP协议搭建了一个服务，监听设置的端口。然后调用srv.Serve(net.Listener)函数，这个函数处理接收客户端的请求信息。这个函数里起了一个for循环，通过Listener接收请求，创建conn，开一个goroutine，把请求的数据当作参数给conn去服务：go c.serve()，即每次请求都是在新的goroutine中去服务，利于高并发。\n\n**src/net/http/server.go**\n\n```go\n// ListenAndServe always returns a non-nil error.\nfunc ListenAndServe(addr string, handler Handler) error {\n    server := &Server{Addr: addr, Handler: handler}\n    return server.ListenAndServe()\n}\n...\n// ListenAndServe listens on the TCP network address srv.Addr and then\n// calls Serve to handle requests on incoming connections.\n// Accepted connections are configured to enable TCP keep-alives.\n// If srv.Addr is blank, \":http\" is used.\n// ListenAndServe always returns a non-nil error.\nfunc (srv *Server) ListenAndServe() error {\n    addr := srv.Addr\n    if addr == \"\" {\n        addr = \":http\"\n    }\n    ln, err := net.Listen(\"tcp\", addr)\n    if err != nil {\n        return err\n    }\n    return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})\n}\n```\n\n### 2.4. 如何接收客户端的请求\n\nsrv.Serve\n\n```go\n// Serve accepts incoming connections on the Listener l, creating a\n// new service goroutine for each. The service goroutines read requests and\n// then call srv.Handler to reply to them.\n// Serve always returns a non-nil error.\nfunc (srv *Server) Serve(l net.Listener) error {\n    defer l.Close()\n    if fn := testHookServerServe; fn != nil {\n        fn(srv, l)\n    }\n    var tempDelay time.Duration // how long to sleep on accept failure\n    if err := srv.setupHTTP2(); err != nil {\n        return err\n    }\n    for {\n        rw, e := l.Accept()\n        if e != nil {\n            if ne, ok := e.(net.Error); ok && ne.Temporary() {\n                if tempDelay == 0 {\n                    tempDelay = 5 * time.Millisecond\n                } else {\n                    tempDelay *= 2\n                }\n                if max := 1 * time.Second; tempDelay > max {\n                    tempDelay = max\n                }\n                srv.logf(\"http: Accept error: %v; retrying in %v\", e, tempDelay)\n                time.Sleep(tempDelay)\n                continue\n            }\n            return e\n        }\n        tempDelay = 0\n        c := srv.newConn(rw)\n        c.setState(c.rwc, StateNew) // before Serve can return\n        go c.serve()\n    }\n}\n```\n\n关键代码：\n\n```go\nc := srv.newConn(rw)\nc.setState(c.rwc, StateNew) // before Serve can return\ngo c.serve()\n```\n\n**newConn**\n\n```go\n// Create new connection from rwc.\nfunc (srv *Server) newConn(rwc net.Conn) *conn {\n    c := &conn{\n        server: srv,\n        rwc:    rwc,\n    }\n    if debugServerConnections {\n        c.rwc = newLoggingConn(\"server\", c.rwc)\n    }\n    return c\n}\n```\n\n### 2.5. 如何分配handler\n\nconn先解析request：c.readRequest()，获取相应的handler:handler:=c.server.Handler，即ListenAndServe的第二个参数，因为值为nil，所以默认handler=DefaultServeMux。该变量是一个路由器，用来匹配url跳转到其相应的handle函数。其中http.HandleFunc(\"/\",sayhelloName)即注册了请求“/”的路由规则，当uri为“/”时，路由跳转到函数sayhelloName。DefaultServeMux会调用ServeHTTP方法，这个方法内部调用sayhelloName本身，最后写入response的信息反馈给客户端。\n\n#### 2.5.1. c.serve()\n\n```go\n// Serve a new connection.\nfunc (c *conn) serve() {\n    ...\n    for {\n        w, err := c.readRequest()\n        ...\n        serverHandler{c.server}.ServeHTTP(w, w.req)\n        ..\n    }\n}\n```\n\n#### 2.5.2. c.readRequest()\n\n```go\n// Read next request from connection.\nfunc (c *conn) readRequest() (w *response, err error) {\n    if c.hijacked() {\n        return nil, ErrHijacked\n    }\n \n    if d := c.server.ReadTimeout; d != 0 {\n        c.rwc.SetReadDeadline(time.Now().Add(d))\n    }\n    if d := c.server.WriteTimeout; d != 0 {\n        defer func() {\n            c.rwc.SetWriteDeadline(time.Now().Add(d))\n        }()\n    }\n \n    c.r.setReadLimit(c.server.initialReadLimitSize())\n    c.mu.Lock() // while using bufr\n    if c.lastMethod == \"POST\" {\n        // RFC 2616 section 4.1 tolerance for old buggy clients.\n        peek, _ := c.bufr.Peek(4) // ReadRequest will get err below\n        c.bufr.Discard(numLeadingCRorLF(peek))\n    }\n    req, err := readRequest(c.bufr, keepHostHeader)\n    c.mu.Unlock()\n    if err != nil {\n        if c.r.hitReadLimit() {\n            return nil, errTooLarge\n        }\n        return nil, err\n    }\n    c.lastMethod = req.Method\n    c.r.setInfiniteReadLimit()\n \n    hosts, haveHost := req.Header[\"Host\"]\n    if req.ProtoAtLeast(1, 1) && (!haveHost || len(hosts) == 0) {\n        return nil, badRequestError(\"missing required Host header\")\n    }\n    if len(hosts) > 1 {\n        return nil, badRequestError(\"too many Host headers\")\n    }\n    if len(hosts) == 1 && !validHostHeader(hosts[0]) {\n        return nil, badRequestError(\"malformed Host header\")\n    }\n    for k, vv := range req.Header {\n        if !validHeaderName(k) {\n            return nil, badRequestError(\"invalid header name\")\n        }\n        for _, v := range vv {\n            if !validHeaderValue(v) {\n                return nil, badRequestError(\"invalid header value\")\n            }\n        }\n    }\n    delete(req.Header, \"Host\")\n \n    req.RemoteAddr = c.remoteAddr\n    req.TLS = c.tlsState\n    if body, ok := req.Body.(*body); ok {\n        body.doEarlyClose = true\n    }\n \n    w = &response{\n        conn:          c,\n        req:           req,\n        reqBody:       req.Body,\n        handlerHeader: make(Header),\n        contentLength: -1,\n    }\n    w.cw.res = w\n    w.w = newBufioWriterSize(&w.cw, bufferBeforeChunkingSize)\n    return w, nil\n}\n```\n\n#### 2.5.3. ServeHTTP(w, w.req)\n\n```go\nfunc (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {\n    handler := sh.srv.Handler\n    if handler == nil {\n        handler = DefaultServeMux\n    }\n    if req.RequestURI == \"*\" && req.Method == \"OPTIONS\" {\n        handler = globalOptionsHandler{}\n    }\n    handler.ServeHTTP(rw, req)\n}\n```\n\n#### 2.5.4. DefaultServeMux\n\n```go\ntype ServeMux struct {\n    mu    sync.RWMutex\n    m     map[string]muxEntry\n    hosts bool // whether any patterns contain hostnames\n}\ntype muxEntry struct {\n    explicit bool\n    h        Handler\n    pattern  string\n}\n// NewServeMux allocates and returns a new ServeMux.\nfunc NewServeMux() *ServeMux { return &ServeMux{m: make(map[string]muxEntry)} }\n// DefaultServeMux is the default ServeMux used by Serve.\nvar DefaultServeMux = NewServeMux()\n```\n\n**handler接口的定义**\n\n```go\ntype Handler interface {\n    ServeHTTP(ResponseWriter, *Request)\n}\n```\n\n#### 2.5.5. ServeMux.ServeHTTP\n\n```go\n// ServeHTTP dispatches the request to the handler whose\n// pattern most closely matches the request URL.\nfunc (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n    if r.RequestURI == \"*\" {\n        if r.ProtoAtLeast(1, 1) {\n            w.Header().Set(\"Connection\", \"close\")\n        }\n        w.WriteHeader(StatusBadRequest)\n        return\n    }\n    h, _ := mux.Handler(r)\n    h.ServeHTTP(w, r)\n}\n```\n\n**mux.Handler(r)**\n\n```go\n// Handler returns the handler to use for the given request,\n// consulting r.Method, r.Host, and r.URL.Path. It always returns\n// a non-nil handler. If the path is not in its canonical form, the\n// handler will be an internally-generated handler that redirects\n// to the canonical path.\n//\n// Handler also returns the registered pattern that matches the\n// request or, in the case of internally-generated redirects,\n// the pattern that will match after following the redirect.\n//\n// If there is no registered handler that applies to the request,\n// Handler returns a ``page not found'' handler and an empty pattern.\nfunc (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {\n    if r.Method != \"CONNECT\" {\n        if p := cleanPath(r.URL.Path); p != r.URL.Path {\n            _, pattern = mux.handler(r.Host, p)\n            url := *r.URL\n            url.Path = p\n            return RedirectHandler(url.String(), StatusMovedPermanently), pattern\n        }\n    }\n \n    return mux.handler(r.Host, r.URL.Path)\n}\n \n// handler is the main implementation of Handler.\n// The path is known to be in canonical form, except for CONNECT methods.\nfunc (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {\n    mux.mu.RLock()\n    defer mux.mu.RUnlock()\n \n    // Host-specific pattern takes precedence over generic ones\n    if mux.hosts {\n        h, pattern = mux.match(host + path)\n    }\n    if h == nil {\n        h, pattern = mux.match(path)\n    }\n    if h == nil {\n        h, pattern = NotFoundHandler(), \"\"\n    }\n    return\n}\n```\n\n### 2.6. http连接处理流程图\n\n![image2017-3-5 23-50-6](/img/article/golang/http执行流程/http连接处理流程图.png)\n\n## 3. http的执行流程总结\n\n1、首先调用Http.HandleFunc，按如下顺序执行：\n\n1. 调用了DefaultServerMux的HandleFunc。\n2. 调用了DefaultServerMux的Handle。\n3. 往DefaultServerMux的map[string] muxEntry中增加对应的handler和路由规则。\n\n2、调用http.ListenAndServe(\":9090\",nil)，按如下顺序执行：\n\n1. 实例化Server。\n2. 调用Server的ListenAndServe()。\n3. 调用net.Listen(\"tcp\",addr)监听端口。\n4. 启动一个for循环，在循环体中Accept请求。\n5. 对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve()。\n6. 读取每个请求的内容w,err:=c.readRequest()。\n7. 判断handler是否为空，如果没有设置handler，handler默认设置为DefaultServeMux。\n8. 调用handler的ServeHttp。\n9. 根据request选择handler，并且进入到这个handler的ServeHTTP,\n   mux.handler(r).ServeHTTP(w,r)\n10. 选择handler\n\n- 判断是否有路由能满足这个request（循环遍历ServeMux的muxEntry）。\n- 如果有路由满足，调用这个路由handler的ServeHttp。\n- 如果没有路由满足，调用NotFoundHandler的ServeHttp。\n\n## 4. 自定义路由\n\nGo支持外部实现路由器，ListenAndServe的第二个参数就是配置外部路由器，它是一个Handler接口。即外部路由器实现Hanlder接口。\n\nHandler接口：\n\n```go\ntype Handler interface {\n    ServeHTTP(ResponseWriter, *Request)\n}\n```\n\n自定义路由\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\n)\ntype MyMux struct{\n}\nfunc (p *MyMux) ServeHTTP(w http.ResponseWriter,r *http.Request){\n    if r.URL.Path==\"/\"{\n        sayhelloName(w,r)\n        return\n    }\n    http.NotFound(w,r)\n    return\n}\nfunc sayhelloName(w http.ResponseWriter,r *http.Request){\n    fmt.Fprintln(w,\"Hello myroute\")\n}\nfunc main() {\n    mux:=&MyMux{}\n    http.ListenAndServe(\":9090\",mux)\n     \n}\n```\n\n文章参考：\n\n《Go web编程》","slug":"Golang/网络编程/Go http执行流程","published":1,"updated":"2017-10-03T08:05:46.351Z","_id":"cj8b7sjao000i2cvuop9t7hjz","comments":1,"layout":"post","photos":[],"link":"","content":"<h2><span id=\"1-http包建立web服务器\">1. http包建立web服务器</span></h2>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">    <span class=\"string\">\"log\"</span></div><div class=\"line\">    <span class=\"string\">\"net/http\"</span></div><div class=\"line\">    <span class=\"string\">\"strings\"</span></div><div class=\"line\">)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sayhelloName</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class=\"line\">    r.ParseForm()</div><div class=\"line\">    fmt.Println(r.Form)</div><div class=\"line\">    fmt.Println(<span class=\"string\">\"path\"</span>, r.URL.Path)</div><div class=\"line\">    fmt.Println(<span class=\"string\">\"scheme\"</span>, r.URL.Scheme)</div><div class=\"line\">    fmt.Println(r.Form[<span class=\"string\">\"url_long\"</span>])</div><div class=\"line\">    <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> r.Form &#123;</div><div class=\"line\">        fmt.Println(<span class=\"string\">\"key:\"</span>, k)</div><div class=\"line\">        fmt.Println(<span class=\"string\">\"val:\"</span>, strings.Join((v), <span class=\"string\">\"\"</span>))</div><div class=\"line\">    &#125;</div><div class=\"line\">    fmt.Println(w, <span class=\"string\">\"hello world\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    http.HandleFunc(<span class=\"string\">\"/\"</span>, sayhelloName)</div><div class=\"line\">    err := http.ListenAndServe(<span class=\"string\">\":9090\"</span>, <span class=\"literal\">nil</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        log.Fatal(<span class=\"string\">\"ListenAndServe:\"</span>, err)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2><span id=\"2-http包的运行机制\">2. http包的运行机制</span></h2>\n<p>相关源码位于：/src/net/http/server.go</p>\n<p><strong>服务端的几个概念</strong></p>\n<ul>\n<li>Request：用户请求的信息，用来解析用户的请求信息，包括post，get，Cookie，url等信息。</li>\n<li>Response:服务器需要反馈给客户端的信息。</li>\n<li>Conn：用户的每次请求链接。</li>\n<li>Handle:处理请求和生成返回信息的处理逻辑。</li>\n</ul>\n<p><strong>Go实现web服务的流程</strong></p>\n<ol>\n<li>创建Listen Socket，监听指定的端口，等待客户端请求到来。</li>\n<li>Listen Socket接受客户端的请求，得到Client Socket，接下来通过Client Socket与客户端通信。</li>\n<li>处理客户端请求，首先从Client Socket读取HTTP请求的协议头，如果是POST方法，还可能要读取客户端提交的数据，然后交给相应的handler处理请求，handler处理完，将数据通过Client Socket返回给客户端。</li>\n</ol>\n<h3><span id=\"21-http包执行流程图\">2.1. http包执行流程图</span></h3>\n<p><img src=\"/img/article/golang/http%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/http%E5%8C%85%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png\" alt=\"image2017-3-5 22-46-35\"></p>\n<h3><span id=\"22-注册路由handlefunc\">2.2. 注册路由[HandleFunc]</span></h3>\n<p>http.HandlerFunc类型默认实现了ServeHTTP的接口。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// The HandlerFunc type is an adapter to allow the use of</span></div><div class=\"line\"><span class=\"comment\">// ordinary functions as HTTP handlers.  If f is a function</span></div><div class=\"line\"><span class=\"comment\">// with the appropriate signature, HandlerFunc(f) is a</span></div><div class=\"line\"><span class=\"comment\">// Handler that calls f.</span></div><div class=\"line\"><span class=\"keyword\">type</span> HandlerFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ResponseWriter, *Request)</span></span></div><div class=\"line\"><span class=\"function\">// <span class=\"title\">ServeHTTP</span> <span class=\"title\">calls</span> <span class=\"title\">f</span><span class=\"params\">(w, r)</span>.</span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(f HandlerFunc)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</div><div class=\"line\">    f(w, r)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// HandleFunc registers the handler function for the given pattern</span></div><div class=\"line\"><span class=\"comment\">// in the DefaultServeMux.</span></div><div class=\"line\"><span class=\"comment\">// The documentation for ServeMux explains how patterns are matched.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</div><div class=\"line\">    DefaultServeMux.HandleFunc(pattern, handler)</div><div class=\"line\">&#125;</div><div class=\"line\">...</div><div class=\"line\"><span class=\"comment\">// HandleFunc registers the handler function for the given pattern.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</div><div class=\"line\">    mux.Handle(pattern, HandlerFunc(handler))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>Handle</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Handle registers the handler for the given pattern.</span></div><div class=\"line\"><span class=\"comment\">// If a handler already exists for pattern, Handle panics.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handle</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler Handler)</span></span> &#123;</div><div class=\"line\">    mux.mu.Lock()</div><div class=\"line\">    <span class=\"keyword\">defer</span> mux.mu.Unlock()</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> pattern == <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">\"http: invalid pattern \"</span> + pattern)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> handler == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">\"http: nil handler\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> mux.m[pattern].explicit &#123;</div><div class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">\"http: multiple registrations for \"</span> + pattern)</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    mux.m[pattern] = muxEntry&#123;explicit: <span class=\"literal\">true</span>, h: handler, pattern: pattern&#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> pattern[<span class=\"number\">0</span>] != <span class=\"string\">'/'</span> &#123;</div><div class=\"line\">        mux.hosts = <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">// Helpful behavior:</span></div><div class=\"line\">    <span class=\"comment\">// If pattern is /tree/, insert an implicit permanent redirect for /tree.</span></div><div class=\"line\">    <span class=\"comment\">// It can be overridden by an explicit registration.</span></div><div class=\"line\">    n := <span class=\"built_in\">len</span>(pattern)</div><div class=\"line\">    <span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &amp;&amp; pattern[n<span class=\"number\">-1</span>] == <span class=\"string\">'/'</span> &amp;&amp; !mux.m[pattern[<span class=\"number\">0</span>:n<span class=\"number\">-1</span>]].explicit &#123;</div><div class=\"line\">        <span class=\"comment\">// If pattern contains a host name, strip it and use remaining</span></div><div class=\"line\">        <span class=\"comment\">// path for redirect.</span></div><div class=\"line\">        path := pattern</div><div class=\"line\">        <span class=\"keyword\">if</span> pattern[<span class=\"number\">0</span>] != <span class=\"string\">'/'</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// In pattern, at least the last character is a '/', so</span></div><div class=\"line\">            <span class=\"comment\">// strings.Index can't be -1.</span></div><div class=\"line\">            path = pattern[strings.Index(pattern, <span class=\"string\">\"/\"</span>):]</div><div class=\"line\">        &#125;</div><div class=\"line\">        url := &amp;url.URL&#123;Path: path&#125;</div><div class=\"line\">        mux.m[pattern[<span class=\"number\">0</span>:n<span class=\"number\">-1</span>]] = muxEntry&#123;h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"23-如何监听端口\">2.3. 如何监听端口</span></h3>\n<p>通过ListenAndServe来监听，底层实现：初始化一个server对象，调用net.Listen(“tcp”,addr)，也就是底层用TCP协议搭建了一个服务，监听设置的端口。然后调用srv.Serve(net.Listener)函数，这个函数处理接收客户端的请求信息。这个函数里起了一个for循环，通过Listener接收请求，创建conn，开一个goroutine，把请求的数据当作参数给conn去服务：go c.serve()，即每次请求都是在新的goroutine中去服务，利于高并发。</p>\n<p><strong>src/net/http/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ListenAndServe always returns a non-nil error.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">(addr <span class=\"keyword\">string</span>, handler Handler)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> server.ListenAndServe()</div><div class=\"line\">&#125;</div><div class=\"line\">...</div><div class=\"line\"><span class=\"comment\">// ListenAndServe listens on the TCP network address srv.Addr and then</span></div><div class=\"line\"><span class=\"comment\">// calls Serve to handle requests on incoming connections.</span></div><div class=\"line\"><span class=\"comment\">// Accepted connections are configured to enable TCP keep-alives.</span></div><div class=\"line\"><span class=\"comment\">// If srv.Addr is blank, \":http\" is used.</span></div><div class=\"line\"><span class=\"comment\">// ListenAndServe always returns a non-nil error.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    addr := srv.Addr</div><div class=\"line\">    <span class=\"keyword\">if</span> addr == <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        addr = <span class=\"string\">\":http\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    ln, err := net.Listen(<span class=\"string\">\"tcp\"</span>, addr)</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"24-如何接收客户端的请求\">2.4. 如何接收客户端的请求</span></h3>\n<p>srv.Serve</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Serve accepts incoming connections on the Listener l, creating a</span></div><div class=\"line\"><span class=\"comment\">// new service goroutine for each. The service goroutines read requests and</span></div><div class=\"line\"><span class=\"comment\">// then call srv.Handler to reply to them.</span></div><div class=\"line\"><span class=\"comment\">// Serve always returns a non-nil error.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">Serve</span><span class=\"params\">(l net.Listener)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">defer</span> l.Close()</div><div class=\"line\">    <span class=\"keyword\">if</span> fn := testHookServerServe; fn != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        fn(srv, l)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> tempDelay time.Duration <span class=\"comment\">// how long to sleep on accept failure</span></div><div class=\"line\">    <span class=\"keyword\">if</span> err := srv.setupHTTP2(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> &#123;</div><div class=\"line\">        rw, e := l.Accept()</div><div class=\"line\">        <span class=\"keyword\">if</span> e != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> tempDelay == <span class=\"number\">0</span> &#123;</div><div class=\"line\">                    tempDelay = <span class=\"number\">5</span> * time.Millisecond</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    tempDelay *= <span class=\"number\">2</span></div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">if</span> max := <span class=\"number\">1</span> * time.Second; tempDelay &gt; max &#123;</div><div class=\"line\">                    tempDelay = max</div><div class=\"line\">                &#125;</div><div class=\"line\">                srv.logf(<span class=\"string\">\"http: Accept error: %v; retrying in %v\"</span>, e, tempDelay)</div><div class=\"line\">                time.Sleep(tempDelay)</div><div class=\"line\">                <span class=\"keyword\">continue</span></div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> e</div><div class=\"line\">        &#125;</div><div class=\"line\">        tempDelay = <span class=\"number\">0</span></div><div class=\"line\">        c := srv.newConn(rw)</div><div class=\"line\">        c.setState(c.rwc, StateNew) <span class=\"comment\">// before Serve can return</span></div><div class=\"line\">        <span class=\"keyword\">go</span> c.serve()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关键代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">c := srv.newConn(rw)</div><div class=\"line\">c.setState(c.rwc, StateNew) <span class=\"comment\">// before Serve can return</span></div><div class=\"line\"><span class=\"keyword\">go</span> c.serve()</div></pre></td></tr></table></figure>\n<p><strong>newConn</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Create new connection from rwc.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">newConn</span><span class=\"params\">(rwc net.Conn)</span> *<span class=\"title\">conn</span></span> &#123;</div><div class=\"line\">    c := &amp;conn&#123;</div><div class=\"line\">        server: srv,</div><div class=\"line\">        rwc:    rwc,</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> debugServerConnections &#123;</div><div class=\"line\">        c.rwc = newLoggingConn(<span class=\"string\">\"server\"</span>, c.rwc)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> c</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"25-如何分配handler\">2.5. 如何分配handler</span></h3>\n<p>conn先解析request：c.readRequest()，获取相应的handler:handler:=c.server.Handler，即ListenAndServe的第二个参数，因为值为nil，所以默认handler=DefaultServeMux。该变量是一个路由器，用来匹配url跳转到其相应的handle函数。其中http.HandleFunc(&quot;/&quot;,sayhelloName)即注册了请求“/”的路由规则，当uri为“/”时，路由跳转到函数sayhelloName。DefaultServeMux会调用ServeHTTP方法，这个方法内部调用sayhelloName本身，最后写入response的信息反馈给客户端。</p>\n<h4><span id=\"251-cserve\">2.5.1. c.serve()</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Serve a new connection.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *conn)</span> <span class=\"title\">serve</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">for</span> &#123;</div><div class=\"line\">        w, err := c.readRequest()</div><div class=\"line\">        ...</div><div class=\"line\">        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</div><div class=\"line\">        ..</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4><span id=\"252-creadrequest\">2.5.2. c.readRequest()</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Read next request from connection.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *conn)</span> <span class=\"title\">readRequest</span><span class=\"params\">()</span> <span class=\"params\">(w *response, err error)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> c.hijacked() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrHijacked</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> d := c.server.ReadTimeout; d != <span class=\"number\">0</span> &#123;</div><div class=\"line\">        c.rwc.SetReadDeadline(time.Now().Add(d))</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> d := c.server.WriteTimeout; d != <span class=\"number\">0</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">            c.rwc.SetWriteDeadline(time.Now().Add(d))</div><div class=\"line\">        &#125;()</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    c.r.setReadLimit(c.server.initialReadLimitSize())</div><div class=\"line\">    c.mu.Lock() <span class=\"comment\">// while using bufr</span></div><div class=\"line\">    <span class=\"keyword\">if</span> c.lastMethod == <span class=\"string\">\"POST\"</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// RFC 2616 section 4.1 tolerance for old buggy clients.</span></div><div class=\"line\">        peek, _ := c.bufr.Peek(<span class=\"number\">4</span>) <span class=\"comment\">// ReadRequest will get err below</span></div><div class=\"line\">        c.bufr.Discard(numLeadingCRorLF(peek))</div><div class=\"line\">    &#125;</div><div class=\"line\">    req, err := readRequest(c.bufr, keepHostHeader)</div><div class=\"line\">    c.mu.Unlock()</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> c.r.hitReadLimit() &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, errTooLarge</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</div><div class=\"line\">    &#125;</div><div class=\"line\">    c.lastMethod = req.Method</div><div class=\"line\">    c.r.setInfiniteReadLimit()</div><div class=\"line\"> </div><div class=\"line\">    hosts, haveHost := req.Header[<span class=\"string\">\"Host\"</span>]</div><div class=\"line\">    <span class=\"keyword\">if</span> req.ProtoAtLeast(<span class=\"number\">1</span>, <span class=\"number\">1</span>) &amp;&amp; (!haveHost || <span class=\"built_in\">len</span>(hosts) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, badRequestError(<span class=\"string\">\"missing required Host header\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(hosts) &gt; <span class=\"number\">1</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, badRequestError(<span class=\"string\">\"too many Host headers\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(hosts) == <span class=\"number\">1</span> &amp;&amp; !validHostHeader(hosts[<span class=\"number\">0</span>]) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, badRequestError(<span class=\"string\">\"malformed Host header\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> k, vv := <span class=\"keyword\">range</span> req.Header &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> !validHeaderName(k) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, badRequestError(<span class=\"string\">\"invalid header name\"</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> vv &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> !validHeaderValue(v) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, badRequestError(<span class=\"string\">\"invalid header value\"</span>)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">delete</span>(req.Header, <span class=\"string\">\"Host\"</span>)</div><div class=\"line\"> </div><div class=\"line\">    req.RemoteAddr = c.remoteAddr</div><div class=\"line\">    req.TLS = c.tlsState</div><div class=\"line\">    <span class=\"keyword\">if</span> body, ok := req.Body.(*body); ok &#123;</div><div class=\"line\">        body.doEarlyClose = <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    w = &amp;response&#123;</div><div class=\"line\">        conn:          c,</div><div class=\"line\">        req:           req,</div><div class=\"line\">        reqBody:       req.Body,</div><div class=\"line\">        handlerHeader: <span class=\"built_in\">make</span>(Header),</div><div class=\"line\">        contentLength: <span class=\"number\">-1</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\">    w.cw.res = w</div><div class=\"line\">    w.w = newBufioWriterSize(&amp;w.cw, bufferBeforeChunkingSize)</div><div class=\"line\">    <span class=\"keyword\">return</span> w, <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4><span id=\"253-servehttpw-wreq\">2.5.3. ServeHTTP(w, w.req)</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sh serverHandler)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(rw ResponseWriter, req *Request)</span></span> &#123;</div><div class=\"line\">    handler := sh.srv.Handler</div><div class=\"line\">    <span class=\"keyword\">if</span> handler == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        handler = DefaultServeMux</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> req.RequestURI == <span class=\"string\">\"*\"</span> &amp;&amp; req.Method == <span class=\"string\">\"OPTIONS\"</span> &#123;</div><div class=\"line\">        handler = globalOptionsHandler&#123;&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    handler.ServeHTTP(rw, req)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4><span id=\"254-defaultservemux\">2.5.4. DefaultServeMux</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> ServeMux <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    mu    sync.RWMutex</div><div class=\"line\">    m     <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]muxEntry</div><div class=\"line\">    hosts <span class=\"keyword\">bool</span> <span class=\"comment\">// whether any patterns contain hostnames</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">type</span> muxEntry <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    explicit <span class=\"keyword\">bool</span></div><div class=\"line\">    h        Handler</div><div class=\"line\">    pattern  <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// NewServeMux allocates and returns a new ServeMux.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServeMux</span><span class=\"params\">()</span> *<span class=\"title\">ServeMux</span></span> &#123; <span class=\"keyword\">return</span> &amp;ServeMux&#123;m: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]muxEntry)&#125; &#125;</div><div class=\"line\"><span class=\"comment\">// DefaultServeMux is the default ServeMux used by Serve.</span></div><div class=\"line\"><span class=\"keyword\">var</span> DefaultServeMux = NewServeMux()</div></pre></td></tr></table></figure>\n<p><strong>handler接口的定义</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Handler <span class=\"keyword\">interface</span> &#123;</div><div class=\"line\">    ServeHTTP(ResponseWriter, *Request)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4><span id=\"255-servemuxservehttp\">2.5.5. ServeMux.ServeHTTP</span></h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ServeHTTP dispatches the request to the handler whose</span></div><div class=\"line\"><span class=\"comment\">// pattern most closely matches the request URL.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> r.RequestURI == <span class=\"string\">\"*\"</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> r.ProtoAtLeast(<span class=\"number\">1</span>, <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            w.Header().Set(<span class=\"string\">\"Connection\"</span>, <span class=\"string\">\"close\"</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">        w.WriteHeader(StatusBadRequest)</div><div class=\"line\">        <span class=\"keyword\">return</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    h, _ := mux.Handler(r)</div><div class=\"line\">    h.ServeHTTP(w, r)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>mux.Handler®</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Handler returns the handler to use for the given request,</span></div><div class=\"line\"><span class=\"comment\">// consulting r.Method, r.Host, and r.URL.Path. It always returns</span></div><div class=\"line\"><span class=\"comment\">// a non-nil handler. If the path is not in its canonical form, the</span></div><div class=\"line\"><span class=\"comment\">// handler will be an internally-generated handler that redirects</span></div><div class=\"line\"><span class=\"comment\">// to the canonical path.</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"comment\">// Handler also returns the registered pattern that matches the</span></div><div class=\"line\"><span class=\"comment\">// request or, in the case of internally-generated redirects,</span></div><div class=\"line\"><span class=\"comment\">// the pattern that will match after following the redirect.</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"comment\">// If there is no registered handler that applies to the request,</span></div><div class=\"line\"><span class=\"comment\">// Handler returns a ``page not found'' handler and an empty pattern.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handler</span><span class=\"params\">(r *Request)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> r.Method != <span class=\"string\">\"CONNECT\"</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> p := cleanPath(r.URL.Path); p != r.URL.Path &#123;</div><div class=\"line\">            _, pattern = mux.handler(r.Host, p)</div><div class=\"line\">            url := *r.URL</div><div class=\"line\">            url.Path = p</div><div class=\"line\">            <span class=\"keyword\">return</span> RedirectHandler(url.String(), StatusMovedPermanently), pattern</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">return</span> mux.handler(r.Host, r.URL.Path)</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// handler is the main implementation of Handler.</span></div><div class=\"line\"><span class=\"comment\">// The path is known to be in canonical form, except for CONNECT methods.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">handler</span><span class=\"params\">(host, path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\">    mux.mu.RLock()</div><div class=\"line\">    <span class=\"keyword\">defer</span> mux.mu.RUnlock()</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">// Host-specific pattern takes precedence over generic ones</span></div><div class=\"line\">    <span class=\"keyword\">if</span> mux.hosts &#123;</div><div class=\"line\">        h, pattern = mux.match(host + path)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> h == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        h, pattern = mux.match(path)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> h == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        h, pattern = NotFoundHandler(), <span class=\"string\">\"\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"26-http连接处理流程图\">2.6. http连接处理流程图</span></h3>\n<p><img src=\"/img/article/golang/http%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/http%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%9B%BE.png\" alt=\"image2017-3-5 23-50-6\"></p>\n<h2><span id=\"3-http的执行流程总结\">3. http的执行流程总结</span></h2>\n<p>1、首先调用Http.HandleFunc，按如下顺序执行：</p>\n<ol>\n<li>调用了DefaultServerMux的HandleFunc。</li>\n<li>调用了DefaultServerMux的Handle。</li>\n<li>往DefaultServerMux的map[string] muxEntry中增加对应的handler和路由规则。</li>\n</ol>\n<p>2、调用http.ListenAndServe(&quot;:9090&quot;,nil)，按如下顺序执行：</p>\n<ol>\n<li>实例化Server。</li>\n<li>调用Server的ListenAndServe()。</li>\n<li>调用net.Listen(“tcp”,addr)监听端口。</li>\n<li>启动一个for循环，在循环体中Accept请求。</li>\n<li>对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve()。</li>\n<li>读取每个请求的内容w,err:=c.readRequest()。</li>\n<li>判断handler是否为空，如果没有设置handler，handler默认设置为DefaultServeMux。</li>\n<li>调用handler的ServeHttp。</li>\n<li>根据request选择handler，并且进入到这个handler的ServeHTTP,<br>\nmux.handler®.ServeHTTP(w,r)</li>\n<li>选择handler</li>\n</ol>\n<ul>\n<li>判断是否有路由能满足这个request（循环遍历ServeMux的muxEntry）。</li>\n<li>如果有路由满足，调用这个路由handler的ServeHttp。</li>\n<li>如果没有路由满足，调用NotFoundHandler的ServeHttp。</li>\n</ul>\n<h2><span id=\"4-自定义路由\">4. 自定义路由</span></h2>\n<p>Go支持外部实现路由器，ListenAndServe的第二个参数就是配置外部路由器，它是一个Handler接口。即外部路由器实现Hanlder接口。</p>\n<p>Handler接口：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Handler <span class=\"keyword\">interface</span> &#123;</div><div class=\"line\">    ServeHTTP(ResponseWriter, *Request)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>自定义路由</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">    <span class=\"string\">\"net/http\"</span></div><div class=\"line\">)</div><div class=\"line\"><span class=\"keyword\">type</span> MyMux <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *MyMux)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> r.URL.Path==<span class=\"string\">\"/\"</span>&#123;</div><div class=\"line\">        sayhelloName(w,r)</div><div class=\"line\">        <span class=\"keyword\">return</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    http.NotFound(w,r)</div><div class=\"line\">    <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sayhelloName</span><span class=\"params\">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</div><div class=\"line\">    fmt.Fprintln(w,<span class=\"string\">\"Hello myroute\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    mux:=&amp;MyMux&#123;&#125;</div><div class=\"line\">    http.ListenAndServe(<span class=\"string\">\":9090\"</span>,mux)</div><div class=\"line\">     </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>文章参考：</p>\n<p>《Go web编程》</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. http包建立web服务器</h2>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">    <span class=\"string\">\"log\"</span></div><div class=\"line\">    <span class=\"string\">\"net/http\"</span></div><div class=\"line\">    <span class=\"string\">\"strings\"</span></div><div class=\"line\">)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sayhelloName</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class=\"line\">    r.ParseForm()</div><div class=\"line\">    fmt.Println(r.Form)</div><div class=\"line\">    fmt.Println(<span class=\"string\">\"path\"</span>, r.URL.Path)</div><div class=\"line\">    fmt.Println(<span class=\"string\">\"scheme\"</span>, r.URL.Scheme)</div><div class=\"line\">    fmt.Println(r.Form[<span class=\"string\">\"url_long\"</span>])</div><div class=\"line\">    <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> r.Form &#123;</div><div class=\"line\">        fmt.Println(<span class=\"string\">\"key:\"</span>, k)</div><div class=\"line\">        fmt.Println(<span class=\"string\">\"val:\"</span>, strings.Join((v), <span class=\"string\">\"\"</span>))</div><div class=\"line\">    &#125;</div><div class=\"line\">    fmt.Println(w, <span class=\"string\">\"hello world\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    http.HandleFunc(<span class=\"string\">\"/\"</span>, sayhelloName)</div><div class=\"line\">    err := http.ListenAndServe(<span class=\"string\">\":9090\"</span>, <span class=\"literal\">nil</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        log.Fatal(<span class=\"string\">\"ListenAndServe:\"</span>, err)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2>2. http包的运行机制</h2>\n<p>相关源码位于：/src/net/http/server.go</p>\n<p><strong>服务端的几个概念</strong></p>\n<ul>\n<li>Request：用户请求的信息，用来解析用户的请求信息，包括post，get，Cookie，url等信息。</li>\n<li>Response:服务器需要反馈给客户端的信息。</li>\n<li>Conn：用户的每次请求链接。</li>\n<li>Handle:处理请求和生成返回信息的处理逻辑。</li>\n</ul>\n<p><strong>Go实现web服务的流程</strong></p>\n<ol>\n<li>创建Listen Socket，监听指定的端口，等待客户端请求到来。</li>\n<li>Listen Socket接受客户端的请求，得到Client Socket，接下来通过Client Socket与客户端通信。</li>\n<li>处理客户端请求，首先从Client Socket读取HTTP请求的协议头，如果是POST方法，还可能要读取客户端提交的数据，然后交给相应的handler处理请求，handler处理完，将数据通过Client Socket返回给客户端。</li>\n</ol>\n<h3>2.1. http包执行流程图</h3>\n<p><img src=\"/img/article/golang/http%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/http%E5%8C%85%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png\" alt=\"image2017-3-5 22-46-35\"></p>\n<h3>2.2. 注册路由[HandleFunc]</h3>\n<p>http.HandlerFunc类型默认实现了ServeHTTP的接口。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// The HandlerFunc type is an adapter to allow the use of</span></div><div class=\"line\"><span class=\"comment\">// ordinary functions as HTTP handlers.  If f is a function</span></div><div class=\"line\"><span class=\"comment\">// with the appropriate signature, HandlerFunc(f) is a</span></div><div class=\"line\"><span class=\"comment\">// Handler that calls f.</span></div><div class=\"line\"><span class=\"keyword\">type</span> HandlerFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ResponseWriter, *Request)</span></span></div><div class=\"line\"><span class=\"function\">// <span class=\"title\">ServeHTTP</span> <span class=\"title\">calls</span> <span class=\"title\">f</span><span class=\"params\">(w, r)</span>.</span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(f HandlerFunc)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</div><div class=\"line\">    f(w, r)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// HandleFunc registers the handler function for the given pattern</span></div><div class=\"line\"><span class=\"comment\">// in the DefaultServeMux.</span></div><div class=\"line\"><span class=\"comment\">// The documentation for ServeMux explains how patterns are matched.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</div><div class=\"line\">    DefaultServeMux.HandleFunc(pattern, handler)</div><div class=\"line\">&#125;</div><div class=\"line\">...</div><div class=\"line\"><span class=\"comment\">// HandleFunc registers the handler function for the given pattern.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</div><div class=\"line\">    mux.Handle(pattern, HandlerFunc(handler))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>Handle</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Handle registers the handler for the given pattern.</span></div><div class=\"line\"><span class=\"comment\">// If a handler already exists for pattern, Handle panics.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handle</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler Handler)</span></span> &#123;</div><div class=\"line\">    mux.mu.Lock()</div><div class=\"line\">    <span class=\"keyword\">defer</span> mux.mu.Unlock()</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> pattern == <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">\"http: invalid pattern \"</span> + pattern)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> handler == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">\"http: nil handler\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> mux.m[pattern].explicit &#123;</div><div class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">\"http: multiple registrations for \"</span> + pattern)</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    mux.m[pattern] = muxEntry&#123;explicit: <span class=\"literal\">true</span>, h: handler, pattern: pattern&#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> pattern[<span class=\"number\">0</span>] != <span class=\"string\">'/'</span> &#123;</div><div class=\"line\">        mux.hosts = <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">// Helpful behavior:</span></div><div class=\"line\">    <span class=\"comment\">// If pattern is /tree/, insert an implicit permanent redirect for /tree.</span></div><div class=\"line\">    <span class=\"comment\">// It can be overridden by an explicit registration.</span></div><div class=\"line\">    n := <span class=\"built_in\">len</span>(pattern)</div><div class=\"line\">    <span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &amp;&amp; pattern[n<span class=\"number\">-1</span>] == <span class=\"string\">'/'</span> &amp;&amp; !mux.m[pattern[<span class=\"number\">0</span>:n<span class=\"number\">-1</span>]].explicit &#123;</div><div class=\"line\">        <span class=\"comment\">// If pattern contains a host name, strip it and use remaining</span></div><div class=\"line\">        <span class=\"comment\">// path for redirect.</span></div><div class=\"line\">        path := pattern</div><div class=\"line\">        <span class=\"keyword\">if</span> pattern[<span class=\"number\">0</span>] != <span class=\"string\">'/'</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// In pattern, at least the last character is a '/', so</span></div><div class=\"line\">            <span class=\"comment\">// strings.Index can't be -1.</span></div><div class=\"line\">            path = pattern[strings.Index(pattern, <span class=\"string\">\"/\"</span>):]</div><div class=\"line\">        &#125;</div><div class=\"line\">        url := &amp;url.URL&#123;Path: path&#125;</div><div class=\"line\">        mux.m[pattern[<span class=\"number\">0</span>:n<span class=\"number\">-1</span>]] = muxEntry&#123;h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>2.3. 如何监听端口</h3>\n<p>通过ListenAndServe来监听，底层实现：初始化一个server对象，调用net.Listen(“tcp”,addr)，也就是底层用TCP协议搭建了一个服务，监听设置的端口。然后调用srv.Serve(net.Listener)函数，这个函数处理接收客户端的请求信息。这个函数里起了一个for循环，通过Listener接收请求，创建conn，开一个goroutine，把请求的数据当作参数给conn去服务：go c.serve()，即每次请求都是在新的goroutine中去服务，利于高并发。</p>\n<p><strong>src/net/http/server.go</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ListenAndServe always returns a non-nil error.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">(addr <span class=\"keyword\">string</span>, handler Handler)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> server.ListenAndServe()</div><div class=\"line\">&#125;</div><div class=\"line\">...</div><div class=\"line\"><span class=\"comment\">// ListenAndServe listens on the TCP network address srv.Addr and then</span></div><div class=\"line\"><span class=\"comment\">// calls Serve to handle requests on incoming connections.</span></div><div class=\"line\"><span class=\"comment\">// Accepted connections are configured to enable TCP keep-alives.</span></div><div class=\"line\"><span class=\"comment\">// If srv.Addr is blank, \":http\" is used.</span></div><div class=\"line\"><span class=\"comment\">// ListenAndServe always returns a non-nil error.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    addr := srv.Addr</div><div class=\"line\">    <span class=\"keyword\">if</span> addr == <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        addr = <span class=\"string\">\":http\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    ln, err := net.Listen(<span class=\"string\">\"tcp\"</span>, addr)</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>2.4. 如何接收客户端的请求</h3>\n<p>srv.Serve</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Serve accepts incoming connections on the Listener l, creating a</span></div><div class=\"line\"><span class=\"comment\">// new service goroutine for each. The service goroutines read requests and</span></div><div class=\"line\"><span class=\"comment\">// then call srv.Handler to reply to them.</span></div><div class=\"line\"><span class=\"comment\">// Serve always returns a non-nil error.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">Serve</span><span class=\"params\">(l net.Listener)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">defer</span> l.Close()</div><div class=\"line\">    <span class=\"keyword\">if</span> fn := testHookServerServe; fn != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        fn(srv, l)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> tempDelay time.Duration <span class=\"comment\">// how long to sleep on accept failure</span></div><div class=\"line\">    <span class=\"keyword\">if</span> err := srv.setupHTTP2(); err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> err</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> &#123;</div><div class=\"line\">        rw, e := l.Accept()</div><div class=\"line\">        <span class=\"keyword\">if</span> e != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> tempDelay == <span class=\"number\">0</span> &#123;</div><div class=\"line\">                    tempDelay = <span class=\"number\">5</span> * time.Millisecond</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    tempDelay *= <span class=\"number\">2</span></div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">if</span> max := <span class=\"number\">1</span> * time.Second; tempDelay &gt; max &#123;</div><div class=\"line\">                    tempDelay = max</div><div class=\"line\">                &#125;</div><div class=\"line\">                srv.logf(<span class=\"string\">\"http: Accept error: %v; retrying in %v\"</span>, e, tempDelay)</div><div class=\"line\">                time.Sleep(tempDelay)</div><div class=\"line\">                <span class=\"keyword\">continue</span></div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> e</div><div class=\"line\">        &#125;</div><div class=\"line\">        tempDelay = <span class=\"number\">0</span></div><div class=\"line\">        c := srv.newConn(rw)</div><div class=\"line\">        c.setState(c.rwc, StateNew) <span class=\"comment\">// before Serve can return</span></div><div class=\"line\">        <span class=\"keyword\">go</span> c.serve()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关键代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">c := srv.newConn(rw)</div><div class=\"line\">c.setState(c.rwc, StateNew) <span class=\"comment\">// before Serve can return</span></div><div class=\"line\"><span class=\"keyword\">go</span> c.serve()</div></pre></td></tr></table></figure>\n<p><strong>newConn</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Create new connection from rwc.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">newConn</span><span class=\"params\">(rwc net.Conn)</span> *<span class=\"title\">conn</span></span> &#123;</div><div class=\"line\">    c := &amp;conn&#123;</div><div class=\"line\">        server: srv,</div><div class=\"line\">        rwc:    rwc,</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> debugServerConnections &#123;</div><div class=\"line\">        c.rwc = newLoggingConn(<span class=\"string\">\"server\"</span>, c.rwc)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> c</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>2.5. 如何分配handler</h3>\n<p>conn先解析request：c.readRequest()，获取相应的handler:handler:=c.server.Handler，即ListenAndServe的第二个参数，因为值为nil，所以默认handler=DefaultServeMux。该变量是一个路由器，用来匹配url跳转到其相应的handle函数。其中http.HandleFunc(&quot;/&quot;,sayhelloName)即注册了请求“/”的路由规则，当uri为“/”时，路由跳转到函数sayhelloName。DefaultServeMux会调用ServeHTTP方法，这个方法内部调用sayhelloName本身，最后写入response的信息反馈给客户端。</p>\n<h4>2.5.1. c.serve()</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Serve a new connection.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *conn)</span> <span class=\"title\">serve</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">for</span> &#123;</div><div class=\"line\">        w, err := c.readRequest()</div><div class=\"line\">        ...</div><div class=\"line\">        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</div><div class=\"line\">        ..</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4>2.5.2. c.readRequest()</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Read next request from connection.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *conn)</span> <span class=\"title\">readRequest</span><span class=\"params\">()</span> <span class=\"params\">(w *response, err error)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> c.hijacked() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrHijacked</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> d := c.server.ReadTimeout; d != <span class=\"number\">0</span> &#123;</div><div class=\"line\">        c.rwc.SetReadDeadline(time.Now().Add(d))</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> d := c.server.WriteTimeout; d != <span class=\"number\">0</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">            c.rwc.SetWriteDeadline(time.Now().Add(d))</div><div class=\"line\">        &#125;()</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    c.r.setReadLimit(c.server.initialReadLimitSize())</div><div class=\"line\">    c.mu.Lock() <span class=\"comment\">// while using bufr</span></div><div class=\"line\">    <span class=\"keyword\">if</span> c.lastMethod == <span class=\"string\">\"POST\"</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// RFC 2616 section 4.1 tolerance for old buggy clients.</span></div><div class=\"line\">        peek, _ := c.bufr.Peek(<span class=\"number\">4</span>) <span class=\"comment\">// ReadRequest will get err below</span></div><div class=\"line\">        c.bufr.Discard(numLeadingCRorLF(peek))</div><div class=\"line\">    &#125;</div><div class=\"line\">    req, err := readRequest(c.bufr, keepHostHeader)</div><div class=\"line\">    c.mu.Unlock()</div><div class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> c.r.hitReadLimit() &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, errTooLarge</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</div><div class=\"line\">    &#125;</div><div class=\"line\">    c.lastMethod = req.Method</div><div class=\"line\">    c.r.setInfiniteReadLimit()</div><div class=\"line\"> </div><div class=\"line\">    hosts, haveHost := req.Header[<span class=\"string\">\"Host\"</span>]</div><div class=\"line\">    <span class=\"keyword\">if</span> req.ProtoAtLeast(<span class=\"number\">1</span>, <span class=\"number\">1</span>) &amp;&amp; (!haveHost || <span class=\"built_in\">len</span>(hosts) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, badRequestError(<span class=\"string\">\"missing required Host header\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(hosts) &gt; <span class=\"number\">1</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, badRequestError(<span class=\"string\">\"too many Host headers\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(hosts) == <span class=\"number\">1</span> &amp;&amp; !validHostHeader(hosts[<span class=\"number\">0</span>]) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, badRequestError(<span class=\"string\">\"malformed Host header\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> k, vv := <span class=\"keyword\">range</span> req.Header &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> !validHeaderName(k) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, badRequestError(<span class=\"string\">\"invalid header name\"</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> vv &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> !validHeaderValue(v) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, badRequestError(<span class=\"string\">\"invalid header value\"</span>)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">delete</span>(req.Header, <span class=\"string\">\"Host\"</span>)</div><div class=\"line\"> </div><div class=\"line\">    req.RemoteAddr = c.remoteAddr</div><div class=\"line\">    req.TLS = c.tlsState</div><div class=\"line\">    <span class=\"keyword\">if</span> body, ok := req.Body.(*body); ok &#123;</div><div class=\"line\">        body.doEarlyClose = <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    w = &amp;response&#123;</div><div class=\"line\">        conn:          c,</div><div class=\"line\">        req:           req,</div><div class=\"line\">        reqBody:       req.Body,</div><div class=\"line\">        handlerHeader: <span class=\"built_in\">make</span>(Header),</div><div class=\"line\">        contentLength: <span class=\"number\">-1</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\">    w.cw.res = w</div><div class=\"line\">    w.w = newBufioWriterSize(&amp;w.cw, bufferBeforeChunkingSize)</div><div class=\"line\">    <span class=\"keyword\">return</span> w, <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4>2.5.3. ServeHTTP(w, w.req)</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sh serverHandler)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(rw ResponseWriter, req *Request)</span></span> &#123;</div><div class=\"line\">    handler := sh.srv.Handler</div><div class=\"line\">    <span class=\"keyword\">if</span> handler == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        handler = DefaultServeMux</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> req.RequestURI == <span class=\"string\">\"*\"</span> &amp;&amp; req.Method == <span class=\"string\">\"OPTIONS\"</span> &#123;</div><div class=\"line\">        handler = globalOptionsHandler&#123;&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    handler.ServeHTTP(rw, req)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4>2.5.4. DefaultServeMux</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> ServeMux <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    mu    sync.RWMutex</div><div class=\"line\">    m     <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]muxEntry</div><div class=\"line\">    hosts <span class=\"keyword\">bool</span> <span class=\"comment\">// whether any patterns contain hostnames</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">type</span> muxEntry <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    explicit <span class=\"keyword\">bool</span></div><div class=\"line\">    h        Handler</div><div class=\"line\">    pattern  <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// NewServeMux allocates and returns a new ServeMux.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServeMux</span><span class=\"params\">()</span> *<span class=\"title\">ServeMux</span></span> &#123; <span class=\"keyword\">return</span> &amp;ServeMux&#123;m: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]muxEntry)&#125; &#125;</div><div class=\"line\"><span class=\"comment\">// DefaultServeMux is the default ServeMux used by Serve.</span></div><div class=\"line\"><span class=\"keyword\">var</span> DefaultServeMux = NewServeMux()</div></pre></td></tr></table></figure>\n<p><strong>handler接口的定义</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Handler <span class=\"keyword\">interface</span> &#123;</div><div class=\"line\">    ServeHTTP(ResponseWriter, *Request)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4>2.5.5. ServeMux.ServeHTTP</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ServeHTTP dispatches the request to the handler whose</span></div><div class=\"line\"><span class=\"comment\">// pattern most closely matches the request URL.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> r.RequestURI == <span class=\"string\">\"*\"</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> r.ProtoAtLeast(<span class=\"number\">1</span>, <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            w.Header().Set(<span class=\"string\">\"Connection\"</span>, <span class=\"string\">\"close\"</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">        w.WriteHeader(StatusBadRequest)</div><div class=\"line\">        <span class=\"keyword\">return</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    h, _ := mux.Handler(r)</div><div class=\"line\">    h.ServeHTTP(w, r)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>mux.Handler®</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Handler returns the handler to use for the given request,</span></div><div class=\"line\"><span class=\"comment\">// consulting r.Method, r.Host, and r.URL.Path. It always returns</span></div><div class=\"line\"><span class=\"comment\">// a non-nil handler. If the path is not in its canonical form, the</span></div><div class=\"line\"><span class=\"comment\">// handler will be an internally-generated handler that redirects</span></div><div class=\"line\"><span class=\"comment\">// to the canonical path.</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"comment\">// Handler also returns the registered pattern that matches the</span></div><div class=\"line\"><span class=\"comment\">// request or, in the case of internally-generated redirects,</span></div><div class=\"line\"><span class=\"comment\">// the pattern that will match after following the redirect.</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"comment\">// If there is no registered handler that applies to the request,</span></div><div class=\"line\"><span class=\"comment\">// Handler returns a ``page not found'' handler and an empty pattern.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handler</span><span class=\"params\">(r *Request)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> r.Method != <span class=\"string\">\"CONNECT\"</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> p := cleanPath(r.URL.Path); p != r.URL.Path &#123;</div><div class=\"line\">            _, pattern = mux.handler(r.Host, p)</div><div class=\"line\">            url := *r.URL</div><div class=\"line\">            url.Path = p</div><div class=\"line\">            <span class=\"keyword\">return</span> RedirectHandler(url.String(), StatusMovedPermanently), pattern</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">return</span> mux.handler(r.Host, r.URL.Path)</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// handler is the main implementation of Handler.</span></div><div class=\"line\"><span class=\"comment\">// The path is known to be in canonical form, except for CONNECT methods.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">handler</span><span class=\"params\">(host, path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span></span> &#123;</div><div class=\"line\">    mux.mu.RLock()</div><div class=\"line\">    <span class=\"keyword\">defer</span> mux.mu.RUnlock()</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">// Host-specific pattern takes precedence over generic ones</span></div><div class=\"line\">    <span class=\"keyword\">if</span> mux.hosts &#123;</div><div class=\"line\">        h, pattern = mux.match(host + path)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> h == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        h, pattern = mux.match(path)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> h == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        h, pattern = NotFoundHandler(), <span class=\"string\">\"\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>2.6. http连接处理流程图</h3>\n<p><img src=\"/img/article/golang/http%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/http%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%9B%BE.png\" alt=\"image2017-3-5 23-50-6\"></p>\n<h2>3. http的执行流程总结</h2>\n<p>1、首先调用Http.HandleFunc，按如下顺序执行：</p>\n<ol>\n<li>调用了DefaultServerMux的HandleFunc。</li>\n<li>调用了DefaultServerMux的Handle。</li>\n<li>往DefaultServerMux的map[string] muxEntry中增加对应的handler和路由规则。</li>\n</ol>\n<p>2、调用http.ListenAndServe(&quot;:9090&quot;,nil)，按如下顺序执行：</p>\n<ol>\n<li>实例化Server。</li>\n<li>调用Server的ListenAndServe()。</li>\n<li>调用net.Listen(“tcp”,addr)监听端口。</li>\n<li>启动一个for循环，在循环体中Accept请求。</li>\n<li>对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve()。</li>\n<li>读取每个请求的内容w,err:=c.readRequest()。</li>\n<li>判断handler是否为空，如果没有设置handler，handler默认设置为DefaultServeMux。</li>\n<li>调用handler的ServeHttp。</li>\n<li>根据request选择handler，并且进入到这个handler的ServeHTTP,<br>\nmux.handler®.ServeHTTP(w,r)</li>\n<li>选择handler</li>\n</ol>\n<ul>\n<li>判断是否有路由能满足这个request（循环遍历ServeMux的muxEntry）。</li>\n<li>如果有路由满足，调用这个路由handler的ServeHttp。</li>\n<li>如果没有路由满足，调用NotFoundHandler的ServeHttp。</li>\n</ul>\n<h2>4. 自定义路由</h2>\n<p>Go支持外部实现路由器，ListenAndServe的第二个参数就是配置外部路由器，它是一个Handler接口。即外部路由器实现Hanlder接口。</p>\n<p>Handler接口：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Handler <span class=\"keyword\">interface</span> &#123;</div><div class=\"line\">    ServeHTTP(ResponseWriter, *Request)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>自定义路由</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">    <span class=\"string\">\"net/http\"</span></div><div class=\"line\">)</div><div class=\"line\"><span class=\"keyword\">type</span> MyMux <span class=\"keyword\">struct</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *MyMux)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> r.URL.Path==<span class=\"string\">\"/\"</span>&#123;</div><div class=\"line\">        sayhelloName(w,r)</div><div class=\"line\">        <span class=\"keyword\">return</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    http.NotFound(w,r)</div><div class=\"line\">    <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sayhelloName</span><span class=\"params\">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</div><div class=\"line\">    fmt.Fprintln(w,<span class=\"string\">\"Hello myroute\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    mux:=&amp;MyMux&#123;&#125;</div><div class=\"line\">    http.ListenAndServe(<span class=\"string\">\":9090\"</span>,mux)</div><div class=\"line\">     </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>文章参考：</p>\n<p>《Go web编程》</p>\n"},{"title":"[Golang] Golang之GDB调试","catalog":true,"date":"2017-09-01T02:50:57.000Z","type":"categories","subtitle":null,"header-img":"/img/article_header_img/article_header.png","catagories":["Golang"],"_content":"\n## 1. GDB简介\n\nGDB是FSF(自由软件基金会)发布的一个强大的类UNIX系统下的程序调试工具。使用GDB可以做如下事情：\n\n1. 启动程序，可以按照开发者的自定义要求运行程序。\n2. 可让被调试的程序在开发者设定的调置的断点处停住。（断点可以是条件表达式）\n3. 当程序被停住时，可以检查此时程序中所发生的事。\n4. 动态的改变当前程序的执行环境。\n\n目前支持调试Go程序的GDB版本必须大于7.1。\n\n编译Go程序的时候需要注意以下几点\n\n1. 传递参数-ldflags \"-s\"，忽略debug的打印信息\n2. 传递-gcflags \"-N -l\" 参数，这样可以忽略Go内部做的一些优化，聚合变量和函数等优化，这样对于GDB调试来说非常困难，所以在编译的时候加入这两个参数避免这些优化。\n\n## 2. 常用命令\n\n### 2.1. list\n\n简写命令`l`，用来显示源代码，默认显示十行代码，后面可以带上参数显示的具体行，例如：`list 15`，显示十行代码，其中第15行在显示的十行里面的中间，如下所示。\n\n```\n  10\t        time.Sleep(2 * time.Second)\n  11\t        c <- i\n  12\t    }\n  13\t    close(c)\n  14\t}\n  15\t\n  16\tfunc main() {\n  17\t    msg := \"Starting main\"\n  18\t    fmt.Println(msg)\n  19\t    bus := make(chan int)\n```\n\n### 2.2. break\n\n简写命令 `b`,用来设置断点，后面跟上参数设置断点的行数，例如`b 10`在第十行设置断点。\n\n### 2.3. delete\n\n简写命令 `d`,用来删除断点，后面跟上断点设置的序号，这个序号可以通过`info breakpoints`获取相应的设置的断点序号，如下是显示的设置断点序号。\n\n```\n  Num     Type           Disp Enb Address            What\n  2       breakpoint     keep y   0x0000000000400dc3 in main.main at /home/xiemengjun/gdb.go:23\n  breakpoint already hit 1 time\n```\n\n### 2.4. backtrace\n\n简写命令 `bt`,用来打印执行的代码过程，如下所示：\n\n```\n  #0  main.main () at /home/xiemengjun/gdb.go:23\n  #1  0x000000000040d61e in runtime.main () at /home/xiemengjun/go/src/pkg/runtime/proc.c:244\n  #2  0x000000000040d6c1 in schedunlock () at /home/xiemengjun/go/src/pkg/runtime/proc.c:267\n  #3  0x0000000000000000 in ?? ()\n```\n\n### 2.5. info\n\ninfo命令用来显示信息，后面有几种参数，我们常用的有如下几种：\n\n- -   `info locals`\n\n      显示当前执行的程序中的变量值\n\n  -   `info breakpoints`\n\n      显示当前设置的断点列表\n\n  -   `info goroutines`\n\n      显示当前执行的goroutine列表，如下代码所示,带*的表示当前执行的\n\n      ```\n      * 1  running runtime.gosched\n      * 2  syscall runtime.entersyscall\n        3  waiting runtime.gosched\n        4 runnable runtime.gosched\n      ```\n    ```\n\n    ```\n\n### 2.6. print\n\n简写命令`p`，用来打印变量或者其他信息，后面跟上需要打印的变量名，当然还有一些很有用的函数$len()和$cap()，用来返回当前string、slices或者maps的长度和容量。\n\n### 2.7. whatis\n\n用来显示当前变量的类型，后面跟上变量名，例如`whatis msg`,显示如下：\n\n```\n  type = struct string\n```\n\n### 2.8. next\n\n简写命令 `n`,用来单步调试，跳到下一步，当有断点之后，可以输入`n`跳转到下一步继续执行\n\n### 2.9. coutinue\n\n简称命令 `c`，用来跳出当前断点处，后面可以跟参数N，跳过多少次断点\n\n### 2.10. set variable\n\n该命令用来改变运行过程中的变量值，格式如：`set variable <var>=<value>`\n\n## 3. 调试过程\n\n### 3.1. 示例代码\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"time\"\n)\nfunc counting(c chan<- int) {\n    for i := 0; i < 10; i++ {\n        time.Sleep(2 * time.Second)\n        c <- i\n    }\n    close(c)\n}\nfunc main() {\n    msg := \"Starting main\"\n    fmt.Println(msg)\n    bus := make(chan int)\n    msg = \"starting a gofunc\"\n    go counting(bus)\n    for count := range bus {\n        fmt.Println(\"count:\", count)\n    }\n}\n```\n\n### 3.2. 调试步骤\n\n编译文件，生成可执行文件gdbfile:\n\n```go\ngo build -gcflags \"-N -l\" gdbfile.go\n```\n\n通过gdb命令启动调试：\n\n```go\ngdb gdbfile\n```\n\n启动之后首先看看这个程序是不是可以运行起来，只要输入`run`命令回车后程序就开始运行，程序正常的话可以看到程序输出如下，和我们在命令行直接执行程序输出是一样的：\n\n```shell\n(gdb) run\nStarting program: /home/xiemengjun/gdbfile\nStarting main\ncount: 0\ncount: 1\ncount: 2\ncount: 3\ncount: 4\ncount: 5\ncount: 6\ncount: 7\ncount: 8\ncount: 9\n[LWP 2771 exited]\n[Inferior 1 (process 2771) exited normally]\n```\n\n好了，现在我们已经知道怎么让程序跑起来了，接下来开始给代码设置断点：\n\n```shell\n(gdb) b 23\nBreakpoint 1 at 0x400d8d: file /home/xiemengjun/gdbfile.go, line 23.\n(gdb) run\nStarting program: /home/xiemengjun/gdbfile\nStarting main\n[New LWP 3284]\n[Switching to LWP 3284]\n \nBreakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23\n23          fmt.Println(\"count:\", count)\n```\n\n上面例子`b 23`表示在第23行设置了断点，之后输入`run`开始运行程序。现在程序在前面设置断点的地方停住了，我们需要查看断点相应上下文的源码，输入`list`就可以看到源码显示从当前停止行的前五行开始：\n\n```\n(gdb) list\n18      fmt.Println(msg)\n19      bus := make(chan int)\n20      msg = \"starting a gofunc\"\n21      go counting(bus)\n22      for count := range bus {\n23          fmt.Println(\"count:\", count)\n24      }\n25  }\n```\n\n现在GDB在运行当前的程序的环境中已经保留了一些有用的调试信息，我们只需打印出相应的变量，查看相应变量的类型及值：\n\n```\n(gdb) info locals\ncount = 0\nbus = 0xf840001a50\n(gdb) p count\n$1 = 0\n(gdb) p bus\n$2 = (chan int) 0xf840001a50\n(gdb) whatis bus\ntype = chan int\n```\n\n接下来该让程序继续往下执行，请继续看下面的命令\n\n```\n(gdb) c\nContinuing.\ncount: 0\n[New LWP 3303]\n[Switching to LWP 3303]\n \nBreakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23\n23 fmt.Println(\"count:\", count)\n(gdb) c\nContinuing.\ncount: 1\n[Switching to LWP 3302]\n \nBreakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23\n23 fmt.Println(\"count:\", count)\n```\n\n每次输入`c`之后都会执行一次代码，又跳到下一次for循环，继续打印出来相应的信息。设想目前需要改变上下文相关变量的信息，跳过一些过程，并继续执行下一步，得出修改后想要的结果：\n\n```\n(gdb) info locals\ncount = 2\nbus = 0xf840001a50\n(gdb) set variable count=9\n(gdb) info locals\ncount = 9\nbus = 0xf840001a50\n(gdb) c\nContinuing.\ncount: 9\n[Switching to LWP 3302]\n \nBreakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23\n23 fmt.Println(\"count:\", count)  \n```\n\n最后稍微思考一下，前面整个程序运行的过程中到底创建了多少个goroutine，每个goroutine都在做什么：\n\n```\n(gdb) info goroutines\n* 1 running runtime.gosched\n* 2 syscall runtime.entersyscall\n3 waiting runtime.gosched\n4 runnable runtime.gosched\n(gdb) goroutine 1 bt\n#0 0x000000000040e33b in runtime.gosched () at /home/xiemengjun/go/src/pkg/runtime/proc.c:927\n#1 0x0000000000403091 in runtime.chanrecv (c=void, ep=void, selected=void, received=void)\nat /home/xiemengjun/go/src/pkg/runtime/chan.c:327\n#2 0x000000000040316f in runtime.chanrecv2 (t=void, c=void)\nat /home/xiemengjun/go/src/pkg/runtime/chan.c:420\n#3 0x0000000000400d6f in main.main () at /home/xiemengjun/gdbfile.go:22\n#4 0x000000000040d0c7 in runtime.main () at /home/xiemengjun/go/src/pkg/runtime/proc.c:244\n#5 0x000000000040d16a in schedunlock () at /home/xiemengjun/go/src/pkg/runtime/proc.c:267\n#6 0x0000000000000000 in ?? ()\n```\n\n \n\n通过查看goroutines的命令我们可以清楚地了解goruntine内部是怎么执行的，每个函数的调用顺序已经明明白白地显示出来了。\n\n参考《Go Web编程》\n\n \n\n ","source":"_posts/Golang/Golang之GDB调试.md","raw":"---\ntitle: \"[Golang] Golang之GDB调试\"\ncatalog: true\ndate: 2017-09-01 10:50:57\ntype: \"categories\"\nsubtitle:\nheader-img: \"/img/article_header_img/article_header.png\"\ntags:\n- Golang\ncatagories:\n- Golang\n---\n\n## 1. GDB简介\n\nGDB是FSF(自由软件基金会)发布的一个强大的类UNIX系统下的程序调试工具。使用GDB可以做如下事情：\n\n1. 启动程序，可以按照开发者的自定义要求运行程序。\n2. 可让被调试的程序在开发者设定的调置的断点处停住。（断点可以是条件表达式）\n3. 当程序被停住时，可以检查此时程序中所发生的事。\n4. 动态的改变当前程序的执行环境。\n\n目前支持调试Go程序的GDB版本必须大于7.1。\n\n编译Go程序的时候需要注意以下几点\n\n1. 传递参数-ldflags \"-s\"，忽略debug的打印信息\n2. 传递-gcflags \"-N -l\" 参数，这样可以忽略Go内部做的一些优化，聚合变量和函数等优化，这样对于GDB调试来说非常困难，所以在编译的时候加入这两个参数避免这些优化。\n\n## 2. 常用命令\n\n### 2.1. list\n\n简写命令`l`，用来显示源代码，默认显示十行代码，后面可以带上参数显示的具体行，例如：`list 15`，显示十行代码，其中第15行在显示的十行里面的中间，如下所示。\n\n```\n  10\t        time.Sleep(2 * time.Second)\n  11\t        c <- i\n  12\t    }\n  13\t    close(c)\n  14\t}\n  15\t\n  16\tfunc main() {\n  17\t    msg := \"Starting main\"\n  18\t    fmt.Println(msg)\n  19\t    bus := make(chan int)\n```\n\n### 2.2. break\n\n简写命令 `b`,用来设置断点，后面跟上参数设置断点的行数，例如`b 10`在第十行设置断点。\n\n### 2.3. delete\n\n简写命令 `d`,用来删除断点，后面跟上断点设置的序号，这个序号可以通过`info breakpoints`获取相应的设置的断点序号，如下是显示的设置断点序号。\n\n```\n  Num     Type           Disp Enb Address            What\n  2       breakpoint     keep y   0x0000000000400dc3 in main.main at /home/xiemengjun/gdb.go:23\n  breakpoint already hit 1 time\n```\n\n### 2.4. backtrace\n\n简写命令 `bt`,用来打印执行的代码过程，如下所示：\n\n```\n  #0  main.main () at /home/xiemengjun/gdb.go:23\n  #1  0x000000000040d61e in runtime.main () at /home/xiemengjun/go/src/pkg/runtime/proc.c:244\n  #2  0x000000000040d6c1 in schedunlock () at /home/xiemengjun/go/src/pkg/runtime/proc.c:267\n  #3  0x0000000000000000 in ?? ()\n```\n\n### 2.5. info\n\ninfo命令用来显示信息，后面有几种参数，我们常用的有如下几种：\n\n- -   `info locals`\n\n      显示当前执行的程序中的变量值\n\n  -   `info breakpoints`\n\n      显示当前设置的断点列表\n\n  -   `info goroutines`\n\n      显示当前执行的goroutine列表，如下代码所示,带*的表示当前执行的\n\n      ```\n      * 1  running runtime.gosched\n      * 2  syscall runtime.entersyscall\n        3  waiting runtime.gosched\n        4 runnable runtime.gosched\n      ```\n    ```\n\n    ```\n\n### 2.6. print\n\n简写命令`p`，用来打印变量或者其他信息，后面跟上需要打印的变量名，当然还有一些很有用的函数$len()和$cap()，用来返回当前string、slices或者maps的长度和容量。\n\n### 2.7. whatis\n\n用来显示当前变量的类型，后面跟上变量名，例如`whatis msg`,显示如下：\n\n```\n  type = struct string\n```\n\n### 2.8. next\n\n简写命令 `n`,用来单步调试，跳到下一步，当有断点之后，可以输入`n`跳转到下一步继续执行\n\n### 2.9. coutinue\n\n简称命令 `c`，用来跳出当前断点处，后面可以跟参数N，跳过多少次断点\n\n### 2.10. set variable\n\n该命令用来改变运行过程中的变量值，格式如：`set variable <var>=<value>`\n\n## 3. 调试过程\n\n### 3.1. 示例代码\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"time\"\n)\nfunc counting(c chan<- int) {\n    for i := 0; i < 10; i++ {\n        time.Sleep(2 * time.Second)\n        c <- i\n    }\n    close(c)\n}\nfunc main() {\n    msg := \"Starting main\"\n    fmt.Println(msg)\n    bus := make(chan int)\n    msg = \"starting a gofunc\"\n    go counting(bus)\n    for count := range bus {\n        fmt.Println(\"count:\", count)\n    }\n}\n```\n\n### 3.2. 调试步骤\n\n编译文件，生成可执行文件gdbfile:\n\n```go\ngo build -gcflags \"-N -l\" gdbfile.go\n```\n\n通过gdb命令启动调试：\n\n```go\ngdb gdbfile\n```\n\n启动之后首先看看这个程序是不是可以运行起来，只要输入`run`命令回车后程序就开始运行，程序正常的话可以看到程序输出如下，和我们在命令行直接执行程序输出是一样的：\n\n```shell\n(gdb) run\nStarting program: /home/xiemengjun/gdbfile\nStarting main\ncount: 0\ncount: 1\ncount: 2\ncount: 3\ncount: 4\ncount: 5\ncount: 6\ncount: 7\ncount: 8\ncount: 9\n[LWP 2771 exited]\n[Inferior 1 (process 2771) exited normally]\n```\n\n好了，现在我们已经知道怎么让程序跑起来了，接下来开始给代码设置断点：\n\n```shell\n(gdb) b 23\nBreakpoint 1 at 0x400d8d: file /home/xiemengjun/gdbfile.go, line 23.\n(gdb) run\nStarting program: /home/xiemengjun/gdbfile\nStarting main\n[New LWP 3284]\n[Switching to LWP 3284]\n \nBreakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23\n23          fmt.Println(\"count:\", count)\n```\n\n上面例子`b 23`表示在第23行设置了断点，之后输入`run`开始运行程序。现在程序在前面设置断点的地方停住了，我们需要查看断点相应上下文的源码，输入`list`就可以看到源码显示从当前停止行的前五行开始：\n\n```\n(gdb) list\n18      fmt.Println(msg)\n19      bus := make(chan int)\n20      msg = \"starting a gofunc\"\n21      go counting(bus)\n22      for count := range bus {\n23          fmt.Println(\"count:\", count)\n24      }\n25  }\n```\n\n现在GDB在运行当前的程序的环境中已经保留了一些有用的调试信息，我们只需打印出相应的变量，查看相应变量的类型及值：\n\n```\n(gdb) info locals\ncount = 0\nbus = 0xf840001a50\n(gdb) p count\n$1 = 0\n(gdb) p bus\n$2 = (chan int) 0xf840001a50\n(gdb) whatis bus\ntype = chan int\n```\n\n接下来该让程序继续往下执行，请继续看下面的命令\n\n```\n(gdb) c\nContinuing.\ncount: 0\n[New LWP 3303]\n[Switching to LWP 3303]\n \nBreakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23\n23 fmt.Println(\"count:\", count)\n(gdb) c\nContinuing.\ncount: 1\n[Switching to LWP 3302]\n \nBreakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23\n23 fmt.Println(\"count:\", count)\n```\n\n每次输入`c`之后都会执行一次代码，又跳到下一次for循环，继续打印出来相应的信息。设想目前需要改变上下文相关变量的信息，跳过一些过程，并继续执行下一步，得出修改后想要的结果：\n\n```\n(gdb) info locals\ncount = 2\nbus = 0xf840001a50\n(gdb) set variable count=9\n(gdb) info locals\ncount = 9\nbus = 0xf840001a50\n(gdb) c\nContinuing.\ncount: 9\n[Switching to LWP 3302]\n \nBreakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23\n23 fmt.Println(\"count:\", count)  \n```\n\n最后稍微思考一下，前面整个程序运行的过程中到底创建了多少个goroutine，每个goroutine都在做什么：\n\n```\n(gdb) info goroutines\n* 1 running runtime.gosched\n* 2 syscall runtime.entersyscall\n3 waiting runtime.gosched\n4 runnable runtime.gosched\n(gdb) goroutine 1 bt\n#0 0x000000000040e33b in runtime.gosched () at /home/xiemengjun/go/src/pkg/runtime/proc.c:927\n#1 0x0000000000403091 in runtime.chanrecv (c=void, ep=void, selected=void, received=void)\nat /home/xiemengjun/go/src/pkg/runtime/chan.c:327\n#2 0x000000000040316f in runtime.chanrecv2 (t=void, c=void)\nat /home/xiemengjun/go/src/pkg/runtime/chan.c:420\n#3 0x0000000000400d6f in main.main () at /home/xiemengjun/gdbfile.go:22\n#4 0x000000000040d0c7 in runtime.main () at /home/xiemengjun/go/src/pkg/runtime/proc.c:244\n#5 0x000000000040d16a in schedunlock () at /home/xiemengjun/go/src/pkg/runtime/proc.c:267\n#6 0x0000000000000000 in ?? ()\n```\n\n \n\n通过查看goroutines的命令我们可以清楚地了解goruntine内部是怎么执行的，每个函数的调用顺序已经明明白白地显示出来了。\n\n参考《Go Web编程》\n\n \n\n ","slug":"Golang/Golang之GDB调试","published":1,"updated":"2017-10-03T06:27:27.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8bbh0vu0000ggvuq0ca248t","content":"<h2><span id=\"1-gdb简介\">1. GDB简介</span></h2>\n<p>GDB是FSF(自由软件基金会)发布的一个强大的类UNIX系统下的程序调试工具。使用GDB可以做如下事情：</p>\n<ol>\n<li>启动程序，可以按照开发者的自定义要求运行程序。</li>\n<li>可让被调试的程序在开发者设定的调置的断点处停住。（断点可以是条件表达式）</li>\n<li>当程序被停住时，可以检查此时程序中所发生的事。</li>\n<li>动态的改变当前程序的执行环境。</li>\n</ol>\n<p>目前支持调试Go程序的GDB版本必须大于7.1。</p>\n<p>编译Go程序的时候需要注意以下几点</p>\n<ol>\n<li>传递参数-ldflags “-s”，忽略debug的打印信息</li>\n<li>传递-gcflags “-N -l” 参数，这样可以忽略Go内部做的一些优化，聚合变量和函数等优化，这样对于GDB调试来说非常困难，所以在编译的时候加入这两个参数避免这些优化。</li>\n</ol>\n<h2><span id=\"2-常用命令\">2. 常用命令</span></h2>\n<h3><span id=\"21-list\">2.1. list</span></h3>\n<p>简写命令<code>l</code>，用来显示源代码，默认显示十行代码，后面可以带上参数显示的具体行，例如：<code>list 15</code>，显示十行代码，其中第15行在显示的十行里面的中间，如下所示。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">10</span>\t        time.Sleep(<span class=\"number\">2</span> * time.Second)</div><div class=\"line\"><span class=\"number\">11</span>\t        c &lt;- i</div><div class=\"line\"><span class=\"number\">12</span>\t    &#125;</div><div class=\"line\"><span class=\"number\">13</span>\t    <span class=\"built_in\">close</span>(c)</div><div class=\"line\"><span class=\"number\">14</span>\t&#125;</div><div class=\"line\"><span class=\"number\">15</span>\t</div><div class=\"line\"><span class=\"number\">16</span>\t<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\"><span class=\"number\">17</span>\t    msg := <span class=\"string\">\"Starting main\"</span></div><div class=\"line\"><span class=\"number\">18</span>\t    fmt.Println(msg)</div><div class=\"line\"><span class=\"number\">19</span>\t    bus := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</div></pre></td></tr></table></figure>\n<h3><span id=\"22-break\">2.2. break</span></h3>\n<p>简写命令 <code>b</code>,用来设置断点，后面跟上参数设置断点的行数，例如<code>b 10</code>在第十行设置断点。</p>\n<h3><span id=\"23-delete\">2.3. delete</span></h3>\n<p>简写命令 <code>d</code>,用来删除断点，后面跟上断点设置的序号，这个序号可以通过<code>info breakpoints</code>获取相应的设置的断点序号，如下是显示的设置断点序号。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Num    <span class=\"built_in\"> Type </span>          Disp Enb<span class=\"built_in\"> Address </span>           What</div><div class=\"line\">2       breakpoint     keep y   0x0000000000400dc3 <span class=\"keyword\">in</span> main.main at /home/xiemengjun/gdb.go:23</div><div class=\"line\">breakpoint already hit 1 time</div></pre></td></tr></table></figure>\n<h3><span id=\"24-backtrace\">2.4. backtrace</span></h3>\n<p>简写命令 <code>bt</code>,用来打印执行的代码过程，如下所示：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#0</span>  <span class=\"selector-tag\">main</span><span class=\"selector-class\">.main</span> () <span class=\"selector-tag\">at</span> /<span class=\"selector-tag\">home</span>/<span class=\"selector-tag\">xiemengjun</span>/<span class=\"selector-tag\">gdb</span><span class=\"selector-class\">.go</span><span class=\"selector-pseudo\">:23</span></div><div class=\"line\"><span class=\"selector-id\">#1</span>  <span class=\"selector-tag\">0x000000000040d61e</span> <span class=\"selector-tag\">in</span> <span class=\"selector-tag\">runtime</span><span class=\"selector-class\">.main</span> () <span class=\"selector-tag\">at</span> /<span class=\"selector-tag\">home</span>/<span class=\"selector-tag\">xiemengjun</span>/<span class=\"selector-tag\">go</span>/<span class=\"selector-tag\">src</span>/<span class=\"selector-tag\">pkg</span>/<span class=\"selector-tag\">runtime</span>/<span class=\"selector-tag\">proc</span><span class=\"selector-class\">.c</span><span class=\"selector-pseudo\">:244</span></div><div class=\"line\"><span class=\"selector-id\">#2</span>  <span class=\"selector-tag\">0x000000000040d6c1</span> <span class=\"selector-tag\">in</span> <span class=\"selector-tag\">schedunlock</span> () <span class=\"selector-tag\">at</span> /<span class=\"selector-tag\">home</span>/<span class=\"selector-tag\">xiemengjun</span>/<span class=\"selector-tag\">go</span>/<span class=\"selector-tag\">src</span>/<span class=\"selector-tag\">pkg</span>/<span class=\"selector-tag\">runtime</span>/<span class=\"selector-tag\">proc</span><span class=\"selector-class\">.c</span><span class=\"selector-pseudo\">:267</span></div><div class=\"line\"><span class=\"selector-id\">#3</span>  <span class=\"selector-tag\">0x0000000000000000</span> <span class=\"selector-tag\">in</span> ?? ()</div></pre></td></tr></table></figure>\n<h3><span id=\"25-info\">2.5. info</span></h3>\n<p>info命令用来显示信息，后面有几种参数，我们常用的有如下几种：</p>\n<ul>\n<li>\n<ul>\n<li>\n<p><code>info locals</code></p>\n<p>显示当前执行的程序中的变量值</p>\n</li>\n<li>\n<p><code>info breakpoints</code></p>\n<p>显示当前设置的断点列表</p>\n</li>\n<li>\n<p><code>info goroutines</code></p>\n<p>显示当前执行的goroutine列表，如下代码所示,带*的表示当前执行的</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">* 1  <span class=\"selector-tag\">running</span> <span class=\"selector-tag\">runtime</span><span class=\"selector-class\">.gosched</span></div><div class=\"line\">* 2  <span class=\"selector-tag\">syscall</span> <span class=\"selector-tag\">runtime</span><span class=\"selector-class\">.entersyscall</span></div><div class=\"line\">  3  <span class=\"selector-tag\">waiting</span> <span class=\"selector-tag\">runtime</span><span class=\"selector-class\">.gosched</span></div><div class=\"line\">  4 <span class=\"selector-tag\">runnable</span> <span class=\"selector-tag\">runtime</span><span class=\"selector-class\">.gosched</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3><span id=\"26-print\">2.6. print</span></h3>\n<p>简写命令<code>p</code>，用来打印变量或者其他信息，后面跟上需要打印的变量名，当然还有一些很有用的函数$len()和$cap()，用来返回当前string、slices或者maps的长度和容量。</p>\n<h3><span id=\"27-whatis\">2.7. whatis</span></h3>\n<p>用来显示当前变量的类型，后面跟上变量名，例如<code>whatis msg</code>,显示如下：</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> = <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">string</span></span></div></pre></td></tr></table></figure>\n<h3><span id=\"28-next\">2.8. next</span></h3>\n<p>简写命令 <code>n</code>,用来单步调试，跳到下一步，当有断点之后，可以输入<code>n</code>跳转到下一步继续执行</p>\n<h3><span id=\"29-coutinue\">2.9. coutinue</span></h3>\n<p>简称命令 <code>c</code>，用来跳出当前断点处，后面可以跟参数N，跳过多少次断点</p>\n<h3><span id=\"210-set-variable\">2.10. set variable</span></h3>\n<p>该命令用来改变运行过程中的变量值，格式如：<code>set variable &lt;var&gt;=&lt;value&gt;</code></p>\n<h2><span id=\"3-调试过程\">3. 调试过程</span></h2>\n<h3><span id=\"31-示例代码\">3.1. 示例代码</span></h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">    <span class=\"string\">\"time\"</span></div><div class=\"line\">)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">counting</span><span class=\"params\">(c <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</div><div class=\"line\">        time.Sleep(<span class=\"number\">2</span> * time.Second)</div><div class=\"line\">        c &lt;- i</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">close</span>(c)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    msg := <span class=\"string\">\"Starting main\"</span></div><div class=\"line\">    fmt.Println(msg)</div><div class=\"line\">    bus := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</div><div class=\"line\">    msg = <span class=\"string\">\"starting a gofunc\"</span></div><div class=\"line\">    <span class=\"keyword\">go</span> counting(bus)</div><div class=\"line\">    <span class=\"keyword\">for</span> count := <span class=\"keyword\">range</span> bus &#123;</div><div class=\"line\">        fmt.Println(<span class=\"string\">\"count:\"</span>, count)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3><span id=\"32-调试步骤\">3.2. 调试步骤</span></h3>\n<p>编译文件，生成可执行文件gdbfile:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">go</span> build -gcflags <span class=\"string\">\"-N -l\"</span> gdbfile.<span class=\"keyword\">go</span></div></pre></td></tr></table></figure>\n<p>通过gdb命令启动调试：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gdb gdbfile</div></pre></td></tr></table></figure>\n<p>启动之后首先看看这个程序是不是可以运行起来，只要输入<code>run</code>命令回车后程序就开始运行，程序正常的话可以看到程序输出如下，和我们在命令行直接执行程序输出是一样的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">(gdb) run</div><div class=\"line\">Starting program: /home/xiemengjun/gdbfile</div><div class=\"line\">Starting main</div><div class=\"line\">count: 0</div><div class=\"line\">count: 1</div><div class=\"line\">count: 2</div><div class=\"line\">count: 3</div><div class=\"line\">count: 4</div><div class=\"line\">count: 5</div><div class=\"line\">count: 6</div><div class=\"line\">count: 7</div><div class=\"line\">count: 8</div><div class=\"line\">count: 9</div><div class=\"line\">[LWP 2771 exited]</div><div class=\"line\">[Inferior 1 (process 2771) exited normally]</div></pre></td></tr></table></figure>\n<p>好了，现在我们已经知道怎么让程序跑起来了，接下来开始给代码设置断点：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">(gdb) b 23</div><div class=\"line\">Breakpoint 1 at 0x400d8d: file /home/xiemengjun/gdbfile.go, line 23.</div><div class=\"line\">(gdb) run</div><div class=\"line\">Starting program: /home/xiemengjun/gdbfile</div><div class=\"line\">Starting main</div><div class=\"line\">[New LWP 3284]</div><div class=\"line\">[Switching to LWP 3284]</div><div class=\"line\"> </div><div class=\"line\">Breakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23</div><div class=\"line\">23          fmt.Println(\"count:\", count)</div></pre></td></tr></table></figure>\n<p>上面例子<code>b 23</code>表示在第23行设置了断点，之后输入<code>run</code>开始运行程序。现在程序在前面设置断点的地方停住了，我们需要查看断点相应上下文的源码，输入<code>list</code>就可以看到源码显示从当前停止行的前五行开始：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">(gdb) list</div><div class=\"line\"><span class=\"number\">18</span>      fmt.Println(msg)</div><div class=\"line\"><span class=\"number\">19</span>      bus := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</div><div class=\"line\"><span class=\"number\">20</span>      msg = <span class=\"string\">\"starting a gofunc\"</span></div><div class=\"line\"><span class=\"number\">21</span>      <span class=\"keyword\">go</span> counting(bus)</div><div class=\"line\"><span class=\"number\">22</span>      <span class=\"keyword\">for</span> count := <span class=\"keyword\">range</span> bus &#123;</div><div class=\"line\"><span class=\"number\">23</span>          fmt.Println(<span class=\"string\">\"count:\"</span>, count)</div><div class=\"line\"><span class=\"number\">24</span>      &#125;</div><div class=\"line\"><span class=\"number\">25</span>  &#125;</div></pre></td></tr></table></figure>\n<p>现在GDB在运行当前的程序的环境中已经保留了一些有用的调试信息，我们只需打印出相应的变量，查看相应变量的类型及值：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">(gdb) <span class=\"builtin-name\">info</span> locals</div><div class=\"line\">count = 0</div><div class=\"line\">bus = 0xf840001a50</div><div class=\"line\">(gdb) p count</div><div class=\"line\"><span class=\"variable\">$1</span> = 0</div><div class=\"line\">(gdb) p bus</div><div class=\"line\"><span class=\"variable\">$2</span> = (chan int) 0xf840001a50</div><div class=\"line\">(gdb) whatis bus</div><div class=\"line\">type = chan int</div></pre></td></tr></table></figure>\n<p>接下来该让程序继续往下执行，请继续看下面的命令</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">(gdb) c</div><div class=\"line\">Continuing.</div><div class=\"line\"><span class=\"built_in\">count</span>: <span class=\"number\">0</span></div><div class=\"line\">[New LWP <span class=\"number\">3303</span>]</div><div class=\"line\">[Switching <span class=\"keyword\">to</span> LWP <span class=\"number\">3303</span>]</div><div class=\"line\"> </div><div class=\"line\">Breakpoint <span class=\"number\">1</span>, main.main () <span class=\"keyword\">at</span> /home/xiemengjun/gdbfile.go:<span class=\"number\">23</span></div><div class=\"line\"><span class=\"number\">23</span> fmt.Println(<span class=\"string\">\"count:\"</span>, <span class=\"built_in\">count</span>)</div><div class=\"line\">(gdb) c</div><div class=\"line\">Continuing.</div><div class=\"line\"><span class=\"built_in\">count</span>: <span class=\"number\">1</span></div><div class=\"line\">[Switching <span class=\"keyword\">to</span> LWP <span class=\"number\">3302</span>]</div><div class=\"line\"> </div><div class=\"line\">Breakpoint <span class=\"number\">1</span>, main.main () <span class=\"keyword\">at</span> /home/xiemengjun/gdbfile.go:<span class=\"number\">23</span></div><div class=\"line\"><span class=\"number\">23</span> fmt.Println(<span class=\"string\">\"count:\"</span>, <span class=\"built_in\">count</span>)</div></pre></td></tr></table></figure>\n<p>每次输入<code>c</code>之后都会执行一次代码，又跳到下一次for循环，继续打印出来相应的信息。设想目前需要改变上下文相关变量的信息，跳过一些过程，并继续执行下一步，得出修改后想要的结果：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">(gdb) info locals</div><div class=\"line\">count = 2</div><div class=\"line\">bus = 0xf840001a50</div><div class=\"line\">(gdb) set variable count=9</div><div class=\"line\">(gdb) info locals</div><div class=\"line\">count = 9</div><div class=\"line\">bus = 0xf840001a50</div><div class=\"line\">(gdb) c</div><div class=\"line\">Continuing.</div><div class=\"line\"><span class=\"section\">count: 9</span></div><div class=\"line\">[Switching to LWP 3302]</div><div class=\"line\"> </div><div class=\"line\">Breakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23</div><div class=\"line\">23 fmt.Println(<span class=\"string\">\"count:\"</span>, count)</div></pre></td></tr></table></figure>\n<p>最后稍微思考一下，前面整个程序运行的过程中到底创建了多少个goroutine，每个goroutine都在做什么：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">(gdb) info goroutines</div><div class=\"line\">* 1 running runtime.gosched</div><div class=\"line\">* 2 syscall runtime.entersyscall</div><div class=\"line\">3 waiting runtime.gosched</div><div class=\"line\">4 runnable runtime.gosched</div><div class=\"line\">(gdb) goroutine 1 bt</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">0 0x000000000040e33b <span class=\"keyword\">in</span> runtime.gosched () at /home/xiemengjun/go/src/pkg/runtime/proc.c:927</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">1 0x0000000000403091 <span class=\"keyword\">in</span> runtime.chanrecv (c=void, ep=void, selected=void, received=void)</span></div><div class=\"line\">at /home/xiemengjun/go/src/pkg/runtime/chan.c:327</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">2 0x000000000040316f <span class=\"keyword\">in</span> runtime.chanrecv2 (t=void, c=void)</span></div><div class=\"line\">at /home/xiemengjun/go/src/pkg/runtime/chan.c:420</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">3 0x0000000000400d6f <span class=\"keyword\">in</span> main.main () at /home/xiemengjun/gdbfile.go:22</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">4 0x000000000040d0c7 <span class=\"keyword\">in</span> runtime.main () at /home/xiemengjun/go/src/pkg/runtime/proc.c:244</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">5 0x000000000040d16a <span class=\"keyword\">in</span> schedunlock () at /home/xiemengjun/go/src/pkg/runtime/proc.c:267</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">6 0x0000000000000000 <span class=\"keyword\">in</span> ?? ()</span></div></pre></td></tr></table></figure>\n<p>通过查看goroutines的命令我们可以清楚地了解goruntine内部是怎么执行的，每个函数的调用顺序已经明明白白地显示出来了。</p>\n<p>参考《Go Web编程》</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. GDB简介</h2>\n<p>GDB是FSF(自由软件基金会)发布的一个强大的类UNIX系统下的程序调试工具。使用GDB可以做如下事情：</p>\n<ol>\n<li>启动程序，可以按照开发者的自定义要求运行程序。</li>\n<li>可让被调试的程序在开发者设定的调置的断点处停住。（断点可以是条件表达式）</li>\n<li>当程序被停住时，可以检查此时程序中所发生的事。</li>\n<li>动态的改变当前程序的执行环境。</li>\n</ol>\n<p>目前支持调试Go程序的GDB版本必须大于7.1。</p>\n<p>编译Go程序的时候需要注意以下几点</p>\n<ol>\n<li>传递参数-ldflags “-s”，忽略debug的打印信息</li>\n<li>传递-gcflags “-N -l” 参数，这样可以忽略Go内部做的一些优化，聚合变量和函数等优化，这样对于GDB调试来说非常困难，所以在编译的时候加入这两个参数避免这些优化。</li>\n</ol>\n<h2>2. 常用命令</h2>\n<h3>2.1. list</h3>\n<p>简写命令<code>l</code>，用来显示源代码，默认显示十行代码，后面可以带上参数显示的具体行，例如：<code>list 15</code>，显示十行代码，其中第15行在显示的十行里面的中间，如下所示。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">10</span>\t        time.Sleep(<span class=\"number\">2</span> * time.Second)</div><div class=\"line\"><span class=\"number\">11</span>\t        c &lt;- i</div><div class=\"line\"><span class=\"number\">12</span>\t    &#125;</div><div class=\"line\"><span class=\"number\">13</span>\t    <span class=\"built_in\">close</span>(c)</div><div class=\"line\"><span class=\"number\">14</span>\t&#125;</div><div class=\"line\"><span class=\"number\">15</span>\t</div><div class=\"line\"><span class=\"number\">16</span>\t<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\"><span class=\"number\">17</span>\t    msg := <span class=\"string\">\"Starting main\"</span></div><div class=\"line\"><span class=\"number\">18</span>\t    fmt.Println(msg)</div><div class=\"line\"><span class=\"number\">19</span>\t    bus := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</div></pre></td></tr></table></figure>\n<h3>2.2. break</h3>\n<p>简写命令 <code>b</code>,用来设置断点，后面跟上参数设置断点的行数，例如<code>b 10</code>在第十行设置断点。</p>\n<h3>2.3. delete</h3>\n<p>简写命令 <code>d</code>,用来删除断点，后面跟上断点设置的序号，这个序号可以通过<code>info breakpoints</code>获取相应的设置的断点序号，如下是显示的设置断点序号。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Num    <span class=\"built_in\"> Type </span>          Disp Enb<span class=\"built_in\"> Address </span>           What</div><div class=\"line\">2       breakpoint     keep y   0x0000000000400dc3 <span class=\"keyword\">in</span> main.main at /home/xiemengjun/gdb.go:23</div><div class=\"line\">breakpoint already hit 1 time</div></pre></td></tr></table></figure>\n<h3>2.4. backtrace</h3>\n<p>简写命令 <code>bt</code>,用来打印执行的代码过程，如下所示：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#0</span>  <span class=\"selector-tag\">main</span><span class=\"selector-class\">.main</span> () <span class=\"selector-tag\">at</span> /<span class=\"selector-tag\">home</span>/<span class=\"selector-tag\">xiemengjun</span>/<span class=\"selector-tag\">gdb</span><span class=\"selector-class\">.go</span><span class=\"selector-pseudo\">:23</span></div><div class=\"line\"><span class=\"selector-id\">#1</span>  <span class=\"selector-tag\">0x000000000040d61e</span> <span class=\"selector-tag\">in</span> <span class=\"selector-tag\">runtime</span><span class=\"selector-class\">.main</span> () <span class=\"selector-tag\">at</span> /<span class=\"selector-tag\">home</span>/<span class=\"selector-tag\">xiemengjun</span>/<span class=\"selector-tag\">go</span>/<span class=\"selector-tag\">src</span>/<span class=\"selector-tag\">pkg</span>/<span class=\"selector-tag\">runtime</span>/<span class=\"selector-tag\">proc</span><span class=\"selector-class\">.c</span><span class=\"selector-pseudo\">:244</span></div><div class=\"line\"><span class=\"selector-id\">#2</span>  <span class=\"selector-tag\">0x000000000040d6c1</span> <span class=\"selector-tag\">in</span> <span class=\"selector-tag\">schedunlock</span> () <span class=\"selector-tag\">at</span> /<span class=\"selector-tag\">home</span>/<span class=\"selector-tag\">xiemengjun</span>/<span class=\"selector-tag\">go</span>/<span class=\"selector-tag\">src</span>/<span class=\"selector-tag\">pkg</span>/<span class=\"selector-tag\">runtime</span>/<span class=\"selector-tag\">proc</span><span class=\"selector-class\">.c</span><span class=\"selector-pseudo\">:267</span></div><div class=\"line\"><span class=\"selector-id\">#3</span>  <span class=\"selector-tag\">0x0000000000000000</span> <span class=\"selector-tag\">in</span> ?? ()</div></pre></td></tr></table></figure>\n<h3>2.5. info</h3>\n<p>info命令用来显示信息，后面有几种参数，我们常用的有如下几种：</p>\n<ul>\n<li>\n<ul>\n<li>\n<p><code>info locals</code></p>\n<p>显示当前执行的程序中的变量值</p>\n</li>\n<li>\n<p><code>info breakpoints</code></p>\n<p>显示当前设置的断点列表</p>\n</li>\n<li>\n<p><code>info goroutines</code></p>\n<p>显示当前执行的goroutine列表，如下代码所示,带*的表示当前执行的</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">* 1  <span class=\"selector-tag\">running</span> <span class=\"selector-tag\">runtime</span><span class=\"selector-class\">.gosched</span></div><div class=\"line\">* 2  <span class=\"selector-tag\">syscall</span> <span class=\"selector-tag\">runtime</span><span class=\"selector-class\">.entersyscall</span></div><div class=\"line\">  3  <span class=\"selector-tag\">waiting</span> <span class=\"selector-tag\">runtime</span><span class=\"selector-class\">.gosched</span></div><div class=\"line\">  4 <span class=\"selector-tag\">runnable</span> <span class=\"selector-tag\">runtime</span><span class=\"selector-class\">.gosched</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3>2.6. print</h3>\n<p>简写命令<code>p</code>，用来打印变量或者其他信息，后面跟上需要打印的变量名，当然还有一些很有用的函数$len()和$cap()，用来返回当前string、slices或者maps的长度和容量。</p>\n<h3>2.7. whatis</h3>\n<p>用来显示当前变量的类型，后面跟上变量名，例如<code>whatis msg</code>,显示如下：</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> = <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">string</span></span></div></pre></td></tr></table></figure>\n<h3>2.8. next</h3>\n<p>简写命令 <code>n</code>,用来单步调试，跳到下一步，当有断点之后，可以输入<code>n</code>跳转到下一步继续执行</p>\n<h3>2.9. coutinue</h3>\n<p>简称命令 <code>c</code>，用来跳出当前断点处，后面可以跟参数N，跳过多少次断点</p>\n<h3>2.10. set variable</h3>\n<p>该命令用来改变运行过程中的变量值，格式如：<code>set variable &lt;var&gt;=&lt;value&gt;</code></p>\n<h2>3. 调试过程</h2>\n<h3>3.1. 示例代码</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">    <span class=\"string\">\"time\"</span></div><div class=\"line\">)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">counting</span><span class=\"params\">(c <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</div><div class=\"line\">        time.Sleep(<span class=\"number\">2</span> * time.Second)</div><div class=\"line\">        c &lt;- i</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">close</span>(c)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    msg := <span class=\"string\">\"Starting main\"</span></div><div class=\"line\">    fmt.Println(msg)</div><div class=\"line\">    bus := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</div><div class=\"line\">    msg = <span class=\"string\">\"starting a gofunc\"</span></div><div class=\"line\">    <span class=\"keyword\">go</span> counting(bus)</div><div class=\"line\">    <span class=\"keyword\">for</span> count := <span class=\"keyword\">range</span> bus &#123;</div><div class=\"line\">        fmt.Println(<span class=\"string\">\"count:\"</span>, count)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3>3.2. 调试步骤</h3>\n<p>编译文件，生成可执行文件gdbfile:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">go</span> build -gcflags <span class=\"string\">\"-N -l\"</span> gdbfile.<span class=\"keyword\">go</span></div></pre></td></tr></table></figure>\n<p>通过gdb命令启动调试：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gdb gdbfile</div></pre></td></tr></table></figure>\n<p>启动之后首先看看这个程序是不是可以运行起来，只要输入<code>run</code>命令回车后程序就开始运行，程序正常的话可以看到程序输出如下，和我们在命令行直接执行程序输出是一样的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">(gdb) run</div><div class=\"line\">Starting program: /home/xiemengjun/gdbfile</div><div class=\"line\">Starting main</div><div class=\"line\">count: 0</div><div class=\"line\">count: 1</div><div class=\"line\">count: 2</div><div class=\"line\">count: 3</div><div class=\"line\">count: 4</div><div class=\"line\">count: 5</div><div class=\"line\">count: 6</div><div class=\"line\">count: 7</div><div class=\"line\">count: 8</div><div class=\"line\">count: 9</div><div class=\"line\">[LWP 2771 exited]</div><div class=\"line\">[Inferior 1 (process 2771) exited normally]</div></pre></td></tr></table></figure>\n<p>好了，现在我们已经知道怎么让程序跑起来了，接下来开始给代码设置断点：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">(gdb) b 23</div><div class=\"line\">Breakpoint 1 at 0x400d8d: file /home/xiemengjun/gdbfile.go, line 23.</div><div class=\"line\">(gdb) run</div><div class=\"line\">Starting program: /home/xiemengjun/gdbfile</div><div class=\"line\">Starting main</div><div class=\"line\">[New LWP 3284]</div><div class=\"line\">[Switching to LWP 3284]</div><div class=\"line\"> </div><div class=\"line\">Breakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23</div><div class=\"line\">23          fmt.Println(\"count:\", count)</div></pre></td></tr></table></figure>\n<p>上面例子<code>b 23</code>表示在第23行设置了断点，之后输入<code>run</code>开始运行程序。现在程序在前面设置断点的地方停住了，我们需要查看断点相应上下文的源码，输入<code>list</code>就可以看到源码显示从当前停止行的前五行开始：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">(gdb) list</div><div class=\"line\"><span class=\"number\">18</span>      fmt.Println(msg)</div><div class=\"line\"><span class=\"number\">19</span>      bus := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</div><div class=\"line\"><span class=\"number\">20</span>      msg = <span class=\"string\">\"starting a gofunc\"</span></div><div class=\"line\"><span class=\"number\">21</span>      <span class=\"keyword\">go</span> counting(bus)</div><div class=\"line\"><span class=\"number\">22</span>      <span class=\"keyword\">for</span> count := <span class=\"keyword\">range</span> bus &#123;</div><div class=\"line\"><span class=\"number\">23</span>          fmt.Println(<span class=\"string\">\"count:\"</span>, count)</div><div class=\"line\"><span class=\"number\">24</span>      &#125;</div><div class=\"line\"><span class=\"number\">25</span>  &#125;</div></pre></td></tr></table></figure>\n<p>现在GDB在运行当前的程序的环境中已经保留了一些有用的调试信息，我们只需打印出相应的变量，查看相应变量的类型及值：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">(gdb) <span class=\"builtin-name\">info</span> locals</div><div class=\"line\">count = 0</div><div class=\"line\">bus = 0xf840001a50</div><div class=\"line\">(gdb) p count</div><div class=\"line\"><span class=\"variable\">$1</span> = 0</div><div class=\"line\">(gdb) p bus</div><div class=\"line\"><span class=\"variable\">$2</span> = (chan int) 0xf840001a50</div><div class=\"line\">(gdb) whatis bus</div><div class=\"line\">type = chan int</div></pre></td></tr></table></figure>\n<p>接下来该让程序继续往下执行，请继续看下面的命令</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">(gdb) c</div><div class=\"line\">Continuing.</div><div class=\"line\"><span class=\"built_in\">count</span>: <span class=\"number\">0</span></div><div class=\"line\">[New LWP <span class=\"number\">3303</span>]</div><div class=\"line\">[Switching <span class=\"keyword\">to</span> LWP <span class=\"number\">3303</span>]</div><div class=\"line\"> </div><div class=\"line\">Breakpoint <span class=\"number\">1</span>, main.main () <span class=\"keyword\">at</span> /home/xiemengjun/gdbfile.go:<span class=\"number\">23</span></div><div class=\"line\"><span class=\"number\">23</span> fmt.Println(<span class=\"string\">\"count:\"</span>, <span class=\"built_in\">count</span>)</div><div class=\"line\">(gdb) c</div><div class=\"line\">Continuing.</div><div class=\"line\"><span class=\"built_in\">count</span>: <span class=\"number\">1</span></div><div class=\"line\">[Switching <span class=\"keyword\">to</span> LWP <span class=\"number\">3302</span>]</div><div class=\"line\"> </div><div class=\"line\">Breakpoint <span class=\"number\">1</span>, main.main () <span class=\"keyword\">at</span> /home/xiemengjun/gdbfile.go:<span class=\"number\">23</span></div><div class=\"line\"><span class=\"number\">23</span> fmt.Println(<span class=\"string\">\"count:\"</span>, <span class=\"built_in\">count</span>)</div></pre></td></tr></table></figure>\n<p>每次输入<code>c</code>之后都会执行一次代码，又跳到下一次for循环，继续打印出来相应的信息。设想目前需要改变上下文相关变量的信息，跳过一些过程，并继续执行下一步，得出修改后想要的结果：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">(gdb) info locals</div><div class=\"line\">count = 2</div><div class=\"line\">bus = 0xf840001a50</div><div class=\"line\">(gdb) set variable count=9</div><div class=\"line\">(gdb) info locals</div><div class=\"line\">count = 9</div><div class=\"line\">bus = 0xf840001a50</div><div class=\"line\">(gdb) c</div><div class=\"line\">Continuing.</div><div class=\"line\"><span class=\"section\">count: 9</span></div><div class=\"line\">[Switching to LWP 3302]</div><div class=\"line\"> </div><div class=\"line\">Breakpoint 1, main.main () at /home/xiemengjun/gdbfile.go:23</div><div class=\"line\">23 fmt.Println(<span class=\"string\">\"count:\"</span>, count)</div></pre></td></tr></table></figure>\n<p>最后稍微思考一下，前面整个程序运行的过程中到底创建了多少个goroutine，每个goroutine都在做什么：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">(gdb) info goroutines</div><div class=\"line\">* 1 running runtime.gosched</div><div class=\"line\">* 2 syscall runtime.entersyscall</div><div class=\"line\">3 waiting runtime.gosched</div><div class=\"line\">4 runnable runtime.gosched</div><div class=\"line\">(gdb) goroutine 1 bt</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">0 0x000000000040e33b <span class=\"keyword\">in</span> runtime.gosched () at /home/xiemengjun/go/src/pkg/runtime/proc.c:927</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">1 0x0000000000403091 <span class=\"keyword\">in</span> runtime.chanrecv (c=void, ep=void, selected=void, received=void)</span></div><div class=\"line\">at /home/xiemengjun/go/src/pkg/runtime/chan.c:327</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">2 0x000000000040316f <span class=\"keyword\">in</span> runtime.chanrecv2 (t=void, c=void)</span></div><div class=\"line\">at /home/xiemengjun/go/src/pkg/runtime/chan.c:420</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">3 0x0000000000400d6f <span class=\"keyword\">in</span> main.main () at /home/xiemengjun/gdbfile.go:22</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">4 0x000000000040d0c7 <span class=\"keyword\">in</span> runtime.main () at /home/xiemengjun/go/src/pkg/runtime/proc.c:244</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">5 0x000000000040d16a <span class=\"keyword\">in</span> schedunlock () at /home/xiemengjun/go/src/pkg/runtime/proc.c:267</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">6 0x0000000000000000 <span class=\"keyword\">in</span> ?? ()</span></div></pre></td></tr></table></figure>\n<p>通过查看goroutines的命令我们可以清楚地了解goruntine内部是怎么执行的，每个函数的调用顺序已经明明白白地显示出来了。</p>\n<p>参考《Go Web编程》</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj8b740gk000430vupvehoi44","tag_id":"cj8b740ib000i30vuplgaql7e","_id":"cj8b740jx000y30vu3djvmt29"},{"post_id":"cj8b740gr000530vu16jczmf6","tag_id":"cj8b740ib000i30vuplgaql7e","_id":"cj8b740jz001130vuv9i9ab7i"},{"post_id":"cj8b740gx000630vuk3goojul","tag_id":"cj8b740iv000m30vu3cqg4sj3","_id":"cj8b740ka001330vuyfxkkoc2"},{"post_id":"cj8b740gz000730vutha76aan","tag_id":"cj8b740iv000m30vu3cqg4sj3","_id":"cj8b740ke001530vumhpx8ln5"},{"post_id":"cj8b740h0000830vusqvqwox2","tag_id":"cj8b740iv000m30vu3cqg4sj3","_id":"cj8b740kf001730vut045sqat"},{"post_id":"cj8b740h3000930vuzfopey4s","tag_id":"cj8b740iy000p30vufqh4jszj","_id":"cj8b740kg001830vu14ew80z7"},{"post_id":"cj8b740h5000a30vurgsoxmtp","tag_id":"cj8b740iy000p30vufqh4jszj","_id":"cj8b740kg001930vu1d8s9ck8"},{"post_id":"cj8b740h7000b30vugk2e2w5n","tag_id":"cj8b740iy000p30vufqh4jszj","_id":"cj8b740kg001a30vu7ksblf2k"},{"post_id":"cj8b740h9000c30vuagm3vh2i","tag_id":"cj8b740j1000s30vue3cdk5tu","_id":"cj8b740kg001b30vumka9z0g6"},{"post_id":"cj8b740hd000d30vu7l4vcit4","tag_id":"cj8b740j1000s30vue3cdk5tu","_id":"cj8b740kh001c30vuab2qt42m"},{"post_id":"cj8b740hf000e30vubo0788j2","tag_id":"cj8b740j1000s30vue3cdk5tu","_id":"cj8b740kh001d30vuy2flowzv"},{"post_id":"cj8b740hh000f30vu912yeccc","tag_id":"cj8b740j1000s30vue3cdk5tu","_id":"cj8b740kh001e30vuuy8hwuuw"},{"post_id":"cj8b740hj000g30vu4qt1jb1u","tag_id":"cj8b740j1000s30vue3cdk5tu","_id":"cj8b740kh001f30vuzzn4j1sc"},{"post_id":"cj8b740i9000h30vuhw8l4h8s","tag_id":"cj8b740j1000s30vue3cdk5tu","_id":"cj8b740ki001g30vuqnc543or"},{"post_id":"cj8b740iq000k30vuewf4boq0","tag_id":"cj8b740j1000s30vue3cdk5tu","_id":"cj8b740ki001h30vuqp5lpgg6"},{"post_id":"cj8b740io000j30vuk7srhi38","tag_id":"cj8b740jx000z30vu7h587gp3","_id":"cj8b740m0001j30vufcyg4cr0"},{"post_id":"cj8b740jv000x30vu4qospztx","tag_id":"cj8b740iv000m30vu3cqg4sj3","_id":"cj8b740m5001l30vubtxpsq3o"},{"post_id":"cj8b740jy001030vuh5f4ru2q","tag_id":"cj8b740iv000m30vu3cqg4sj3","_id":"cj8b740m7001n30vus6ory91o"},{"post_id":"cj8b740k0001230vuwlr9wtxj","tag_id":"cj8b740iv000m30vu3cqg4sj3","_id":"cj8b740m9001p30vu0qluccu8"},{"post_id":"cj8b740kb001430vumzunsimk","tag_id":"cj8b740j1000s30vue3cdk5tu","_id":"cj8b740mb001r30vu4x5rk5cv"},{"post_id":"cj8b740ke001630vus0jb3jqx","tag_id":"cj8b740j1000s30vue3cdk5tu","_id":"cj8b740mf001t30vu1mch1pcq"},{"post_id":"cj8b740ly001i30vuct9xss8s","tag_id":"cj8b740j1000s30vue3cdk5tu","_id":"cj8b740mz001u30vuryv19d67"},{"post_id":"cj8b740m4001k30vug3eif8as","tag_id":"cj8b740j1000s30vue3cdk5tu","_id":"cj8b740mz001v30vuy62hhbye"},{"post_id":"cj8b740m6001m30vukb6fuaat","tag_id":"cj8b740j1000s30vue3cdk5tu","_id":"cj8b740n0001w30vu9aahc3c7"},{"post_id":"cj8b740m7001o30vu3pfnaip8","tag_id":"cj8b740j1000s30vue3cdk5tu","_id":"cj8b740n0001x30vuf2o7mq2b"},{"post_id":"cj8b740ma001q30vugqj7g1e4","tag_id":"cj8b740j1000s30vue3cdk5tu","_id":"cj8b740n0001y30vunfhe9p0s"},{"post_id":"cj8b740mc001s30vufcnlc05l","tag_id":"cj8b740j1000s30vue3cdk5tu","_id":"cj8b740n1001z30vuw3czfwlm"},{"post_id":"cj8b79uq800002cvuah6ya5o4","tag_id":"cj8b79uqh00012cvudnpsq0b4","_id":"cj8b7aipy00032cvuski3a8tc"},{"post_id":"cj8b7chee00042cvu9eng582l","tag_id":"cj8b79uqh00012cvudnpsq0b4","_id":"cj8b7chf300052cvu9a66gowd"},{"post_id":"cj8b7dfgo00082cvub0lu6984","tag_id":"cj8b79uqh00012cvudnpsq0b4","_id":"cj8b7dfgq00092cvudw55n160"},{"post_id":"cj8b7jgj2000a2cvue872b4nf","tag_id":"cj8b79uqh00012cvudnpsq0b4","_id":"cj8b7jgjr000c2cvutyk1m38p"},{"post_id":"cj8b7jgj2000a2cvue872b4nf","tag_id":"cj8b7jgjk000b2cvuekf4t1t0","_id":"cj8b7jgjs000d2cvugttk9snt"},{"post_id":"cj8b7n8ow000e2cvuhb3idmfp","tag_id":"cj8b79uqh00012cvudnpsq0b4","_id":"cj8b7n8p5000f2cvu5th0l195"},{"post_id":"cj8b7p04e000g2cvurnu7m2rv","tag_id":"cj8b79uqh00012cvudnpsq0b4","_id":"cj8b7p04i000h2cvuy8cba8jv"},{"post_id":"cj8bbh0vu0000ggvuq0ca248t","tag_id":"cj8b79uqh00012cvudnpsq0b4","_id":"cj8bbh0z30001ggvu2ndf56sn"},{"post_id":"cj8b7sjao000i2cvuop9t7hjz","tag_id":"cj8b79uqh00012cvudnpsq0b4","_id":"cj8bbkpl600006gvuqr9y7m7d"},{"post_id":"cj8b7dfg800062cvu492d7xjx","tag_id":"cj8b79uqh00012cvudnpsq0b4","_id":"cj8bblf630000ugvu1gup7gcc"}],"Tag":[{"name":"Database","_id":"cj8b740ib000i30vuplgaql7e"},{"name":"Docker","_id":"cj8b740iv000m30vu3cqg4sj3"},{"name":"Etcd","_id":"cj8b740iy000p30vufqh4jszj"},{"name":"Kubernetes","_id":"cj8b740j1000s30vue3cdk5tu"},{"name":"Nginx","_id":"cj8b740jx000z30vu7h587gp3"},{"name":"Golang","_id":"cj8b79uqh00012cvudnpsq0b4"},{"name":"Beego","_id":"cj8b7jgjk000b2cvuekf4t1t0"}]}}
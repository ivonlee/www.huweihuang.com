<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          [Docker] Docker源码分析（二）之Docker Daemon - 胡伟煌 | Blog
        
    </title>

    <link rel="canonical" href="http://www.huweihuang.com/2017/07/09/Docker/Docker源码/Docker源码分析（二）之Docker Daemon/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/article_header_img/article_header.png')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Docker" title="Docker">Docker</a>
                            
                        </div>
                        <h1>[Docker] Docker源码分析（二）之Docker Daemon</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by 胡伟煌 on
                            2017-07-09
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">胡伟煌</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2><span id="一-docker-daemon架构示意图">一、Docker Daemon架构示意图</span></h2>
<p><img src="/img/article/docker/docker%E6%BA%90%E7%A0%81%E4%B9%8BDocker-Daemon/Daemon%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="Daemon架构图"></p>
<p>Docker Daemon是Docker架构中运行在后台的守护进程，大致可以分为Docker Server、Engine和Job三部分。</p>
<p>Docker Daemon可以认为是通过Docker Server模块接受Docker Client的请求，并在Engine中处理请求，然后根据请求类型，创建出指定的Job并运行。</p>
<p>运行过程的作用有以下几种可能：</p>
<ul>
<li>向Docker Registry获取镜像，</li>
<li>通过graphdriver执行容器镜像的本地化操作，</li>
<li>通过networkdriver执行容器网络环境的配置，</li>
<li>通过execdriver执行容器内部运行的执行工作等。</li>
</ul>
<p>说明：本文分析的代码为Docker 1.2.0版本。</p>
<h2><span id="二-docker-daemon启动流程图">二、Docker Daemon启动流程图</span></h2>
<p><img src="/img/article/docker/docker%E6%BA%90%E7%A0%81%E4%B9%8BDocker-Daemon/Daemon%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.jpg" alt="Daemon启动流程"></p>
<p>启动Docker Daemon时，一般可以使用以下命令：docker --daemon=true; docker –d; docker –d=true等。接着由docker的main()函数来解析以上命令的相应flag参数，并最终完成Docker Daemon的启动。</p>
<p><strong>/docker/docker.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> *flDaemon &#123;</div><div class="line">        mainDaemon()</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2><span id="三-maindaemon的具体实现">三、mainDaemon的具体实现</span></h2>
<p>宏观来讲，mainDaemon()完成创建一个daemon进程，并使其正常运行。</p>
<p>从功能的角度来说，mainDaemon()实现了两部分内容：</p>
<ul>
<li>第一，创建Docker运行环境；</li>
<li>第二，服务于Docker Client，接收并处理相应请求。</li>
</ul>
<h3><span id="一配置初始化">（一）配置初始化</span></h3>
<p><strong>/docker/daemon.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">    daemonCfg = &amp;daemon.Config&#123;&#125;</div><div class="line">)</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">    daemonCfg.InstallFlags()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在mainDaemon()运行之前，关于Docker Daemon所需要的config配置信息均已经初始化完毕。</p>
<p>声明一个为daemon包中Config类型的变量，名为daemonCfg。而Config对象，定义了Docker Daemon所需的配置信息。在Docker Daemon在启动时，daemonCfg变量被传递至Docker Daemon并被使用。</p>
<p><strong>/daemon/config.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</div><div class="line">    Pidfile                  <span class="keyword">string</span>   <span class="comment">//Docker Daemon所属进程的PID文件</span></div><div class="line">    Root                   <span class="keyword">string</span>   <span class="comment">//Docker运行时所使用的root路径</span></div><div class="line">    AutoRestart             <span class="keyword">bool</span>    <span class="comment">//已被启用，转而支持docker run时的重启</span></div><div class="line">    Dns                   []<span class="keyword">string</span>  <span class="comment">//Docker使用的DNS Server地址</span></div><div class="line">    DnsSearch              []<span class="keyword">string</span>  <span class="comment">//Docker使用的指定的DNS查找域名</span></div><div class="line">    Mirrors                 []<span class="keyword">string</span>  <span class="comment">//指定的优先Docker Registry镜像</span></div><div class="line">    EnableIptables           <span class="keyword">bool</span>    <span class="comment">//启用Docker的iptables功能</span></div><div class="line">    EnableIpForward         <span class="keyword">bool</span>    <span class="comment">//启用net.ipv4.ip_forward功能</span></div><div class="line">    EnableIpMasq            <span class="keyword">bool</span>      <span class="comment">//启用IP伪装技术</span></div><div class="line">    DefaultIp                net.IP     <span class="comment">//绑定容器端口时使用的默认IP</span></div><div class="line">    BridgeIface              <span class="keyword">string</span>      <span class="comment">//添加容器网络至已有的网桥</span></div><div class="line">    BridgeIP                 <span class="keyword">string</span>     <span class="comment">//创建网桥的IP地址</span></div><div class="line">    FixedCIDR               <span class="keyword">string</span>     <span class="comment">//指定IP的IPv4子网，必须被网桥子网包含</span></div><div class="line">    InterContainerCommunication   <span class="keyword">bool</span>  <span class="comment">//是否允许相同host上容器间的通信</span></div><div class="line">    GraphDriver             <span class="keyword">string</span>      <span class="comment">//Docker运行时使用的特定存储驱动</span></div><div class="line">    GraphOptions            []<span class="keyword">string</span>   <span class="comment">//可设置的存储驱动选项</span></div><div class="line">    ExecDriver               <span class="keyword">string</span>    <span class="comment">// Docker运行时使用的特定exec驱动</span></div><div class="line">    Mtu                    <span class="keyword">int</span>      <span class="comment">//设置容器网络的MTU</span></div><div class="line">    DisableNetwork          <span class="keyword">bool</span>     <span class="comment">//有定义，之后未初始化</span></div><div class="line">    EnableSelinuxSupport      <span class="keyword">bool</span>     <span class="comment">//启用SELinux功能的支持</span></div><div class="line">    Context                 <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>   <span class="comment">//有定义，之后未初始化</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>init()函数实现了daemonCfg变量中各属性的赋值，具体的实现为：daemonCfg.InstallFlags()</p>
<p><strong>/daemon/config.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// InstallFlags adds command-line options to the top-level flag parser for</span></div><div class="line"><span class="comment">// the current process.</span></div><div class="line"><span class="comment">// Subsequent calls to `flag.Parse` will populate config with values parsed</span></div><div class="line"><span class="comment">// from the command-line.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(config *Config)</span> <span class="title">InstallFlags</span><span class="params">()</span></span> &#123;</div><div class="line">    flag.StringVar(&amp;config.Pidfile, []<span class="keyword">string</span>&#123;<span class="string">"p"</span>, <span class="string">"-pidfile"</span>&#125;, <span class="string">"/var/run/docker.pid"</span>, <span class="string">"Path to use for daemon PID file"</span>)</div><div class="line">    flag.StringVar(&amp;config.Root, []<span class="keyword">string</span>&#123;<span class="string">"g"</span>, <span class="string">"-graph"</span>&#125;, <span class="string">"/var/lib/docker"</span>, <span class="string">"Path to use as the root of the Docker runtime"</span>)</div><div class="line">    flag.BoolVar(&amp;config.AutoRestart, []<span class="keyword">string</span>&#123;<span class="string">"#r"</span>, <span class="string">"#-restart"</span>&#125;, <span class="literal">true</span>, <span class="string">"--restart on the daemon has been deprecated infavor of --restart policies on docker run"</span>)</div><div class="line">    flag.BoolVar(&amp;config.EnableIptables, []<span class="keyword">string</span>&#123;<span class="string">"#iptables"</span>, <span class="string">"-iptables"</span>&#125;, <span class="literal">true</span>, <span class="string">"Enable Docker's addition of iptables rules"</span>)</div><div class="line">    flag.BoolVar(&amp;config.EnableIpForward, []<span class="keyword">string</span>&#123;<span class="string">"#ip-forward"</span>, <span class="string">"-ip-forward"</span>&#125;, <span class="literal">true</span>, <span class="string">"Enable net.ipv4.ip_forward"</span>)</div><div class="line">    flag.StringVar(&amp;config.BridgeIP, []<span class="keyword">string</span>&#123;<span class="string">"#bip"</span>, <span class="string">"-bip"</span>&#125;, <span class="string">""</span>, <span class="string">"Use this CIDR notation address for the network bridge's IP, not compatible with -b"</span>)</div><div class="line">    flag.StringVar(&amp;config.BridgeIface, []<span class="keyword">string</span>&#123;<span class="string">"b"</span>, <span class="string">"-bridge"</span>&#125;, <span class="string">""</span>, <span class="string">"Attach containers to a pre-existing network bridge/nuse 'none' to disable container networking"</span>)</div><div class="line">    flag.BoolVar(&amp;config.InterContainerCommunication, []<span class="keyword">string</span>&#123;<span class="string">"#icc"</span>, <span class="string">"-icc"</span>&#125;, <span class="literal">true</span>, <span class="string">"Enable inter-container communication"</span>)</div><div class="line">    flag.StringVar(&amp;config.GraphDriver, []<span class="keyword">string</span>&#123;<span class="string">"s"</span>, <span class="string">"-storage-driver"</span>&#125;, <span class="string">""</span>, <span class="string">"Force the Docker runtime to use a specific storage driver"</span>)</div><div class="line">    flag.StringVar(&amp;config.ExecDriver, []<span class="keyword">string</span>&#123;<span class="string">"e"</span>, <span class="string">"-exec-driver"</span>&#125;, <span class="string">"native"</span>, <span class="string">"Force the Docker runtime to use a specific exec driver"</span>)</div><div class="line">    flag.BoolVar(&amp;config.EnableSelinuxSupport, []<span class="keyword">string</span>&#123;<span class="string">"-selinux-enabled"</span>&#125;, <span class="literal">false</span>, <span class="string">"Enable selinux support. SELinux does not presently support the BTRFS storage driver"</span>)</div><div class="line">    flag.IntVar(&amp;config.Mtu, []<span class="keyword">string</span>&#123;<span class="string">"#mtu"</span>, <span class="string">"-mtu"</span>&#125;, <span class="number">0</span>, <span class="string">"Set the containers network MTU/nif no value is provided: default to the default route MTU or 1500 if no default route is available"</span>)</div><div class="line">    opts.IPVar(&amp;config.DefaultIp, []<span class="keyword">string</span>&#123;<span class="string">"#ip"</span>, <span class="string">"-ip"</span>&#125;, <span class="string">"0.0.0.0"</span>, <span class="string">"Default IP address to use when binding container ports"</span>)</div><div class="line">    opts.ListVar(&amp;config.GraphOptions, []<span class="keyword">string</span>&#123;<span class="string">"-storage-opt"</span>&#125;, <span class="string">"Set storage driver options"</span>)</div><div class="line">    <span class="comment">// <span class="doctag">FIXME:</span> why the inconsistency between "hosts" and "sockets"?</span></div><div class="line">    opts.IPListVar(&amp;config.Dns, []<span class="keyword">string</span>&#123;<span class="string">"#dns"</span>, <span class="string">"-dns"</span>&#125;, <span class="string">"Force Docker to use specific DNS servers"</span>)</div><div class="line">    opts.DnsSearchListVar(&amp;config.DnsSearch, []<span class="keyword">string</span>&#123;<span class="string">"-dns-search"</span>&#125;, <span class="string">"Force Docker to use specific DNS search domains"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在InstallFlags()函数的实现过程中，主要是定义某种类型的flag参数，并将该参数的值绑定在config变量的指定属性上，如：</p>
<p>flag.StringVar(&amp;config.Pidfile, []string{“p”, “-pidfile”}, &quot; /var/run/docker.pid&quot;, “Path to use for daemon PID file”)</p>
<p>以上语句的含义为：</p>
<ul>
<li>定义一个为String类型的flag参数；</li>
<li>该flag的名称为”p”或者”-pidfile”;</li>
<li>该flag的值为” /var/run/docker.pid”,并将该值绑定在变量config.Pidfile上；</li>
<li>该flag的描述信息为&quot;Path to use for daemon PID file&quot;。</li>
</ul>
<h3><span id="二flag参数检查">（二）flag参数检查</span></h3>
<p><strong>/docker/daemon.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> flag.NArg() != <span class="number">0</span> &#123;</div><div class="line">    flag.Usage()</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>参数个数不为0，则说明在启动Docker Daemon的时候，传入了多余的参数，此时会输出错误提示，并退出运行程序。</li>
<li>若为0，则说明Docker Daemon的启动命令无误，正常运行。</li>
</ul>
<h3><span id="三创建engine对象">（三）创建engine对象</span></h3>
<p><strong>/docker/daemon.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eng := engine.New()</div></pre></td></tr></table></figure>
<p>Engine是Docker架构中的运行引擎，同时也是Docker运行的核心模块。Engine扮演着Docker container存储仓库的角色，并且通过job的形式来管理这些容器。</p>
<p><strong>/engine/engine.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</div><div class="line">    handlers   <span class="keyword">map</span>[<span class="keyword">string</span>]Handler</div><div class="line">    catchall   Handler</div><div class="line">    hack       Hack <span class="comment">// data for temporary hackery (see hack.go)</span></div><div class="line">    id         <span class="keyword">string</span></div><div class="line">    Stdout     io.Writer</div><div class="line">    Stderr     io.Writer</div><div class="line">    Stdin      io.Reader</div><div class="line">    Logging    <span class="keyword">bool</span></div><div class="line">    tasks      sync.WaitGroup</div><div class="line">    l          sync.RWMutex <span class="comment">// lock for shutdown</span></div><div class="line">    shutdown   <span class="keyword">bool</span></div><div class="line">    onShutdown []<span class="function"><span class="keyword">func</span><span class="params">()</span> // <span class="title">shutdown</span> <span class="title">handlers</span></span></div><div class="line"><span class="function">&#125;</span></div></pre></td></tr></table></figure>
<p>Engine结构体中最为重要的即为handlers属性。该handlers属性为map类型，key为string类型，value为Handler类型。Handler为一个定义的函数。该函数传入的参数为Job指针，返回为Status状态。</p>
<p><strong>/engine/engine.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Handler <span class="function"><span class="keyword">func</span><span class="params">(*Job)</span> <span class="title">Status</span></span></div></pre></td></tr></table></figure>
<p>New()函数的实现:</p>
<p><strong>/engine/engine.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// New initializes a new engine.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Engine</span></span> &#123;</div><div class="line">    eng := &amp;Engine&#123;</div><div class="line">        handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Handler),</div><div class="line">        id:       utils.RandomString(),</div><div class="line">        Stdout:   os.Stdout,</div><div class="line">        Stderr:   os.Stderr,</div><div class="line">        Stdin:    os.Stdin,</div><div class="line">        Logging:  <span class="literal">true</span>,</div><div class="line">    &#125;</div><div class="line">    eng.Register(<span class="string">"commands"</span>, <span class="function"><span class="keyword">func</span><span class="params">(job *Job)</span> <span class="title">Status</span></span> &#123;</div><div class="line">        <span class="keyword">for</span> _, name := <span class="keyword">range</span> eng.commands() &#123;</div><div class="line">            job.Printf(<span class="string">"%s/n"</span>, name)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> StatusOK</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// Copy existing global handlers</span></div><div class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> globalHandlers &#123;</div><div class="line">        eng.handlers[k] = v</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> eng</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>创建一个Engine结构体实例eng</li>
<li>向eng对象注册名为commands的Handler，其中Handler为临时定义的函数func(job *Job) Status{ } , 该函数的作用是通过job来打印所有已经注册完毕的command名称，最终返回状态StatusOK。</li>
<li>将已定义的变量globalHandlers中的所有的Handler，都复制到eng对象的handlers属性中。最后成功返回eng对象。</li>
</ol>
<h3><span id="四设置engine的信号捕获">（四）设置engine的信号捕获</span></h3>
<p><strong>/daemon/daemon.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">signal.Trap(eng.Shutdown)</div></pre></td></tr></table></figure>
<p>在Docker Daemon的运行中，设置Trap特定信号的处理方法，特定信号有SIGINT，SIGTERM以及SIGQUIT；当程序捕获到SIGINT或者SIGTERM信号时，执行相应的善后操作，最后保证Docker Daemon程序退出。</p>
<p><strong>/pkg/signal/trap.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Trap sets up a simplified signal "trap", appropriate for common</span></div><div class="line"><span class="comment">// behavior expected from a vanilla unix command-line tool in general</span></div><div class="line"><span class="comment">// (and the Docker engine in particular).</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// * If SIGINT or SIGTERM are received, `cleanup` is called, then the process is terminated.</span></div><div class="line"><span class="comment">// * If SIGINT or SIGTERM are repeated 3 times before cleanup is complete, then cleanup is</span></div><div class="line"><span class="comment">// skipped and the process terminated directly.</span></div><div class="line"><span class="comment">// * If "DEBUG" is set in the environment, SIGQUIT causes an exit without cleanup.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trap</span><span class="params">(cleanup <span class="keyword">func</span>()</span>)</span> &#123;</div><div class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</div><div class="line">    signals := []os.Signal&#123;os.Interrupt, syscall.SIGTERM&#125;</div><div class="line">    <span class="keyword">if</span> os.Getenv(<span class="string">"DEBUG"</span>) == <span class="string">""</span> &#123;</div><div class="line">        signals = <span class="built_in">append</span>(signals, syscall.SIGQUIT)</div><div class="line">    &#125;</div><div class="line">    gosignal.Notify(c, signals...)</div><div class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">        interruptCount := <span class="keyword">uint32</span>(<span class="number">0</span>)</div><div class="line">        <span class="keyword">for</span> sig := <span class="keyword">range</span> c &#123;</div><div class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(sig os.Signal)</span></span> &#123;</div><div class="line">                log.Printf(<span class="string">"Received signal '%v', starting shutdown of docker.../n"</span>, sig)</div><div class="line">                <span class="keyword">switch</span> sig &#123;</div><div class="line">                <span class="keyword">case</span> os.Interrupt, syscall.SIGTERM:</div><div class="line">                    <span class="comment">// If the user really wants to interrupt, let him do so.</span></div><div class="line">                    <span class="keyword">if</span> atomic.LoadUint32(&amp;interruptCount) &lt; <span class="number">3</span> &#123;</div><div class="line">                        atomic.AddUint32(&amp;interruptCount, <span class="number">1</span>)</div><div class="line">                        <span class="comment">// Initiate the cleanup only once</span></div><div class="line">                        <span class="keyword">if</span> atomic.LoadUint32(&amp;interruptCount) == <span class="number">1</span> &#123;</div><div class="line">                            <span class="comment">// Call cleanup handler</span></div><div class="line">                            cleanup()</div><div class="line">                            os.Exit(<span class="number">0</span>)</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">return</span></div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        log.Printf(<span class="string">"Force shutdown of docker, interrupting cleanup/n"</span>)</div><div class="line">                    &#125;</div><div class="line">                <span class="keyword">case</span> syscall.SIGQUIT:</div><div class="line">                &#125;</div><div class="line">                os.Exit(<span class="number">128</span> + <span class="keyword">int</span>(sig.(syscall.Signal)))</div><div class="line">            &#125;(sig)</div><div class="line">        &#125;</div><div class="line">    &#125;()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>创建并设置一个channel，用于发送信号通知；</li>
<li>定义signals数组变量，初始值为os.SIGINT, os.SIGTERM;若环境变量DEBUG为空的话，则添加os.SIGQUIT至signals数组；</li>
<li>通过gosignal.Notify(c, signals…)中Notify函数来实现将接收到的signal信号传递给c。需要注意的是只有signals中被罗列出的信号才会被传递给c，其余信号会被直接忽略；</li>
<li>创建一个goroutine来处理具体的signal信号，当信号类型为os.Interrupt或者syscall.SIGTERM时，执行传入Trap函数的具体执行方法，形参为cleanup(),实参为eng.Shutdown。</li>
</ul>
<p>Shutdown()函数的定义位于<a href="https://github.com/docker/docker/blob/v1.2.0/engine/engine.go#L153" target="_blank" rel="external">./docker/engine/engine.go</a>，主要做的工作是为Docker Daemon的关闭做一些善后工作。</p>
<p><strong>/engine/engine.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Shutdown permanently shuts down eng as follows:</span></div><div class="line"><span class="comment">// - It refuses all new jobs, permanently.</span></div><div class="line"><span class="comment">// - It waits for all active jobs to complete (with no timeout)</span></div><div class="line"><span class="comment">// - It calls all shutdown handlers concurrently (if any)</span></div><div class="line"><span class="comment">// - It returns when all handlers complete, or after 15 seconds,</span></div><div class="line"><span class="comment">//    whichever happens first.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(eng *Engine)</span> <span class="title">Shutdown</span><span class="params">()</span></span> &#123;</div><div class="line">    eng.l.Lock()</div><div class="line">    <span class="keyword">if</span> eng.shutdown &#123;</div><div class="line">        eng.l.Unlock()</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    eng.shutdown = <span class="literal">true</span></div><div class="line">    eng.l.Unlock()</div><div class="line">    <span class="comment">// We don't need to protect the rest with a lock, to allow</span></div><div class="line">    <span class="comment">// for other calls to immediately fail with "shutdown" instead</span></div><div class="line">    <span class="comment">// of hanging for 15 seconds.</span></div><div class="line">    <span class="comment">// This requires all concurrent calls to check for shutdown, otherwise</span></div><div class="line">    <span class="comment">// it might cause a race.</span></div><div class="line">    <span class="comment">// Wait for all jobs to complete.</span></div><div class="line">    <span class="comment">// Timeout after 5 seconds.</span></div><div class="line">    tasksDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</div><div class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">        eng.tasks.Wait()</div><div class="line">        <span class="built_in">close</span>(tasksDone)</div><div class="line">    &#125;()</div><div class="line">    <span class="keyword">select</span> &#123;</div><div class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">5</span>):</div><div class="line">    <span class="keyword">case</span> &lt;-tasksDone:</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Call shutdown handlers, if any.</span></div><div class="line">    <span class="comment">// Timeout after 10 seconds.</span></div><div class="line">    <span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">    <span class="keyword">for</span> _, h := <span class="keyword">range</span> eng.onShutdown &#123;</div><div class="line">        wg.Add(<span class="number">1</span>)</div><div class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(h <span class="keyword">func</span>()</span>)</span> &#123;</div><div class="line">            <span class="keyword">defer</span> wg.Done()</div><div class="line">            h()</div><div class="line">        &#125;(h)</div><div class="line">    &#125;</div><div class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</div><div class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">        wg.Wait()</div><div class="line">        <span class="built_in">close</span>(done)</div><div class="line">    &#125;()</div><div class="line">    <span class="keyword">select</span> &#123;</div><div class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">10</span>):</div><div class="line">    <span class="keyword">case</span> &lt;-done:</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Docker Daemon不再接收任何新的Job；</li>
<li>Docker Daemon等待所有存活的Job执行完毕；</li>
<li>Docker Daemon调用所有shutdown的处理方法；</li>
<li>当所有的handler执行完毕，或者15秒之后，Shutdown()函数返回。</li>
</ul>
<p>由于在signal.Trap( eng.Shutdown )函数的具体实现中执行eng.Shutdown，在执行完eng.Shutdown之后，随即执行<a href="https://github.com/docker/docker/blob/v1.2.0/pkg/signal/trap.go#L41" target="_blank" rel="external">os.Exit(0)</a>，完成当前程序的立即退出。</p>
<h3><span id="五加载builtins">（五）加载builtins</span></h3>
<p><strong>/docker/daemon.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> err := builtins.Register(eng); err != <span class="literal">nil</span> &#123;</div><div class="line">    log.Fatal(err)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为engine注册多个Handler，以便后续在执行相应任务时，运行指定的Handler。</p>
<p>这些Handler包括：</p>
<ul>
<li>网络初始化、</li>
<li>web API服务、</li>
<li>事件查询、</li>
<li>版本查看、</li>
<li>Docker Registry验证与搜索。</li>
</ul>
<p><strong>/builtins/builtins.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(eng *engine.Engine)</span> <span class="title">error</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> err := daemon(eng); err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> err := remote(eng); err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> err := events.New().Install(eng); err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> err := eng.Register(<span class="string">"version"</span>, dockerVersion); err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> registry.NewService().Install(eng)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4><span id="1-注册初始化网络驱动的handler">1、注册初始化网络驱动的Handler</span></h4>
<p>daemon(eng)的实现过程，主要为eng对象注册了一个key为”init_networkdriver”的Handler，该Handler的值为bridge.InitDriver函数，代码如下：</p>
<p><strong>/builtins/builtins.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">daemon</span><span class="params">(eng *engine.Engine)</span> <span class="title">error</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> eng.Register(<span class="string">"init_networkdriver"</span>, bridge.InitDriver)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是，向eng对象注册Handler，并不代表Handler的值函数会被直接运行，如bridge.InitDriver，并不会直接运行，而是将bridge.InitDriver的函数入口，写入eng的handlers属性中。</p>
<p><strong>/daemon/networkdriver/bridge/driver.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitDriver</span><span class="params">(job *engine.Job)</span> <span class="title">engine</span>.<span class="title">Status</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> (</div><div class="line">        network        *net.IPNet</div><div class="line">        enableIPTables = job.GetenvBool(<span class="string">"EnableIptables"</span>)</div><div class="line">        icc            = job.GetenvBool(<span class="string">"InterContainerCommunication"</span>)</div><div class="line">        ipForward      = job.GetenvBool(<span class="string">"EnableIpForward"</span>)</div><div class="line">        bridgeIP       = job.Getenv(<span class="string">"BridgeIP"</span>)</div><div class="line">    )</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> defaultIP := job.Getenv(<span class="string">"DefaultBindingIP"</span>); defaultIP != <span class="string">""</span> &#123;</div><div class="line">        defaultBindingIP = net.ParseIP(defaultIP)</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    bridgeIface = job.Getenv(<span class="string">"BridgeIface"</span>)</div><div class="line">    usingDefaultBridge := <span class="literal">false</span></div><div class="line">    <span class="keyword">if</span> bridgeIface == <span class="string">""</span> &#123;</div><div class="line">        usingDefaultBridge = <span class="literal">true</span></div><div class="line">        bridgeIface = DefaultNetworkBridge</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    addr, err := networkdriver.GetIfaceAddr(bridgeIface)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="comment">// If we're not using the default bridge, fail without trying to create it</span></div><div class="line">        <span class="keyword">if</span> !usingDefaultBridge &#123;</div><div class="line">            job.Logf(<span class="string">"bridge not found: %s"</span>, bridgeIface)</div><div class="line">            <span class="keyword">return</span> job.Error(err)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// If the iface is not found, try to create it</span></div><div class="line">        job.Logf(<span class="string">"creating new bridge for %s"</span>, bridgeIface)</div><div class="line">        <span class="keyword">if</span> err := createBridge(bridgeIP); err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> job.Error(err)</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        job.Logf(<span class="string">"getting iface addr"</span>)</div><div class="line">        addr, err = networkdriver.GetIfaceAddr(bridgeIface)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> job.Error(err)</div><div class="line">        &#125;</div><div class="line">        network = addr.(*net.IPNet)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        network = addr.(*net.IPNet)</div><div class="line">        <span class="comment">// validate that the bridge ip matches the ip specified by BridgeIP</span></div><div class="line">        <span class="keyword">if</span> bridgeIP != <span class="string">""</span> &#123;</div><div class="line">            bip, _, err := net.ParseCIDR(bridgeIP)</div><div class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">                <span class="keyword">return</span> job.Error(err)</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> !network.IP.Equal(bip) &#123;</div><div class="line">                <span class="keyword">return</span> job.Errorf(<span class="string">"bridge ip (%s) does not match existing bridge configuration %s"</span>, network.IP, bip)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">// Configure iptables for link support</span></div><div class="line">    <span class="keyword">if</span> enableIPTables &#123;</div><div class="line">        <span class="keyword">if</span> err := setupIPTables(addr, icc); err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> job.Error(err)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> ipForward &#123;</div><div class="line">        <span class="comment">// Enable IPv4 forwarding</span></div><div class="line">        <span class="keyword">if</span> err := ioutil.WriteFile(<span class="string">"/proc/sys/net/ipv4/ip_forward"</span>, []<span class="keyword">byte</span>&#123;<span class="string">'1'</span>, <span class="string">'/n'</span>&#125;, <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</div><div class="line">            job.Logf(<span class="string">"WARNING: unable to enable IPv4 forwarding: %s/n"</span>, err)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">// We can always try removing the iptables</span></div><div class="line">    <span class="keyword">if</span> err := iptables.RemoveExistingChain(<span class="string">"DOCKER"</span>); err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> job.Error(err)</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> enableIPTables &#123;</div><div class="line">        chain, err := iptables.NewChain(<span class="string">"DOCKER"</span>, bridgeIface)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> job.Error(err)</div><div class="line">        &#125;</div><div class="line">        portmapper.SetIptablesChain(chain)</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    bridgeNetwork = network</div><div class="line"> </div><div class="line">    <span class="comment">// https://github.com/docker/docker/issues/2768</span></div><div class="line">    job.Eng.Hack_SetGlobalVar(<span class="string">"httpapi.bridgeIP"</span>, bridgeNetwork.IP)</div><div class="line"> </div><div class="line">    <span class="keyword">for</span> name, f := <span class="keyword">range</span> <span class="keyword">map</span>[<span class="keyword">string</span>]engine.Handler&#123;</div><div class="line">        <span class="string">"allocate_interface"</span>: Allocate,</div><div class="line">        <span class="string">"release_interface"</span>:  Release,</div><div class="line">        <span class="string">"allocate_port"</span>:      AllocatePort,</div><div class="line">        <span class="string">"link"</span>:               LinkContainers,</div><div class="line">    &#125; &#123;</div><div class="line">        <span class="keyword">if</span> err := job.Eng.Register(name, f); err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> job.Error(err)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> engine.StatusOK</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Bridge.InitDriver的作用：</p>
<ul>
<li>获取为Docker服务的网络设备的地址；</li>
<li>创建指定IP地址的网桥；</li>
<li>配置网络iptables规则；</li>
<li>另外还为eng对象注册了多个Handler,如 ”allocate_interface”， ”release_interface”， ”allocate_port”，”link”。</li>
</ul>
<h4><span id="2-注册api服务的handler">2、注册API服务的Handler</span></h4>
<p>remote(eng)的实现过程，主要为eng对象注册了两个Handler，分别为”serveapi”与”acceptconnections”。代码实现如下：</p>
<p><strong>/builtins/builtins.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">remote</span><span class="params">(eng *engine.Engine)</span> <span class="title">error</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> err := eng.Register(<span class="string">"serveapi"</span>, apiserver.ServeApi); err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> eng.Register(<span class="string">"acceptconnections"</span>, apiserver.AcceptConnections)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注册的两个Handler名称分别为”serveapi”与”acceptconnections”</p>
<ul>
<li>ServeApi执行时，通过循环多种协议，创建出goroutine来配置指定的http.Server，最终为不同的协议请求服务；</li>
<li>AcceptConnections的实现主要是为了通知init守护进程，Docker Daemon已经启动完毕，可以让Docker Daemon进程接受请求。(守护进程)</li>
</ul>
<h4><span id="3-注册events事件的handler">3、注册events事件的Handler</span></h4>
<p>events.New().Install(eng)的实现过程，为Docker注册了多个event事件，功能是给Docker用户提供API，使得用户可以通过这些API查看Docker内部的events信息，log信息以及subscribers_count信息。</p>
<p><strong>/events/events.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Events <span class="keyword">struct</span> &#123;</div><div class="line">    mu          sync.RWMutex</div><div class="line">    events      []*utils.JSONMessage</div><div class="line">    subscribers []listener</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Events</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> &amp;Events&#123;</div><div class="line">        events: <span class="built_in">make</span>([]*utils.JSONMessage, <span class="number">0</span>, eventsLimit),</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Install installs events public api in docker engine</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Events)</span> <span class="title">Install</span><span class="params">(eng *engine.Engine)</span> <span class="title">error</span></span> &#123;</div><div class="line">    <span class="comment">// Here you should describe public interface</span></div><div class="line">    jobs := <span class="keyword">map</span>[<span class="keyword">string</span>]engine.Handler&#123;</div><div class="line">        <span class="string">"events"</span>:            e.Get,</div><div class="line">        <span class="string">"log"</span>:               e.Log,</div><div class="line">        <span class="string">"subscribers_count"</span>: e.SubscribersCount,</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> name, job := <span class="keyword">range</span> jobs &#123;</div><div class="line">        <span class="keyword">if</span> err := eng.Register(name, job); err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> err</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4><span id="4-注册版本的handler">4、注册版本的Handler</span></h4>
<p>eng.Register(“version”,dockerVersion)的实现过程，向eng对象注册key为”version”，value为”dockerVersion”执行方法的Handler，dockerVersion的执行过程中，会向名为version的job的标准输出中写入Docker的版本，Docker API的版本，git版本，Go语言运行时版本以及操作系统等版本信息。</p>
<p><strong>/builtins/builtins.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// builtins jobs independent of any subsystem</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">dockerVersion</span><span class="params">(job *engine.Job)</span> <span class="title">engine</span>.<span class="title">Status</span></span> &#123;</div><div class="line">    v := &amp;engine.Env&#123;&#125;</div><div class="line">    v.SetJson(<span class="string">"Version"</span>, dockerversion.VERSION)</div><div class="line">    v.SetJson(<span class="string">"ApiVersion"</span>, api.APIVERSION)</div><div class="line">    v.Set(<span class="string">"GitCommit"</span>, dockerversion.GITCOMMIT)</div><div class="line">    v.Set(<span class="string">"GoVersion"</span>, runtime.Version())</div><div class="line">    v.Set(<span class="string">"Os"</span>, runtime.GOOS)</div><div class="line">    v.Set(<span class="string">"Arch"</span>, runtime.GOARCH)</div><div class="line">    <span class="keyword">if</span> kernelVersion, err := kernel.GetKernelVersion(); err == <span class="literal">nil</span> &#123;</div><div class="line">        v.Set(<span class="string">"KernelVersion"</span>, kernelVersion.String())</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> _, err := v.WriteTo(job.Stdout); err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> job.Error(err)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> engine.StatusOK</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4><span id="5-注册registry的handler">5、注册registry的Handler</span></h4>
<p>registry.NewService().Install(eng)的实现过程位于<a href="https://github.com/docker/docker/blob/v1.2.0/registry/service.go#L25" target="_blank" rel="external">./docker/registry/service.go</a>，在eng对象对外暴露的API信息中添加docker registry的信息。当registry.NewService()成功被Install安装完毕的话，则有两个调用能够被eng使用：”auth”，向公有registry进行认证；”search”，在公有registry上搜索指定的镜像。</p>
<p><strong>/registry/service.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewService returns a new instance of Service ready to be</span></div><div class="line"><span class="comment">// installed no an engine.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewService</span><span class="params">()</span> *<span class="title">Service</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> &amp;Service&#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Install installs registry capabilities to eng.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">Install</span><span class="params">(eng *engine.Engine)</span> <span class="title">error</span></span> &#123;</div><div class="line">    eng.Register(<span class="string">"auth"</span>, s.Auth)</div><div class="line">    eng.Register(<span class="string">"search"</span>, s.Search)</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3><span id="六使用goroutine加载daemon对象">（六）使用goroutine加载daemon对象</span></h3>
<p>执行完builtins的加载，回到mainDaemon()的执行，通过一个goroutine来加载daemon对象并开始运行。这一环节的执行，主要包含三个步骤：</p>
<ul>
<li>通过init函数中初始化的daemonCfg与eng对象来创建一个daemon对象d；(守护进程)</li>
<li>通过daemon对象的Install函数，向eng对象中注册众多的Handler；</li>
<li>在Docker Daemon启动完毕之后，运行名为”acceptconnections”的job，主要工作为向init守护进程发送”READY=1”信号，以便开始正常接受请求。</li>
</ul>
<p><strong>/docker/daemon.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// load the daemon in the background so we can immediately start</span></div><div class="line"><span class="comment">// the http api so that connections don't fail while the daemon</span></div><div class="line"><span class="comment">// is booting</span></div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">    d, err := daemon.NewDaemon(daemonCfg, eng)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        log.Fatal(err)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> err := d.Install(eng); err != <span class="literal">nil</span> &#123;</div><div class="line">        log.Fatal(err)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// after the daemon is done setting up we can tell the api to start</span></div><div class="line">    <span class="comment">// accepting connections</span></div><div class="line">    <span class="keyword">if</span> err := eng.Job(<span class="string">"acceptconnections"</span>).Run(); err != <span class="literal">nil</span> &#123;</div><div class="line">        log.Fatal(err)</div><div class="line">    &#125;</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<h4><span id="1-创建daemon对象">1、创建daemon对象</span></h4>
<p><strong>/docker/daemon.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">d, err := daemon.NewDaemon(daemonCfg, eng)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">    log.Fatal(err)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>daemon.NewDaemon(daemonCfg, eng)是创建daemon对象d的核心部分。主要作用为初始化Docker Daemon的基本环境，如处理config参数，验证系统支持度，配置Docker工作目录，设置与加载多种driver，创建graph环境等，验证DNS配置等。具体参考<a href="http://wiki.haplat.net/display/~huwh/NewDaemon" target="_blank" rel="external">NewDaemon</a> 。</p>
<h4><span id="2-通过daemon对象为engine注册handler">2、通过daemon对象为engine注册Handler</span></h4>
<p>当创建完daemon对象，goroutine执行d.Install(eng)</p>
<p><strong>/daemon/daemon.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Daemon <span class="keyword">struct</span> &#123;</div><div class="line">    repository     <span class="keyword">string</span></div><div class="line">    sysInitPath    <span class="keyword">string</span></div><div class="line">    containers     *contStore</div><div class="line">    graph          *graph.Graph</div><div class="line">    repositories   *graph.TagStore</div><div class="line">    idIndex        *truncindex.TruncIndex</div><div class="line">    sysInfo        *sysinfo.SysInfo</div><div class="line">    volumes        *graph.Graph</div><div class="line">    eng            *engine.Engine</div><div class="line">    config         *Config</div><div class="line">    containerGraph *graphdb.Database</div><div class="line">    driver         graphdriver.Driver</div><div class="line">    execDriver     execdriver.Driver</div><div class="line">&#125;</div><div class="line"><span class="comment">// Install installs daemon capabilities to eng.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">Install</span><span class="params">(eng *engine.Engine)</span> <span class="title">error</span></span> &#123;</div><div class="line">    <span class="comment">// <span class="doctag">FIXME:</span> rename "delete" to "rm" for consistency with the CLI command</span></div><div class="line">    <span class="comment">// <span class="doctag">FIXME:</span> rename ContainerDestroy to ContainerRm for consistency with the CLI command</span></div><div class="line">    <span class="comment">// <span class="doctag">FIXME:</span> remove ImageDelete's dependency on Daemon, then move to graph/</span></div><div class="line">    <span class="keyword">for</span> name, method := <span class="keyword">range</span> <span class="keyword">map</span>[<span class="keyword">string</span>]engine.Handler&#123;</div><div class="line">        <span class="string">"attach"</span>:            daemon.ContainerAttach,</div><div class="line">        <span class="string">"build"</span>:             daemon.CmdBuild,</div><div class="line">        <span class="string">"commit"</span>:            daemon.ContainerCommit,</div><div class="line">        <span class="string">"container_changes"</span>: daemon.ContainerChanges,</div><div class="line">        <span class="string">"container_copy"</span>:    daemon.ContainerCopy,</div><div class="line">        <span class="string">"container_inspect"</span>: daemon.ContainerInspect,</div><div class="line">        <span class="string">"containers"</span>:        daemon.Containers,</div><div class="line">        <span class="string">"create"</span>:            daemon.ContainerCreate,</div><div class="line">        <span class="string">"delete"</span>:            daemon.ContainerDestroy,</div><div class="line">        <span class="string">"export"</span>:            daemon.ContainerExport,</div><div class="line">        <span class="string">"info"</span>:              daemon.CmdInfo,</div><div class="line">        <span class="string">"kill"</span>:              daemon.ContainerKill,</div><div class="line">        <span class="string">"logs"</span>:              daemon.ContainerLogs,</div><div class="line">        <span class="string">"pause"</span>:             daemon.ContainerPause,</div><div class="line">        <span class="string">"resize"</span>:            daemon.ContainerResize,</div><div class="line">        <span class="string">"restart"</span>:           daemon.ContainerRestart,</div><div class="line">        <span class="string">"start"</span>:             daemon.ContainerStart,</div><div class="line">        <span class="string">"stop"</span>:              daemon.ContainerStop,</div><div class="line">        <span class="string">"top"</span>:               daemon.ContainerTop,</div><div class="line">        <span class="string">"unpause"</span>:           daemon.ContainerUnpause,</div><div class="line">        <span class="string">"wait"</span>:              daemon.ContainerWait,</div><div class="line">        <span class="string">"image_delete"</span>:      daemon.ImageDelete, <span class="comment">// <span class="doctag">FIXME:</span> see above</span></div><div class="line">    &#125; &#123;</div><div class="line">        <span class="keyword">if</span> err := eng.Register(name, method); err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> err</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> err := daemon.Repositories().Install(eng); err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// <span class="doctag">FIXME:</span> this hack is necessary for legacy integration tests to access</span></div><div class="line">    <span class="comment">// the daemon object.</span></div><div class="line">    eng.Hack_SetGlobalVar(<span class="string">"httpapi.daemon"</span>, daemon)</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码的实现分为三部分：</p>
<ul>
<li>向eng对象中注册众多的Handler对象；</li>
<li>daemon.Repositories().Install(eng)实现了向eng对象注册多个与image相关的Handler，Install的实现位于<a href="https://github.com/docker/docker/blob/v1.2.0/graph/service.go#L12" target="_blank" rel="external">./docker/graph/service.go</a>；</li>
<li>eng.Hack_SetGlobalVar(“httpapi.daemon”, daemon)实现向eng对象中map类型的hack对象中添加一条记录，key为”httpapi.daemon”，value为daemon。</li>
</ul>
<h4><span id="3-运行acceptconnections的job">3、运行acceptconnections的job</span></h4>
<p><strong>/docker/daemon.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> err := eng.Job(<span class="string">"acceptconnections"</span>).Run(); err != <span class="literal">nil</span> &#123;</div><div class="line">    log.Fatal(err)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在goroutine内部最后运行名为”acceptconnections”的job，主要作用是通知init守护进程，Docker Daemon可以开始接受请求了。</p>
<p>首先执行eng.Job(“acceptconnections”)，返回一个Job，随后再执行eng.Job(“acceptconnections”).Run()，也就是该执行Job的run函数。</p>
<p><strong>/engine/engine.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Job creates a new job which can later be executed.</span></div><div class="line"><span class="comment">// This function mimics `Command` from the standard os/exec package.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(eng *Engine)</span> <span class="title">Job</span><span class="params">(name <span class="keyword">string</span>, args ...<span class="keyword">string</span>)</span> *<span class="title">Job</span></span> &#123;</div><div class="line">    job := &amp;Job&#123;</div><div class="line">        Eng:    eng,</div><div class="line">        Name:   name,</div><div class="line">        Args:   args,</div><div class="line">        Stdin:  NewInput(),</div><div class="line">        Stdout: NewOutput(),</div><div class="line">        Stderr: NewOutput(),</div><div class="line">        env:    &amp;Env&#123;&#125;,</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> eng.Logging &#123;</div><div class="line">        job.Stderr.Add(utils.NopWriteCloser(eng.Stderr))</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Catchall is shadowed by specific Register.</span></div><div class="line">    <span class="keyword">if</span> handler, exists := eng.handlers[name]; exists &#123;</div><div class="line">        job.handler = handler</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> eng.catchall != <span class="literal">nil</span> &amp;&amp; name != <span class="string">""</span> &#123;</div><div class="line">        <span class="comment">// empty job names are illegal, catchall or not.</span></div><div class="line">        job.handler = eng.catchall</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> job</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>首先创建一个类型为Job的job对象，该对象中Eng属性为函数的调用者eng，Name属性为”acceptconnections”，没有参数传入。</li>
<li>另外在eng对象所有的handlers属性中寻找键为”acceptconnections”记录的值，由于在加载builtins操作中的remote(eng)中已经向eng注册过这样的一条记录，key为”acceptconnections”，value为apiserver.AcceptConnections。</li>
<li>因此job对象的handler为apiserver.AcceptConnections。</li>
<li>最后返回已经初始化完毕的对象job。</li>
</ol>
<p>创建完job对象之后，随即执行该job对象的run()函数。</p>
<p><strong>/engine/job.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A job is the fundamental unit of work in the docker engine.</span></div><div class="line"><span class="comment">// Everything docker can do should eventually be exposed as a job.</span></div><div class="line"><span class="comment">// For example: execute a process in a container, create a new container,</span></div><div class="line"><span class="comment">// download an archive from the internet, serve the http api, etc.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// The job API is designed after unix processes: a job has a name, arguments,</span></div><div class="line"><span class="comment">// environment variables, standard streams for input, output and error, and</span></div><div class="line"><span class="comment">// an exit status which can indicate success (0) or error (anything else).</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// One slight variation is that jobs report their status as a string. The</span></div><div class="line"><span class="comment">// string "0" indicates success, and any other strings indicates an error.</span></div><div class="line"><span class="comment">// This allows for richer error reporting.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</div><div class="line">    Eng     *Engine</div><div class="line">    Name    <span class="keyword">string</span></div><div class="line">    Args    []<span class="keyword">string</span></div><div class="line">    env     *Env</div><div class="line">    Stdout  *Output</div><div class="line">    Stderr  *Output</div><div class="line">    Stdin   *Input</div><div class="line">    handler Handler</div><div class="line">    status  Status</div><div class="line">    end     time.Time</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> Status <span class="keyword">int</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    StatusOK       Status = <span class="number">0</span></div><div class="line">    StatusErr      Status = <span class="number">1</span></div><div class="line">    StatusNotFound Status = <span class="number">127</span></div><div class="line">)</div><div class="line"><span class="comment">// Run executes the job and blocks until the job completes.</span></div><div class="line"><span class="comment">// If the job returns a failure status, an error is returned</span></div><div class="line"><span class="comment">// which includes the status.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(job *Job)</span> <span class="title">Run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> job.Eng.IsShutdown() &#123;</div><div class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"engine is shutdown"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// <span class="doctag">FIXME:</span> this is a temporary workaround to avoid Engine.Shutdown</span></div><div class="line">    <span class="comment">// waiting 5 seconds for server/api.ServeApi to complete (which it never will)</span></div><div class="line">    <span class="comment">// everytime the daemon is cleanly restarted.</span></div><div class="line">    <span class="comment">// The permanent fix is to implement Job.Stop and Job.OnStop so that</span></div><div class="line">    <span class="comment">// ServeApi can cooperate and terminate cleanly.</span></div><div class="line">    <span class="keyword">if</span> job.Name != <span class="string">"serveapi"</span> &#123;</div><div class="line">        job.Eng.l.Lock()</div><div class="line">        job.Eng.tasks.Add(<span class="number">1</span>)</div><div class="line">        job.Eng.l.Unlock()</div><div class="line">        <span class="keyword">defer</span> job.Eng.tasks.Done()</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// <span class="doctag">FIXME:</span> make this thread-safe</span></div><div class="line">    <span class="comment">// <span class="doctag">FIXME:</span> implement wait</span></div><div class="line">    <span class="keyword">if</span> !job.end.IsZero() &#123;</div><div class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: job has already completed"</span>, job.Name)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Log beginning and end of the job</span></div><div class="line">    job.Eng.Logf(<span class="string">"+job %s"</span>, job.CallString())</div><div class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">        job.Eng.Logf(<span class="string">"-job %s%s"</span>, job.CallString(), job.StatusString())</div><div class="line">    &#125;()</div><div class="line">    <span class="keyword">var</span> errorMessage = bytes.NewBuffer(<span class="literal">nil</span>)</div><div class="line">    job.Stderr.Add(errorMessage)</div><div class="line">    <span class="keyword">if</span> job.handler == <span class="literal">nil</span> &#123;</div><div class="line">        job.Errorf(<span class="string">"%s: command not found"</span>, job.Name)</div><div class="line">        job.status = <span class="number">127</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        job.status = job.handler(job)</div><div class="line">        job.end = time.Now()</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Wait for all background tasks to complete</span></div><div class="line">    <span class="keyword">if</span> err := job.Stdout.Close(); err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> err := job.Stderr.Close(); err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> err := job.Stdin.Close(); err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> job.status != <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s"</span>, Tail(errorMessage, <span class="number">1</span>))</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Run()函数的实现位于<a href="https://github.com/docker/docker/blob/v1.2.0/engine/job.go#L48" target="_blank" rel="external">./docker/engine/job.go</a>，该函数执行指定的job，并在job执行完成前一直阻塞。对于名为”acceptconnections”的job对象，运行代码为<a href="https://github.com/docker/docker/blob/v1.2.0/engine/job.go#L79" target="_blank" rel="external">job.status = job.handler(job)</a>，由于job.handler值为apiserver.AcceptConnections，故真正执行的是job.status = apiserver.AcceptConnections(job)。</p>
<p>进入AcceptConnections的具体实现，位于<a href="https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1370" target="_blank" rel="external">./docker/api/server/server.go</a>,如下：</p>
<p><strong>/api/server/server.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">AcceptConnections</span><span class="params">(job *engine.Job)</span> <span class="title">engine</span>.<span class="title">Status</span></span> &#123;</div><div class="line">    <span class="comment">// Tell the init daemon we are accepting requests</span></div><div class="line">    <span class="keyword">go</span>  systemd.SdNotify(<span class="string">"READY=1"</span>)</div><div class="line">    <span class="keyword">if</span> activationLock != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="built_in">close</span>(activationLock)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> engine.StatusOK</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重点为go systemd.SdNotify(“READY=1”)的实现，位于<a href="https://github.com/docker/docker/blob/v1.2.0/pkg/systemd/sd_notify.go#L12" target="_blank" rel="external">./docker/pkg/system/sd_notify.go</a>，主要作用是通知init守护进程Docker Daemon的启动已经全部完成，潜在的功能是使得Docker Daemon开始接受Docker Client发送来的API请求。</p>
<p>至此，已经完成通过goroutine来加载daemon对象并运行。</p>
<h3><span id="七打印docker版本及驱动信息">（七）打印Docker版本及驱动信息</span></h3>
<p>显示docker的版本信息，以及ExecDriver和GraphDriver这两个驱动的具体信息</p>
<p><strong>/docker/daemon.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TODO actually have a resolved graphdriver to show?</span></div><div class="line">log.Printf(<span class="string">"docker daemon: %s %s; execdriver: %s; graphdriver: %s"</span>,</div><div class="line">    dockerversion.VERSION,</div><div class="line">    dockerversion.GITCOMMIT,</div><div class="line">    daemonCfg.ExecDriver,</div><div class="line">    daemonCfg.GraphDriver,</div><div class="line">)</div></pre></td></tr></table></figure>
<h3><span id="八serveapi的创建与运行">（八）serveapi的创建与运行</span></h3>
<p>打印部分Docker具体信息之后，Docker Daemon立即创建并运行名为”serveapi”的job，主要作用为让Docker Daemon提供API访问服务。</p>
<p><strong>/docker/daemon.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Serve api</span></div><div class="line">job := eng.Job(<span class="string">"serveapi"</span>, flHosts...)</div><div class="line">job.SetenvBool(<span class="string">"Logging"</span>, <span class="literal">true</span>)</div><div class="line">job.SetenvBool(<span class="string">"EnableCors"</span>, *flEnableCors)</div><div class="line">job.Setenv(<span class="string">"Version"</span>, dockerversion.VERSION)</div><div class="line">job.Setenv(<span class="string">"SocketGroup"</span>, *flSocketGroup)</div><div class="line">job.SetenvBool(<span class="string">"Tls"</span>, *flTls)</div><div class="line">job.SetenvBool(<span class="string">"TlsVerify"</span>, *flTlsVerify)</div><div class="line">job.Setenv(<span class="string">"TlsCa"</span>, *flCa)</div><div class="line">job.Setenv(<span class="string">"TlsCert"</span>, *flCert)</div><div class="line">job.Setenv(<span class="string">"TlsKey"</span>, *flKey)</div><div class="line">job.SetenvBool(<span class="string">"BufferRequests"</span>, <span class="literal">true</span>)</div><div class="line"><span class="keyword">if</span> err := job.Run(); err != <span class="literal">nil</span> &#123;</div><div class="line">    log.Fatal(err)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>创建一个名为”serveapi”的job，并将flHosts的值赋给job.Args。flHost的作用主要是为Docker Daemon提供使用的协议与监听的地址。</li>
<li>Docker Daemon为该job设置了众多的环境变量，如安全传输层协议的环境变量等。最后通过job.Run()运行该serveapi的job。</li>
</ol>
<p>由于在eng中key为”serveapi”的handler，value为apiserver.ServeApi，故该job运行时，执行apiserver.ServeApi函数，位于<a href="https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1339" target="_blank" rel="external">./docker/api/server/server.go</a>。ServeApi函数的作用主要是对于用户定义的所有支持协议，Docker Daemon均创建一个goroutine来启动相应的http.Server，分别为不同的协议服务。具体参考<a href="http://wiki.haplat.net/display/~huwh/Docker+Server" target="_blank" rel="external">Docker Server</a>。</p>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2017/07/09/Docker/Docker源码/Docker源码分析（三）之Docker Server/" data-toggle="tooltip" data-placement="top" title="[Docker] Docker源码分析（三）之Docker Server">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2017/07/09/Docker/Docker整体架构图/" data-toggle="tooltip" data-placement="top" title="[Docker] Docker整体架构图">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">一、Docker Daemon架构示意图</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">二、Docker Daemon启动流程图</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">三、mainDaemon的具体实现</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">（一）配置初始化</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">（二）flag参数检查</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">（三）创建engine对象</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.4.</span> <span class="toc-nav-text">（四）设置engine的信号捕获</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.5.</span> <span class="toc-nav-text">（五）加载builtins</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.5.1.</span> <span class="toc-nav-text">1、注册初始化网络驱动的Handler</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.5.2.</span> <span class="toc-nav-text">2、注册API服务的Handler</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.5.3.</span> <span class="toc-nav-text">3、注册events事件的Handler</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.5.4.</span> <span class="toc-nav-text">4、注册版本的Handler</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.5.5.</span> <span class="toc-nav-text">5、注册registry的Handler</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.6.</span> <span class="toc-nav-text">（六）使用goroutine加载daemon对象</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.6.1.</span> <span class="toc-nav-text">1、创建daemon对象</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.6.2.</span> <span class="toc-nav-text">2、通过daemon对象为engine注册Handler</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.6.3.</span> <span class="toc-nav-text">3、运行acceptconnections的job</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.7.</span> <span class="toc-nav-text">（七）打印Docker版本及驱动信息</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.8.</span> <span class="toc-nav-text">（八）serveapi的创建与运行</span></a></li></ol></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Docker" title="Docker">Docker</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="http://blog.csdn.net/huwh_" target="_blank">CSDN Blog 胡伟煌</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>







<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/huweihuang">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://www.linkedin.com/in/伟煌-胡-5b757ba4">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 胡伟煌 2017 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://beantech.org">BeanTech</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=YenYuHsuan&repo=hexo-theme-beantech&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://www.huweihuang.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="http://www.huweihuang.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
